/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dexie";
exports.ids = ["vendor-chunks/dexie"];
exports.modules = {

/***/ "(ssr)/./node_modules/dexie/dist/dexie.js":
/*!******************************************!*\
  !*** ./node_modules/dexie/dist/dexie.js ***!
  \******************************************/
/***/ (function(module) {

eval("/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 4.3.0, Sat Dec 20 2025\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n    return extendStatics(d, b);\n  };\n  function __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  }\n  var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n  };\n  function __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n  }\n  typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n  };\n\n  var _global = typeof globalThis !== 'undefined' ? globalThis :\n      typeof self !== 'undefined' ? self :\n          typeof window !== 'undefined' ? window :\n              global;\n\n  var keys = Object.keys;\n  var isArray = Array.isArray;\n  if (typeof Promise !== 'undefined' && !_global.Promise) {\n      _global.Promise = Promise;\n  }\n  function extend(obj, extension) {\n      if (typeof extension !== 'object')\n          return obj;\n      keys(extension).forEach(function (key) {\n          obj[key] = extension[key];\n      });\n      return obj;\n  }\n  var getProto = Object.getPrototypeOf;\n  var _hasOwn = {}.hasOwnProperty;\n  function hasOwn(obj, prop) {\n      return _hasOwn.call(obj, prop);\n  }\n  function props(proto, extension) {\n      if (typeof extension === 'function')\n          extension = extension(getProto(proto));\n      (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {\n          setProp(proto, key, extension[key]);\n      });\n  }\n  var defineProperty = Object.defineProperty;\n  function setProp(obj, prop, functionOrGetSet, options) {\n      defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n          { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n          { value: functionOrGetSet, configurable: true, writable: true }, options));\n  }\n  function derive(Child) {\n      return {\n          from: function (Parent) {\n              Child.prototype = Object.create(Parent.prototype);\n              setProp(Child.prototype, \"constructor\", Child);\n              return {\n                  extend: props.bind(null, Child.prototype)\n              };\n          }\n      };\n  }\n  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  function getPropertyDescriptor(obj, prop) {\n      var pd = getOwnPropertyDescriptor(obj, prop);\n      var proto;\n      return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n  }\n  var _slice = [].slice;\n  function slice(args, start, end) {\n      return _slice.call(args, start, end);\n  }\n  function override(origFunc, overridedFactory) {\n      return overridedFactory(origFunc);\n  }\n  function assert(b) {\n      if (!b)\n          throw new Error(\"Assertion Failed\");\n  }\n  function asap$1(fn) {\n      if (_global.setImmediate)\n          setImmediate(fn);\n      else\n          setTimeout(fn, 0);\n  }\n  function arrayToObject(array, extractor) {\n      return array.reduce(function (result, item, i) {\n          var nameAndValue = extractor(item, i);\n          if (nameAndValue)\n              result[nameAndValue[0]] = nameAndValue[1];\n          return result;\n      }, {});\n  }\n  function getByKeyPath(obj, keyPath) {\n      if (typeof keyPath === 'string' && hasOwn(obj, keyPath))\n          return obj[keyPath];\n      if (!keyPath)\n          return obj;\n      if (typeof keyPath !== 'string') {\n          var rv = [];\n          for (var i = 0, l = keyPath.length; i < l; ++i) {\n              var val = getByKeyPath(obj, keyPath[i]);\n              rv.push(val);\n          }\n          return rv;\n      }\n      var period = keyPath.indexOf('.');\n      if (period !== -1) {\n          var innerObj = obj[keyPath.substr(0, period)];\n          return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n      }\n      return undefined;\n  }\n  function setByKeyPath(obj, keyPath, value) {\n      if (!obj || keyPath === undefined)\n          return;\n      if ('isFrozen' in Object && Object.isFrozen(obj))\n          return;\n      if (typeof keyPath !== 'string' && 'length' in keyPath) {\n          assert(typeof value !== 'string' && 'length' in value);\n          for (var i = 0, l = keyPath.length; i < l; ++i) {\n              setByKeyPath(obj, keyPath[i], value[i]);\n          }\n      }\n      else {\n          var period = keyPath.indexOf('.');\n          if (period !== -1) {\n              var currentKeyPath = keyPath.substr(0, period);\n              var remainingKeyPath = keyPath.substr(period + 1);\n              if (remainingKeyPath === \"\")\n                  if (value === undefined) {\n                      if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                          obj.splice(currentKeyPath, 1);\n                      else\n                          delete obj[currentKeyPath];\n                  }\n                  else\n                      obj[currentKeyPath] = value;\n              else {\n                  var innerObj = obj[currentKeyPath];\n                  if (!innerObj || !hasOwn(obj, currentKeyPath))\n                      innerObj = (obj[currentKeyPath] = {});\n                  setByKeyPath(innerObj, remainingKeyPath, value);\n              }\n          }\n          else {\n              if (value === undefined) {\n                  if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                      obj.splice(keyPath, 1);\n                  else\n                      delete obj[keyPath];\n              }\n              else\n                  obj[keyPath] = value;\n          }\n      }\n  }\n  function delByKeyPath(obj, keyPath) {\n      if (typeof keyPath === 'string')\n          setByKeyPath(obj, keyPath, undefined);\n      else if ('length' in keyPath)\n          [].map.call(keyPath, function (kp) {\n              setByKeyPath(obj, kp, undefined);\n          });\n  }\n  function shallowClone(obj) {\n      var rv = {};\n      for (var m in obj) {\n          if (hasOwn(obj, m))\n              rv[m] = obj[m];\n      }\n      return rv;\n  }\n  var concat = [].concat;\n  function flatten(a) {\n      return concat.apply([], a);\n  }\n  var intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n      .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return [\"Int\", \"Uint\", \"Float\"].map(function (t) { return t + num + \"Array\"; }); }))).filter(function (t) { return _global[t]; });\n  var intrinsicTypes = new Set(intrinsicTypeNames.map(function (t) { return _global[t]; }));\n  function cloneSimpleObjectTree(o) {\n      var rv = {};\n      for (var k in o)\n          if (hasOwn(o, k)) {\n              var v = o[k];\n              rv[k] = !v || typeof v !== 'object' || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);\n          }\n      return rv;\n  }\n  function objectIsEmpty(o) {\n      for (var k in o)\n          if (hasOwn(o, k))\n              return false;\n      return true;\n  }\n  var circularRefs = null;\n  function deepClone(any) {\n      circularRefs = new WeakMap();\n      var rv = innerDeepClone(any);\n      circularRefs = null;\n      return rv;\n  }\n  function innerDeepClone(x) {\n      if (!x || typeof x !== 'object')\n          return x;\n      var rv = circularRefs.get(x);\n      if (rv)\n          return rv;\n      if (isArray(x)) {\n          rv = [];\n          circularRefs.set(x, rv);\n          for (var i = 0, l = x.length; i < l; ++i) {\n              rv.push(innerDeepClone(x[i]));\n          }\n      }\n      else if (intrinsicTypes.has(x.constructor)) {\n          rv = x;\n      }\n      else {\n          var proto = getProto(x);\n          rv = proto === Object.prototype ? {} : Object.create(proto);\n          circularRefs.set(x, rv);\n          for (var prop in x) {\n              if (hasOwn(x, prop)) {\n                  rv[prop] = innerDeepClone(x[prop]);\n              }\n          }\n      }\n      return rv;\n  }\n  var toString = {}.toString;\n  function toStringTag(o) {\n      return toString.call(o).slice(8, -1);\n  }\n  var iteratorSymbol = typeof Symbol !== 'undefined' ?\n      Symbol.iterator :\n      '@@iterator';\n  var getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n      var i;\n      return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n  } : function () { return null; };\n  function delArrayItem(a, x) {\n      var i = a.indexOf(x);\n      if (i >= 0)\n          a.splice(i, 1);\n      return i >= 0;\n  }\n  var NO_CHAR_ARRAY = {};\n  function getArrayOf(arrayLike) {\n      var i, a, x, it;\n      if (arguments.length === 1) {\n          if (isArray(arrayLike))\n              return arrayLike.slice();\n          if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n              return [arrayLike];\n          if ((it = getIteratorOf(arrayLike))) {\n              a = [];\n              while ((x = it.next()), !x.done)\n                  a.push(x.value);\n              return a;\n          }\n          if (arrayLike == null)\n              return [arrayLike];\n          i = arrayLike.length;\n          if (typeof i === 'number') {\n              a = new Array(i);\n              while (i--)\n                  a[i] = arrayLike[i];\n              return a;\n          }\n          return [arrayLike];\n      }\n      i = arguments.length;\n      a = new Array(i);\n      while (i--)\n          a[i] = arguments[i];\n      return a;\n  }\n  var isAsyncFunction = typeof Symbol !== 'undefined'\n      ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }\n      : function () { return false; };\n\n  var dexieErrorNames = [\n      'Modify',\n      'Bulk',\n      'OpenFailed',\n      'VersionChange',\n      'Schema',\n      'Upgrade',\n      'InvalidTable',\n      'MissingAPI',\n      'NoSuchDatabase',\n      'InvalidArgument',\n      'SubTransaction',\n      'Unsupported',\n      'Internal',\n      'DatabaseClosed',\n      'PrematureCommit',\n      'ForeignAwait'\n  ];\n  var idbDomErrorNames = [\n      'Unknown',\n      'Constraint',\n      'Data',\n      'TransactionInactive',\n      'ReadOnly',\n      'Version',\n      'NotFound',\n      'InvalidState',\n      'InvalidAccess',\n      'Abort',\n      'Timeout',\n      'QuotaExceeded',\n      'Syntax',\n      'DataClone'\n  ];\n  var errorList = dexieErrorNames.concat(idbDomErrorNames);\n  var defaultTexts = {\n      VersionChanged: \"Database version changed by other database connection\",\n      DatabaseClosed: \"Database has been closed\",\n      Abort: \"Transaction aborted\",\n      TransactionInactive: \"Transaction has already completed or failed\",\n      MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n  };\n  function DexieError(name, msg) {\n      this.name = name;\n      this.message = msg;\n  }\n  derive(DexieError).from(Error).extend({\n      toString: function () { return this.name + \": \" + this.message; }\n  });\n  function getMultiErrorMessage(msg, failures) {\n      return msg + \". Errors: \" + Object.keys(failures)\n          .map(function (key) { return failures[key].toString(); })\n          .filter(function (v, i, s) { return s.indexOf(v) === i; })\n          .join('\\n');\n  }\n  function ModifyError(msg, failures, successCount, failedKeys) {\n      this.failures = failures;\n      this.failedKeys = failedKeys;\n      this.successCount = successCount;\n      this.message = getMultiErrorMessage(msg, failures);\n  }\n  derive(ModifyError).from(DexieError);\n  function BulkError(msg, failures) {\n      this.name = \"BulkError\";\n      this.failures = Object.keys(failures).map(function (pos) { return failures[pos]; });\n      this.failuresByPos = failures;\n      this.message = getMultiErrorMessage(msg, this.failures);\n  }\n  derive(BulkError).from(DexieError);\n  var errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + \"Error\", obj); }, {});\n  var BaseException = DexieError;\n  var exceptions = errorList.reduce(function (obj, name) {\n      var fullName = name + \"Error\";\n      function DexieError(msgOrInner, inner) {\n          this.name = fullName;\n          if (!msgOrInner) {\n              this.message = defaultTexts[name] || fullName;\n              this.inner = null;\n          }\n          else if (typeof msgOrInner === 'string') {\n              this.message = \"\".concat(msgOrInner).concat(!inner ? '' : '\\n ' + inner);\n              this.inner = inner || null;\n          }\n          else if (typeof msgOrInner === 'object') {\n              this.message = \"\".concat(msgOrInner.name, \" \").concat(msgOrInner.message);\n              this.inner = msgOrInner;\n          }\n      }\n      derive(DexieError).from(BaseException);\n      obj[name] = DexieError;\n      return obj;\n  }, {});\n  exceptions.Syntax = SyntaxError;\n  exceptions.Type = TypeError;\n  exceptions.Range = RangeError;\n  var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\n      obj[name + \"Error\"] = exceptions[name];\n      return obj;\n  }, {});\n  function mapError(domError, message) {\n      if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n          return domError;\n      var rv = new exceptionMap[domError.name](message || domError.message, domError);\n      if (\"stack\" in domError) {\n          setProp(rv, \"stack\", { get: function () {\n                  return this.inner.stack;\n              } });\n      }\n      return rv;\n  }\n  var fullNameExceptions = errorList.reduce(function (obj, name) {\n      if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n          obj[name + \"Error\"] = exceptions[name];\n      return obj;\n  }, {});\n  fullNameExceptions.ModifyError = ModifyError;\n  fullNameExceptions.DexieError = DexieError;\n  fullNameExceptions.BulkError = BulkError;\n\n  function nop() { }\n  function mirror(val) { return val; }\n  function pureFunctionChain(f1, f2) {\n      if (f1 == null || f1 === mirror)\n          return f2;\n      return function (val) {\n          return f2(f1(val));\n      };\n  }\n  function callBoth(on1, on2) {\n      return function () {\n          on1.apply(this, arguments);\n          on2.apply(this, arguments);\n      };\n  }\n  function hookCreatingChain(f1, f2) {\n      if (f1 === nop)\n          return f2;\n      return function () {\n          var res = f1.apply(this, arguments);\n          if (res !== undefined)\n              arguments[0] = res;\n          var onsuccess = this.onsuccess,\n          onerror = this.onerror;\n          this.onsuccess = null;\n          this.onerror = null;\n          var res2 = f2.apply(this, arguments);\n          if (onsuccess)\n              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n          if (onerror)\n              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n          return res2 !== undefined ? res2 : res;\n      };\n  }\n  function hookDeletingChain(f1, f2) {\n      if (f1 === nop)\n          return f2;\n      return function () {\n          f1.apply(this, arguments);\n          var onsuccess = this.onsuccess,\n          onerror = this.onerror;\n          this.onsuccess = this.onerror = null;\n          f2.apply(this, arguments);\n          if (onsuccess)\n              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n          if (onerror)\n              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n      };\n  }\n  function hookUpdatingChain(f1, f2) {\n      if (f1 === nop)\n          return f2;\n      return function (modifications) {\n          var res = f1.apply(this, arguments);\n          extend(modifications, res);\n          var onsuccess = this.onsuccess,\n          onerror = this.onerror;\n          this.onsuccess = null;\n          this.onerror = null;\n          var res2 = f2.apply(this, arguments);\n          if (onsuccess)\n              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n          if (onerror)\n              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n          return res === undefined ?\n              (res2 === undefined ? undefined : res2) :\n              (extend(res, res2));\n      };\n  }\n  function reverseStoppableEventChain(f1, f2) {\n      if (f1 === nop)\n          return f2;\n      return function () {\n          if (f2.apply(this, arguments) === false)\n              return false;\n          return f1.apply(this, arguments);\n      };\n  }\n  function promisableChain(f1, f2) {\n      if (f1 === nop)\n          return f2;\n      return function () {\n          var res = f1.apply(this, arguments);\n          if (res && typeof res.then === 'function') {\n              var thiz = this, i = arguments.length, args = new Array(i);\n              while (i--)\n                  args[i] = arguments[i];\n              return res.then(function () {\n                  return f2.apply(thiz, args);\n              });\n          }\n          return f2.apply(this, arguments);\n      };\n  }\n\n  var debug = typeof location !== 'undefined' &&\n      /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n  function setDebug(value, filter) {\n      debug = value;\n  }\n\n  var INTERNAL = {};\n  var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ?\n      [] :\n      (function () {\n          var globalP = Promise.resolve();\n          if (typeof crypto === 'undefined' || !crypto.subtle)\n              return [globalP, getProto(globalP), globalP];\n          var nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n          return [\n              nativeP,\n              getProto(nativeP),\n              globalP\n          ];\n      })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\n  var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\n  var patchGlobalPromise = !!resolvedGlobalPromise;\n  function schedulePhysicalTick() {\n      queueMicrotask(physicalTick);\n  }\n  var asap = function (callback, args) {\n      microtickQueue.push([callback, args]);\n      if (needsNewPhysicalTick) {\n          schedulePhysicalTick();\n          needsNewPhysicalTick = false;\n      }\n  };\n  var isOutsideMicroTick = true,\n  needsNewPhysicalTick = true,\n  unhandledErrors = [],\n  rejectingErrors = [],\n  rejectionMapper = mirror;\n  var globalPSD = {\n      id: 'global',\n      global: true,\n      ref: 0,\n      unhandleds: [],\n      onunhandled: nop,\n      pgp: false,\n      env: {},\n      finalize: nop\n  };\n  var PSD = globalPSD;\n  var microtickQueue = [];\n  var numScheduledCalls = 0;\n  var tickFinalizers = [];\n  function DexiePromise(fn) {\n      if (typeof this !== 'object')\n          throw new TypeError('Promises must be constructed via new');\n      this._listeners = [];\n      this._lib = false;\n      var psd = (this._PSD = PSD);\n      if (typeof fn !== 'function') {\n          if (fn !== INTERNAL)\n              throw new TypeError('Not a function');\n          this._state = arguments[1];\n          this._value = arguments[2];\n          if (this._state === false)\n              handleRejection(this, this._value);\n          return;\n      }\n      this._state = null;\n      this._value = null;\n      ++psd.ref;\n      executePromiseTask(this, fn);\n  }\n  var thenProp = {\n      get: function () {\n          var psd = PSD, microTaskId = totalEchoes;\n          function then(onFulfilled, onRejected) {\n              var _this = this;\n              var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n              var cleanup = possibleAwait && !decrementExpectedAwaits();\n              var rv = new DexiePromise(function (resolve, reject) {\n                  propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n              });\n              if (this._consoleTask)\n                  rv._consoleTask = this._consoleTask;\n              return rv;\n          }\n          then.prototype = INTERNAL;\n          return then;\n      },\n      set: function (value) {\n          setProp(this, 'then', value && value.prototype === INTERNAL ?\n              thenProp :\n              {\n                  get: function () {\n                      return value;\n                  },\n                  set: thenProp.set\n              });\n      }\n  };\n  props(DexiePromise.prototype, {\n      then: thenProp,\n      _then: function (onFulfilled, onRejected) {\n          propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n      },\n      catch: function (onRejected) {\n          if (arguments.length === 1)\n              return this.then(null, onRejected);\n          var type = arguments[0], handler = arguments[1];\n          return typeof type === 'function' ? this.then(null, function (err) {\n              return err instanceof type ? handler(err) : PromiseReject(err);\n          })\n              : this.then(null, function (err) {\n                  return err && err.name === type ? handler(err) : PromiseReject(err);\n              });\n      },\n      finally: function (onFinally) {\n          return this.then(function (value) {\n              return DexiePromise.resolve(onFinally()).then(function () { return value; });\n          }, function (err) {\n              return DexiePromise.resolve(onFinally()).then(function () { return PromiseReject(err); });\n          });\n      },\n      timeout: function (ms, msg) {\n          var _this = this;\n          return ms < Infinity ?\n              new DexiePromise(function (resolve, reject) {\n                  var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);\n                  _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n              }) : this;\n      }\n  });\n  if (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n      setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\n  globalPSD.env = snapShot();\n  function Listener(onFulfilled, onRejected, resolve, reject, zone) {\n      this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n      this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n      this.resolve = resolve;\n      this.reject = reject;\n      this.psd = zone;\n  }\n  props(DexiePromise, {\n      all: function () {\n          var values = getArrayOf.apply(null, arguments)\n              .map(onPossibleParallellAsync);\n          return new DexiePromise(function (resolve, reject) {\n              if (values.length === 0)\n                  resolve([]);\n              var remaining = values.length;\n              values.forEach(function (a, i) { return DexiePromise.resolve(a).then(function (x) {\n                  values[i] = x;\n                  if (!--remaining)\n                      resolve(values);\n              }, reject); });\n          });\n      },\n      resolve: function (value) {\n          if (value instanceof DexiePromise)\n              return value;\n          if (value && typeof value.then === 'function')\n              return new DexiePromise(function (resolve, reject) {\n                  value.then(resolve, reject);\n              });\n          var rv = new DexiePromise(INTERNAL, true, value);\n          return rv;\n      },\n      reject: PromiseReject,\n      race: function () {\n          var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n          return new DexiePromise(function (resolve, reject) {\n              values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });\n          });\n      },\n      PSD: {\n          get: function () { return PSD; },\n          set: function (value) { return PSD = value; }\n      },\n      totalEchoes: { get: function () { return totalEchoes; } },\n      newPSD: newScope,\n      usePSD: usePSD,\n      scheduler: {\n          get: function () { return asap; },\n          set: function (value) { asap = value; }\n      },\n      rejectionMapper: {\n          get: function () { return rejectionMapper; },\n          set: function (value) { rejectionMapper = value; }\n      },\n      follow: function (fn, zoneProps) {\n          return new DexiePromise(function (resolve, reject) {\n              return newScope(function (resolve, reject) {\n                  var psd = PSD;\n                  psd.unhandleds = [];\n                  psd.onunhandled = reject;\n                  psd.finalize = callBoth(function () {\n                      var _this = this;\n                      run_at_end_of_this_or_next_physical_tick(function () {\n                          _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);\n                      });\n                  }, psd.finalize);\n                  fn();\n              }, zoneProps, resolve, reject);\n          });\n      }\n  });\n  if (NativePromise) {\n      if (NativePromise.allSettled)\n          setProp(DexiePromise, \"allSettled\", function () {\n              var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n              return new DexiePromise(function (resolve) {\n                  if (possiblePromises.length === 0)\n                      resolve([]);\n                  var remaining = possiblePromises.length;\n                  var results = new Array(remaining);\n                  possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: \"fulfilled\", value: value }; }, function (reason) { return results[i] = { status: \"rejected\", reason: reason }; })\n                      .then(function () { return --remaining || resolve(results); }); });\n              });\n          });\n      if (NativePromise.any && typeof AggregateError !== 'undefined')\n          setProp(DexiePromise, \"any\", function () {\n              var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n              return new DexiePromise(function (resolve, reject) {\n                  if (possiblePromises.length === 0)\n                      reject(new AggregateError([]));\n                  var remaining = possiblePromises.length;\n                  var failures = new Array(remaining);\n                  possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {\n                      failures[i] = failure;\n                      if (!--remaining)\n                          reject(new AggregateError(failures));\n                  }); });\n              });\n          });\n      if (NativePromise.withResolvers)\n          DexiePromise.withResolvers = NativePromise.withResolvers;\n  }\n  function executePromiseTask(promise, fn) {\n      try {\n          fn(function (value) {\n              if (promise._state !== null)\n                  return;\n              if (value === promise)\n                  throw new TypeError('A promise cannot be resolved with itself.');\n              var shouldExecuteTick = promise._lib && beginMicroTickScope();\n              if (value && typeof value.then === 'function') {\n                  executePromiseTask(promise, function (resolve, reject) {\n                      value instanceof DexiePromise ?\n                          value._then(resolve, reject) :\n                          value.then(resolve, reject);\n                  });\n              }\n              else {\n                  promise._state = true;\n                  promise._value = value;\n                  propagateAllListeners(promise);\n              }\n              if (shouldExecuteTick)\n                  endMicroTickScope();\n          }, handleRejection.bind(null, promise));\n      }\n      catch (ex) {\n          handleRejection(promise, ex);\n      }\n  }\n  function handleRejection(promise, reason) {\n      rejectingErrors.push(reason);\n      if (promise._state !== null)\n          return;\n      var shouldExecuteTick = promise._lib && beginMicroTickScope();\n      reason = rejectionMapper(reason);\n      promise._state = false;\n      promise._value = reason;\n      addPossiblyUnhandledError(promise);\n      propagateAllListeners(promise);\n      if (shouldExecuteTick)\n          endMicroTickScope();\n  }\n  function propagateAllListeners(promise) {\n      var listeners = promise._listeners;\n      promise._listeners = [];\n      for (var i = 0, len = listeners.length; i < len; ++i) {\n          propagateToListener(promise, listeners[i]);\n      }\n      var psd = promise._PSD;\n      --psd.ref || psd.finalize();\n      if (numScheduledCalls === 0) {\n          ++numScheduledCalls;\n          asap(function () {\n              if (--numScheduledCalls === 0)\n                  finalizePhysicalTick();\n          }, []);\n      }\n  }\n  function propagateToListener(promise, listener) {\n      if (promise._state === null) {\n          promise._listeners.push(listener);\n          return;\n      }\n      var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n      if (cb === null) {\n          return (promise._state ? listener.resolve : listener.reject)(promise._value);\n      }\n      ++listener.psd.ref;\n      ++numScheduledCalls;\n      asap(callListener, [cb, promise, listener]);\n  }\n  function callListener(cb, promise, listener) {\n      try {\n          var ret, value = promise._value;\n          if (!promise._state && rejectingErrors.length)\n              rejectingErrors = [];\n          ret = debug && promise._consoleTask ? promise._consoleTask.run(function () { return cb(value); }) : cb(value);\n          if (!promise._state && rejectingErrors.indexOf(value) === -1) {\n              markErrorAsHandled(promise);\n          }\n          listener.resolve(ret);\n      }\n      catch (e) {\n          listener.reject(e);\n      }\n      finally {\n          if (--numScheduledCalls === 0)\n              finalizePhysicalTick();\n          --listener.psd.ref || listener.psd.finalize();\n      }\n  }\n  function physicalTick() {\n      usePSD(globalPSD, function () {\n          beginMicroTickScope() && endMicroTickScope();\n      });\n  }\n  function beginMicroTickScope() {\n      var wasRootExec = isOutsideMicroTick;\n      isOutsideMicroTick = false;\n      needsNewPhysicalTick = false;\n      return wasRootExec;\n  }\n  function endMicroTickScope() {\n      var callbacks, i, l;\n      do {\n          while (microtickQueue.length > 0) {\n              callbacks = microtickQueue;\n              microtickQueue = [];\n              l = callbacks.length;\n              for (i = 0; i < l; ++i) {\n                  var item = callbacks[i];\n                  item[0].apply(null, item[1]);\n              }\n          }\n      } while (microtickQueue.length > 0);\n      isOutsideMicroTick = true;\n      needsNewPhysicalTick = true;\n  }\n  function finalizePhysicalTick() {\n      var unhandledErrs = unhandledErrors;\n      unhandledErrors = [];\n      unhandledErrs.forEach(function (p) {\n          p._PSD.onunhandled.call(null, p._value, p);\n      });\n      var finalizers = tickFinalizers.slice(0);\n      var i = finalizers.length;\n      while (i)\n          finalizers[--i]();\n  }\n  function run_at_end_of_this_or_next_physical_tick(fn) {\n      function finalizer() {\n          fn();\n          tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n      }\n      tickFinalizers.push(finalizer);\n      ++numScheduledCalls;\n      asap(function () {\n          if (--numScheduledCalls === 0)\n              finalizePhysicalTick();\n      }, []);\n  }\n  function addPossiblyUnhandledError(promise) {\n      if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))\n          unhandledErrors.push(promise);\n  }\n  function markErrorAsHandled(promise) {\n      var i = unhandledErrors.length;\n      while (i)\n          if (unhandledErrors[--i]._value === promise._value) {\n              unhandledErrors.splice(i, 1);\n              return;\n          }\n  }\n  function PromiseReject(reason) {\n      return new DexiePromise(INTERNAL, false, reason);\n  }\n  function wrap(fn, errorCatcher) {\n      var psd = PSD;\n      return function () {\n          var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n          try {\n              switchToZone(psd, true);\n              return fn.apply(this, arguments);\n          }\n          catch (e) {\n              errorCatcher && errorCatcher(e);\n          }\n          finally {\n              switchToZone(outerScope, false);\n              if (wasRootExec)\n                  endMicroTickScope();\n          }\n      };\n  }\n  var task = { awaits: 0, echoes: 0, id: 0 };\n  var taskCounter = 0;\n  var zoneStack = [];\n  var zoneEchoes = 0;\n  var totalEchoes = 0;\n  var zone_id_counter = 0;\n  function newScope(fn, props, a1, a2) {\n      var parent = PSD, psd = Object.create(parent);\n      psd.parent = parent;\n      psd.ref = 0;\n      psd.global = false;\n      psd.id = ++zone_id_counter;\n      globalPSD.env;\n      psd.env = patchGlobalPromise ? {\n          Promise: DexiePromise,\n          PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n          all: DexiePromise.all,\n          race: DexiePromise.race,\n          allSettled: DexiePromise.allSettled,\n          any: DexiePromise.any,\n          resolve: DexiePromise.resolve,\n          reject: DexiePromise.reject,\n      } : {};\n      if (props)\n          extend(psd, props);\n      ++parent.ref;\n      psd.finalize = function () {\n          --this.parent.ref || this.parent.finalize();\n      };\n      var rv = usePSD(psd, fn, a1, a2);\n      if (psd.ref === 0)\n          psd.finalize();\n      return rv;\n  }\n  function incrementExpectedAwaits() {\n      if (!task.id)\n          task.id = ++taskCounter;\n      ++task.awaits;\n      task.echoes += ZONE_ECHO_LIMIT;\n      return task.id;\n  }\n  function decrementExpectedAwaits() {\n      if (!task.awaits)\n          return false;\n      if (--task.awaits === 0)\n          task.id = 0;\n      task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n      return true;\n  }\n  if (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n      incrementExpectedAwaits = decrementExpectedAwaits = nop;\n  }\n  function onPossibleParallellAsync(possiblePromise) {\n      if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n          incrementExpectedAwaits();\n          return possiblePromise.then(function (x) {\n              decrementExpectedAwaits();\n              return x;\n          }, function (e) {\n              decrementExpectedAwaits();\n              return rejection(e);\n          });\n      }\n      return possiblePromise;\n  }\n  function zoneEnterEcho(targetZone) {\n      ++totalEchoes;\n      if (!task.echoes || --task.echoes === 0) {\n          task.echoes = task.awaits = task.id = 0;\n      }\n      zoneStack.push(PSD);\n      switchToZone(targetZone, true);\n  }\n  function zoneLeaveEcho() {\n      var zone = zoneStack[zoneStack.length - 1];\n      zoneStack.pop();\n      switchToZone(zone, false);\n  }\n  function switchToZone(targetZone, bEnteringZone) {\n      var currentZone = PSD;\n      if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n          queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n      }\n      if (targetZone === PSD)\n          return;\n      PSD = targetZone;\n      if (currentZone === globalPSD)\n          globalPSD.env = snapShot();\n      if (patchGlobalPromise) {\n          var GlobalPromise = globalPSD.env.Promise;\n          var targetEnv = targetZone.env;\n          if (currentZone.global || targetZone.global) {\n              Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n              GlobalPromise.all = targetEnv.all;\n              GlobalPromise.race = targetEnv.race;\n              GlobalPromise.resolve = targetEnv.resolve;\n              GlobalPromise.reject = targetEnv.reject;\n              if (targetEnv.allSettled)\n                  GlobalPromise.allSettled = targetEnv.allSettled;\n              if (targetEnv.any)\n                  GlobalPromise.any = targetEnv.any;\n          }\n      }\n  }\n  function snapShot() {\n      var GlobalPromise = _global.Promise;\n      return patchGlobalPromise ? {\n          Promise: GlobalPromise,\n          PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n          all: GlobalPromise.all,\n          race: GlobalPromise.race,\n          allSettled: GlobalPromise.allSettled,\n          any: GlobalPromise.any,\n          resolve: GlobalPromise.resolve,\n          reject: GlobalPromise.reject,\n      } : {};\n  }\n  function usePSD(psd, fn, a1, a2, a3) {\n      var outerScope = PSD;\n      try {\n          switchToZone(psd, true);\n          return fn(a1, a2, a3);\n      }\n      finally {\n          switchToZone(outerScope, false);\n      }\n  }\n  function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n      return typeof fn !== 'function' ? fn : function () {\n          var outerZone = PSD;\n          if (possibleAwait)\n              incrementExpectedAwaits();\n          switchToZone(zone, true);\n          try {\n              return fn.apply(this, arguments);\n          }\n          finally {\n              switchToZone(outerZone, false);\n              if (cleanup)\n                  queueMicrotask(decrementExpectedAwaits);\n          }\n      };\n  }\n  function execInGlobalContext(cb) {\n      if (Promise === NativePromise && task.echoes === 0) {\n          if (zoneEchoes === 0) {\n              cb();\n          }\n          else {\n              enqueueNativeMicroTask(cb);\n          }\n      }\n      else {\n          setTimeout(cb, 0);\n      }\n  }\n  var rejection = DexiePromise.reject;\n\n  function tempTransaction(db, mode, storeNames, fn) {\n      if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n          if (db._state.openComplete) {\n              return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n          }\n          if (!db._state.isBeingOpened) {\n              if (!db._state.autoOpen)\n                  return rejection(new exceptions.DatabaseClosed());\n              db.open().catch(nop);\n          }\n          return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });\n      }\n      else {\n          var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n          try {\n              trans.create();\n              db._state.PR1398_maxLoop = 3;\n          }\n          catch (ex) {\n              if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                  console.warn('Dexie: Need to reopen db');\n                  db.close({ disableAutoOpen: false });\n                  return db.open().then(function () { return tempTransaction(db, mode, storeNames, fn); });\n              }\n              return rejection(ex);\n          }\n          return trans._promise(mode, function (resolve, reject) {\n              return newScope(function () {\n                  PSD.trans = trans;\n                  return fn(resolve, reject, trans);\n              });\n          }).then(function (result) {\n              if (mode === 'readwrite')\n                  try {\n                      trans.idbtrans.commit();\n                  }\n                  catch (_a) { }\n              return mode === 'readonly' ? result : trans._completion.then(function () { return result; });\n          });\n      }\n  }\n\n  var DEXIE_VERSION = '4.3.0';\n  var maxString = String.fromCharCode(65535);\n  var minKey = -Infinity;\n  var INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\n  var STRING_EXPECTED = \"String expected.\";\n  var connections = [];\n  var DBNAMES_DB = '__dbnames';\n  var READONLY = 'readonly';\n  var READWRITE = 'readwrite';\n\n  function combine(filter1, filter2) {\n      return filter1 ?\n          filter2 ?\n              function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n              filter1 :\n          filter2;\n  }\n\n  var AnyRange = {\n      type: 3 ,\n      lower: -Infinity,\n      lowerOpen: false,\n      upper: [[]],\n      upperOpen: false\n  };\n\n  function workaroundForUndefinedPrimKey(keyPath) {\n      return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n          ? function (obj) {\n              if (obj[keyPath] === undefined && (keyPath in obj)) {\n                  obj = deepClone(obj);\n                  delete obj[keyPath];\n              }\n              return obj;\n          }\n          : function (obj) { return obj; };\n  }\n\n  function Entity() {\n      throw exceptions.Type(\"Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.\");\n  }\n\n  function cmp(a, b) {\n      try {\n          var ta = type(a);\n          var tb = type(b);\n          if (ta !== tb) {\n              if (ta === 'Array')\n                  return 1;\n              if (tb === 'Array')\n                  return -1;\n              if (ta === 'binary')\n                  return 1;\n              if (tb === 'binary')\n                  return -1;\n              if (ta === 'string')\n                  return 1;\n              if (tb === 'string')\n                  return -1;\n              if (ta === 'Date')\n                  return 1;\n              if (tb !== 'Date')\n                  return NaN;\n              return -1;\n          }\n          switch (ta) {\n              case 'number':\n              case 'Date':\n              case 'string':\n                  return a > b ? 1 : a < b ? -1 : 0;\n              case 'binary': {\n                  return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n              }\n              case 'Array':\n                  return compareArrays(a, b);\n          }\n      }\n      catch (_a) { }\n      return NaN;\n  }\n  function compareArrays(a, b) {\n      var al = a.length;\n      var bl = b.length;\n      var l = al < bl ? al : bl;\n      for (var i = 0; i < l; ++i) {\n          var res = cmp(a[i], b[i]);\n          if (res !== 0)\n              return res;\n      }\n      return al === bl ? 0 : al < bl ? -1 : 1;\n  }\n  function compareUint8Arrays(a, b) {\n      var al = a.length;\n      var bl = b.length;\n      var l = al < bl ? al : bl;\n      for (var i = 0; i < l; ++i) {\n          if (a[i] !== b[i])\n              return a[i] < b[i] ? -1 : 1;\n      }\n      return al === bl ? 0 : al < bl ? -1 : 1;\n  }\n  function type(x) {\n      var t = typeof x;\n      if (t !== 'object')\n          return t;\n      if (ArrayBuffer.isView(x))\n          return 'binary';\n      var tsTag = toStringTag(x);\n      return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n  }\n  function getUint8Array(a) {\n      if (a instanceof Uint8Array)\n          return a;\n      if (ArrayBuffer.isView(a))\n          return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n      return new Uint8Array(a);\n  }\n\n  function builtInDeletionTrigger(table, keys, res) {\n      var yProps = table.schema.yProps;\n      if (!yProps)\n          return res;\n      if (keys && res.numFailures > 0)\n          keys = keys.filter(function (_, i) { return !res.failures[i]; });\n      return Promise.all(yProps.map(function (_a) {\n          var updatesTable = _a.updatesTable;\n          return keys\n              ? table.db.table(updatesTable).where('k').anyOf(keys).delete()\n              : table.db.table(updatesTable).clear();\n      })).then(function () { return res; });\n  }\n\n  var PropModification =  (function () {\n      function PropModification(spec) {\n          this[\"@@propmod\"] = spec;\n      }\n      PropModification.prototype.execute = function (value) {\n          var _a;\n          var spec = this[\"@@propmod\"];\n          if (spec.add !== undefined) {\n              var term = spec.add;\n              if (isArray(term)) {\n                  return __spreadArray(__spreadArray([], (isArray(value) ? value : []), true), term, true).sort();\n              }\n              if (typeof term === 'number')\n                  return (Number(value) || 0) + term;\n              if (typeof term === 'bigint') {\n                  try {\n                      return BigInt(value) + term;\n                  }\n                  catch (_b) {\n                      return BigInt(0) + term;\n                  }\n              }\n              throw new TypeError(\"Invalid term \".concat(term));\n          }\n          if (spec.remove !== undefined) {\n              var subtrahend_1 = spec.remove;\n              if (isArray(subtrahend_1)) {\n                  return isArray(value) ? value.filter(function (item) { return !subtrahend_1.includes(item); }).sort() : [];\n              }\n              if (typeof subtrahend_1 === 'number')\n                  return Number(value) - subtrahend_1;\n              if (typeof subtrahend_1 === 'bigint') {\n                  try {\n                      return BigInt(value) - subtrahend_1;\n                  }\n                  catch (_c) {\n                      return BigInt(0) - subtrahend_1;\n                  }\n              }\n              throw new TypeError(\"Invalid subtrahend \".concat(subtrahend_1));\n          }\n          var prefixToReplace = (_a = spec.replacePrefix) === null || _a === void 0 ? void 0 : _a[0];\n          if (prefixToReplace && typeof value === 'string' && value.startsWith(prefixToReplace)) {\n              return spec.replacePrefix[1] + value.substring(prefixToReplace.length);\n          }\n          return value;\n      };\n      return PropModification;\n  }());\n\n  function applyUpdateSpec(obj, changes) {\n      var keyPaths = keys(changes);\n      var numKeys = keyPaths.length;\n      var anythingModified = false;\n      for (var i = 0; i < numKeys; ++i) {\n          var keyPath = keyPaths[i];\n          var value = changes[keyPath];\n          var origValue = getByKeyPath(obj, keyPath);\n          if (value instanceof PropModification) {\n              setByKeyPath(obj, keyPath, value.execute(origValue));\n              anythingModified = true;\n          }\n          else if (origValue !== value) {\n              setByKeyPath(obj, keyPath, value);\n              anythingModified = true;\n          }\n      }\n      return anythingModified;\n  }\n\n  var Table =  (function () {\n      function Table() {\n      }\n      Table.prototype._trans = function (mode, fn, writeLocked) {\n          var trans = this._tx || PSD.trans;\n          var tableName = this.name;\n          var task = debug && typeof console !== 'undefined' && console.createTask && console.createTask(\"Dexie: \".concat(mode === 'readonly' ? 'read' : 'write', \" \").concat(this.name));\n          function checkTableInTransaction(resolve, reject, trans) {\n              if (!trans.schema[tableName])\n                  throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n              return fn(trans.idbtrans, trans);\n          }\n          var wasRootExec = beginMicroTickScope();\n          try {\n              var p = trans && trans.db._novip === this.db._novip ?\n                  trans === PSD.trans ?\n                      trans._promise(mode, checkTableInTransaction, writeLocked) :\n                      newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :\n                  tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n              if (task) {\n                  p._consoleTask = task;\n                  p = p.catch(function (err) {\n                      console.trace(err);\n                      return rejection(err);\n                  });\n              }\n              return p;\n          }\n          finally {\n              if (wasRootExec)\n                  endMicroTickScope();\n          }\n      };\n      Table.prototype.get = function (keyOrCrit, cb) {\n          var _this = this;\n          if (keyOrCrit && keyOrCrit.constructor === Object)\n              return this.where(keyOrCrit).first(cb);\n          if (keyOrCrit == null)\n              return rejection(new exceptions.Type(\"Invalid argument to Table.get()\"));\n          return this._trans('readonly', function (trans) {\n              return _this.core.get({ trans: trans, key: keyOrCrit })\n                  .then(function (res) { return _this.hook.reading.fire(res); });\n          }).then(cb);\n      };\n      Table.prototype.where = function (indexOrCrit) {\n          if (typeof indexOrCrit === 'string')\n              return new this.db.WhereClause(this, indexOrCrit);\n          if (isArray(indexOrCrit))\n              return new this.db.WhereClause(this, \"[\".concat(indexOrCrit.join('+'), \"]\"));\n          var keyPaths = keys(indexOrCrit);\n          if (keyPaths.length === 1)\n              return this\n                  .where(keyPaths[0])\n                  .equals(indexOrCrit[keyPaths[0]]);\n          var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {\n              if (ix.compound &&\n                  keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; })) {\n                  for (var i = 0; i < keyPaths.length; ++i) {\n                      if (keyPaths.indexOf(ix.keyPath[i]) === -1)\n                          return false;\n                  }\n                  return true;\n              }\n              return false;\n          }).sort(function (a, b) { return a.keyPath.length - b.keyPath.length; })[0];\n          if (compoundIndex && this.db._maxKey !== maxString) {\n              var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n              return this\n                  .where(keyPathsInValidOrder)\n                  .equals(keyPathsInValidOrder.map(function (kp) { return indexOrCrit[kp]; }));\n          }\n          if (!compoundIndex && debug)\n              console.warn(\"The query \".concat(JSON.stringify(indexOrCrit), \" on \").concat(this.name, \" would benefit from a \") +\n                  \"compound index [\".concat(keyPaths.join('+'), \"]\"));\n          var idxByName = this.schema.idxByName;\n          function equals(a, b) {\n              return cmp(a, b) === 0;\n          }\n          var _a = keyPaths.reduce(function (_a, keyPath) {\n              var prevIndex = _a[0], prevFilterFn = _a[1];\n              var index = idxByName[keyPath];\n              var value = indexOrCrit[keyPath];\n              return [\n                  prevIndex || index,\n                  prevIndex || !index ?\n                      combine(prevFilterFn, index && index.multi ?\n                          function (x) {\n                              var prop = getByKeyPath(x, keyPath);\n                              return isArray(prop) && prop.some(function (item) { return equals(value, item); });\n                          } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })\n                      : prevFilterFn\n              ];\n          }, [null, null]), idx = _a[0], filterFunction = _a[1];\n          return idx ?\n              this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                  .filter(filterFunction) :\n              compoundIndex ?\n                  this.filter(filterFunction) :\n                  this.where(keyPaths).equals('');\n      };\n      Table.prototype.filter = function (filterFunction) {\n          return this.toCollection().and(filterFunction);\n      };\n      Table.prototype.count = function (thenShortcut) {\n          return this.toCollection().count(thenShortcut);\n      };\n      Table.prototype.offset = function (offset) {\n          return this.toCollection().offset(offset);\n      };\n      Table.prototype.limit = function (numRows) {\n          return this.toCollection().limit(numRows);\n      };\n      Table.prototype.each = function (callback) {\n          return this.toCollection().each(callback);\n      };\n      Table.prototype.toArray = function (thenShortcut) {\n          return this.toCollection().toArray(thenShortcut);\n      };\n      Table.prototype.toCollection = function () {\n          return new this.db.Collection(new this.db.WhereClause(this));\n      };\n      Table.prototype.orderBy = function (index) {\n          return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n              \"[\".concat(index.join('+'), \"]\") :\n              index));\n      };\n      Table.prototype.reverse = function () {\n          return this.toCollection().reverse();\n      };\n      Table.prototype.mapToClass = function (constructor) {\n          var _a = this, db = _a.db, tableName = _a.name;\n          this.schema.mappedClass = constructor;\n          if (constructor.prototype instanceof Entity) {\n              constructor =  (function (_super) {\n                  __extends(class_1, _super);\n                  function class_1() {\n                      return _super !== null && _super.apply(this, arguments) || this;\n                  }\n                  Object.defineProperty(class_1.prototype, \"db\", {\n                      get: function () { return db; },\n                      enumerable: false,\n                      configurable: true\n                  });\n                  class_1.prototype.table = function () { return tableName; };\n                  return class_1;\n              }(constructor));\n          }\n          var inheritedProps = new Set();\n          for (var proto = constructor.prototype; proto; proto = getProto(proto)) {\n              Object.getOwnPropertyNames(proto).forEach(function (propName) { return inheritedProps.add(propName); });\n          }\n          var readHook = function (obj) {\n              if (!obj)\n                  return obj;\n              var res = Object.create(constructor.prototype);\n              for (var m in obj)\n                  if (!inheritedProps.has(m))\n                      try {\n                          res[m] = obj[m];\n                      }\n                      catch (_) { }\n              return res;\n          };\n          if (this.schema.readHook) {\n              this.hook.reading.unsubscribe(this.schema.readHook);\n          }\n          this.schema.readHook = readHook;\n          this.hook(\"reading\", readHook);\n          return constructor;\n      };\n      Table.prototype.defineClass = function () {\n          function Class(content) {\n              extend(this, content);\n          }\n          return this.mapToClass(Class);\n      };\n      Table.prototype.add = function (obj, key) {\n          var _this = this;\n          var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n          var objToAdd = obj;\n          if (keyPath && auto) {\n              objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n          }\n          return this._trans('readwrite', function (trans) {\n              return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n          }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n              .then(function (lastResult) {\n              if (keyPath) {\n                  try {\n                      setByKeyPath(obj, keyPath, lastResult);\n                  }\n                  catch (_) { }\n              }\n              return lastResult;\n          });\n      };\n      Table.prototype.upsert = function (key, modifications) {\n          var _this = this;\n          var keyPath = this.schema.primKey.keyPath;\n          return this._trans('readwrite', function (trans) {\n              return _this.core.get({ trans: trans, key: key }).then(function (existing) {\n                  var obj = existing !== null && existing !== void 0 ? existing : {};\n                  applyUpdateSpec(obj, modifications);\n                  if (keyPath)\n                      setByKeyPath(obj, keyPath, key);\n                  return _this.core.mutate({\n                      trans: trans,\n                      type: 'put',\n                      values: [obj],\n                      keys: [key],\n                      upsert: true,\n                      updates: { keys: [key], changeSpecs: [modifications] }\n                  }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : !!existing; });\n              });\n          });\n      };\n      Table.prototype.update = function (keyOrObject, modifications) {\n          if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n              var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n              if (key === undefined)\n                  return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n              return this.where(\":id\").equals(key).modify(modifications);\n          }\n          else {\n              return this.where(\":id\").equals(keyOrObject).modify(modifications);\n          }\n      };\n      Table.prototype.put = function (obj, key) {\n          var _this = this;\n          var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n          var objToAdd = obj;\n          if (keyPath && auto) {\n              objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n          }\n          return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })\n              .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n              .then(function (lastResult) {\n              if (keyPath) {\n                  try {\n                      setByKeyPath(obj, keyPath, lastResult);\n                  }\n                  catch (_) { }\n              }\n              return lastResult;\n          });\n      };\n      Table.prototype.delete = function (key) {\n          var _this = this;\n          return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] })\n              .then(function (res) { return builtInDeletionTrigger(_this, [key], res); })\n              .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; }); });\n      };\n      Table.prototype.clear = function () {\n          var _this = this;\n          return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange })\n              .then(function (res) { return builtInDeletionTrigger(_this, null, res); }); })\n              .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n      };\n      Table.prototype.bulkGet = function (keys) {\n          var _this = this;\n          return this._trans('readonly', function (trans) {\n              return _this.core.getMany({\n                  keys: keys,\n                  trans: trans\n              }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });\n          });\n      };\n      Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {\n          var _this = this;\n          var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n          options = options || (keys ? undefined : keysOrOptions);\n          var wantResults = options ? options.allKeys : undefined;\n          return this._trans('readwrite', function (trans) {\n              var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n              if (keyPath && keys)\n                  throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n              if (keys && keys.length !== objects.length)\n                  throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n              var numObjects = objects.length;\n              var objectsToAdd = keyPath && auto ?\n                  objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                  objects;\n              return _this.core.mutate({ trans: trans, type: 'add', keys: keys, values: objectsToAdd, wantResults: wantResults })\n                  .then(function (_a) {\n                  var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n                  var result = wantResults ? results : lastResult;\n                  if (numFailures === 0)\n                      return result;\n                  throw new BulkError(\"\".concat(_this.name, \".bulkAdd(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n              });\n          });\n      };\n      Table.prototype.bulkPut = function (objects, keysOrOptions, options) {\n          var _this = this;\n          var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n          options = options || (keys ? undefined : keysOrOptions);\n          var wantResults = options ? options.allKeys : undefined;\n          return this._trans('readwrite', function (trans) {\n              var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n              if (keyPath && keys)\n                  throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n              if (keys && keys.length !== objects.length)\n                  throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n              var numObjects = objects.length;\n              var objectsToPut = keyPath && auto ?\n                  objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                  objects;\n              return _this.core.mutate({ trans: trans, type: 'put', keys: keys, values: objectsToPut, wantResults: wantResults })\n                  .then(function (_a) {\n                  var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n                  var result = wantResults ? results : lastResult;\n                  if (numFailures === 0)\n                      return result;\n                  throw new BulkError(\"\".concat(_this.name, \".bulkPut(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n              });\n          });\n      };\n      Table.prototype.bulkUpdate = function (keysAndChanges) {\n          var _this = this;\n          var coreTable = this.core;\n          var keys = keysAndChanges.map(function (entry) { return entry.key; });\n          var changeSpecs = keysAndChanges.map(function (entry) { return entry.changes; });\n          var offsetMap = [];\n          return this._trans('readwrite', function (trans) {\n              return coreTable.getMany({ trans: trans, keys: keys, cache: 'clone' }).then(function (objs) {\n                  var resultKeys = [];\n                  var resultObjs = [];\n                  keysAndChanges.forEach(function (_a, idx) {\n                      var key = _a.key, changes = _a.changes;\n                      var obj = objs[idx];\n                      if (obj) {\n                          for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {\n                              var keyPath = _b[_i];\n                              var value = changes[keyPath];\n                              if (keyPath === _this.schema.primKey.keyPath) {\n                                  if (cmp(value, key) !== 0) {\n                                      throw new exceptions.Constraint(\"Cannot update primary key in bulkUpdate()\");\n                                  }\n                              }\n                              else {\n                                  setByKeyPath(obj, keyPath, value);\n                              }\n                          }\n                          offsetMap.push(idx);\n                          resultKeys.push(key);\n                          resultObjs.push(obj);\n                      }\n                  });\n                  var numEntries = resultKeys.length;\n                  return coreTable\n                      .mutate({\n                      trans: trans,\n                      type: 'put',\n                      keys: resultKeys,\n                      values: resultObjs,\n                      updates: {\n                          keys: keys,\n                          changeSpecs: changeSpecs\n                      }\n                  })\n                      .then(function (_a) {\n                      var numFailures = _a.numFailures, failures = _a.failures;\n                      if (numFailures === 0)\n                          return numEntries;\n                      for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {\n                          var offset = _b[_i];\n                          var mappedOffset = offsetMap[Number(offset)];\n                          if (mappedOffset != null) {\n                              var failure = failures[offset];\n                              delete failures[offset];\n                              failures[mappedOffset] = failure;\n                          }\n                      }\n                      throw new BulkError(\"\".concat(_this.name, \".bulkUpdate(): \").concat(numFailures, \" of \").concat(numEntries, \" operations failed\"), failures);\n                  });\n              });\n          });\n      };\n      Table.prototype.bulkDelete = function (keys) {\n          var _this = this;\n          var numKeys = keys.length;\n          return this._trans('readwrite', function (trans) {\n              return _this.core.mutate({ trans: trans, type: 'delete', keys: keys })\n                  .then(function (res) { return builtInDeletionTrigger(_this, keys, res); });\n          }).then(function (_a) {\n              var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;\n              if (numFailures === 0)\n                  return lastResult;\n              throw new BulkError(\"\".concat(_this.name, \".bulkDelete(): \").concat(numFailures, \" of \").concat(numKeys, \" operations failed\"), failures);\n          });\n      };\n      return Table;\n  }());\n\n  function Events(ctx) {\n      var evs = {};\n      var rv = function (eventName, subscriber) {\n          if (subscriber) {\n              var i = arguments.length, args = new Array(i - 1);\n              while (--i)\n                  args[i - 1] = arguments[i];\n              evs[eventName].subscribe.apply(null, args);\n              return ctx;\n          }\n          else if (typeof (eventName) === 'string') {\n              return evs[eventName];\n          }\n      };\n      rv.addEventType = add;\n      for (var i = 1, l = arguments.length; i < l; ++i) {\n          add(arguments[i]);\n      }\n      return rv;\n      function add(eventName, chainFunction, defaultFunction) {\n          if (typeof eventName === 'object')\n              return addConfiguredEvents(eventName);\n          if (!chainFunction)\n              chainFunction = reverseStoppableEventChain;\n          if (!defaultFunction)\n              defaultFunction = nop;\n          var context = {\n              subscribers: [],\n              fire: defaultFunction,\n              subscribe: function (cb) {\n                  if (context.subscribers.indexOf(cb) === -1) {\n                      context.subscribers.push(cb);\n                      context.fire = chainFunction(context.fire, cb);\n                  }\n              },\n              unsubscribe: function (cb) {\n                  context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                  context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n              }\n          };\n          evs[eventName] = rv[eventName] = context;\n          return context;\n      }\n      function addConfiguredEvents(cfg) {\n          keys(cfg).forEach(function (eventName) {\n              var args = cfg[eventName];\n              if (isArray(args)) {\n                  add(eventName, cfg[eventName][0], cfg[eventName][1]);\n              }\n              else if (args === 'asap') {\n                  var context = add(eventName, mirror, function fire() {\n                      var i = arguments.length, args = new Array(i);\n                      while (i--)\n                          args[i] = arguments[i];\n                      context.subscribers.forEach(function (fn) {\n                          asap$1(function fireEvent() {\n                              fn.apply(null, args);\n                          });\n                      });\n                  });\n              }\n              else\n                  throw new exceptions.InvalidArgument(\"Invalid event config\");\n          });\n      }\n  }\n\n  function makeClassConstructor(prototype, constructor) {\n      derive(constructor).from({ prototype: prototype });\n      return constructor;\n  }\n\n  function createTableConstructor(db) {\n      return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n          this.db = db;\n          this._tx = trans;\n          this.name = name;\n          this.schema = tableSchema;\n          this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n              \"creating\": [hookCreatingChain, nop],\n              \"reading\": [pureFunctionChain, mirror],\n              \"updating\": [hookUpdatingChain, nop],\n              \"deleting\": [hookDeletingChain, nop]\n          });\n      });\n  }\n\n  function isPlainKeyRange(ctx, ignoreLimitFilter) {\n      return !(ctx.filter || ctx.algorithm || ctx.or) &&\n          (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n  }\n  function addFilter(ctx, fn) {\n      ctx.filter = combine(ctx.filter, fn);\n  }\n  function addReplayFilter(ctx, factory, isLimitFilter) {\n      var curr = ctx.replayFilter;\n      ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;\n      ctx.justLimit = isLimitFilter && !curr;\n  }\n  function addMatchFilter(ctx, fn) {\n      ctx.isMatch = combine(ctx.isMatch, fn);\n  }\n  function getIndexOrStore(ctx, coreSchema) {\n      if (ctx.isPrimKey)\n          return coreSchema.primaryKey;\n      var index = coreSchema.getIndexByKeyPath(ctx.index);\n      if (!index)\n          throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n      return index;\n  }\n  function openCursor(ctx, coreTable, trans) {\n      var index = getIndexOrStore(ctx, coreTable.schema);\n      return coreTable.openCursor({\n          trans: trans,\n          values: !ctx.keysOnly,\n          reverse: ctx.dir === 'prev',\n          unique: !!ctx.unique,\n          query: {\n              index: index,\n              range: ctx.range\n          }\n      });\n  }\n  function iter(ctx, fn, coreTrans, coreTable) {\n      var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n      if (!ctx.or) {\n          return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n      }\n      else {\n          var set_1 = {};\n          var union = function (item, cursor, advance) {\n              if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {\n                  var primaryKey = cursor.primaryKey;\n                  var key = '' + primaryKey;\n                  if (key === '[object ArrayBuffer]')\n                      key = '' + new Uint8Array(primaryKey);\n                  if (!hasOwn(set_1, key)) {\n                      set_1[key] = true;\n                      fn(item, cursor, advance);\n                  }\n              }\n          };\n          return Promise.all([\n              ctx.or._iterate(union, coreTrans),\n              iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n          ]);\n      }\n  }\n  function iterate(cursorPromise, filter, fn, valueMapper) {\n      var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;\n      var wrappedFn = wrap(mappedFn);\n      return cursorPromise.then(function (cursor) {\n          if (cursor) {\n              return cursor.start(function () {\n                  var c = function () { return cursor.continue(); };\n                  if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))\n                      wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });\n                  c();\n              });\n          }\n      });\n  }\n\n  var Collection =  (function () {\n      function Collection() {\n      }\n      Collection.prototype._read = function (fn, cb) {\n          var ctx = this._ctx;\n          return ctx.error ?\n              ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n              ctx.table._trans('readonly', fn).then(cb);\n      };\n      Collection.prototype._write = function (fn) {\n          var ctx = this._ctx;\n          return ctx.error ?\n              ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n              ctx.table._trans('readwrite', fn, \"locked\");\n      };\n      Collection.prototype._addAlgorithm = function (fn) {\n          var ctx = this._ctx;\n          ctx.algorithm = combine(ctx.algorithm, fn);\n      };\n      Collection.prototype._iterate = function (fn, coreTrans) {\n          return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n      };\n      Collection.prototype.clone = function (props) {\n          var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n          if (props)\n              extend(ctx, props);\n          rv._ctx = ctx;\n          return rv;\n      };\n      Collection.prototype.raw = function () {\n          this._ctx.valueMapper = null;\n          return this;\n      };\n      Collection.prototype.each = function (fn) {\n          var ctx = this._ctx;\n          return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });\n      };\n      Collection.prototype.count = function (cb) {\n          var _this = this;\n          return this._read(function (trans) {\n              var ctx = _this._ctx;\n              var coreTable = ctx.table.core;\n              if (isPlainKeyRange(ctx, true)) {\n                  return coreTable.count({\n                      trans: trans,\n                      query: {\n                          index: getIndexOrStore(ctx, coreTable.schema),\n                          range: ctx.range\n                      }\n                  }).then(function (count) { return Math.min(count, ctx.limit); });\n              }\n              else {\n                  var count = 0;\n                  return iter(ctx, function () { ++count; return false; }, trans, coreTable)\n                      .then(function () { return count; });\n              }\n          }).then(cb);\n      };\n      Collection.prototype.sortBy = function (keyPath, cb) {\n          var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n          function getval(obj, i) {\n              if (i)\n                  return getval(obj[parts[i]], i - 1);\n              return obj[lastPart];\n          }\n          var order = this._ctx.dir === \"next\" ? 1 : -1;\n          function sorter(a, b) {\n              var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n              return cmp(aVal, bVal) * order;\n          }\n          return this.toArray(function (a) {\n              return a.sort(sorter);\n          }).then(cb);\n      };\n      Collection.prototype.toArray = function (cb) {\n          var _this = this;\n          return this._read(function (trans) {\n              var ctx = _this._ctx;\n              if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                  var valueMapper_1 = ctx.valueMapper;\n                  var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                  return ctx.table.core.query({\n                      trans: trans,\n                      limit: ctx.limit,\n                      values: true,\n                      query: {\n                          index: index,\n                          range: ctx.range\n                      }\n                  }).then(function (_a) {\n                      var result = _a.result;\n                      return valueMapper_1 ? result.map(valueMapper_1) : result;\n                  });\n              }\n              else {\n                  var a_1 = [];\n                  return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });\n              }\n          }, cb);\n      };\n      Collection.prototype.offset = function (offset) {\n          var ctx = this._ctx;\n          if (offset <= 0)\n              return this;\n          ctx.offset += offset;\n          if (isPlainKeyRange(ctx)) {\n              addReplayFilter(ctx, function () {\n                  var offsetLeft = offset;\n                  return function (cursor, advance) {\n                      if (offsetLeft === 0)\n                          return true;\n                      if (offsetLeft === 1) {\n                          --offsetLeft;\n                          return false;\n                      }\n                      advance(function () {\n                          cursor.advance(offsetLeft);\n                          offsetLeft = 0;\n                      });\n                      return false;\n                  };\n              });\n          }\n          else {\n              addReplayFilter(ctx, function () {\n                  var offsetLeft = offset;\n                  return function () { return (--offsetLeft < 0); };\n              });\n          }\n          return this;\n      };\n      Collection.prototype.limit = function (numRows) {\n          this._ctx.limit = Math.min(this._ctx.limit, numRows);\n          addReplayFilter(this._ctx, function () {\n              var rowsLeft = numRows;\n              return function (cursor, advance, resolve) {\n                  if (--rowsLeft <= 0)\n                      advance(resolve);\n                  return rowsLeft >= 0;\n              };\n          }, true);\n          return this;\n      };\n      Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {\n          addFilter(this._ctx, function (cursor, advance, resolve) {\n              if (filterFunction(cursor.value)) {\n                  advance(resolve);\n                  return bIncludeStopEntry;\n              }\n              else {\n                  return true;\n              }\n          });\n          return this;\n      };\n      Collection.prototype.first = function (cb) {\n          return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n      };\n      Collection.prototype.last = function (cb) {\n          return this.reverse().first(cb);\n      };\n      Collection.prototype.filter = function (filterFunction) {\n          addFilter(this._ctx, function (cursor) {\n              return filterFunction(cursor.value);\n          });\n          addMatchFilter(this._ctx, filterFunction);\n          return this;\n      };\n      Collection.prototype.and = function (filter) {\n          return this.filter(filter);\n      };\n      Collection.prototype.or = function (indexName) {\n          return new this.db.WhereClause(this._ctx.table, indexName, this);\n      };\n      Collection.prototype.reverse = function () {\n          this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n          if (this._ondirectionchange)\n              this._ondirectionchange(this._ctx.dir);\n          return this;\n      };\n      Collection.prototype.desc = function () {\n          return this.reverse();\n      };\n      Collection.prototype.eachKey = function (cb) {\n          var ctx = this._ctx;\n          ctx.keysOnly = !ctx.isMatch;\n          return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n      };\n      Collection.prototype.eachUniqueKey = function (cb) {\n          this._ctx.unique = \"unique\";\n          return this.eachKey(cb);\n      };\n      Collection.prototype.eachPrimaryKey = function (cb) {\n          var ctx = this._ctx;\n          ctx.keysOnly = !ctx.isMatch;\n          return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n      };\n      Collection.prototype.keys = function (cb) {\n          var ctx = this._ctx;\n          ctx.keysOnly = !ctx.isMatch;\n          var a = [];\n          return this.each(function (item, cursor) {\n              a.push(cursor.key);\n          }).then(function () {\n              return a;\n          }).then(cb);\n      };\n      Collection.prototype.primaryKeys = function (cb) {\n          var ctx = this._ctx;\n          if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n              return this._read(function (trans) {\n                  var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                  return ctx.table.core.query({\n                      trans: trans,\n                      values: false,\n                      limit: ctx.limit,\n                      query: {\n                          index: index,\n                          range: ctx.range\n                      }\n                  });\n              }).then(function (_a) {\n                  var result = _a.result;\n                  return result;\n              }).then(cb);\n          }\n          ctx.keysOnly = !ctx.isMatch;\n          var a = [];\n          return this.each(function (item, cursor) {\n              a.push(cursor.primaryKey);\n          }).then(function () {\n              return a;\n          }).then(cb);\n      };\n      Collection.prototype.uniqueKeys = function (cb) {\n          this._ctx.unique = \"unique\";\n          return this.keys(cb);\n      };\n      Collection.prototype.firstKey = function (cb) {\n          return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n      };\n      Collection.prototype.lastKey = function (cb) {\n          return this.reverse().firstKey(cb);\n      };\n      Collection.prototype.distinct = function () {\n          var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n          if (!idx || !idx.multi)\n              return this;\n          var set = {};\n          addFilter(this._ctx, function (cursor) {\n              var strKey = cursor.primaryKey.toString();\n              var found = hasOwn(set, strKey);\n              set[strKey] = true;\n              return !found;\n          });\n          return this;\n      };\n      Collection.prototype.modify = function (changes) {\n          var _this = this;\n          var ctx = this._ctx;\n          return this._write(function (trans) {\n              var modifyer;\n              if (typeof changes === 'function') {\n                  modifyer = changes;\n              }\n              else {\n                  modifyer = function (item) { return applyUpdateSpec(item, changes); };\n              }\n              var coreTable = ctx.table.core;\n              var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;\n              var limit = 200;\n              var modifyChunkSize = _this.db._options.modifyChunkSize;\n              if (modifyChunkSize) {\n                  if (typeof modifyChunkSize == 'object') {\n                      limit = modifyChunkSize[coreTable.name] || modifyChunkSize['*'] || 200;\n                  }\n                  else {\n                      limit = modifyChunkSize;\n                  }\n              }\n              var totalFailures = [];\n              var successCount = 0;\n              var failedKeys = [];\n              var applyMutateResult = function (expectedCount, res) {\n                  var failures = res.failures, numFailures = res.numFailures;\n                  successCount += expectedCount - numFailures;\n                  for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {\n                      var pos = _a[_i];\n                      totalFailures.push(failures[pos]);\n                  }\n              };\n              var isUnconditionalDelete = changes === deleteCallback;\n              return _this.clone().primaryKeys().then(function (keys) {\n                  var criteria = isPlainKeyRange(ctx) &&\n                      ctx.limit === Infinity &&\n                      (typeof changes !== 'function' || isUnconditionalDelete) && {\n                      index: ctx.index,\n                      range: ctx.range\n                  };\n                  var nextChunk = function (offset) {\n                      var count = Math.min(limit, keys.length - offset);\n                      var keysInChunk = keys.slice(offset, offset + count);\n                      return (isUnconditionalDelete ? Promise.resolve([]) : coreTable.getMany({\n                          trans: trans,\n                          keys: keysInChunk,\n                          cache: \"immutable\"\n                      })).then(function (values) {\n                          var addValues = [];\n                          var putValues = [];\n                          var putKeys = outbound ? [] : null;\n                          var deleteKeys = isUnconditionalDelete ? keysInChunk : [];\n                          if (!isUnconditionalDelete)\n                              for (var i = 0; i < count; ++i) {\n                                  var origValue = values[i];\n                                  var ctx_1 = {\n                                      value: deepClone(origValue),\n                                      primKey: keys[offset + i]\n                                  };\n                                  if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {\n                                      if (ctx_1.value == null) {\n                                          deleteKeys.push(keys[offset + i]);\n                                      }\n                                      else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {\n                                          deleteKeys.push(keys[offset + i]);\n                                          addValues.push(ctx_1.value);\n                                      }\n                                      else {\n                                          putValues.push(ctx_1.value);\n                                          if (outbound)\n                                              putKeys.push(keys[offset + i]);\n                                      }\n                                  }\n                              }\n                          return Promise.resolve(addValues.length > 0 &&\n                              coreTable.mutate({ trans: trans, type: 'add', values: addValues })\n                                  .then(function (res) {\n                                  for (var pos in res.failures) {\n                                      deleteKeys.splice(parseInt(pos), 1);\n                                  }\n                                  applyMutateResult(addValues.length, res);\n                              })).then(function () { return (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                              coreTable.mutate({\n                                  trans: trans,\n                                  type: 'put',\n                                  keys: putKeys,\n                                  values: putValues,\n                                  criteria: criteria,\n                                  changeSpec: typeof changes !== 'function'\n                                      && changes,\n                                  isAdditionalChunk: offset > 0\n                              }).then(function (res) { return applyMutateResult(putValues.length, res); }); }).then(function () { return (deleteKeys.length > 0 || (criteria && isUnconditionalDelete)) &&\n                              coreTable.mutate({\n                                  trans: trans,\n                                  type: 'delete',\n                                  keys: deleteKeys,\n                                  criteria: criteria,\n                                  isAdditionalChunk: offset > 0\n                              }).then(function (res) { return builtInDeletionTrigger(ctx.table, deleteKeys, res); })\n                                  .then(function (res) { return applyMutateResult(deleteKeys.length, res); }); }).then(function () {\n                              return keys.length > offset + count && nextChunk(offset + limit);\n                          });\n                      });\n                  };\n                  return nextChunk(0).then(function () {\n                      if (totalFailures.length > 0)\n                          throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                      return keys.length;\n                  });\n              });\n          });\n      };\n      Collection.prototype.delete = function () {\n          var ctx = this._ctx, range = ctx.range;\n          if (isPlainKeyRange(ctx) &&\n              !ctx.table.schema.yProps &&\n              (ctx.isPrimKey || range.type === 3 ))\n           {\n              return this._write(function (trans) {\n                  var primaryKey = ctx.table.core.schema.primaryKey;\n                  var coreRange = range;\n                  return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {\n                      return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })\n                          .then(function (_a) {\n                          var failures = _a.failures, numFailures = _a.numFailures;\n                          if (numFailures)\n                              throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);\n                          return count - numFailures;\n                      });\n                  });\n              });\n          }\n          return this.modify(deleteCallback);\n      };\n      return Collection;\n  }());\n  var deleteCallback = function (value, ctx) { return ctx.value = null; };\n\n  function createCollectionConstructor(db) {\n      return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n          this.db = db;\n          var keyRange = AnyRange, error = null;\n          if (keyRangeGenerator)\n              try {\n                  keyRange = keyRangeGenerator();\n              }\n              catch (ex) {\n                  error = ex;\n              }\n          var whereCtx = whereClause._ctx;\n          var table = whereCtx.table;\n          var readingHook = table.hook.reading.fire;\n          this._ctx = {\n              table: table,\n              index: whereCtx.index,\n              isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n              range: keyRange,\n              keysOnly: false,\n              dir: \"next\",\n              unique: \"\",\n              algorithm: null,\n              filter: null,\n              replayFilter: null,\n              justLimit: true,\n              isMatch: null,\n              offset: 0,\n              limit: Infinity,\n              error: error,\n              or: whereCtx.or,\n              valueMapper: readingHook !== mirror ? readingHook : null\n          };\n      });\n  }\n\n  function simpleCompare(a, b) {\n      return a < b ? -1 : a === b ? 0 : 1;\n  }\n  function simpleCompareReverse(a, b) {\n      return a > b ? -1 : a === b ? 0 : 1;\n  }\n\n  function fail(collectionOrWhereClause, err, T) {\n      var collection = collectionOrWhereClause instanceof WhereClause ?\n          new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n          collectionOrWhereClause;\n      collection._ctx.error = T ? new T(err) : new TypeError(err);\n      return collection;\n  }\n  function emptyCollection(whereClause) {\n      return new whereClause.Collection(whereClause, function () { return rangeEqual(\"\"); }).limit(0);\n  }\n  function upperFactory(dir) {\n      return dir === \"next\" ?\n          function (s) { return s.toUpperCase(); } :\n          function (s) { return s.toLowerCase(); };\n  }\n  function lowerFactory(dir) {\n      return dir === \"next\" ?\n          function (s) { return s.toLowerCase(); } :\n          function (s) { return s.toUpperCase(); };\n  }\n  function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n      var length = Math.min(key.length, lowerNeedle.length);\n      var llp = -1;\n      for (var i = 0; i < length; ++i) {\n          var lwrKeyChar = lowerKey[i];\n          if (lwrKeyChar !== lowerNeedle[i]) {\n              if (cmp(key[i], upperNeedle[i]) < 0)\n                  return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n              if (cmp(key[i], lowerNeedle[i]) < 0)\n                  return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n              if (llp >= 0)\n                  return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n              return null;\n          }\n          if (cmp(key[i], lwrKeyChar) < 0)\n              llp = i;\n      }\n      if (length < lowerNeedle.length && dir === \"next\")\n          return key + upperNeedle.substr(key.length);\n      if (length < key.length && dir === \"prev\")\n          return key.substr(0, upperNeedle.length);\n      return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n  }\n  function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n      var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n      if (!needles.every(function (s) { return typeof s === 'string'; })) {\n          return fail(whereClause, STRING_EXPECTED);\n      }\n      function initDirection(dir) {\n          upper = upperFactory(dir);\n          lower = lowerFactory(dir);\n          compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n          var needleBounds = needles.map(function (needle) {\n              return { lower: lower(needle), upper: upper(needle) };\n          }).sort(function (a, b) {\n              return compare(a.lower, b.lower);\n          });\n          upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n          lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n          direction = dir;\n          nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n      }\n      initDirection(\"next\");\n      var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });\n      c._ondirectionchange = function (direction) {\n          initDirection(direction);\n      };\n      var firstPossibleNeedle = 0;\n      c._addAlgorithm(function (cursor, advance, resolve) {\n          var key = cursor.key;\n          if (typeof key !== 'string')\n              return false;\n          var lowerKey = lower(key);\n          if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n              return true;\n          }\n          else {\n              var lowestPossibleCasing = null;\n              for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                  var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                  if (casing === null && lowestPossibleCasing === null)\n                      firstPossibleNeedle = i + 1;\n                  else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                      lowestPossibleCasing = casing;\n                  }\n              }\n              if (lowestPossibleCasing !== null) {\n                  advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n              }\n              else {\n                  advance(resolve);\n              }\n              return false;\n          }\n      });\n      return c;\n  }\n  function createRange(lower, upper, lowerOpen, upperOpen) {\n      return {\n          type: 2 ,\n          lower: lower,\n          upper: upper,\n          lowerOpen: lowerOpen,\n          upperOpen: upperOpen\n      };\n  }\n  function rangeEqual(value) {\n      return {\n          type: 1 ,\n          lower: value,\n          upper: value\n      };\n  }\n\n  var WhereClause =  (function () {\n      function WhereClause() {\n      }\n      Object.defineProperty(WhereClause.prototype, \"Collection\", {\n          get: function () {\n              return this._ctx.table.db.Collection;\n          },\n          enumerable: false,\n          configurable: true\n      });\n      WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {\n          includeLower = includeLower !== false;\n          includeUpper = includeUpper === true;\n          try {\n              if ((this._cmp(lower, upper) > 0) ||\n                  (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                  return emptyCollection(this);\n              return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });\n          }\n          catch (e) {\n              return fail(this, INVALID_KEY_ARGUMENT);\n          }\n      };\n      WhereClause.prototype.equals = function (value) {\n          if (value == null)\n              return fail(this, INVALID_KEY_ARGUMENT);\n          return new this.Collection(this, function () { return rangeEqual(value); });\n      };\n      WhereClause.prototype.above = function (value) {\n          if (value == null)\n              return fail(this, INVALID_KEY_ARGUMENT);\n          return new this.Collection(this, function () { return createRange(value, undefined, true); });\n      };\n      WhereClause.prototype.aboveOrEqual = function (value) {\n          if (value == null)\n              return fail(this, INVALID_KEY_ARGUMENT);\n          return new this.Collection(this, function () { return createRange(value, undefined, false); });\n      };\n      WhereClause.prototype.below = function (value) {\n          if (value == null)\n              return fail(this, INVALID_KEY_ARGUMENT);\n          return new this.Collection(this, function () { return createRange(undefined, value, false, true); });\n      };\n      WhereClause.prototype.belowOrEqual = function (value) {\n          if (value == null)\n              return fail(this, INVALID_KEY_ARGUMENT);\n          return new this.Collection(this, function () { return createRange(undefined, value); });\n      };\n      WhereClause.prototype.startsWith = function (str) {\n          if (typeof str !== 'string')\n              return fail(this, STRING_EXPECTED);\n          return this.between(str, str + maxString, true, true);\n      };\n      WhereClause.prototype.startsWithIgnoreCase = function (str) {\n          if (str === \"\")\n              return this.startsWith(str);\n          return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);\n      };\n      WhereClause.prototype.equalsIgnoreCase = function (str) {\n          return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], \"\");\n      };\n      WhereClause.prototype.anyOfIgnoreCase = function () {\n          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n          if (set.length === 0)\n              return emptyCollection(this);\n          return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, \"\");\n      };\n      WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {\n          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n          if (set.length === 0)\n              return emptyCollection(this);\n          return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);\n      };\n      WhereClause.prototype.anyOf = function () {\n          var _this = this;\n          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n          var compare = this._cmp;\n          try {\n              set.sort(compare);\n          }\n          catch (e) {\n              return fail(this, INVALID_KEY_ARGUMENT);\n          }\n          if (set.length === 0)\n              return emptyCollection(this);\n          var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });\n          c._ondirectionchange = function (direction) {\n              compare = (direction === \"next\" ?\n                  _this._ascending :\n                  _this._descending);\n              set.sort(compare);\n          };\n          var i = 0;\n          c._addAlgorithm(function (cursor, advance, resolve) {\n              var key = cursor.key;\n              while (compare(key, set[i]) > 0) {\n                  ++i;\n                  if (i === set.length) {\n                      advance(resolve);\n                      return false;\n                  }\n              }\n              if (compare(key, set[i]) === 0) {\n                  return true;\n              }\n              else {\n                  advance(function () { cursor.continue(set[i]); });\n                  return false;\n              }\n          });\n          return c;\n      };\n      WhereClause.prototype.notEqual = function (value) {\n          return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n      };\n      WhereClause.prototype.noneOf = function () {\n          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n          if (set.length === 0)\n              return new this.Collection(this);\n          try {\n              set.sort(this._ascending);\n          }\n          catch (e) {\n              return fail(this, INVALID_KEY_ARGUMENT);\n          }\n          var ranges = set.reduce(function (res, val) { return res ?\n              res.concat([[res[res.length - 1][1], val]]) :\n              [[minKey, val]]; }, null);\n          ranges.push([set[set.length - 1], this.db._maxKey]);\n          return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n      };\n      WhereClause.prototype.inAnyRange = function (ranges, options) {\n          var _this = this;\n          var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n          if (ranges.length === 0)\n              return emptyCollection(this);\n          if (!ranges.every(function (range) {\n              return range[0] !== undefined &&\n                  range[1] !== undefined &&\n                  ascending(range[0], range[1]) <= 0;\n          })) {\n              return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n          }\n          var includeLowers = !options || options.includeLowers !== false;\n          var includeUppers = options && options.includeUppers === true;\n          function addRange(ranges, newRange) {\n              var i = 0, l = ranges.length;\n              for (; i < l; ++i) {\n                  var range = ranges[i];\n                  if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                      range[0] = min(range[0], newRange[0]);\n                      range[1] = max(range[1], newRange[1]);\n                      break;\n                  }\n              }\n              if (i === l)\n                  ranges.push(newRange);\n              return ranges;\n          }\n          var sortDirection = ascending;\n          function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n          var set;\n          try {\n              set = ranges.reduce(addRange, []);\n              set.sort(rangeSorter);\n          }\n          catch (ex) {\n              return fail(this, INVALID_KEY_ARGUMENT);\n          }\n          var rangePos = 0;\n          var keyIsBeyondCurrentEntry = includeUppers ?\n              function (key) { return ascending(key, set[rangePos][1]) > 0; } :\n              function (key) { return ascending(key, set[rangePos][1]) >= 0; };\n          var keyIsBeforeCurrentEntry = includeLowers ?\n              function (key) { return descending(key, set[rangePos][0]) > 0; } :\n              function (key) { return descending(key, set[rangePos][0]) >= 0; };\n          function keyWithinCurrentRange(key) {\n              return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n          }\n          var checkKey = keyIsBeyondCurrentEntry;\n          var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });\n          c._ondirectionchange = function (direction) {\n              if (direction === \"next\") {\n                  checkKey = keyIsBeyondCurrentEntry;\n                  sortDirection = ascending;\n              }\n              else {\n                  checkKey = keyIsBeforeCurrentEntry;\n                  sortDirection = descending;\n              }\n              set.sort(rangeSorter);\n          };\n          c._addAlgorithm(function (cursor, advance, resolve) {\n              var key = cursor.key;\n              while (checkKey(key)) {\n                  ++rangePos;\n                  if (rangePos === set.length) {\n                      advance(resolve);\n                      return false;\n                  }\n              }\n              if (keyWithinCurrentRange(key)) {\n                  return true;\n              }\n              else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {\n                  return false;\n              }\n              else {\n                  advance(function () {\n                      if (sortDirection === ascending)\n                          cursor.continue(set[rangePos][0]);\n                      else\n                          cursor.continue(set[rangePos][1]);\n                  });\n                  return false;\n              }\n          });\n          return c;\n      };\n      WhereClause.prototype.startsWithAnyOf = function () {\n          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n          if (!set.every(function (s) { return typeof s === 'string'; })) {\n              return fail(this, \"startsWithAnyOf() only works with strings\");\n          }\n          if (set.length === 0)\n              return emptyCollection(this);\n          return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));\n      };\n      return WhereClause;\n  }());\n\n  function createWhereClauseConstructor(db) {\n      return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n          this.db = db;\n          this._ctx = {\n              table: table,\n              index: index === \":id\" ? null : index,\n              or: orCollection\n          };\n          this._cmp = this._ascending = cmp;\n          this._descending = function (a, b) { return cmp(b, a); };\n          this._max = function (a, b) { return cmp(a, b) > 0 ? a : b; };\n          this._min = function (a, b) { return cmp(a, b) < 0 ? a : b; };\n          this._IDBKeyRange = db._deps.IDBKeyRange;\n          if (!this._IDBKeyRange)\n              throw new exceptions.MissingAPI();\n      });\n  }\n\n  function eventRejectHandler(reject) {\n      return wrap(function (event) {\n          preventDefault(event);\n          reject(event.target.error);\n          return false;\n      });\n  }\n  function preventDefault(event) {\n      if (event.stopPropagation)\n          event.stopPropagation();\n      if (event.preventDefault)\n          event.preventDefault();\n  }\n\n  var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\n  var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\n  var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\n  var Transaction =  (function () {\n      function Transaction() {\n      }\n      Transaction.prototype._lock = function () {\n          assert(!PSD.global);\n          ++this._reculock;\n          if (this._reculock === 1 && !PSD.global)\n              PSD.lockOwnerFor = this;\n          return this;\n      };\n      Transaction.prototype._unlock = function () {\n          assert(!PSD.global);\n          if (--this._reculock === 0) {\n              if (!PSD.global)\n                  PSD.lockOwnerFor = null;\n              while (this._blockedFuncs.length > 0 && !this._locked()) {\n                  var fnAndPSD = this._blockedFuncs.shift();\n                  try {\n                      usePSD(fnAndPSD[1], fnAndPSD[0]);\n                  }\n                  catch (e) { }\n              }\n          }\n          return this;\n      };\n      Transaction.prototype._locked = function () {\n          return this._reculock && PSD.lockOwnerFor !== this;\n      };\n      Transaction.prototype.create = function (idbtrans) {\n          var _this = this;\n          if (!this.mode)\n              return this;\n          var idbdb = this.db.idbdb;\n          var dbOpenError = this.db._state.dbOpenError;\n          assert(!this.idbtrans);\n          if (!idbtrans && !idbdb) {\n              switch (dbOpenError && dbOpenError.name) {\n                  case \"DatabaseClosedError\":\n                      throw new exceptions.DatabaseClosed(dbOpenError);\n                  case \"MissingAPIError\":\n                      throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                  default:\n                      throw new exceptions.OpenFailed(dbOpenError);\n              }\n          }\n          if (!this.active)\n              throw new exceptions.TransactionInactive();\n          assert(this._completion._state === null);\n          idbtrans = this.idbtrans = idbtrans ||\n              (this.db.core\n                  ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                  : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n          idbtrans.onerror = wrap(function (ev) {\n              preventDefault(ev);\n              _this._reject(idbtrans.error);\n          });\n          idbtrans.onabort = wrap(function (ev) {\n              preventDefault(ev);\n              _this.active && _this._reject(new exceptions.Abort(idbtrans.error));\n              _this.active = false;\n              _this.on(\"abort\").fire(ev);\n          });\n          idbtrans.oncomplete = wrap(function () {\n              _this.active = false;\n              _this._resolve();\n              if ('mutatedParts' in idbtrans) {\n                  globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n              }\n          });\n          return this;\n      };\n      Transaction.prototype._promise = function (mode, fn, bWriteLock) {\n          var _this = this;\n          if (mode === 'readwrite' && this.mode !== 'readwrite')\n              return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n          if (!this.active)\n              return rejection(new exceptions.TransactionInactive());\n          if (this._locked()) {\n              return new DexiePromise(function (resolve, reject) {\n                  _this._blockedFuncs.push([function () {\n                          _this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                      }, PSD]);\n              });\n          }\n          else if (bWriteLock) {\n              return newScope(function () {\n                  var p = new DexiePromise(function (resolve, reject) {\n                      _this._lock();\n                      var rv = fn(resolve, reject, _this);\n                      if (rv && rv.then)\n                          rv.then(resolve, reject);\n                  });\n                  p.finally(function () { return _this._unlock(); });\n                  p._lib = true;\n                  return p;\n              });\n          }\n          else {\n              var p = new DexiePromise(function (resolve, reject) {\n                  var rv = fn(resolve, reject, _this);\n                  if (rv && rv.then)\n                      rv.then(resolve, reject);\n              });\n              p._lib = true;\n              return p;\n          }\n      };\n      Transaction.prototype._root = function () {\n          return this.parent ? this.parent._root() : this;\n      };\n      Transaction.prototype.waitFor = function (promiseLike) {\n          var root = this._root();\n          var promise = DexiePromise.resolve(promiseLike);\n          if (root._waitingFor) {\n              root._waitingFor = root._waitingFor.then(function () { return promise; });\n          }\n          else {\n              root._waitingFor = promise;\n              root._waitingQueue = [];\n              var store = root.idbtrans.objectStore(root.storeNames[0]);\n              (function spin() {\n                  ++root._spinCount;\n                  while (root._waitingQueue.length)\n                      (root._waitingQueue.shift())();\n                  if (root._waitingFor)\n                      store.get(-Infinity).onsuccess = spin;\n              }());\n          }\n          var currentWaitPromise = root._waitingFor;\n          return new DexiePromise(function (resolve, reject) {\n              promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {\n                  if (root._waitingFor === currentWaitPromise) {\n                      root._waitingFor = null;\n                  }\n              });\n          });\n      };\n      Transaction.prototype.abort = function () {\n          if (this.active) {\n              this.active = false;\n              if (this.idbtrans)\n                  this.idbtrans.abort();\n              this._reject(new exceptions.Abort());\n          }\n      };\n      Transaction.prototype.table = function (tableName) {\n          var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n          if (hasOwn(memoizedTables, tableName))\n              return memoizedTables[tableName];\n          var tableSchema = this.schema[tableName];\n          if (!tableSchema) {\n              throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n          }\n          var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n          transactionBoundTable.core = this.db.core.table(tableName);\n          memoizedTables[tableName] = transactionBoundTable;\n          return transactionBoundTable;\n      };\n      return Transaction;\n  }());\n\n  function createTransactionConstructor(db) {\n      return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n          var _this = this;\n          if (mode !== 'readonly')\n              storeNames.forEach(function (storeName) {\n                  var _a;\n                  var yProps = (_a = dbschema[storeName]) === null || _a === void 0 ? void 0 : _a.yProps;\n                  if (yProps)\n                      storeNames = storeNames.concat(yProps.map(function (p) { return p.updatesTable; }));\n              });\n          this.db = db;\n          this.mode = mode;\n          this.storeNames = storeNames;\n          this.schema = dbschema;\n          this.chromeTransactionDurability = chromeTransactionDurability;\n          this.idbtrans = null;\n          this.on = Events(this, \"complete\", \"error\", \"abort\");\n          this.parent = parent || null;\n          this.active = true;\n          this._reculock = 0;\n          this._blockedFuncs = [];\n          this._resolve = null;\n          this._reject = null;\n          this._waitingFor = null;\n          this._waitingQueue = null;\n          this._spinCount = 0;\n          this._completion = new DexiePromise(function (resolve, reject) {\n              _this._resolve = resolve;\n              _this._reject = reject;\n          });\n          this._completion.then(function () {\n              _this.active = false;\n              _this.on.complete.fire();\n          }, function (e) {\n              var wasActive = _this.active;\n              _this.active = false;\n              _this.on.error.fire(e);\n              _this.parent ?\n                  _this.parent._reject(e) :\n                  wasActive && _this.idbtrans && _this.idbtrans.abort();\n              return rejection(e);\n          });\n      });\n  }\n\n  function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey, type) {\n      return {\n          name: name,\n          keyPath: keyPath,\n          unique: unique,\n          multi: multi,\n          auto: auto,\n          compound: compound,\n          src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath),\n          type: type\n      };\n  }\n  function nameFromKeyPath(keyPath) {\n      return typeof keyPath === 'string' ?\n          keyPath :\n          keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n  }\n\n  function createTableSchema(name, primKey, indexes) {\n      return {\n          name: name,\n          primKey: primKey,\n          indexes: indexes,\n          mappedClass: null,\n          idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; }),\n      };\n  }\n\n  function safariMultiStoreFix(storeNames) {\n      return storeNames.length === 1 ? storeNames[0] : storeNames;\n  }\n  var getMaxKey = function (IdbKeyRange) {\n      try {\n          IdbKeyRange.only([[]]);\n          getMaxKey = function () { return [[]]; };\n          return [[]];\n      }\n      catch (e) {\n          getMaxKey = function () { return maxString; };\n          return maxString;\n      }\n  };\n\n  function getKeyExtractor(keyPath) {\n      if (keyPath == null) {\n          return function () { return undefined; };\n      }\n      else if (typeof keyPath === 'string') {\n          return getSinglePathKeyExtractor(keyPath);\n      }\n      else {\n          return function (obj) { return getByKeyPath(obj, keyPath); };\n      }\n  }\n  function getSinglePathKeyExtractor(keyPath) {\n      var split = keyPath.split('.');\n      if (split.length === 1) {\n          return function (obj) { return obj[keyPath]; };\n      }\n      else {\n          return function (obj) { return getByKeyPath(obj, keyPath); };\n      }\n  }\n\n  function arrayify(arrayLike) {\n      return [].slice.call(arrayLike);\n  }\n  var _id_counter = 0;\n  function getKeyPathAlias(keyPath) {\n      return keyPath == null ?\n          \":id\" :\n          typeof keyPath === 'string' ?\n              keyPath :\n              \"[\".concat(keyPath.join('+'), \"]\");\n  }\n  function createDBCore(db, IdbKeyRange, tmpTrans) {\n      function extractSchema(db, trans) {\n          var tables = arrayify(db.objectStoreNames);\n          return {\n              schema: {\n                  name: db.name,\n                  tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {\n                      var keyPath = store.keyPath, autoIncrement = store.autoIncrement;\n                      var compound = isArray(keyPath);\n                      var outbound = keyPath == null;\n                      var indexByKeyPath = {};\n                      var result = {\n                          name: store.name,\n                          primaryKey: {\n                              name: null,\n                              isPrimaryKey: true,\n                              outbound: outbound,\n                              compound: compound,\n                              keyPath: keyPath,\n                              autoIncrement: autoIncrement,\n                              unique: true,\n                              extractKey: getKeyExtractor(keyPath)\n                          },\n                          indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })\n                              .map(function (index) {\n                              var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;\n                              var compound = isArray(keyPath);\n                              var result = {\n                                  name: name,\n                                  compound: compound,\n                                  keyPath: keyPath,\n                                  unique: unique,\n                                  multiEntry: multiEntry,\n                                  extractKey: getKeyExtractor(keyPath)\n                              };\n                              indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                              return result;\n                          }),\n                          getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }\n                      };\n                      indexByKeyPath[\":id\"] = result.primaryKey;\n                      if (keyPath != null) {\n                          indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                      }\n                      return result;\n                  })\n              },\n              hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                  !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                      !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                      [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n          };\n      }\n      function makeIDBKeyRange(range) {\n          if (range.type === 3 )\n              return null;\n          if (range.type === 4 )\n              throw new Error(\"Cannot convert never type to IDBKeyRange\");\n          var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;\n          var idbRange = lower === undefined ?\n              upper === undefined ?\n                  null :\n                  IdbKeyRange.upperBound(upper, !!upperOpen) :\n              upper === undefined ?\n                  IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                  IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n          return idbRange;\n      }\n      function createDbCoreTable(tableSchema) {\n          var tableName = tableSchema.name;\n          function mutate(_a) {\n              var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;\n              return new Promise(function (resolve, reject) {\n                  resolve = wrap(resolve);\n                  var store = trans.objectStore(tableName);\n                  var outbound = store.keyPath == null;\n                  var isAddOrPut = type === \"put\" || type === \"add\";\n                  if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                      throw new Error(\"Invalid operation type: \" + type);\n                  var length = (keys || values || { length: 1 }).length;\n                  if (keys && values && keys.length !== values.length) {\n                      throw new Error(\"Given keys array must have same length as given values array.\");\n                  }\n                  if (length === 0)\n                      return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                  var req;\n                  var reqs = [];\n                  var failures = [];\n                  var numFailures = 0;\n                  var errorHandler = function (event) {\n                      ++numFailures;\n                      preventDefault(event);\n                  };\n                  if (type === 'deleteRange') {\n                      if (range.type === 4 )\n                          return resolve({ numFailures: numFailures, failures: failures, results: [], lastResult: undefined });\n                      if (range.type === 3 )\n                          reqs.push(req = store.clear());\n                      else\n                          reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                  }\n                  else {\n                      var _a = isAddOrPut ?\n                          outbound ?\n                              [values, keys] :\n                              [values, null] :\n                          [keys, null], args1 = _a[0], args2 = _a[1];\n                      if (isAddOrPut) {\n                          for (var i = 0; i < length; ++i) {\n                              reqs.push(req = (args2 && args2[i] !== undefined ?\n                                  store[type](args1[i], args2[i]) :\n                                  store[type](args1[i])));\n                              req.onerror = errorHandler;\n                          }\n                      }\n                      else {\n                          for (var i = 0; i < length; ++i) {\n                              reqs.push(req = store[type](args1[i]));\n                              req.onerror = errorHandler;\n                          }\n                      }\n                  }\n                  var done = function (event) {\n                      var lastResult = event.target.result;\n                      reqs.forEach(function (req, i) { return req.error != null && (failures[i] = req.error); });\n                      resolve({\n                          numFailures: numFailures,\n                          failures: failures,\n                          results: type === \"delete\" ? keys : reqs.map(function (req) { return req.result; }),\n                          lastResult: lastResult\n                      });\n                  };\n                  req.onerror = function (event) {\n                      errorHandler(event);\n                      done(event);\n                  };\n                  req.onsuccess = done;\n              });\n          }\n          function openCursor(_a) {\n              var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;\n              return new Promise(function (resolve, reject) {\n                  resolve = wrap(resolve);\n                  var index = query.index, range = query.range;\n                  var store = trans.objectStore(tableName);\n                  var source = index.isPrimaryKey ?\n                      store :\n                      store.index(index.name);\n                  var direction = reverse ?\n                      unique ?\n                          \"prevunique\" :\n                          \"prev\" :\n                      unique ?\n                          \"nextunique\" :\n                          \"next\";\n                  var req = values || !('openKeyCursor' in source) ?\n                      source.openCursor(makeIDBKeyRange(range), direction) :\n                      source.openKeyCursor(makeIDBKeyRange(range), direction);\n                  req.onerror = eventRejectHandler(reject);\n                  req.onsuccess = wrap(function (ev) {\n                      var cursor = req.result;\n                      if (!cursor) {\n                          resolve(null);\n                          return;\n                      }\n                      cursor.___id = ++_id_counter;\n                      cursor.done = false;\n                      var _cursorContinue = cursor.continue.bind(cursor);\n                      var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                      if (_cursorContinuePrimaryKey)\n                          _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                      var _cursorAdvance = cursor.advance.bind(cursor);\n                      var doThrowCursorIsNotStarted = function () { throw new Error(\"Cursor not started\"); };\n                      var doThrowCursorIsStopped = function () { throw new Error(\"Cursor not stopped\"); };\n                      cursor.trans = trans;\n                      cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                      cursor.fail = wrap(reject);\n                      cursor.next = function () {\n                          var _this = this;\n                          var gotOne = 1;\n                          return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });\n                      };\n                      cursor.start = function (callback) {\n                          var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {\n                              resolveIteration = wrap(resolveIteration);\n                              req.onerror = eventRejectHandler(rejectIteration);\n                              cursor.fail = rejectIteration;\n                              cursor.stop = function (value) {\n                                  cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                  resolveIteration(value);\n                              };\n                          });\n                          var guardedCallback = function () {\n                              if (req.result) {\n                                  try {\n                                      callback();\n                                  }\n                                  catch (err) {\n                                      cursor.fail(err);\n                                  }\n                              }\n                              else {\n                                  cursor.done = true;\n                                  cursor.start = function () { throw new Error(\"Cursor behind last entry\"); };\n                                  cursor.stop();\n                              }\n                          };\n                          req.onsuccess = wrap(function (ev) {\n                              req.onsuccess = guardedCallback;\n                              guardedCallback();\n                          });\n                          cursor.continue = _cursorContinue;\n                          cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                          cursor.advance = _cursorAdvance;\n                          guardedCallback();\n                          return iterationPromise;\n                      };\n                      resolve(cursor);\n                  }, reject);\n              });\n          }\n          function query(hasGetAll) {\n              return function (request) {\n                  return new Promise(function (resolve, reject) {\n                      resolve = wrap(resolve);\n                      var trans = request.trans, values = request.values, limit = request.limit, query = request.query;\n                      var nonInfinitLimit = limit === Infinity ? undefined : limit;\n                      var index = query.index, range = query.range;\n                      var store = trans.objectStore(tableName);\n                      var source = index.isPrimaryKey ? store : store.index(index.name);\n                      var idbKeyRange = makeIDBKeyRange(range);\n                      if (limit === 0)\n                          return resolve({ result: [] });\n                      if (hasGetAll) {\n                          var req = values ?\n                              source.getAll(idbKeyRange, nonInfinitLimit) :\n                              source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                          req.onsuccess = function (event) { return resolve({ result: event.target.result }); };\n                          req.onerror = eventRejectHandler(reject);\n                      }\n                      else {\n                          var count_1 = 0;\n                          var req_1 = values || !('openKeyCursor' in source) ?\n                              source.openCursor(idbKeyRange) :\n                              source.openKeyCursor(idbKeyRange);\n                          var result_1 = [];\n                          req_1.onsuccess = function (event) {\n                              var cursor = req_1.result;\n                              if (!cursor)\n                                  return resolve({ result: result_1 });\n                              result_1.push(values ? cursor.value : cursor.primaryKey);\n                              if (++count_1 === limit)\n                                  return resolve({ result: result_1 });\n                              cursor.continue();\n                          };\n                          req_1.onerror = eventRejectHandler(reject);\n                      }\n                  });\n              };\n          }\n          return {\n              name: tableName,\n              schema: tableSchema,\n              mutate: mutate,\n              getMany: function (_a) {\n                  var trans = _a.trans, keys = _a.keys;\n                  return new Promise(function (resolve, reject) {\n                      resolve = wrap(resolve);\n                      var store = trans.objectStore(tableName);\n                      var length = keys.length;\n                      var result = new Array(length);\n                      var keyCount = 0;\n                      var callbackCount = 0;\n                      var req;\n                      var successHandler = function (event) {\n                          var req = event.target;\n                          if ((result[req._pos] = req.result) != null)\n                              ;\n                          if (++callbackCount === keyCount)\n                              resolve(result);\n                      };\n                      var errorHandler = eventRejectHandler(reject);\n                      for (var i = 0; i < length; ++i) {\n                          var key = keys[i];\n                          if (key != null) {\n                              req = store.get(keys[i]);\n                              req._pos = i;\n                              req.onsuccess = successHandler;\n                              req.onerror = errorHandler;\n                              ++keyCount;\n                          }\n                      }\n                      if (keyCount === 0)\n                          resolve(result);\n                  });\n              },\n              get: function (_a) {\n                  var trans = _a.trans, key = _a.key;\n                  return new Promise(function (resolve, reject) {\n                      resolve = wrap(resolve);\n                      var store = trans.objectStore(tableName);\n                      var req = store.get(key);\n                      req.onsuccess = function (event) { return resolve(event.target.result); };\n                      req.onerror = eventRejectHandler(reject);\n                  });\n              },\n              query: query(hasGetAll),\n              openCursor: openCursor,\n              count: function (_a) {\n                  var query = _a.query, trans = _a.trans;\n                  var index = query.index, range = query.range;\n                  return new Promise(function (resolve, reject) {\n                      var store = trans.objectStore(tableName);\n                      var source = index.isPrimaryKey ? store : store.index(index.name);\n                      var idbKeyRange = makeIDBKeyRange(range);\n                      var req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                      req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });\n                      req.onerror = eventRejectHandler(reject);\n                  });\n              }\n          };\n      }\n      var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;\n      var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });\n      var tableMap = {};\n      tables.forEach(function (table) { return tableMap[table.name] = table; });\n      return {\n          stack: \"dbcore\",\n          transaction: db.transaction.bind(db),\n          table: function (name) {\n              var result = tableMap[name];\n              if (!result)\n                  throw new Error(\"Table '\".concat(name, \"' not found\"));\n              return tableMap[name];\n          },\n          MIN_KEY: -Infinity,\n          MAX_KEY: getMaxKey(IdbKeyRange),\n          schema: schema\n      };\n  }\n\n  function createMiddlewareStack(stackImpl, middlewares) {\n      return middlewares.reduce(function (down, _a) {\n          var create = _a.create;\n          return (__assign(__assign({}, down), create(down)));\n      }, stackImpl);\n  }\n  function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {\n      var IDBKeyRange = _a.IDBKeyRange; _a.indexedDB;\n      var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n      return {\n          dbcore: dbcore\n      };\n  }\n  function generateMiddlewareStacks(db, tmpTrans) {\n      var idbdb = tmpTrans.db;\n      var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n      db.core = stacks.dbcore;\n      db.tables.forEach(function (table) {\n          var tableName = table.name;\n          if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {\n              table.core = db.core.table(tableName);\n              if (db[tableName] instanceof db.Table) {\n                  db[tableName].core = table.core;\n              }\n          }\n      });\n  }\n\n  function setApiOnPlace(db, objs, tableNames, dbschema) {\n      tableNames.forEach(function (tableName) {\n          var schema = dbschema[tableName];\n          objs.forEach(function (obj) {\n              var propDesc = getPropertyDescriptor(obj, tableName);\n              if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                  if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                      setProp(obj, tableName, {\n                          get: function () { return this.table(tableName); },\n                          set: function (value) {\n                              defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });\n                          }\n                      });\n                  }\n                  else {\n                      obj[tableName] = new db.Table(tableName, schema);\n                  }\n              }\n          });\n      });\n  }\n  function removeTablesApi(db, objs) {\n      objs.forEach(function (obj) {\n          for (var key in obj) {\n              if (obj[key] instanceof db.Table)\n                  delete obj[key];\n          }\n      });\n  }\n  function lowerVersionFirst(a, b) {\n      return a._cfg.version - b._cfg.version;\n  }\n  function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n      var globalSchema = db._dbSchema;\n      if (idbUpgradeTrans.objectStoreNames.contains('$meta') && !globalSchema.$meta) {\n          globalSchema.$meta = createTableSchema(\"$meta\", parseIndexSyntax(\"\")[0], []);\n          db._storeNames.push('$meta');\n      }\n      var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n      trans.create(idbUpgradeTrans);\n      trans._completion.catch(reject);\n      var rejectTransaction = trans._reject.bind(trans);\n      var transless = PSD.transless || PSD;\n      newScope(function () {\n          PSD.trans = trans;\n          PSD.transless = transless;\n          if (oldVersion === 0) {\n              keys(globalSchema).forEach(function (tableName) {\n                  createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n              });\n              generateMiddlewareStacks(db, idbUpgradeTrans);\n              DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);\n          }\n          else {\n              generateMiddlewareStacks(db, idbUpgradeTrans);\n              return getExistingVersion(db, trans, oldVersion)\n                  .then(function (oldVersion) { return updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans); })\n                  .catch(rejectTransaction);\n          }\n      });\n  }\n  function patchCurrentVersion(db, idbUpgradeTrans) {\n      createMissingTables(db._dbSchema, idbUpgradeTrans);\n      if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains('$meta')) {\n          idbUpgradeTrans.db.createObjectStore('$meta').add(Math.ceil((idbUpgradeTrans.db.version / 10) - 1), 'version');\n      }\n      var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n      adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);\n      var diff = getSchemaDiff(globalSchema, db._dbSchema);\n      var _loop_1 = function (tableChange) {\n          if (tableChange.change.length || tableChange.recreate) {\n              console.warn(\"Unable to patch indexes of table \".concat(tableChange.name, \" because it has changes on the type of index or primary key.\"));\n              return { value: void 0 };\n          }\n          var store = idbUpgradeTrans.objectStore(tableChange.name);\n          tableChange.add.forEach(function (idx) {\n              if (debug)\n                  console.debug(\"Dexie upgrade patch: Creating missing index \".concat(tableChange.name, \".\").concat(idx.src));\n              addIndex(store, idx);\n          });\n      };\n      for (var _i = 0, _a = diff.change; _i < _a.length; _i++) {\n          var tableChange = _a[_i];\n          var state_1 = _loop_1(tableChange);\n          if (typeof state_1 === \"object\")\n              return state_1.value;\n      }\n  }\n  function getExistingVersion(db, trans, oldVersion) {\n      if (trans.storeNames.includes('$meta')) {\n          return trans.table('$meta').get('version').then(function (metaVersion) {\n              return metaVersion != null ? metaVersion : oldVersion;\n          });\n      }\n      else {\n          return DexiePromise.resolve(oldVersion);\n      }\n  }\n  function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {\n      var queue = [];\n      var versions = db._versions;\n      var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n      var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });\n      if (versToRun.length === 0) {\n          return DexiePromise.resolve();\n      }\n      versToRun.forEach(function (version) {\n          queue.push(function () {\n              var oldSchema = globalSchema;\n              var newSchema = version._cfg.dbschema;\n              adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n              adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n              globalSchema = db._dbSchema = newSchema;\n              var diff = getSchemaDiff(oldSchema, newSchema);\n              diff.add.forEach(function (tuple) {\n                  createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n              });\n              diff.change.forEach(function (change) {\n                  if (change.recreate) {\n                      throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                  }\n                  else {\n                      var store_1 = idbUpgradeTrans.objectStore(change.name);\n                      change.add.forEach(function (idx) { return addIndex(store_1, idx); });\n                      change.change.forEach(function (idx) {\n                          store_1.deleteIndex(idx.name);\n                          addIndex(store_1, idx);\n                      });\n                      change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });\n                  }\n              });\n              var contentUpgrade = version._cfg.contentUpgrade;\n              if (contentUpgrade && version._cfg.version > oldVersion) {\n                  generateMiddlewareStacks(db, idbUpgradeTrans);\n                  trans._memoizedTables = {};\n                  var upgradeSchema_1 = shallowClone(newSchema);\n                  diff.del.forEach(function (table) {\n                      upgradeSchema_1[table] = oldSchema[table];\n                  });\n                  removeTablesApi(db, [db.Transaction.prototype]);\n                  setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);\n                  trans.schema = upgradeSchema_1;\n                  var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);\n                  if (contentUpgradeIsAsync_1) {\n                      incrementExpectedAwaits();\n                  }\n                  var returnValue_1;\n                  var promiseFollowed = DexiePromise.follow(function () {\n                      returnValue_1 = contentUpgrade(trans);\n                      if (returnValue_1) {\n                          if (contentUpgradeIsAsync_1) {\n                              var decrementor = decrementExpectedAwaits.bind(null, null);\n                              returnValue_1.then(decrementor, decrementor);\n                          }\n                      }\n                  });\n                  return (returnValue_1 && typeof returnValue_1.then === 'function' ?\n                      DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));\n              }\n          });\n          queue.push(function (idbtrans) {\n              var newSchema = version._cfg.dbschema;\n              deleteRemovedTables(newSchema, idbtrans);\n              removeTablesApi(db, [db.Transaction.prototype]);\n              setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n              trans.schema = db._dbSchema;\n          });\n          queue.push(function (idbtrans) {\n              if (db.idbdb.objectStoreNames.contains('$meta')) {\n                  if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {\n                      db.idbdb.deleteObjectStore('$meta');\n                      delete db._dbSchema.$meta;\n                      db._storeNames = db._storeNames.filter(function (name) { return name !== '$meta'; });\n                  }\n                  else {\n                      idbtrans.objectStore('$meta').put(version._cfg.version, 'version');\n                  }\n              }\n          });\n      });\n      function runQueue() {\n          return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n              DexiePromise.resolve();\n      }\n      return runQueue().then(function () {\n          createMissingTables(globalSchema, idbUpgradeTrans);\n      });\n  }\n  function getSchemaDiff(oldSchema, newSchema) {\n      var diff = {\n          del: [],\n          add: [],\n          change: []\n      };\n      var table;\n      for (table in oldSchema) {\n          if (!newSchema[table])\n              diff.del.push(table);\n      }\n      for (table in newSchema) {\n          var oldDef = oldSchema[table], newDef = newSchema[table];\n          if (!oldDef) {\n              diff.add.push([table, newDef]);\n          }\n          else {\n              var change = {\n                  name: table,\n                  def: newDef,\n                  recreate: false,\n                  del: [],\n                  add: [],\n                  change: []\n              };\n              if ((\n              '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                  (oldDef.primKey.auto !== newDef.primKey.auto)) {\n                  change.recreate = true;\n                  diff.change.push(change);\n              }\n              else {\n                  var oldIndexes = oldDef.idxByName;\n                  var newIndexes = newDef.idxByName;\n                  var idxName = void 0;\n                  for (idxName in oldIndexes) {\n                      if (!newIndexes[idxName])\n                          change.del.push(idxName);\n                  }\n                  for (idxName in newIndexes) {\n                      var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                      if (!oldIdx)\n                          change.add.push(newIdx);\n                      else if (oldIdx.src !== newIdx.src)\n                          change.change.push(newIdx);\n                  }\n                  if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                      diff.change.push(change);\n                  }\n              }\n          }\n      }\n      return diff;\n  }\n  function createTable(idbtrans, tableName, primKey, indexes) {\n      var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n          { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n          { autoIncrement: primKey.auto });\n      indexes.forEach(function (idx) { return addIndex(store, idx); });\n      return store;\n  }\n  function createMissingTables(newSchema, idbtrans) {\n      keys(newSchema).forEach(function (tableName) {\n          if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n              if (debug)\n                  console.debug('Dexie: Creating missing table', tableName);\n              createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n          }\n      });\n  }\n  function deleteRemovedTables(newSchema, idbtrans) {\n      [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {\n          return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);\n      });\n  }\n  function addIndex(store, idx) {\n      store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n  }\n  function buildGlobalSchema(db, idbdb, tmpTrans) {\n      var globalSchema = {};\n      var dbStoreNames = slice(idbdb.objectStoreNames, 0);\n      dbStoreNames.forEach(function (storeName) {\n          var store = tmpTrans.objectStore(storeName);\n          var keyPath = store.keyPath;\n          var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n          var indexes = [];\n          for (var j = 0; j < store.indexNames.length; ++j) {\n              var idbindex = store.index(store.indexNames[j]);\n              keyPath = idbindex.keyPath;\n              var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n              indexes.push(index);\n          }\n          globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n      });\n      return globalSchema;\n  }\n  function readGlobalSchema(db, idbdb, tmpTrans) {\n      db.verno = idbdb.version / 10;\n      var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n      db._storeNames = slice(idbdb.objectStoreNames, 0);\n      setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n  }\n  function verifyInstalledSchema(db, tmpTrans) {\n      var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n      var diff = getSchemaDiff(installedSchema, db._dbSchema);\n      return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));\n  }\n  function adjustToExistingIndexNames(db, schema, idbtrans) {\n      var storeNames = idbtrans.db.objectStoreNames;\n      for (var i = 0; i < storeNames.length; ++i) {\n          var storeName = storeNames[i];\n          var store = idbtrans.objectStore(storeName);\n          db._hasGetAll = 'getAll' in store;\n          for (var j = 0; j < store.indexNames.length; ++j) {\n              var indexName = store.indexNames[j];\n              var keyPath = store.index(indexName).keyPath;\n              var dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n              if (schema[storeName]) {\n                  var indexSpec = schema[storeName].idxByName[dexieName];\n                  if (indexSpec) {\n                      indexSpec.name = indexName;\n                      delete schema[storeName].idxByName[dexieName];\n                      schema[storeName].idxByName[indexName] = indexSpec;\n                  }\n              }\n          }\n      }\n      if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n          !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n          _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n          [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n          db._hasGetAll = false;\n      }\n  }\n  function parseIndexSyntax(primKeyAndIndexes) {\n      return primKeyAndIndexes.split(',').map(function (index, indexNum) {\n          var _a;\n          var typeSplit = index.split(':');\n          var type = (_a = typeSplit[1]) === null || _a === void 0 ? void 0 : _a.trim();\n          index = typeSplit[0].trim();\n          var name = index.replace(/([&*]|\\+\\+)/g, \"\");\n          var keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n          return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0, type);\n      });\n  }\n\n  var Version =  (function () {\n      function Version() {\n      }\n      Version.prototype._createTableSchema = function (name, primKey, indexes) {\n          return createTableSchema(name, primKey, indexes);\n      };\n      Version.prototype._parseIndexSyntax = function (primKeyAndIndexes) {\n          return parseIndexSyntax(primKeyAndIndexes);\n      };\n      Version.prototype._parseStoresSpec = function (stores, outSchema) {\n          var _this = this;\n          keys(stores).forEach(function (tableName) {\n              if (stores[tableName] !== null) {\n                  var indexes = _this._parseIndexSyntax(stores[tableName]);\n                  var primKey = indexes.shift();\n                  if (!primKey) {\n                      throw new exceptions.Schema('Invalid schema for table ' + tableName + ': ' + stores[tableName]);\n                  }\n                  primKey.unique = true;\n                  if (primKey.multi)\n                      throw new exceptions.Schema('Primary key cannot be multiEntry*');\n                  indexes.forEach(function (idx) {\n                      if (idx.auto)\n                          throw new exceptions.Schema('Only primary key can be marked as autoIncrement (++)');\n                      if (!idx.keyPath)\n                          throw new exceptions.Schema('Index must have a name and cannot be an empty string');\n                  });\n                  var tblSchema = _this._createTableSchema(tableName, primKey, indexes);\n                  outSchema[tableName] = tblSchema;\n              }\n          });\n      };\n      Version.prototype.stores = function (stores) {\n          var db = this.db;\n          this._cfg.storesSource = this._cfg.storesSource\n              ? extend(this._cfg.storesSource, stores)\n              : stores;\n          var versions = db._versions;\n          var storesSpec = {};\n          var dbschema = {};\n          versions.forEach(function (version) {\n              extend(storesSpec, version._cfg.storesSource);\n              dbschema = version._cfg.dbschema = {};\n              version._parseStoresSpec(storesSpec, dbschema);\n          });\n          db._dbSchema = dbschema;\n          removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n          setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n          db._storeNames = keys(dbschema);\n          return this;\n      };\n      Version.prototype.upgrade = function (upgradeFunction) {\n          this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n          return this;\n      };\n      return Version;\n  }());\n\n  function createVersionConstructor(db) {\n      return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n          this.db = db;\n          this._cfg = {\n              version: versionNumber,\n              storesSource: null,\n              dbschema: {},\n              tables: {},\n              contentUpgrade: null\n          };\n      });\n  }\n\n  function getDbNamesTable(indexedDB, IDBKeyRange) {\n      var dbNamesDB = indexedDB[\"_dbNamesDB\"];\n      if (!dbNamesDB) {\n          dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n              addons: [],\n              indexedDB: indexedDB,\n              IDBKeyRange: IDBKeyRange,\n          });\n          dbNamesDB.version(1).stores({ dbnames: \"name\" });\n      }\n      return dbNamesDB.table(\"dbnames\");\n  }\n  function hasDatabasesNative(indexedDB) {\n      return indexedDB && typeof indexedDB.databases === \"function\";\n  }\n  function getDatabaseNames(_a) {\n      var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n      return hasDatabasesNative(indexedDB)\n          ? Promise.resolve(indexedDB.databases()).then(function (infos) {\n              return infos\n                  .map(function (info) { return info.name; })\n                  .filter(function (name) { return name !== DBNAMES_DB; });\n          })\n          : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n  }\n  function _onDatabaseCreated(_a, name) {\n      var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n      !hasDatabasesNative(indexedDB) &&\n          name !== DBNAMES_DB &&\n          getDbNamesTable(indexedDB, IDBKeyRange).put({ name: name }).catch(nop);\n  }\n  function _onDatabaseDeleted(_a, name) {\n      var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n      !hasDatabasesNative(indexedDB) &&\n          name !== DBNAMES_DB &&\n          getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n  }\n\n  function vip(fn) {\n      return newScope(function () {\n          PSD.letThrough = true;\n          return fn();\n      });\n  }\n\n  function idbReady() {\n      var isSafari = !navigator.userAgentData &&\n          /Safari\\//.test(navigator.userAgent) &&\n          !/Chrom(e|ium)\\//.test(navigator.userAgent);\n      if (!isSafari || !indexedDB.databases)\n          return Promise.resolve();\n      var intervalId;\n      return new Promise(function (resolve) {\n          var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n          intervalId = setInterval(tryIdb, 100);\n          tryIdb();\n      }).finally(function () { return clearInterval(intervalId); });\n  }\n\n  var _a;\n  function isEmptyRange(node) {\n      return !(\"from\" in node);\n  }\n  var RangeSet = function (fromOrTree, to) {\n      if (this) {\n          extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n      }\n      else {\n          var rv = new RangeSet();\n          if (fromOrTree && (\"d\" in fromOrTree)) {\n              extend(rv, fromOrTree);\n          }\n          return rv;\n      }\n  };\n  props(RangeSet.prototype, (_a = {\n          add: function (rangeSet) {\n              mergeRanges(this, rangeSet);\n              return this;\n          },\n          addKey: function (key) {\n              addRange(this, key, key);\n              return this;\n          },\n          addKeys: function (keys) {\n              var _this = this;\n              keys.forEach(function (key) { return addRange(_this, key, key); });\n              return this;\n          },\n          hasKey: function (key) {\n              var node = getRangeSetIterator(this).next(key).value;\n              return node && cmp(node.from, key) <= 0 && cmp(node.to, key) >= 0;\n          }\n      },\n      _a[iteratorSymbol] = function () {\n          return getRangeSetIterator(this);\n      },\n      _a));\n  function addRange(target, from, to) {\n      var diff = cmp(from, to);\n      if (isNaN(diff))\n          return;\n      if (diff > 0)\n          throw RangeError();\n      if (isEmptyRange(target))\n          return extend(target, { from: from, to: to, d: 1 });\n      var left = target.l;\n      var right = target.r;\n      if (cmp(to, target.from) < 0) {\n          left\n              ? addRange(left, from, to)\n              : (target.l = { from: from, to: to, d: 1, l: null, r: null });\n          return rebalance(target);\n      }\n      if (cmp(from, target.to) > 0) {\n          right\n              ? addRange(right, from, to)\n              : (target.r = { from: from, to: to, d: 1, l: null, r: null });\n          return rebalance(target);\n      }\n      if (cmp(from, target.from) < 0) {\n          target.from = from;\n          target.l = null;\n          target.d = right ? right.d + 1 : 1;\n      }\n      if (cmp(to, target.to) > 0) {\n          target.to = to;\n          target.r = null;\n          target.d = target.l ? target.l.d + 1 : 1;\n      }\n      var rightWasCutOff = !target.r;\n      if (left && !target.l) {\n          mergeRanges(target, left);\n      }\n      if (right && rightWasCutOff) {\n          mergeRanges(target, right);\n      }\n  }\n  function mergeRanges(target, newSet) {\n      function _addRangeSet(target, _a) {\n          var from = _a.from, to = _a.to, l = _a.l, r = _a.r;\n          addRange(target, from, to);\n          if (l)\n              _addRangeSet(target, l);\n          if (r)\n              _addRangeSet(target, r);\n      }\n      if (!isEmptyRange(newSet))\n          _addRangeSet(target, newSet);\n  }\n  function rangesOverlap(rangeSet1, rangeSet2) {\n      var i1 = getRangeSetIterator(rangeSet2);\n      var nextResult1 = i1.next();\n      if (nextResult1.done)\n          return false;\n      var a = nextResult1.value;\n      var i2 = getRangeSetIterator(rangeSet1);\n      var nextResult2 = i2.next(a.from);\n      var b = nextResult2.value;\n      while (!nextResult1.done && !nextResult2.done) {\n          if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n              return true;\n          cmp(a.from, b.from) < 0\n              ? (a = (nextResult1 = i1.next(b.from)).value)\n              : (b = (nextResult2 = i2.next(a.from)).value);\n      }\n      return false;\n  }\n  function getRangeSetIterator(node) {\n      var state = isEmptyRange(node) ? null : { s: 0, n: node };\n      return {\n          next: function (key) {\n              var keyProvided = arguments.length > 0;\n              while (state) {\n                  switch (state.s) {\n                      case 0:\n                          state.s = 1;\n                          if (keyProvided) {\n                              while (state.n.l && cmp(key, state.n.from) < 0)\n                                  state = { up: state, n: state.n.l, s: 1 };\n                          }\n                          else {\n                              while (state.n.l)\n                                  state = { up: state, n: state.n.l, s: 1 };\n                          }\n                      case 1:\n                          state.s = 2;\n                          if (!keyProvided || cmp(key, state.n.to) <= 0)\n                              return { value: state.n, done: false };\n                      case 2:\n                          if (state.n.r) {\n                              state.s = 3;\n                              state = { up: state, n: state.n.r, s: 0 };\n                              continue;\n                          }\n                      case 3:\n                          state = state.up;\n                  }\n              }\n              return { done: true };\n          },\n      };\n  }\n  function rebalance(target) {\n      var _a, _b;\n      var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n      var r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n      if (r) {\n          var l = r === \"r\" ? \"l\" : \"r\";\n          var rootClone = __assign({}, target);\n          var oldRootRight = target[r];\n          target.from = oldRootRight.from;\n          target.to = oldRootRight.to;\n          target[r] = oldRootRight[r];\n          rootClone[r] = oldRootRight[l];\n          target[l] = rootClone;\n          rootClone.d = computeDepth(rootClone);\n      }\n      target.d = computeDepth(target);\n  }\n  function computeDepth(_a) {\n      var r = _a.r, l = _a.l;\n      return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n  }\n\n  function extendObservabilitySet(target, newSet) {\n      keys(newSet).forEach(function (part) {\n          if (target[part])\n              mergeRanges(target[part], newSet[part]);\n          else\n              target[part] = cloneSimpleObjectTree(newSet[part]);\n      });\n      return target;\n  }\n\n  function obsSetsOverlap(os1, os2) {\n      return os1.all || os2.all || Object.keys(os1).some(function (key) { return os2[key] && rangesOverlap(os2[key], os1[key]); });\n  }\n\n  var cache = {};\n\n  var unsignaledParts = {};\n  var isTaskEnqueued = false;\n  function signalSubscribersLazily(part, optimistic) {\n      extendObservabilitySet(unsignaledParts, part);\n      if (!isTaskEnqueued) {\n          isTaskEnqueued = true;\n          setTimeout(function () {\n              isTaskEnqueued = false;\n              var parts = unsignaledParts;\n              unsignaledParts = {};\n              signalSubscribersNow(parts, false);\n          }, 0);\n      }\n  }\n  function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {\n      if (deleteAffectedCacheEntries === void 0) { deleteAffectedCacheEntries = false; }\n      var queriesToSignal = new Set();\n      if (updatedParts.all) {\n          for (var _i = 0, _a = Object.values(cache); _i < _a.length; _i++) {\n              var tblCache = _a[_i];\n              collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n          }\n      }\n      else {\n          for (var key in updatedParts) {\n              var parts = /^idb\\:\\/\\/(.*)\\/(.*)\\//.exec(key);\n              if (parts) {\n                  var dbName = parts[1], tableName = parts[2];\n                  var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n                  if (tblCache)\n                      collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n              }\n          }\n      }\n      queriesToSignal.forEach(function (requery) { return requery(); });\n  }\n  function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {\n      var updatedEntryLists = [];\n      for (var _i = 0, _a = Object.entries(tblCache.queries.query); _i < _a.length; _i++) {\n          var _b = _a[_i], indexName = _b[0], entries = _b[1];\n          var filteredEntries = [];\n          for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {\n              var entry = entries_1[_c];\n              if (obsSetsOverlap(updatedParts, entry.obsSet)) {\n                  entry.subscribers.forEach(function (requery) { return outQueriesToSignal.add(requery); });\n              }\n              else if (deleteAffectedCacheEntries) {\n                  filteredEntries.push(entry);\n              }\n          }\n          if (deleteAffectedCacheEntries)\n              updatedEntryLists.push([indexName, filteredEntries]);\n      }\n      if (deleteAffectedCacheEntries) {\n          for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {\n              var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];\n              tblCache.queries.query[indexName] = filteredEntries;\n          }\n      }\n  }\n\n  function dexieOpen(db) {\n      var state = db._state;\n      var indexedDB = db._deps.indexedDB;\n      if (state.isBeingOpened || db.idbdb)\n          return state.dbReadyPromise.then(function () { return state.dbOpenError ?\n              rejection(state.dbOpenError) :\n              db; });\n      state.isBeingOpened = true;\n      state.dbOpenError = null;\n      state.openComplete = false;\n      var openCanceller = state.openCanceller;\n      var nativeVerToOpen = Math.round(db.verno * 10);\n      var schemaPatchMode = false;\n      function throwIfCancelled() {\n          if (state.openCanceller !== openCanceller)\n              throw new exceptions.DatabaseClosed('db.open() was cancelled');\n      }\n      var resolveDbReady = state.dbReadyResolve,\n      upgradeTransaction = null, wasCreated = false;\n      var tryOpenDB = function () { return new DexiePromise(function (resolve, reject) {\n          throwIfCancelled();\n          if (!indexedDB)\n              throw new exceptions.MissingAPI();\n          var dbName = db.name;\n          var req = state.autoSchema || !nativeVerToOpen ?\n              indexedDB.open(dbName) :\n              indexedDB.open(dbName, nativeVerToOpen);\n          if (!req)\n              throw new exceptions.MissingAPI();\n          req.onerror = eventRejectHandler(reject);\n          req.onblocked = wrap(db._fireOnBlocked);\n          req.onupgradeneeded = wrap(function (e) {\n              upgradeTransaction = req.transaction;\n              if (state.autoSchema && !db._options.allowEmptyDB) {\n                  req.onerror = preventDefault;\n                  upgradeTransaction.abort();\n                  req.result.close();\n                  var delreq = indexedDB.deleteDatabase(dbName);\n                  delreq.onsuccess = delreq.onerror = wrap(function () {\n                      reject(new exceptions.NoSuchDatabase(\"Database \".concat(dbName, \" doesnt exist\")));\n                  });\n              }\n              else {\n                  upgradeTransaction.onerror = eventRejectHandler(reject);\n                  var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                  wasCreated = oldVer < 1;\n                  db.idbdb = req.result;\n                  if (schemaPatchMode) {\n                      patchCurrentVersion(db, upgradeTransaction);\n                  }\n                  runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n              }\n          }, reject);\n          req.onsuccess = wrap(function () {\n              upgradeTransaction = null;\n              var idbdb = db.idbdb = req.result;\n              var objectStoreNames = slice(idbdb.objectStoreNames);\n              if (objectStoreNames.length > 0)\n                  try {\n                      var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                      if (state.autoSchema)\n                          readGlobalSchema(db, idbdb, tmpTrans);\n                      else {\n                          adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                          if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {\n                              console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.\");\n                              idbdb.close();\n                              nativeVerToOpen = idbdb.version + 1;\n                              schemaPatchMode = true;\n                              return resolve(tryOpenDB());\n                          }\n                      }\n                      generateMiddlewareStacks(db, tmpTrans);\n                  }\n                  catch (e) {\n                  }\n              connections.push(db);\n              idbdb.onversionchange = wrap(function (ev) {\n                  state.vcFired = true;\n                  db.on(\"versionchange\").fire(ev);\n              });\n              idbdb.onclose = wrap(function () {\n                  db.close({ disableAutoOpen: false });\n              });\n              if (wasCreated)\n                  _onDatabaseCreated(db._deps, dbName);\n              resolve();\n          }, reject);\n      }).catch(function (err) {\n          switch (err === null || err === void 0 ? void 0 : err.name) {\n              case \"UnknownError\":\n                  if (state.PR1398_maxLoop > 0) {\n                      state.PR1398_maxLoop--;\n                      console.warn('Dexie: Workaround for Chrome UnknownError on open()');\n                      return tryOpenDB();\n                  }\n                  break;\n              case \"VersionError\":\n                  if (nativeVerToOpen > 0) {\n                      nativeVerToOpen = 0;\n                      return tryOpenDB();\n                  }\n                  break;\n          }\n          return DexiePromise.reject(err);\n      }); };\n      return DexiePromise.race([\n          openCanceller,\n          (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n      ]).then(function () {\n          throwIfCancelled();\n          state.onReadyBeingFired = [];\n          return DexiePromise.resolve(vip(function () { return db.on.ready.fire(db.vip); })).then(function fireRemainders() {\n              if (state.onReadyBeingFired.length > 0) {\n                  var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);\n                  state.onReadyBeingFired = [];\n                  return DexiePromise.resolve(vip(function () { return remainders_1(db.vip); })).then(fireRemainders);\n              }\n          });\n      }).finally(function () {\n          if (state.openCanceller === openCanceller) {\n              state.onReadyBeingFired = null;\n              state.isBeingOpened = false;\n          }\n      }).catch(function (err) {\n          state.dbOpenError = err;\n          try {\n              upgradeTransaction && upgradeTransaction.abort();\n          }\n          catch (_a) { }\n          if (openCanceller === state.openCanceller) {\n              db._close();\n          }\n          return rejection(err);\n      }).finally(function () {\n          state.openComplete = true;\n          resolveDbReady();\n      }).then(function () {\n          if (wasCreated) {\n              var everything_1 = {};\n              db.tables.forEach(function (table) {\n                  table.schema.indexes.forEach(function (idx) {\n                      if (idx.name)\n                          everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\").concat(idx.name)] = new RangeSet(-Infinity, [[[]]]);\n                  });\n                  everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\")] = everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/:dels\")] = new RangeSet(-Infinity, [[[]]]);\n              });\n              globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);\n              signalSubscribersNow(everything_1, true);\n          }\n          return db;\n      });\n  }\n\n  function awaitIterator(iterator) {\n      var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);\n      function step(getNext) {\n          return function (val) {\n              var next = getNext(val), value = next.value;\n              return next.done ? value :\n                  (!value || typeof value.then !== 'function' ?\n                      isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                      value.then(onSuccess, onError));\n          };\n      }\n      return step(callNext)();\n  }\n\n  function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n      var i = arguments.length;\n      if (i < 2)\n          throw new exceptions.InvalidArgument(\"Too few arguments\");\n      var args = new Array(i - 1);\n      while (--i)\n          args[i - 1] = arguments[i];\n      scopeFunc = args.pop();\n      var tables = flatten(args);\n      return [mode, tables, scopeFunc];\n  }\n  function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n      return DexiePromise.resolve().then(function () {\n          var transless = PSD.transless || PSD;\n          var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n          trans.explicit = true;\n          var zoneProps = {\n              trans: trans,\n              transless: transless\n          };\n          if (parentTransaction) {\n              trans.idbtrans = parentTransaction.idbtrans;\n          }\n          else {\n              try {\n                  trans.create();\n                  trans.idbtrans._explicit = true;\n                  db._state.PR1398_maxLoop = 3;\n              }\n              catch (ex) {\n                  if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                      console.warn('Dexie: Need to reopen db');\n                      db.close({ disableAutoOpen: false });\n                      return db.open().then(function () { return enterTransactionScope(db, mode, storeNames, null, scopeFunc); });\n                  }\n                  return rejection(ex);\n              }\n          }\n          var scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n          if (scopeFuncIsAsync) {\n              incrementExpectedAwaits();\n          }\n          var returnValue;\n          var promiseFollowed = DexiePromise.follow(function () {\n              returnValue = scopeFunc.call(trans, trans);\n              if (returnValue) {\n                  if (scopeFuncIsAsync) {\n                      var decrementor = decrementExpectedAwaits.bind(null, null);\n                      returnValue.then(decrementor, decrementor);\n                  }\n                  else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                      returnValue = awaitIterator(returnValue);\n                  }\n              }\n          }, zoneProps);\n          return (returnValue && typeof returnValue.then === 'function' ?\n              DexiePromise.resolve(returnValue).then(function (x) { return trans.active ?\n                  x\n                  : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")); })\n              : promiseFollowed.then(function () { return returnValue; })).then(function (x) {\n              if (parentTransaction)\n                  trans._resolve();\n              return trans._completion.then(function () { return x; });\n          }).catch(function (e) {\n              trans._reject(e);\n              return rejection(e);\n          });\n      });\n  }\n\n  function pad(a, value, count) {\n      var result = isArray(a) ? a.slice() : [a];\n      for (var i = 0; i < count; ++i)\n          result.push(value);\n      return result;\n  }\n  function createVirtualIndexMiddleware(down) {\n      return __assign(__assign({}, down), { table: function (tableName) {\n              var table = down.table(tableName);\n              var schema = table.schema;\n              var indexLookup = {};\n              var allVirtualIndexes = [];\n              function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                  var keyPathAlias = getKeyPathAlias(keyPath);\n                  var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                  var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                  var isVirtual = keyTail > 0;\n                  var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual\n                          ? \"\".concat(keyPathAlias, \"(virtual-from:\").concat(lowLevelIndex.name, \")\")\n                          : lowLevelIndex.name, lowLevelIndex: lowLevelIndex, isVirtual: isVirtual, keyTail: keyTail, keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });\n                  indexList.push(virtualIndex);\n                  if (!virtualIndex.isPrimaryKey) {\n                      allVirtualIndexes.push(virtualIndex);\n                  }\n                  if (keyLength > 1) {\n                      var virtualKeyPath = keyLength === 2 ?\n                          keyPath[0] :\n                          keyPath.slice(0, keyLength - 1);\n                      addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                  }\n                  indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });\n                  return virtualIndex;\n              }\n              var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n              indexLookup[\":id\"] = [primaryKey];\n              for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {\n                  var index = _a[_i];\n                  addVirtualIndexes(index.keyPath, 0, index);\n              }\n              function findBestIndex(keyPath) {\n                  var result = indexLookup[getKeyPathAlias(keyPath)];\n                  return result && result[0];\n              }\n              function translateRange(range, keyTail) {\n                  return {\n                      type: range.type === 1  ?\n                          2  :\n                          range.type,\n                      lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                      lowerOpen: true,\n                      upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                      upperOpen: true\n                  };\n              }\n              function translateRequest(req) {\n                  var index = req.query.index;\n                  return index.isVirtual ? __assign(__assign({}, req), { query: {\n                          index: index.lowLevelIndex,\n                          range: translateRange(req.query.range, index.keyTail)\n                      } }) : req;\n              }\n              var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {\n                      return table.count(translateRequest(req));\n                  }, query: function (req) {\n                      return table.query(translateRequest(req));\n                  }, openCursor: function (req) {\n                      var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;\n                      if (!isVirtual)\n                          return table.openCursor(req);\n                      function createVirtualCursor(cursor) {\n                          function _continue(key) {\n                              key != null ?\n                                  cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                  req.unique ?\n                                      cursor.continue(cursor.key.slice(0, keyLength)\n                                          .concat(req.reverse\n                                          ? down.MIN_KEY\n                                          : down.MAX_KEY, keyTail)) :\n                                      cursor.continue();\n                          }\n                          var virtualCursor = Object.create(cursor, {\n                              continue: { value: _continue },\n                              continuePrimaryKey: {\n                                  value: function (key, primaryKey) {\n                                      cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                  }\n                              },\n                              primaryKey: {\n                                  get: function () {\n                                      return cursor.primaryKey;\n                                  }\n                              },\n                              key: {\n                                  get: function () {\n                                      var key = cursor.key;\n                                      return keyLength === 1 ?\n                                          key[0] :\n                                          key.slice(0, keyLength);\n                                  }\n                              },\n                              value: {\n                                  get: function () {\n                                      return cursor.value;\n                                  }\n                              }\n                          });\n                          return virtualCursor;\n                      }\n                      return table.openCursor(translateRequest(req))\n                          .then(function (cursor) { return cursor && createVirtualCursor(cursor); });\n                  } });\n              return result;\n          } });\n  }\n  var virtualIndexMiddleware = {\n      stack: \"dbcore\",\n      name: \"VirtualIndexMiddleware\",\n      level: 1,\n      create: createVirtualIndexMiddleware\n  };\n\n  function getObjectDiff(a, b, rv, prfx) {\n      rv = rv || {};\n      prfx = prfx || '';\n      keys(a).forEach(function (prop) {\n          if (!hasOwn(b, prop)) {\n              rv[prfx + prop] = undefined;\n          }\n          else {\n              var ap = a[prop], bp = b[prop];\n              if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                  var apTypeName = toStringTag(ap);\n                  var bpTypeName = toStringTag(bp);\n                  if (apTypeName !== bpTypeName) {\n                      rv[prfx + prop] = b[prop];\n                  }\n                  else if (apTypeName === 'Object') {\n                      getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                  }\n                  else if (ap !== bp) {\n                      rv[prfx + prop] = b[prop];\n                  }\n              }\n              else if (ap !== bp)\n                  rv[prfx + prop] = b[prop];\n          }\n      });\n      keys(b).forEach(function (prop) {\n          if (!hasOwn(a, prop)) {\n              rv[prfx + prop] = b[prop];\n          }\n      });\n      return rv;\n  }\n\n  function getEffectiveKeys(primaryKey, req) {\n      if (req.type === 'delete')\n          return req.keys;\n      return req.keys || req.values.map(primaryKey.extractKey);\n  }\n\n  var hooksMiddleware = {\n      stack: \"dbcore\",\n      name: \"HooksMiddleware\",\n      level: 2,\n      create: function (downCore) { return (__assign(__assign({}, downCore), { table: function (tableName) {\n              var downTable = downCore.table(tableName);\n              var primaryKey = downTable.schema.primaryKey;\n              var tableMiddleware = __assign(__assign({}, downTable), { mutate: function (req) {\n                      var dxTrans = PSD.trans;\n                      var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;\n                      switch (req.type) {\n                          case 'add':\n                              if (creating.fire === nop)\n                                  break;\n                              return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                          case 'put':\n                              if (creating.fire === nop && updating.fire === nop)\n                                  break;\n                              return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                          case 'delete':\n                              if (deleting.fire === nop)\n                                  break;\n                              return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                          case 'deleteRange':\n                              if (deleting.fire === nop)\n                                  break;\n                              return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);\n                      }\n                      return downTable.mutate(req);\n                      function addPutOrDelete(req) {\n                          var dxTrans = PSD.trans;\n                          var keys = req.keys || getEffectiveKeys(primaryKey, req);\n                          if (!keys)\n                              throw new Error(\"Keys missing\");\n                          req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys }) : __assign({}, req);\n                          if (req.type !== 'delete')\n                              req.values = __spreadArray([], req.values, true);\n                          if (req.keys)\n                              req.keys = __spreadArray([], req.keys, true);\n                          return getExistingValues(downTable, req, keys).then(function (existingValues) {\n                              var contexts = keys.map(function (key, i) {\n                                  var existingValue = existingValues[i];\n                                  var ctx = { onerror: null, onsuccess: null };\n                                  if (req.type === 'delete') {\n                                      deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                  }\n                                  else if (req.type === 'add' || existingValue === undefined) {\n                                      var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                      if (key == null && generatedPrimaryKey != null) {\n                                          key = generatedPrimaryKey;\n                                          req.keys[i] = key;\n                                          if (!primaryKey.outbound) {\n                                              setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                          }\n                                      }\n                                  }\n                                  else {\n                                      var objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                      var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                      if (additionalChanges_1) {\n                                          var requestedValue_1 = req.values[i];\n                                          Object.keys(additionalChanges_1).forEach(function (keyPath) {\n                                              if (hasOwn(requestedValue_1, keyPath)) {\n                                                  requestedValue_1[keyPath] = additionalChanges_1[keyPath];\n                                              }\n                                              else {\n                                                  setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);\n                                              }\n                                          });\n                                      }\n                                  }\n                                  return ctx;\n                              });\n                              return downTable.mutate(req).then(function (_a) {\n                                  var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;\n                                  for (var i = 0; i < keys.length; ++i) {\n                                      var primKey = results ? results[i] : keys[i];\n                                      var ctx = contexts[i];\n                                      if (primKey == null) {\n                                          ctx.onerror && ctx.onerror(failures[i]);\n                                      }\n                                      else {\n                                          ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                              req.values[i] :\n                                              primKey\n                                          );\n                                      }\n                                  }\n                                  return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };\n                              }).catch(function (error) {\n                                  contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });\n                                  return Promise.reject(error);\n                              });\n                          });\n                      }\n                      function deleteRange(req) {\n                          return deleteNextChunk(req.trans, req.range, 10000);\n                      }\n                      function deleteNextChunk(trans, range, limit) {\n                          return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })\n                              .then(function (_a) {\n                              var result = _a.result;\n                              return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {\n                                  if (res.numFailures > 0)\n                                      return Promise.reject(res.failures[0]);\n                                  if (result.length < limit) {\n                                      return { failures: [], numFailures: 0, lastResult: undefined };\n                                  }\n                                  else {\n                                      return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);\n                                  }\n                              });\n                          });\n                      }\n                  } });\n              return tableMiddleware;\n          } })); }\n  };\n  function getExistingValues(table, req, effectiveKeys) {\n      return req.type === \"add\"\n          ? Promise.resolve([])\n          : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n  }\n\n  function getFromTransactionCache(keys, cache, clone) {\n      try {\n          if (!cache)\n              return null;\n          if (cache.keys.length < keys.length)\n              return null;\n          var result = [];\n          for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n              if (cmp(cache.keys[i], keys[j]) !== 0)\n                  continue;\n              result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n              ++j;\n          }\n          return result.length === keys.length ? result : null;\n      }\n      catch (_a) {\n          return null;\n      }\n  }\n  var cacheExistingValuesMiddleware = {\n      stack: \"dbcore\",\n      level: -1,\n      create: function (core) {\n          return {\n              table: function (tableName) {\n                  var table = core.table(tableName);\n                  return __assign(__assign({}, table), { getMany: function (req) {\n                          if (!req.cache) {\n                              return table.getMany(req);\n                          }\n                          var cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                          if (cachedResult) {\n                              return DexiePromise.resolve(cachedResult);\n                          }\n                          return table.getMany(req).then(function (res) {\n                              req.trans[\"_cache\"] = {\n                                  keys: req.keys,\n                                  values: req.cache === \"clone\" ? deepClone(res) : res,\n                              };\n                              return res;\n                          });\n                      }, mutate: function (req) {\n                          if (req.type !== \"add\")\n                              req.trans[\"_cache\"] = null;\n                          return table.mutate(req);\n                      } });\n              },\n          };\n      },\n  };\n\n  function isCachableContext(ctx, table) {\n      return (ctx.trans.mode === 'readonly' &&\n          !!ctx.subscr &&\n          !ctx.trans.explicit &&\n          ctx.trans.db._options.cache !== 'disabled' &&\n          !table.schema.primaryKey.outbound);\n  }\n\n  function isCachableRequest(type, req) {\n      switch (type) {\n          case 'query':\n              return req.values && !req.unique;\n          case 'get':\n              return false;\n          case 'getMany':\n              return false;\n          case 'count':\n              return false;\n          case 'openCursor':\n              return false;\n      }\n  }\n\n  var observabilityMiddleware = {\n      stack: \"dbcore\",\n      level: 0,\n      name: \"Observability\",\n      create: function (core) {\n          var dbName = core.schema.name;\n          var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n          return __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n                  if (PSD.subscr && mode !== 'readonly') {\n                      throw new exceptions.ReadOnly(\"Readwrite transaction in liveQuery context. Querier source: \".concat(PSD.querier));\n                  }\n                  return core.transaction(stores, mode, options);\n              }, table: function (tableName) {\n                  var table = core.table(tableName);\n                  var schema = table.schema;\n                  var primaryKey = schema.primaryKey, indexes = schema.indexes;\n                  var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;\n                  var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function (index) { return index.compound && index.keyPath.includes(primaryKey.keyPath); });\n                  var tableClone = __assign(__assign({}, table), { mutate: function (req) {\n                          var _a, _b;\n                          var trans = req.trans;\n                          var mutatedParts = req.mutatedParts || (req.mutatedParts = {});\n                          var getRangeSet = function (indexName) {\n                              var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n                              return (mutatedParts[part] ||\n                                  (mutatedParts[part] = new RangeSet()));\n                          };\n                          var pkRangeSet = getRangeSet(\"\");\n                          var delsRangeSet = getRangeSet(\":dels\");\n                          var type = req.type;\n                          var _c = req.type === \"deleteRange\"\n                              ? [req.range]\n                              : req.type === \"delete\"\n                                  ? [req.keys]\n                                  : req.values.length < 50\n                                      ? [getEffectiveKeys(primaryKey, req).filter(function (id) { return id; }), req.values]\n                                      : [], keys = _c[0], newObjs = _c[1];\n                          var oldCache = req.trans[\"_cache\"];\n                          if (isArray(keys)) {\n                              pkRangeSet.addKeys(keys);\n                              var oldObjs = type === 'delete' || keys.length === newObjs.length ? getFromTransactionCache(keys, oldCache) : null;\n                              if (!oldObjs) {\n                                  delsRangeSet.addKeys(keys);\n                              }\n                              if (oldObjs || newObjs) {\n                                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                              }\n                          }\n                          else if (keys) {\n                              var range = {\n                                  from: (_a = keys.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY,\n                                  to: (_b = keys.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY\n                              };\n                              delsRangeSet.add(range);\n                              pkRangeSet.add(range);\n                          }\n                          else {\n                              pkRangeSet.add(FULL_RANGE);\n                              delsRangeSet.add(FULL_RANGE);\n                              schema.indexes.forEach(function (idx) { return getRangeSet(idx.name).add(FULL_RANGE); });\n                          }\n                          return table.mutate(req).then(function (res) {\n                              if (keys && (req.type === 'add' || req.type === 'put')) {\n                                  pkRangeSet.addKeys(res.results);\n                                  if (indexesWithAutoIncPK) {\n                                      indexesWithAutoIncPK.forEach(function (idx) {\n                                          var idxVals = req.values.map(function (v) { return idx.extractKey(v); });\n                                          var pkPos = idx.keyPath.findIndex(function (prop) { return prop === primaryKey.keyPath; });\n                                          for (var i = 0, len = res.results.length; i < len; ++i) {\n                                              idxVals[i][pkPos] = res.results[i];\n                                          }\n                                          getRangeSet(idx.name).addKeys(idxVals);\n                                      });\n                                  }\n                              }\n                              trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);\n                              return res;\n                          });\n                      } });\n                  var getRange = function (_a) {\n                      var _b, _c;\n                      var _d = _a.query, index = _d.index, range = _d.range;\n                      return [\n                          index,\n                          new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY),\n                      ];\n                  };\n                  var readSubscribers = {\n                      get: function (req) { return [primaryKey, new RangeSet(req.key)]; },\n                      getMany: function (req) { return [primaryKey, new RangeSet().addKeys(req.keys)]; },\n                      count: getRange,\n                      query: getRange,\n                      openCursor: getRange,\n                  };\n                  keys(readSubscribers).forEach(function (method) {\n                      tableClone[method] = function (req) {\n                          var subscr = PSD.subscr;\n                          var isLiveQuery = !!subscr;\n                          var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);\n                          var obsSet = cachable\n                              ? req.obsSet = {}\n                              : subscr;\n                          if (isLiveQuery) {\n                              var getRangeSet = function (indexName) {\n                                  var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n                                  return (obsSet[part] ||\n                                      (obsSet[part] = new RangeSet()));\n                              };\n                              var pkRangeSet_1 = getRangeSet(\"\");\n                              var delsRangeSet_1 = getRangeSet(\":dels\");\n                              var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];\n                              if (method === 'query' && queriedIndex.isPrimaryKey && !req.values) {\n                                  delsRangeSet_1.add(queriedRanges);\n                              }\n                              else {\n                                  getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                              }\n                              if (!queriedIndex.isPrimaryKey) {\n                                  if (method === \"count\") {\n                                      delsRangeSet_1.add(FULL_RANGE);\n                                  }\n                                  else {\n                                      var keysPromise_1 = method === \"query\" &&\n                                          outbound &&\n                                          req.values &&\n                                          table.query(__assign(__assign({}, req), { values: false }));\n                                      return table[method].apply(this, arguments).then(function (res) {\n                                          if (method === \"query\") {\n                                              if (outbound && req.values) {\n                                                  return keysPromise_1.then(function (_a) {\n                                                      var resultingKeys = _a.result;\n                                                      pkRangeSet_1.addKeys(resultingKeys);\n                                                      return res;\n                                                  });\n                                              }\n                                              var pKeys = req.values\n                                                  ? res.result.map(extractKey)\n                                                  : res.result;\n                                              if (req.values) {\n                                                  pkRangeSet_1.addKeys(pKeys);\n                                              }\n                                              else {\n                                                  delsRangeSet_1.addKeys(pKeys);\n                                              }\n                                          }\n                                          else if (method === \"openCursor\") {\n                                              var cursor_1 = res;\n                                              var wantValues_1 = req.values;\n                                              return (cursor_1 &&\n                                                  Object.create(cursor_1, {\n                                                      key: {\n                                                          get: function () {\n                                                              delsRangeSet_1.addKey(cursor_1.primaryKey);\n                                                              return cursor_1.key;\n                                                          },\n                                                      },\n                                                      primaryKey: {\n                                                          get: function () {\n                                                              var pkey = cursor_1.primaryKey;\n                                                              delsRangeSet_1.addKey(pkey);\n                                                              return pkey;\n                                                          },\n                                                      },\n                                                      value: {\n                                                          get: function () {\n                                                              wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);\n                                                              return cursor_1.value;\n                                                          },\n                                                      },\n                                                  }));\n                                          }\n                                          return res;\n                                      });\n                                  }\n                              }\n                          }\n                          return table[method].apply(this, arguments);\n                      };\n                  });\n                  return tableClone;\n              } });\n      },\n  };\n  function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n      function addAffectedIndex(ix) {\n          var rangeSet = getRangeSet(ix.name || \"\");\n          function extractKey(obj) {\n              return obj != null ? ix.extractKey(obj) : null;\n          }\n          var addKeyOrKeys = function (key) { return ix.multiEntry && isArray(key)\n              ? key.forEach(function (key) { return rangeSet.addKey(key); })\n              : rangeSet.addKey(key); };\n          (oldObjs || newObjs).forEach(function (_, i) {\n              var oldKey = oldObjs && extractKey(oldObjs[i]);\n              var newKey = newObjs && extractKey(newObjs[i]);\n              if (cmp(oldKey, newKey) !== 0) {\n                  if (oldKey != null)\n                      addKeyOrKeys(oldKey);\n                  if (newKey != null)\n                      addKeyOrKeys(newKey);\n              }\n          });\n      }\n      schema.indexes.forEach(addAffectedIndex);\n  }\n\n  function adjustOptimisticFromFailures(tblCache, req, res) {\n      if (res.numFailures === 0)\n          return req;\n      if (req.type === 'deleteRange') {\n          return null;\n      }\n      var numBulkOps = req.keys\n          ? req.keys.length\n          : 'values' in req && req.values\n              ? req.values.length\n              : 1;\n      if (res.numFailures === numBulkOps) {\n          return null;\n      }\n      var clone = __assign({}, req);\n      if (isArray(clone.keys)) {\n          clone.keys = clone.keys.filter(function (_, i) { return !(i in res.failures); });\n      }\n      if ('values' in clone && isArray(clone.values)) {\n          clone.values = clone.values.filter(function (_, i) { return !(i in res.failures); });\n      }\n      return clone;\n  }\n\n  function isAboveLower(key, range) {\n      return range.lower === undefined\n          ? true\n          : range.lowerOpen\n              ? cmp(key, range.lower) > 0\n              : cmp(key, range.lower) >= 0;\n  }\n  function isBelowUpper(key, range) {\n      return range.upper === undefined\n          ? true\n          : range.upperOpen\n              ? cmp(key, range.upper) < 0\n              : cmp(key, range.upper) <= 0;\n  }\n  function isWithinRange(key, range) {\n      return isAboveLower(key, range) && isBelowUpper(key, range);\n  }\n\n  function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {\n      if (!ops || ops.length === 0)\n          return result;\n      var index = req.query.index;\n      var multiEntry = index.multiEntry;\n      var queryRange = req.query.range;\n      var primaryKey = table.schema.primaryKey;\n      var extractPrimKey = primaryKey.extractKey;\n      var extractIndex = index.extractKey;\n      var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;\n      var finalResult = ops.reduce(function (result, op) {\n          var modifedResult = result;\n          var includedValues = [];\n          if (op.type === 'add' || op.type === 'put') {\n              var includedPKs = new RangeSet();\n              for (var i = op.values.length - 1; i >= 0; --i) {\n                  var value = op.values[i];\n                  var pk = extractPrimKey(value);\n                  if (includedPKs.hasKey(pk))\n                      continue;\n                  var key = extractIndex(value);\n                  if (multiEntry && isArray(key)\n                      ? key.some(function (k) { return isWithinRange(k, queryRange); })\n                      : isWithinRange(key, queryRange)) {\n                      includedPKs.addKey(pk);\n                      includedValues.push(value);\n                  }\n              }\n          }\n          switch (op.type) {\n              case 'add': {\n                  var existingKeys_1 = new RangeSet().addKeys(req.values ? result.map(function (v) { return extractPrimKey(v); }) : result);\n                  modifedResult = result.concat(req.values\n                      ? includedValues.filter(function (v) {\n                          var key = extractPrimKey(v);\n                          if (existingKeys_1.hasKey(key))\n                              return false;\n                          existingKeys_1.addKey(key);\n                          return true;\n                      })\n                      : includedValues\n                          .map(function (v) { return extractPrimKey(v); })\n                          .filter(function (k) {\n                          if (existingKeys_1.hasKey(k))\n                              return false;\n                          existingKeys_1.addKey(k);\n                          return true;\n                      }));\n                  break;\n              }\n              case 'put': {\n                  var keySet_1 = new RangeSet().addKeys(op.values.map(function (v) { return extractPrimKey(v); }));\n                  modifedResult = result\n                      .filter(\n                  function (item) { return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item); })\n                      .concat(\n                  req.values\n                      ? includedValues\n                      : includedValues.map(function (v) { return extractPrimKey(v); }));\n                  break;\n              }\n              case 'delete':\n                  var keysToDelete_1 = new RangeSet().addKeys(op.keys);\n                  modifedResult = result.filter(function (item) {\n                      return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);\n                  });\n                  break;\n              case 'deleteRange':\n                  var range_1 = op.range;\n                  modifedResult = result.filter(function (item) { return !isWithinRange(extractPrimKey(item), range_1); });\n                  break;\n          }\n          return modifedResult;\n      }, result);\n      if (finalResult === result)\n          return result;\n      finalResult.sort(function (a, b) {\n          return cmp(extractLowLevelIndex(a), extractLowLevelIndex(b)) ||\n              cmp(extractPrimKey(a), extractPrimKey(b));\n      });\n      if (req.limit && req.limit < Infinity) {\n          if (finalResult.length > req.limit) {\n              finalResult.length = req.limit;\n          }\n          else if (result.length === req.limit && finalResult.length < req.limit) {\n              cacheEntry.dirty = true;\n          }\n      }\n      return immutable ? Object.freeze(finalResult) : finalResult;\n  }\n\n  function areRangesEqual(r1, r2) {\n      return (cmp(r1.lower, r2.lower) === 0 &&\n          cmp(r1.upper, r2.upper) === 0 &&\n          !!r1.lowerOpen === !!r2.lowerOpen &&\n          !!r1.upperOpen === !!r2.upperOpen);\n  }\n\n  function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {\n      if (lower1 === undefined)\n          return lower2 !== undefined ? -1 : 0;\n      if (lower2 === undefined)\n          return 1;\n      var c = cmp(lower1, lower2);\n      if (c === 0) {\n          if (lowerOpen1 && lowerOpen2)\n              return 0;\n          if (lowerOpen1)\n              return 1;\n          if (lowerOpen2)\n              return -1;\n      }\n      return c;\n  }\n  function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {\n      if (upper1 === undefined)\n          return upper2 !== undefined ? 1 : 0;\n      if (upper2 === undefined)\n          return -1;\n      var c = cmp(upper1, upper2);\n      if (c === 0) {\n          if (upperOpen1 && upperOpen2)\n              return 0;\n          if (upperOpen1)\n              return -1;\n          if (upperOpen2)\n              return 1;\n      }\n      return c;\n  }\n  function isSuperRange(r1, r2) {\n      return (compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 &&\n          compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0);\n  }\n\n  function findCompatibleQuery(dbName, tableName, type, req) {\n      var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n      if (!tblCache)\n          return [];\n      var queries = tblCache.queries[type];\n      if (!queries)\n          return [null, false, tblCache, null];\n      var indexName = req.query ? req.query.index.name : null;\n      var entries = queries[indexName || ''];\n      if (!entries)\n          return [null, false, tblCache, null];\n      switch (type) {\n          case 'query':\n              var equalEntry = entries.find(function (entry) {\n                  return entry.req.limit === req.limit &&\n                      entry.req.values === req.values &&\n                      areRangesEqual(entry.req.query.range, req.query.range);\n              });\n              if (equalEntry)\n                  return [\n                      equalEntry,\n                      true,\n                      tblCache,\n                      entries,\n                  ];\n              var superEntry = entries.find(function (entry) {\n                  var limit = 'limit' in entry.req ? entry.req.limit : Infinity;\n                  return (limit >= req.limit &&\n                      (req.values ? entry.req.values : true) &&\n                      isSuperRange(entry.req.query.range, req.query.range));\n              });\n              return [superEntry, false, tblCache, entries];\n          case 'count':\n              var countQuery = entries.find(function (entry) {\n                  return areRangesEqual(entry.req.query.range, req.query.range);\n              });\n              return [countQuery, !!countQuery, tblCache, entries];\n      }\n  }\n\n  function subscribeToCacheEntry(cacheEntry, container, requery, signal) {\n      cacheEntry.subscribers.add(requery);\n      signal.addEventListener(\"abort\", function () {\n          cacheEntry.subscribers.delete(requery);\n          if (cacheEntry.subscribers.size === 0) {\n              enqueForDeletion(cacheEntry, container);\n          }\n      });\n  }\n  function enqueForDeletion(cacheEntry, container) {\n      setTimeout(function () {\n          if (cacheEntry.subscribers.size === 0) {\n              delArrayItem(container, cacheEntry);\n          }\n      }, 3000);\n  }\n\n  var cacheMiddleware = {\n      stack: 'dbcore',\n      level: 0,\n      name: 'Cache',\n      create: function (core) {\n          var dbName = core.schema.name;\n          var coreMW = __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n                  var idbtrans = core.transaction(stores, mode, options);\n                  if (mode === 'readwrite') {\n                      var ac_1 = new AbortController();\n                      var signal = ac_1.signal;\n                      var endTransaction = function (wasCommitted) { return function () {\n                          ac_1.abort();\n                          if (mode === 'readwrite') {\n                              var affectedSubscribers_1 = new Set();\n                              for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {\n                                  var storeName = stores_1[_i];\n                                  var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(storeName)];\n                                  if (tblCache) {\n                                      var table = core.table(storeName);\n                                      var ops = tblCache.optimisticOps.filter(function (op) { return op.trans === idbtrans; });\n                                      if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {\n                                          for (var _a = 0, _b = Object.values(tblCache.queries.query); _a < _b.length; _a++) {\n                                              var entries = _b[_a];\n                                              for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {\n                                                  var entry = _d[_c];\n                                                  if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {\n                                                      delArrayItem(entries, entry);\n                                                      entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                  }\n                                              }\n                                          }\n                                      }\n                                      else if (ops.length > 0) {\n                                          tblCache.optimisticOps = tblCache.optimisticOps.filter(function (op) { return op.trans !== idbtrans; });\n                                          for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {\n                                              var entries = _f[_e];\n                                              for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {\n                                                  var entry = _h[_g];\n                                                  if (entry.res != null &&\n                                                      idbtrans.mutatedParts\n  ) {\n                                                      if (wasCommitted && !entry.dirty) {\n                                                          var freezeResults = Object.isFrozen(entry.res);\n                                                          var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);\n                                                          if (entry.dirty) {\n                                                              delArrayItem(entries, entry);\n                                                              entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                          }\n                                                          else if (modRes !== entry.res) {\n                                                              entry.res = modRes;\n                                                              entry.promise = DexiePromise.resolve({ result: modRes });\n                                                          }\n                                                      }\n                                                      else {\n                                                          if (entry.dirty) {\n                                                              delArrayItem(entries, entry);\n                                                          }\n                                                          entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                      }\n                                                  }\n                                              }\n                                          }\n                                      }\n                                  }\n                              }\n                              affectedSubscribers_1.forEach(function (requery) { return requery(); });\n                          }\n                      }; };\n                      idbtrans.addEventListener('abort', endTransaction(false), {\n                          signal: signal,\n                      });\n                      idbtrans.addEventListener('error', endTransaction(false), {\n                          signal: signal,\n                      });\n                      idbtrans.addEventListener('complete', endTransaction(true), {\n                          signal: signal,\n                      });\n                  }\n                  return idbtrans;\n              }, table: function (tableName) {\n                  var downTable = core.table(tableName);\n                  var primKey = downTable.schema.primaryKey;\n                  var tableMW = __assign(__assign({}, downTable), { mutate: function (req) {\n                          var trans = PSD.trans;\n                          if (primKey.outbound ||\n                              trans.db._options.cache === 'disabled' ||\n                              trans.explicit ||\n                              trans.idbtrans.mode !== 'readwrite'\n                          ) {\n                              return downTable.mutate(req);\n                          }\n                          var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n                          if (!tblCache)\n                              return downTable.mutate(req);\n                          var promise = downTable.mutate(req);\n                          if ((req.type === 'add' || req.type === 'put') && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function (key) { return key == null; }))) {\n                              promise.then(function (res) {\n                                  var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function (value, i) {\n                                          var _a;\n                                          if (res.failures[i])\n                                              return value;\n                                          var valueWithKey = ((_a = primKey.keyPath) === null || _a === void 0 ? void 0 : _a.includes('.'))\n                                              ? deepClone(value)\n                                              : __assign({}, value);\n                                          setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);\n                                          return valueWithKey;\n                                      }) });\n                                  var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);\n                                  tblCache.optimisticOps.push(adjustedReq);\n                                  queueMicrotask(function () { return req.mutatedParts && signalSubscribersLazily(req.mutatedParts); });\n                              });\n                          }\n                          else {\n                              tblCache.optimisticOps.push(req);\n                              req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                              promise.then(function (res) {\n                                  if (res.numFailures > 0) {\n                                      delArrayItem(tblCache.optimisticOps, req);\n                                      var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);\n                                      if (adjustedReq) {\n                                          tblCache.optimisticOps.push(adjustedReq);\n                                      }\n                                      req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                                  }\n                              });\n                              promise.catch(function () {\n                                  delArrayItem(tblCache.optimisticOps, req);\n                                  req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                              });\n                          }\n                          return promise;\n                      }, query: function (req) {\n                          var _a;\n                          if (!isCachableContext(PSD, downTable) || !isCachableRequest(\"query\", req))\n                              return downTable.query(req);\n                          var freezeResults = ((_a = PSD.trans) === null || _a === void 0 ? void 0 : _a.db._options.cache) === 'immutable';\n                          var _b = PSD, requery = _b.requery, signal = _b.signal;\n                          var _c = findCompatibleQuery(dbName, tableName, 'query', req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];\n                          if (cacheEntry && exactMatch) {\n                              cacheEntry.obsSet = req.obsSet;\n                          }\n                          else {\n                              var promise = downTable.query(req).then(function (res) {\n                                  var result = res.result;\n                                  if (cacheEntry)\n                                      cacheEntry.res = result;\n                                  if (freezeResults) {\n                                      for (var i = 0, l = result.length; i < l; ++i) {\n                                          Object.freeze(result[i]);\n                                      }\n                                      Object.freeze(result);\n                                  }\n                                  else {\n                                      res.result = deepClone(result);\n                                  }\n                                  return res;\n                              }).catch(function (error) {\n                                  if (container && cacheEntry)\n                                      delArrayItem(container, cacheEntry);\n                                  return Promise.reject(error);\n                              });\n                              cacheEntry = {\n                                  obsSet: req.obsSet,\n                                  promise: promise,\n                                  subscribers: new Set(),\n                                  type: 'query',\n                                  req: req,\n                                  dirty: false,\n                              };\n                              if (container) {\n                                  container.push(cacheEntry);\n                              }\n                              else {\n                                  container = [cacheEntry];\n                                  if (!tblCache) {\n                                      tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)] = {\n                                          queries: {\n                                              query: {},\n                                              count: {},\n                                          },\n                                          objs: new Map(),\n                                          optimisticOps: [],\n                                          unsignaledParts: {}\n                                      };\n                                  }\n                                  tblCache.queries.query[req.query.index.name || ''] = container;\n                              }\n                          }\n                          subscribeToCacheEntry(cacheEntry, container, requery, signal);\n                          return cacheEntry.promise.then(function (res) {\n                              return {\n                                  result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults),\n                              };\n                          });\n                      } });\n                  return tableMW;\n              } });\n          return coreMW;\n      },\n  };\n\n  function vipify(target, vipDb) {\n      return new Proxy(target, {\n          get: function (target, prop, receiver) {\n              if (prop === 'db')\n                  return vipDb;\n              return Reflect.get(target, prop, receiver);\n          }\n      });\n  }\n\n  var Dexie$1 =  (function () {\n      function Dexie(name, options) {\n          var _this = this;\n          this._middlewares = {};\n          this.verno = 0;\n          var deps = Dexie.dependencies;\n          this._options = options = __assign({\n              addons: Dexie.addons, autoOpen: true,\n              indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange, cache: 'cloned' }, options);\n          this._deps = {\n              indexedDB: options.indexedDB,\n              IDBKeyRange: options.IDBKeyRange\n          };\n          var addons = options.addons;\n          this._dbSchema = {};\n          this._versions = [];\n          this._storeNames = [];\n          this._allTables = {};\n          this.idbdb = null;\n          this._novip = this;\n          var state = {\n              dbOpenError: null,\n              isBeingOpened: false,\n              onReadyBeingFired: null,\n              openComplete: false,\n              dbReadyResolve: nop,\n              dbReadyPromise: null,\n              cancelOpen: nop,\n              openCanceller: null,\n              autoSchema: true,\n              PR1398_maxLoop: 3,\n              autoOpen: options.autoOpen,\n          };\n          state.dbReadyPromise = new DexiePromise(function (resolve) {\n              state.dbReadyResolve = resolve;\n          });\n          state.openCanceller = new DexiePromise(function (_, reject) {\n              state.cancelOpen = reject;\n          });\n          this._state = state;\n          this.name = name;\n          this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n          this.once = function (event, callback) {\n              var fn = function () {\n                  var args = [];\n                  for (var _i = 0; _i < arguments.length; _i++) {\n                      args[_i] = arguments[_i];\n                  }\n                  _this.on(event).unsubscribe(fn);\n                  callback.apply(_this, args);\n              };\n              return _this.on(event, fn);\n          };\n          this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\n              return function (subscriber, bSticky) {\n                  Dexie.vip(function () {\n                      var state = _this._state;\n                      if (state.openComplete) {\n                          if (!state.dbOpenError)\n                              DexiePromise.resolve().then(subscriber);\n                          if (bSticky)\n                              subscribe(subscriber);\n                      }\n                      else if (state.onReadyBeingFired) {\n                          state.onReadyBeingFired.push(subscriber);\n                          if (bSticky)\n                              subscribe(subscriber);\n                      }\n                      else {\n                          subscribe(subscriber);\n                          var db_1 = _this;\n                          if (!bSticky)\n                              subscribe(function unsubscribe() {\n                                  db_1.on.ready.unsubscribe(subscriber);\n                                  db_1.on.ready.unsubscribe(unsubscribe);\n                              });\n                      }\n                  });\n              };\n          });\n          this.Collection = createCollectionConstructor(this);\n          this.Table = createTableConstructor(this);\n          this.Transaction = createTransactionConstructor(this);\n          this.Version = createVersionConstructor(this);\n          this.WhereClause = createWhereClauseConstructor(this);\n          this.on(\"versionchange\", function (ev) {\n              if (ev.newVersion > 0)\n                  console.warn(\"Another connection wants to upgrade database '\".concat(_this.name, \"'. Closing db now to resume the upgrade.\"));\n              else\n                  console.warn(\"Another connection wants to delete database '\".concat(_this.name, \"'. Closing db now to resume the delete request.\"));\n              _this.close({ disableAutoOpen: false });\n          });\n          this.on(\"blocked\", function (ev) {\n              if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                  console.warn(\"Dexie.delete('\".concat(_this.name, \"') was blocked\"));\n              else\n                  console.warn(\"Upgrade '\".concat(_this.name, \"' blocked by other connection holding version \").concat(ev.oldVersion / 10));\n          });\n          this._maxKey = getMaxKey(options.IDBKeyRange);\n          this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction); };\n          this._fireOnBlocked = function (ev) {\n              _this.on(\"blocked\").fire(ev);\n              connections\n                  .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })\n                  .map(function (c) { return c.on(\"versionchange\").fire(ev); });\n          };\n          this.use(cacheExistingValuesMiddleware);\n          this.use(cacheMiddleware);\n          this.use(observabilityMiddleware);\n          this.use(virtualIndexMiddleware);\n          this.use(hooksMiddleware);\n          var vipDB = new Proxy(this, {\n              get: function (_, prop, receiver) {\n                  if (prop === '_vip')\n                      return true;\n                  if (prop === 'table')\n                      return function (tableName) { return vipify(_this.table(tableName), vipDB); };\n                  var rv = Reflect.get(_, prop, receiver);\n                  if (rv instanceof Table)\n                      return vipify(rv, vipDB);\n                  if (prop === 'tables')\n                      return rv.map(function (t) { return vipify(t, vipDB); });\n                  if (prop === '_createTransaction')\n                      return function () {\n                          var tx = rv.apply(this, arguments);\n                          return vipify(tx, vipDB);\n                      };\n                  return rv;\n              }\n          });\n          this.vip = vipDB;\n          addons.forEach(function (addon) { return addon(_this); });\n      }\n      Dexie.prototype.version = function (versionNumber) {\n          if (isNaN(versionNumber) || versionNumber < 0.1)\n              throw new exceptions.Type(\"Given version is not a positive number\");\n          versionNumber = Math.round(versionNumber * 10) / 10;\n          if (this.idbdb || this._state.isBeingOpened)\n              throw new exceptions.Schema(\"Cannot add version when database is open\");\n          this.verno = Math.max(this.verno, versionNumber);\n          var versions = this._versions;\n          var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];\n          if (versionInstance)\n              return versionInstance;\n          versionInstance = new this.Version(versionNumber);\n          versions.push(versionInstance);\n          versions.sort(lowerVersionFirst);\n          versionInstance.stores({});\n          this._state.autoSchema = false;\n          return versionInstance;\n      };\n      Dexie.prototype._whenReady = function (fn) {\n          var _this = this;\n          return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise(function (resolve, reject) {\n              if (_this._state.openComplete) {\n                  return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));\n              }\n              if (!_this._state.isBeingOpened) {\n                  if (!_this._state.autoOpen) {\n                      reject(new exceptions.DatabaseClosed());\n                      return;\n                  }\n                  _this.open().catch(nop);\n              }\n              _this._state.dbReadyPromise.then(resolve, reject);\n          }).then(fn);\n      };\n      Dexie.prototype.use = function (_a) {\n          var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;\n          if (name)\n              this.unuse({ stack: stack, name: name });\n          var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n          middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });\n          middlewares.sort(function (a, b) { return a.level - b.level; });\n          return this;\n      };\n      Dexie.prototype.unuse = function (_a) {\n          var stack = _a.stack, name = _a.name, create = _a.create;\n          if (stack && this._middlewares[stack]) {\n              this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {\n                  return create ? mw.create !== create :\n                      name ? mw.name !== name :\n                          false;\n              });\n          }\n          return this;\n      };\n      Dexie.prototype.open = function () {\n          var _this = this;\n          return usePSD(globalPSD,\n          function () { return dexieOpen(_this); });\n      };\n      Dexie.prototype._close = function () {\n          this.on.close.fire(new CustomEvent('close'));\n          var state = this._state;\n          var idx = connections.indexOf(this);\n          if (idx >= 0)\n              connections.splice(idx, 1);\n          if (this.idbdb) {\n              try {\n                  this.idbdb.close();\n              }\n              catch (e) { }\n              this.idbdb = null;\n          }\n          if (!state.isBeingOpened) {\n              state.dbReadyPromise = new DexiePromise(function (resolve) {\n                  state.dbReadyResolve = resolve;\n              });\n              state.openCanceller = new DexiePromise(function (_, reject) {\n                  state.cancelOpen = reject;\n              });\n          }\n      };\n      Dexie.prototype.close = function (_a) {\n          var _b = _a === void 0 ? { disableAutoOpen: true } : _a, disableAutoOpen = _b.disableAutoOpen;\n          var state = this._state;\n          if (disableAutoOpen) {\n              if (state.isBeingOpened) {\n                  state.cancelOpen(new exceptions.DatabaseClosed());\n              }\n              this._close();\n              state.autoOpen = false;\n              state.dbOpenError = new exceptions.DatabaseClosed();\n          }\n          else {\n              this._close();\n              state.autoOpen = this._options.autoOpen ||\n                  state.isBeingOpened;\n              state.openComplete = false;\n              state.dbOpenError = null;\n          }\n      };\n      Dexie.prototype.delete = function (closeOptions) {\n          var _this = this;\n          if (closeOptions === void 0) { closeOptions = { disableAutoOpen: true }; }\n          var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== 'object';\n          var state = this._state;\n          return new DexiePromise(function (resolve, reject) {\n              var doDelete = function () {\n                  _this.close(closeOptions);\n                  var req = _this._deps.indexedDB.deleteDatabase(_this.name);\n                  req.onsuccess = wrap(function () {\n                      _onDatabaseDeleted(_this._deps, _this.name);\n                      resolve();\n                  });\n                  req.onerror = eventRejectHandler(reject);\n                  req.onblocked = _this._fireOnBlocked;\n              };\n              if (hasInvalidArguments)\n                  throw new exceptions.InvalidArgument(\"Invalid closeOptions argument to db.delete()\");\n              if (state.isBeingOpened) {\n                  state.dbReadyPromise.then(doDelete);\n              }\n              else {\n                  doDelete();\n              }\n          });\n      };\n      Dexie.prototype.backendDB = function () {\n          return this.idbdb;\n      };\n      Dexie.prototype.isOpen = function () {\n          return this.idbdb !== null;\n      };\n      Dexie.prototype.hasBeenClosed = function () {\n          var dbOpenError = this._state.dbOpenError;\n          return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n      };\n      Dexie.prototype.hasFailed = function () {\n          return this._state.dbOpenError !== null;\n      };\n      Dexie.prototype.dynamicallyOpened = function () {\n          return this._state.autoSchema;\n      };\n      Object.defineProperty(Dexie.prototype, \"tables\", {\n          get: function () {\n              var _this = this;\n              return keys(this._allTables).map(function (name) { return _this._allTables[name]; });\n          },\n          enumerable: false,\n          configurable: true\n      });\n      Dexie.prototype.transaction = function () {\n          var args = extractTransactionArgs.apply(this, arguments);\n          return this._transaction.apply(this, args);\n      };\n      Dexie.prototype._transaction = function (mode, tables, scopeFunc) {\n          var _this = this;\n          var parentTransaction = PSD.trans;\n          if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n              parentTransaction = null;\n          var onlyIfCompatible = mode.indexOf('?') !== -1;\n          mode = mode.replace('!', '').replace('?', '');\n          var idbMode, storeNames;\n          try {\n              storeNames = tables.map(function (table) {\n                  var storeName = table instanceof _this.Table ? table.name : table;\n                  if (typeof storeName !== 'string')\n                      throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                  return storeName;\n              });\n              if (mode == \"r\" || mode === READONLY)\n                  idbMode = READONLY;\n              else if (mode == \"rw\" || mode == READWRITE)\n                  idbMode = READWRITE;\n              else\n                  throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n              if (parentTransaction) {\n                  if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                      if (onlyIfCompatible) {\n                          parentTransaction = null;\n                      }\n                      else\n                          throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                  }\n                  if (parentTransaction) {\n                      storeNames.forEach(function (storeName) {\n                          if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                              if (onlyIfCompatible) {\n                                  parentTransaction = null;\n                              }\n                              else\n                                  throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                      \" not included in parent transaction.\");\n                          }\n                      });\n                  }\n                  if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                      parentTransaction = null;\n                  }\n              }\n          }\n          catch (e) {\n              return parentTransaction ?\n                  parentTransaction._promise(null, function (_, reject) { reject(e); }) :\n                  rejection(e);\n          }\n          var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n          return (parentTransaction ?\n              parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n              PSD.trans ?\n                  usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :\n                  this._whenReady(enterTransaction));\n      };\n      Dexie.prototype.table = function (tableName) {\n          if (!hasOwn(this._allTables, tableName)) {\n              throw new exceptions.InvalidTable(\"Table \".concat(tableName, \" does not exist\"));\n          }\n          return this._allTables[tableName];\n      };\n      return Dexie;\n  }());\n\n  var symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n      ? Symbol.observable\n      : \"@@observable\";\n  var Observable =  (function () {\n      function Observable(subscribe) {\n          this._subscribe = subscribe;\n      }\n      Observable.prototype.subscribe = function (x, error, complete) {\n          return this._subscribe(!x || typeof x === \"function\" ? { next: x, error: error, complete: complete } : x);\n      };\n      Observable.prototype[symbolObservable] = function () {\n          return this;\n      };\n      return Observable;\n  }());\n\n  var domDeps;\n  try {\n      domDeps = {\n          indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n          IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n      };\n  }\n  catch (e) {\n      domDeps = { indexedDB: null, IDBKeyRange: null };\n  }\n\n  function liveQuery(querier) {\n      var hasValue = false;\n      var currentValue;\n      var observable = new Observable(function (observer) {\n          var scopeFuncIsAsync = isAsyncFunction(querier);\n          function execute(ctx) {\n              var wasRootExec = beginMicroTickScope();\n              try {\n                  if (scopeFuncIsAsync) {\n                      incrementExpectedAwaits();\n                  }\n                  var rv = newScope(querier, ctx);\n                  if (scopeFuncIsAsync) {\n                      rv = rv.finally(decrementExpectedAwaits);\n                  }\n                  return rv;\n              }\n              finally {\n                  wasRootExec && endMicroTickScope();\n              }\n          }\n          var closed = false;\n          var abortController;\n          var accumMuts = {};\n          var currentObs = {};\n          var subscription = {\n              get closed() {\n                  return closed;\n              },\n              unsubscribe: function () {\n                  if (closed)\n                      return;\n                  closed = true;\n                  if (abortController)\n                      abortController.abort();\n                  if (startedListening)\n                      globalEvents.storagemutated.unsubscribe(mutationListener);\n              },\n          };\n          observer.start && observer.start(subscription);\n          var startedListening = false;\n          var doQuery = function () { return execInGlobalContext(_doQuery); };\n          function shouldNotify() {\n              return obsSetsOverlap(currentObs, accumMuts);\n          }\n          var mutationListener = function (parts) {\n              extendObservabilitySet(accumMuts, parts);\n              if (shouldNotify()) {\n                  doQuery();\n              }\n          };\n          var _doQuery = function () {\n              if (closed ||\n                  !domDeps.indexedDB)\n               {\n                  return;\n              }\n              accumMuts = {};\n              var subscr = {};\n              if (abortController)\n                  abortController.abort();\n              abortController = new AbortController();\n              var ctx = {\n                  subscr: subscr,\n                  signal: abortController.signal,\n                  requery: doQuery,\n                  querier: querier,\n                  trans: null\n              };\n              var ret = execute(ctx);\n              Promise.resolve(ret).then(function (result) {\n                  hasValue = true;\n                  currentValue = result;\n                  if (closed || ctx.signal.aborted) {\n                      return;\n                  }\n                  accumMuts = {};\n                  currentObs = subscr;\n                  if (!objectIsEmpty(currentObs) && !startedListening) {\n                      globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                      startedListening = true;\n                  }\n                  execInGlobalContext(function () { return !closed && observer.next && observer.next(result); });\n              }, function (err) {\n                  hasValue = false;\n                  if (!['DatabaseClosedError', 'AbortError'].includes(err === null || err === void 0 ? void 0 : err.name)) {\n                      if (!closed)\n                          execInGlobalContext(function () {\n                              if (closed)\n                                  return;\n                              observer.error && observer.error(err);\n                          });\n                  }\n              });\n          };\n          setTimeout(doQuery, 0);\n          return subscription;\n      });\n      observable.hasValue = function () { return hasValue; };\n      observable.getValue = function () { return currentValue; };\n      return observable;\n  }\n\n  var Dexie = Dexie$1;\n  props(Dexie, __assign(__assign({}, fullNameExceptions), {\n      delete: function (databaseName) {\n          var db = new Dexie(databaseName, { addons: [] });\n          return db.delete();\n      },\n      exists: function (name) {\n          return new Dexie(name, { addons: [] }).open().then(function (db) {\n              db.close();\n              return true;\n          }).catch('NoSuchDatabaseError', function () { return false; });\n      },\n      getDatabaseNames: function (cb) {\n          try {\n              return getDatabaseNames(Dexie.dependencies).then(cb);\n          }\n          catch (_a) {\n              return rejection(new exceptions.MissingAPI());\n          }\n      },\n      defineClass: function () {\n          function Class(content) {\n              extend(this, content);\n          }\n          return Class;\n      }, ignoreTransaction: function (scopeFunc) {\n          return PSD.trans ?\n              usePSD(PSD.transless, scopeFunc) :\n              scopeFunc();\n      }, vip: vip, async: function (generatorFn) {\n          return function () {\n              try {\n                  var rv = awaitIterator(generatorFn.apply(this, arguments));\n                  if (!rv || typeof rv.then !== 'function')\n                      return DexiePromise.resolve(rv);\n                  return rv;\n              }\n              catch (e) {\n                  return rejection(e);\n              }\n          };\n      }, spawn: function (generatorFn, args, thiz) {\n          try {\n              var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n              if (!rv || typeof rv.then !== 'function')\n                  return DexiePromise.resolve(rv);\n              return rv;\n          }\n          catch (e) {\n              return rejection(e);\n          }\n      },\n      currentTransaction: {\n          get: function () { return PSD.trans || null; }\n      }, waitFor: function (promiseOrFunction, optionalTimeout) {\n          var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n              Dexie.ignoreTransaction(promiseOrFunction) :\n              promiseOrFunction)\n              .timeout(optionalTimeout || 60000);\n          return PSD.trans ?\n              PSD.trans.waitFor(promise) :\n              promise;\n      },\n      Promise: DexiePromise,\n      debug: {\n          get: function () { return debug; },\n          set: function (value) {\n              setDebug(value);\n          }\n      },\n      derive: derive, extend: extend, props: props, override: override,\n      Events: Events, on: globalEvents, liveQuery: liveQuery, extendObservabilitySet: extendObservabilitySet,\n      getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, cmp: cmp, asap: asap$1,\n      minKey: minKey,\n      addons: [],\n      connections: connections,\n      errnames: errnames,\n      dependencies: domDeps, cache: cache,\n      semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')\n          .map(function (n) { return parseInt(n); })\n          .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }) }));\n  Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\n  if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n      globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {\n          if (!propagatingLocally) {\n              var event_1;\n              event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                  detail: updatedParts\n              });\n              propagatingLocally = true;\n              dispatchEvent(event_1);\n              propagatingLocally = false;\n          }\n      });\n      addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {\n          var detail = _a.detail;\n          if (!propagatingLocally) {\n              propagateLocally(detail);\n          }\n      });\n  }\n  function propagateLocally(updateParts) {\n      var wasMe = propagatingLocally;\n      try {\n          propagatingLocally = true;\n          globalEvents.storagemutated.fire(updateParts);\n          signalSubscribersNow(updateParts, true);\n      }\n      finally {\n          propagatingLocally = wasMe;\n      }\n  }\n  var propagatingLocally = false;\n\n  var bc;\n  var createBC = function () { };\n  if (typeof BroadcastChannel !== 'undefined') {\n      createBC = function () {\n          bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n          bc.onmessage = function (ev) { return ev.data && propagateLocally(ev.data); };\n      };\n      createBC();\n      if (typeof bc.unref === 'function') {\n          bc.unref();\n      }\n      globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n          if (!propagatingLocally) {\n              bc.postMessage(changedParts);\n          }\n      });\n  }\n\n  if (typeof addEventListener !== 'undefined') {\n      addEventListener('pagehide', function (event) {\n          if (!Dexie$1.disableBfCache && event.persisted) {\n              if (debug)\n                  console.debug('Dexie: handling persisted pagehide');\n              bc === null || bc === void 0 ? void 0 : bc.close();\n              for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {\n                  var db = connections_1[_i];\n                  db.close({ disableAutoOpen: false });\n              }\n          }\n      });\n      addEventListener('pageshow', function (event) {\n          if (!Dexie$1.disableBfCache && event.persisted) {\n              if (debug)\n                  console.debug('Dexie: handling persisted pageshow');\n              createBC();\n              propagateLocally({ all: new RangeSet(-Infinity, [[]]) });\n          }\n      });\n  }\n\n  function add(value) {\n      return new PropModification({ add: value });\n  }\n\n  function remove(value) {\n      return new PropModification({ remove: value });\n  }\n\n  function replacePrefix(a, b) {\n      return new PropModification({ replacePrefix: [a, b] });\n  }\n\n  DexiePromise.rejectionMapper = mapError;\n  setDebug(debug);\n\n  var namedExports = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Dexie: Dexie$1,\n    Entity: Entity,\n    PropModification: PropModification,\n    RangeSet: RangeSet,\n    add: add,\n    cmp: cmp,\n    default: Dexie$1,\n    liveQuery: liveQuery,\n    mergeRanges: mergeRanges,\n    rangesOverlap: rangesOverlap,\n    remove: remove,\n    replacePrefix: replacePrefix\n  });\n\n  __assign(Dexie$1, namedExports, { default: Dexie$1 });\n\n  return Dexie$1;\n\n}));\n//# sourceMappingURL=dexie.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGV4aWUvZGlzdC9kZXhpZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLENBQ29HO0FBQ3RHLENBQUMsdUJBQXVCOztBQUV4QjtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJFQUEyRTtBQUN2RixZQUFZLDZEQUE2RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FB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QTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFD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Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDdkY7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvQ0FBb0M7QUFDckU7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRDs7QUFFQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25EOztBQUVBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILG9DQUFvQyxrQkFBa0I7O0FBRXREOztBQUVBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsiL1VzZXJzL3RpbW90aHllZGliby9wcm9qZWN0cy9wZXJzb25hbC9ibHVlY291bnRzL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9kZXhpZS9kaXN0L2RleGllLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBEZXhpZS5qcyAtIGEgbWluaW1hbGlzdGljIHdyYXBwZXIgZm9yIEluZGV4ZWREQlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBCeSBEYXZpZCBGYWhsYW5kZXIsIGRhdmlkLmZhaGxhbmRlckBnbWFpbC5jb21cbiAqXG4gKiBWZXJzaW9uIDQuMy4wLCBTYXQgRGVjIDIwIDIwMjVcbiAqXG4gKiBodHRwczovL2RleGllLm9yZ1xuICpcbiAqIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBKYW51YXJ5IDIwMDQsIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9cbiAqL1xuIFxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuRGV4aWUgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICB9O1xuICBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfVxuICB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xuICB9XG4gIHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG4gIH07XG5cbiAgdmFyIF9nbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDpcbiAgICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOlxuICAgICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDpcbiAgICAgICAgICAgICAgZ2xvYmFsO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXM7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiAhX2dsb2JhbC5Qcm9taXNlKSB7XG4gICAgICBfZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlO1xuICB9XG4gIGZ1bmN0aW9uIGV4dGVuZChvYmosIGV4dGVuc2lvbikge1xuICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24gIT09ICdvYmplY3QnKVxuICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICBrZXlzKGV4dGVuc2lvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBleHRlbnNpb25ba2V5XTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgfVxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBfaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG4gIGZ1bmN0aW9uIGhhc093bihvYmosIHByb3ApIHtcbiAgICAgIHJldHVybiBfaGFzT3duLmNhbGwob2JqLCBwcm9wKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9wcyhwcm90bywgZXh0ZW5zaW9uKSB7XG4gICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24oZ2V0UHJvdG8ocHJvdG8pKTtcbiAgICAgICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiA/IGtleXMgOiBSZWZsZWN0Lm93bktleXMpKGV4dGVuc2lvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgc2V0UHJvcChwcm90bywga2V5LCBleHRlbnNpb25ba2V5XSk7XG4gICAgICB9KTtcbiAgfVxuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIGZ1bmN0aW9uIHNldFByb3Aob2JqLCBwcm9wLCBmdW5jdGlvbk9yR2V0U2V0LCBvcHRpb25zKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGV4dGVuZChmdW5jdGlvbk9yR2V0U2V0ICYmIGhhc093bihmdW5jdGlvbk9yR2V0U2V0LCBcImdldFwiKSAmJiB0eXBlb2YgZnVuY3Rpb25PckdldFNldC5nZXQgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgIHsgZ2V0OiBmdW5jdGlvbk9yR2V0U2V0LmdldCwgc2V0OiBmdW5jdGlvbk9yR2V0U2V0LnNldCwgY29uZmlndXJhYmxlOiB0cnVlIH0gOlxuICAgICAgICAgIHsgdmFsdWU6IGZ1bmN0aW9uT3JHZXRTZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSwgb3B0aW9ucykpO1xuICB9XG4gIGZ1bmN0aW9uIGRlcml2ZShDaGlsZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmcm9tOiBmdW5jdGlvbiAoUGFyZW50KSB7XG4gICAgICAgICAgICAgIENoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgIHNldFByb3AoQ2hpbGQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIENoaWxkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGV4dGVuZDogcHJvcHMuYmluZChudWxsLCBDaGlsZC5wcm90b3R5cGUpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgfVxuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgZnVuY3Rpb24gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCkge1xuICAgICAgdmFyIHBkID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgICB2YXIgcHJvdG87XG4gICAgICByZXR1cm4gcGQgfHwgKHByb3RvID0gZ2V0UHJvdG8ob2JqKSkgJiYgZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wKTtcbiAgfVxuICB2YXIgX3NsaWNlID0gW10uc2xpY2U7XG4gIGZ1bmN0aW9uIHNsaWNlKGFyZ3MsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBfc2xpY2UuY2FsbChhcmdzLCBzdGFydCwgZW5kKTtcbiAgfVxuICBmdW5jdGlvbiBvdmVycmlkZShvcmlnRnVuYywgb3ZlcnJpZGVkRmFjdG9yeSkge1xuICAgICAgcmV0dXJuIG92ZXJyaWRlZEZhY3Rvcnkob3JpZ0Z1bmMpO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2VydChiKSB7XG4gICAgICBpZiAoIWIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIEZhaWxlZFwiKTtcbiAgfVxuICBmdW5jdGlvbiBhc2FwJDEoZm4pIHtcbiAgICAgIGlmIChfZ2xvYmFsLnNldEltbWVkaWF0ZSlcbiAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgICAgZWxzZVxuICAgICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICB9XG4gIGZ1bmN0aW9uIGFycmF5VG9PYmplY3QoYXJyYXksIGV4dHJhY3Rvcikge1xuICAgICAgcmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBpdGVtLCBpKSB7XG4gICAgICAgICAgdmFyIG5hbWVBbmRWYWx1ZSA9IGV4dHJhY3RvcihpdGVtLCBpKTtcbiAgICAgICAgICBpZiAobmFtZUFuZFZhbHVlKVxuICAgICAgICAgICAgICByZXN1bHRbbmFtZUFuZFZhbHVlWzBdXSA9IG5hbWVBbmRWYWx1ZVsxXTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwge30pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgJiYgaGFzT3duKG9iaiwga2V5UGF0aCkpXG4gICAgICAgICAgcmV0dXJuIG9ialtrZXlQYXRoXTtcbiAgICAgIGlmICgha2V5UGF0aClcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBydiA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5UGF0aC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0pO1xuICAgICAgICAgICAgICBydi5wdXNoKHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBydjtcbiAgICAgIH1cbiAgICAgIHZhciBwZXJpb2QgPSBrZXlQYXRoLmluZGV4T2YoJy4nKTtcbiAgICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG4gICAgICAgICAgdmFyIGlubmVyT2JqID0gb2JqW2tleVBhdGguc3Vic3RyKDAsIHBlcmlvZCldO1xuICAgICAgICAgIHJldHVybiBpbm5lck9iaiA9PSBudWxsID8gdW5kZWZpbmVkIDogZ2V0QnlLZXlQYXRoKGlubmVyT2JqLCBrZXlQYXRoLnN1YnN0cihwZXJpb2QgKyAxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKSB7XG4gICAgICBpZiAoIW9iaiB8fCBrZXlQYXRoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCdpc0Zyb3plbicgaW4gT2JqZWN0ICYmIE9iamVjdC5pc0Zyb3plbihvYmopKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycgJiYgJ2xlbmd0aCcgaW4ga2V5UGF0aCkge1xuICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICdsZW5ndGgnIGluIHZhbHVlKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleVBhdGgubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0sIHZhbHVlW2ldKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcGVyaW9kID0ga2V5UGF0aC5pbmRleE9mKCcuJyk7XG4gICAgICAgICAgaWYgKHBlcmlvZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIoMCwgcGVyaW9kKTtcbiAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZ0tleVBhdGggPSBrZXlQYXRoLnN1YnN0cihwZXJpb2QgKyAxKTtcbiAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0tleVBhdGggPT09IFwiXCIpXG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KG9iaikgJiYgIWlzTmFOKHBhcnNlSW50KGN1cnJlbnRLZXlQYXRoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zcGxpY2UoY3VycmVudEtleVBhdGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtjdXJyZW50S2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgb2JqW2N1cnJlbnRLZXlQYXRoXSA9IHZhbHVlO1xuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtjdXJyZW50S2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICBpZiAoIWlubmVyT2JqIHx8ICFoYXNPd24ob2JqLCBjdXJyZW50S2V5UGF0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmogPSAob2JqW2N1cnJlbnRLZXlQYXRoXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpbm5lck9iaiwgcmVtYWluaW5nS2V5UGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSAmJiAhaXNOYU4ocGFyc2VJbnQoa2V5UGF0aCkpKVxuICAgICAgICAgICAgICAgICAgICAgIG9iai5zcGxpY2Uoa2V5UGF0aCwgMSk7XG4gICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXlQYXRoXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBvYmpba2V5UGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGVsQnlLZXlQYXRoKG9iaiwga2V5UGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJylcbiAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCB1bmRlZmluZWQpO1xuICAgICAgZWxzZSBpZiAoJ2xlbmd0aCcgaW4ga2V5UGF0aClcbiAgICAgICAgICBbXS5tYXAuY2FsbChrZXlQYXRoLCBmdW5jdGlvbiAoa3ApIHtcbiAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga3AsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG9iaikge1xuICAgICAgdmFyIHJ2ID0ge307XG4gICAgICBmb3IgKHZhciBtIGluIG9iaikge1xuICAgICAgICAgIGlmIChoYXNPd24ob2JqLCBtKSlcbiAgICAgICAgICAgICAgcnZbbV0gPSBvYmpbbV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcnY7XG4gIH1cbiAgdmFyIGNvbmNhdCA9IFtdLmNvbmNhdDtcbiAgZnVuY3Rpb24gZmxhdHRlbihhKSB7XG4gICAgICByZXR1cm4gY29uY2F0LmFwcGx5KFtdLCBhKTtcbiAgfVxuICB2YXIgaW50cmluc2ljVHlwZU5hbWVzID0gXCJCaWdVaW50NjRBcnJheSxCaWdJbnQ2NEFycmF5LEFycmF5LEJvb2xlYW4sU3RyaW5nLERhdGUsUmVnRXhwLEJsb2IsRmlsZSxGaWxlTGlzdCxGaWxlU3lzdGVtRmlsZUhhbmRsZSxGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlLEFycmF5QnVmZmVyLERhdGFWaWV3LFVpbnQ4Q2xhbXBlZEFycmF5LEltYWdlQml0bWFwLEltYWdlRGF0YSxNYXAsU2V0LENyeXB0b0tleVwiXG4gICAgICAuc3BsaXQoJywnKS5jb25jYXQoZmxhdHRlbihbOCwgMTYsIDMyLCA2NF0ubWFwKGZ1bmN0aW9uIChudW0pIHsgcmV0dXJuIFtcIkludFwiLCBcIlVpbnRcIiwgXCJGbG9hdFwiXS5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKyBudW0gKyBcIkFycmF5XCI7IH0pOyB9KSkpLmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gX2dsb2JhbFt0XTsgfSk7XG4gIHZhciBpbnRyaW5zaWNUeXBlcyA9IG5ldyBTZXQoaW50cmluc2ljVHlwZU5hbWVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gX2dsb2JhbFt0XTsgfSkpO1xuICBmdW5jdGlvbiBjbG9uZVNpbXBsZU9iamVjdFRyZWUobykge1xuICAgICAgdmFyIHJ2ID0ge307XG4gICAgICBmb3IgKHZhciBrIGluIG8pXG4gICAgICAgICAgaWYgKGhhc093bihvLCBrKSkge1xuICAgICAgICAgICAgICB2YXIgdiA9IG9ba107XG4gICAgICAgICAgICAgIHJ2W2tdID0gIXYgfHwgdHlwZW9mIHYgIT09ICdvYmplY3QnIHx8IGludHJpbnNpY1R5cGVzLmhhcyh2LmNvbnN0cnVjdG9yKSA/IHYgOiBjbG9uZVNpbXBsZU9iamVjdFRyZWUodik7XG4gICAgICAgICAgfVxuICAgICAgcmV0dXJuIHJ2O1xuICB9XG4gIGZ1bmN0aW9uIG9iamVjdElzRW1wdHkobykge1xuICAgICAgZm9yICh2YXIgayBpbiBvKVxuICAgICAgICAgIGlmIChoYXNPd24obywgaykpXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBjaXJjdWxhclJlZnMgPSBudWxsO1xuICBmdW5jdGlvbiBkZWVwQ2xvbmUoYW55KSB7XG4gICAgICBjaXJjdWxhclJlZnMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgdmFyIHJ2ID0gaW5uZXJEZWVwQ2xvbmUoYW55KTtcbiAgICAgIGNpcmN1bGFyUmVmcyA9IG51bGw7XG4gICAgICByZXR1cm4gcnY7XG4gIH1cbiAgZnVuY3Rpb24gaW5uZXJEZWVwQ2xvbmUoeCkge1xuICAgICAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JylcbiAgICAgICAgICByZXR1cm4geDtcbiAgICAgIHZhciBydiA9IGNpcmN1bGFyUmVmcy5nZXQoeCk7XG4gICAgICBpZiAocnYpXG4gICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgaWYgKGlzQXJyYXkoeCkpIHtcbiAgICAgICAgICBydiA9IFtdO1xuICAgICAgICAgIGNpcmN1bGFyUmVmcy5zZXQoeCwgcnYpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0geC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgcnYucHVzaChpbm5lckRlZXBDbG9uZSh4W2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaW50cmluc2ljVHlwZXMuaGFzKHguY29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgcnYgPSB4O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHByb3RvID0gZ2V0UHJvdG8oeCk7XG4gICAgICAgICAgcnYgPSBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSA/IHt9IDogT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICAgICAgY2lyY3VsYXJSZWZzLnNldCh4LCBydik7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB4KSB7XG4gICAgICAgICAgICAgIGlmIChoYXNPd24oeCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgIHJ2W3Byb3BdID0gaW5uZXJEZWVwQ2xvbmUoeFtwcm9wXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcnY7XG4gIH1cbiAgdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG4gIGZ1bmN0aW9uIHRvU3RyaW5nVGFnKG8pIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgfVxuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICBTeW1ib2wuaXRlcmF0b3IgOlxuICAgICAgJ0BAaXRlcmF0b3InO1xuICB2YXIgZ2V0SXRlcmF0b3JPZiA9IHR5cGVvZiBpdGVyYXRvclN5bWJvbCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHJldHVybiB4ICE9IG51bGwgJiYgKGkgPSB4W2l0ZXJhdG9yU3ltYm9sXSkgJiYgaS5hcHBseSh4KTtcbiAgfSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gIGZ1bmN0aW9uIGRlbEFycmF5SXRlbShhLCB4KSB7XG4gICAgICB2YXIgaSA9IGEuaW5kZXhPZih4KTtcbiAgICAgIGlmIChpID49IDApXG4gICAgICAgICAgYS5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gaSA+PSAwO1xuICB9XG4gIHZhciBOT19DSEFSX0FSUkFZID0ge307XG4gIGZ1bmN0aW9uIGdldEFycmF5T2YoYXJyYXlMaWtlKSB7XG4gICAgICB2YXIgaSwgYSwgeCwgaXQ7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGlmIChpc0FycmF5KGFycmF5TGlrZSkpXG4gICAgICAgICAgICAgIHJldHVybiBhcnJheUxpa2Uuc2xpY2UoKTtcbiAgICAgICAgICBpZiAodGhpcyA9PT0gTk9fQ0hBUl9BUlJBWSAmJiB0eXBlb2YgYXJyYXlMaWtlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuICAgICAgICAgIGlmICgoaXQgPSBnZXRJdGVyYXRvck9mKGFycmF5TGlrZSkpKSB7XG4gICAgICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICAgICAgd2hpbGUgKCh4ID0gaXQubmV4dCgpKSwgIXguZG9uZSlcbiAgICAgICAgICAgICAgICAgIGEucHVzaCh4LnZhbHVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhcnJheUxpa2UgPT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuICAgICAgICAgIGkgPSBhcnJheUxpa2UubGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgYSA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgICAgICAgIGFbaV0gPSBhcnJheUxpa2VbaV07XG4gICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgICB9XG4gICAgICBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGEgPSBuZXcgQXJyYXkoaSk7XG4gICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgIGFbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gYTtcbiAgfVxuICB2YXIgaXNBc3luY0Z1bmN0aW9uID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbltTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQXN5bmNGdW5jdGlvbic7IH1cbiAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbiAgdmFyIGRleGllRXJyb3JOYW1lcyA9IFtcbiAgICAgICdNb2RpZnknLFxuICAgICAgJ0J1bGsnLFxuICAgICAgJ09wZW5GYWlsZWQnLFxuICAgICAgJ1ZlcnNpb25DaGFuZ2UnLFxuICAgICAgJ1NjaGVtYScsXG4gICAgICAnVXBncmFkZScsXG4gICAgICAnSW52YWxpZFRhYmxlJyxcbiAgICAgICdNaXNzaW5nQVBJJyxcbiAgICAgICdOb1N1Y2hEYXRhYmFzZScsXG4gICAgICAnSW52YWxpZEFyZ3VtZW50JyxcbiAgICAgICdTdWJUcmFuc2FjdGlvbicsXG4gICAgICAnVW5zdXBwb3J0ZWQnLFxuICAgICAgJ0ludGVybmFsJyxcbiAgICAgICdEYXRhYmFzZUNsb3NlZCcsXG4gICAgICAnUHJlbWF0dXJlQ29tbWl0JyxcbiAgICAgICdGb3JlaWduQXdhaXQnXG4gIF07XG4gIHZhciBpZGJEb21FcnJvck5hbWVzID0gW1xuICAgICAgJ1Vua25vd24nLFxuICAgICAgJ0NvbnN0cmFpbnQnLFxuICAgICAgJ0RhdGEnLFxuICAgICAgJ1RyYW5zYWN0aW9uSW5hY3RpdmUnLFxuICAgICAgJ1JlYWRPbmx5JyxcbiAgICAgICdWZXJzaW9uJyxcbiAgICAgICdOb3RGb3VuZCcsXG4gICAgICAnSW52YWxpZFN0YXRlJyxcbiAgICAgICdJbnZhbGlkQWNjZXNzJyxcbiAgICAgICdBYm9ydCcsXG4gICAgICAnVGltZW91dCcsXG4gICAgICAnUXVvdGFFeGNlZWRlZCcsXG4gICAgICAnU3ludGF4JyxcbiAgICAgICdEYXRhQ2xvbmUnXG4gIF07XG4gIHZhciBlcnJvckxpc3QgPSBkZXhpZUVycm9yTmFtZXMuY29uY2F0KGlkYkRvbUVycm9yTmFtZXMpO1xuICB2YXIgZGVmYXVsdFRleHRzID0ge1xuICAgICAgVmVyc2lvbkNoYW5nZWQ6IFwiRGF0YWJhc2UgdmVyc2lvbiBjaGFuZ2VkIGJ5IG90aGVyIGRhdGFiYXNlIGNvbm5lY3Rpb25cIixcbiAgICAgIERhdGFiYXNlQ2xvc2VkOiBcIkRhdGFiYXNlIGhhcyBiZWVuIGNsb3NlZFwiLFxuICAgICAgQWJvcnQ6IFwiVHJhbnNhY3Rpb24gYWJvcnRlZFwiLFxuICAgICAgVHJhbnNhY3Rpb25JbmFjdGl2ZTogXCJUcmFuc2FjdGlvbiBoYXMgYWxyZWFkeSBjb21wbGV0ZWQgb3IgZmFpbGVkXCIsXG4gICAgICBNaXNzaW5nQVBJOiBcIkluZGV4ZWREQiBBUEkgbWlzc2luZy4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vdGlueXVybC5jb20veTJ1dXZza2JcIlxuICB9O1xuICBmdW5jdGlvbiBEZXhpZUVycm9yKG5hbWUsIG1zZykge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgfVxuICBkZXJpdmUoRGV4aWVFcnJvcikuZnJvbShFcnJvcikuZXh0ZW5kKHtcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7IH1cbiAgfSk7XG4gIGZ1bmN0aW9uIGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpIHtcbiAgICAgIHJldHVybiBtc2cgKyBcIi4gRXJyb3JzOiBcIiArIE9iamVjdC5rZXlzKGZhaWx1cmVzKVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZmFpbHVyZXNba2V5XS50b1N0cmluZygpOyB9KVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHYsIGksIHMpIHsgcmV0dXJuIHMuaW5kZXhPZih2KSA9PT0gaTsgfSlcbiAgICAgICAgICAuam9pbignXFxuJyk7XG4gIH1cbiAgZnVuY3Rpb24gTW9kaWZ5RXJyb3IobXNnLCBmYWlsdXJlcywgc3VjY2Vzc0NvdW50LCBmYWlsZWRLZXlzKSB7XG4gICAgICB0aGlzLmZhaWx1cmVzID0gZmFpbHVyZXM7XG4gICAgICB0aGlzLmZhaWxlZEtleXMgPSBmYWlsZWRLZXlzO1xuICAgICAgdGhpcy5zdWNjZXNzQ291bnQgPSBzdWNjZXNzQ291bnQ7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIGZhaWx1cmVzKTtcbiAgfVxuICBkZXJpdmUoTW9kaWZ5RXJyb3IpLmZyb20oRGV4aWVFcnJvcik7XG4gIGZ1bmN0aW9uIEJ1bGtFcnJvcihtc2csIGZhaWx1cmVzKSB7XG4gICAgICB0aGlzLm5hbWUgPSBcIkJ1bGtFcnJvclwiO1xuICAgICAgdGhpcy5mYWlsdXJlcyA9IE9iamVjdC5rZXlzKGZhaWx1cmVzKS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gZmFpbHVyZXNbcG9zXTsgfSk7XG4gICAgICB0aGlzLmZhaWx1cmVzQnlQb3MgPSBmYWlsdXJlcztcbiAgICAgIHRoaXMubWVzc2FnZSA9IGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgdGhpcy5mYWlsdXJlcyk7XG4gIH1cbiAgZGVyaXZlKEJ1bGtFcnJvcikuZnJvbShEZXhpZUVycm9yKTtcbiAgdmFyIGVycm5hbWVzID0gZXJyb3JMaXN0LnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7IHJldHVybiAob2JqW25hbWVdID0gbmFtZSArIFwiRXJyb3JcIiwgb2JqKTsgfSwge30pO1xuICB2YXIgQmFzZUV4Y2VwdGlvbiA9IERleGllRXJyb3I7XG4gIHZhciBleGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gICAgICB2YXIgZnVsbE5hbWUgPSBuYW1lICsgXCJFcnJvclwiO1xuICAgICAgZnVuY3Rpb24gRGV4aWVFcnJvcihtc2dPcklubmVyLCBpbm5lcikge1xuICAgICAgICAgIHRoaXMubmFtZSA9IGZ1bGxOYW1lO1xuICAgICAgICAgIGlmICghbXNnT3JJbm5lcikge1xuICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBkZWZhdWx0VGV4dHNbbmFtZV0gfHwgZnVsbE5hbWU7XG4gICAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJcIi5jb25jYXQobXNnT3JJbm5lcikuY29uY2F0KCFpbm5lciA/ICcnIDogJ1xcbiAnICsgaW5uZXIpO1xuICAgICAgICAgICAgICB0aGlzLmlubmVyID0gaW5uZXIgfHwgbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1zZ09ySW5uZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IFwiXCIuY29uY2F0KG1zZ09ySW5uZXIubmFtZSwgXCIgXCIpLmNvbmNhdChtc2dPcklubmVyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICB0aGlzLmlubmVyID0gbXNnT3JJbm5lcjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZXJpdmUoRGV4aWVFcnJvcikuZnJvbShCYXNlRXhjZXB0aW9uKTtcbiAgICAgIG9ialtuYW1lXSA9IERleGllRXJyb3I7XG4gICAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG4gIGV4Y2VwdGlvbnMuU3ludGF4ID0gU3ludGF4RXJyb3I7XG4gIGV4Y2VwdGlvbnMuVHlwZSA9IFR5cGVFcnJvcjtcbiAgZXhjZXB0aW9ucy5SYW5nZSA9IFJhbmdlRXJyb3I7XG4gIHZhciBleGNlcHRpb25NYXAgPSBpZGJEb21FcnJvck5hbWVzLnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gICAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuICAgICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xuICBmdW5jdGlvbiBtYXBFcnJvcihkb21FcnJvciwgbWVzc2FnZSkge1xuICAgICAgaWYgKCFkb21FcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIERleGllRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBTeW50YXhFcnJvciB8fCAhZG9tRXJyb3IubmFtZSB8fCAhZXhjZXB0aW9uTWFwW2RvbUVycm9yLm5hbWVdKVxuICAgICAgICAgIHJldHVybiBkb21FcnJvcjtcbiAgICAgIHZhciBydiA9IG5ldyBleGNlcHRpb25NYXBbZG9tRXJyb3IubmFtZV0obWVzc2FnZSB8fCBkb21FcnJvci5tZXNzYWdlLCBkb21FcnJvcik7XG4gICAgICBpZiAoXCJzdGFja1wiIGluIGRvbUVycm9yKSB7XG4gICAgICAgICAgc2V0UHJvcChydiwgXCJzdGFja1wiLCB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXIuc3RhY2s7XG4gICAgICAgICAgICAgIH0gfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnY7XG4gIH1cbiAgdmFyIGZ1bGxOYW1lRXhjZXB0aW9ucyA9IGVycm9yTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgbmFtZSkge1xuICAgICAgaWYgKFtcIlN5bnRheFwiLCBcIlR5cGVcIiwgXCJSYW5nZVwiXS5pbmRleE9mKG5hbWUpID09PSAtMSlcbiAgICAgICAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuICAgICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xuICBmdWxsTmFtZUV4Y2VwdGlvbnMuTW9kaWZ5RXJyb3IgPSBNb2RpZnlFcnJvcjtcbiAgZnVsbE5hbWVFeGNlcHRpb25zLkRleGllRXJyb3IgPSBEZXhpZUVycm9yO1xuICBmdWxsTmFtZUV4Y2VwdGlvbnMuQnVsa0Vycm9yID0gQnVsa0Vycm9yO1xuXG4gIGZ1bmN0aW9uIG5vcCgpIHsgfVxuICBmdW5jdGlvbiBtaXJyb3IodmFsKSB7IHJldHVybiB2YWw7IH1cbiAgZnVuY3Rpb24gcHVyZUZ1bmN0aW9uQ2hhaW4oZjEsIGYyKSB7XG4gICAgICBpZiAoZjEgPT0gbnVsbCB8fCBmMSA9PT0gbWlycm9yKVxuICAgICAgICAgIHJldHVybiBmMjtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGYyKGYxKHZhbCkpO1xuICAgICAgfTtcbiAgfVxuICBmdW5jdGlvbiBjYWxsQm90aChvbjEsIG9uMikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvbjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gaG9va0NyZWF0aW5nQ2hhaW4oZjEsIGYyKSB7XG4gICAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgICByZXR1cm4gZjI7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gcmVzO1xuICAgICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyxcbiAgICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gbnVsbDtcbiAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAob25zdWNjZXNzKVxuICAgICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgICAgaWYgKG9uZXJyb3IpXG4gICAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgICAgICAgIHJldHVybiByZXMyICE9PSB1bmRlZmluZWQgPyByZXMyIDogcmVzO1xuICAgICAgfTtcbiAgfVxuICBmdW5jdGlvbiBob29rRGVsZXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICAgIHJldHVybiBmMjtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB2YXIgb25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MsXG4gICAgICAgICAgb25lcnJvciA9IHRoaXMub25lcnJvcjtcbiAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAob25zdWNjZXNzKVxuICAgICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgICAgaWYgKG9uZXJyb3IpXG4gICAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgICAgfTtcbiAgfVxuICBmdW5jdGlvbiBob29rVXBkYXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICAgIHJldHVybiBmMjtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobW9kaWZpY2F0aW9ucykge1xuICAgICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGV4dGVuZChtb2RpZmljYXRpb25zLCByZXMpO1xuICAgICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyxcbiAgICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gbnVsbDtcbiAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAob25zdWNjZXNzKVxuICAgICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgICAgaWYgKG9uZXJyb3IpXG4gICAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgICAgICAgIHJldHVybiByZXMgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgIChyZXMyID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZXMyKSA6XG4gICAgICAgICAgICAgIChleHRlbmQocmVzLCByZXMyKSk7XG4gICAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluKGYxLCBmMikge1xuICAgICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgICAgcmV0dXJuIGYyO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gcHJvbWlzYWJsZUNoYWluKGYxLCBmMikge1xuICAgICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgICAgcmV0dXJuIGYyO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB2YXIgdGhpeiA9IHRoaXMsIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcy50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGl6LCBhcmdzKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfVxuXG4gIHZhciBkZWJ1ZyA9IHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIC9eKGh0dHB8aHR0cHMpOlxcL1xcLyhsb2NhbGhvc3R8MTI3XFwuMFxcLjBcXC4xKS8udGVzdChsb2NhdGlvbi5ocmVmKTtcbiAgZnVuY3Rpb24gc2V0RGVidWcodmFsdWUsIGZpbHRlcikge1xuICAgICAgZGVidWcgPSB2YWx1ZTtcbiAgfVxuXG4gIHZhciBJTlRFUk5BTCA9IHt9O1xuICB2YXIgWk9ORV9FQ0hPX0xJTUlUID0gMTAwLCBfYSQxID0gdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID9cbiAgICAgIFtdIDpcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGdsb2JhbFAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcgfHwgIWNyeXB0by5zdWJ0bGUpXG4gICAgICAgICAgICAgIHJldHVybiBbZ2xvYmFsUCwgZ2V0UHJvdG8oZ2xvYmFsUCksIGdsb2JhbFBdO1xuICAgICAgICAgIHZhciBuYXRpdmVQID0gY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtNTEyXCIsIG5ldyBVaW50OEFycmF5KFswXSkpO1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIG5hdGl2ZVAsXG4gICAgICAgICAgICAgIGdldFByb3RvKG5hdGl2ZVApLFxuICAgICAgICAgICAgICBnbG9iYWxQXG4gICAgICAgICAgXTtcbiAgICAgIH0pKCksIHJlc29sdmVkTmF0aXZlUHJvbWlzZSA9IF9hJDFbMF0sIG5hdGl2ZVByb21pc2VQcm90byA9IF9hJDFbMV0sIHJlc29sdmVkR2xvYmFsUHJvbWlzZSA9IF9hJDFbMl0sIG5hdGl2ZVByb21pc2VUaGVuID0gbmF0aXZlUHJvbWlzZVByb3RvICYmIG5hdGl2ZVByb21pc2VQcm90by50aGVuO1xuICB2YXIgTmF0aXZlUHJvbWlzZSA9IHJlc29sdmVkTmF0aXZlUHJvbWlzZSAmJiByZXNvbHZlZE5hdGl2ZVByb21pc2UuY29uc3RydWN0b3I7XG4gIHZhciBwYXRjaEdsb2JhbFByb21pc2UgPSAhIXJlc29sdmVkR2xvYmFsUHJvbWlzZTtcbiAgZnVuY3Rpb24gc2NoZWR1bGVQaHlzaWNhbFRpY2soKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzayhwaHlzaWNhbFRpY2spO1xuICB9XG4gIHZhciBhc2FwID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgICBtaWNyb3RpY2tRdWV1ZS5wdXNoKFtjYWxsYmFjaywgYXJnc10pO1xuICAgICAgaWYgKG5lZWRzTmV3UGh5c2ljYWxUaWNrKSB7XG4gICAgICAgICAgc2NoZWR1bGVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IGZhbHNlO1xuICAgICAgfVxuICB9O1xuICB2YXIgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZSxcbiAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSB0cnVlLFxuICB1bmhhbmRsZWRFcnJvcnMgPSBbXSxcbiAgcmVqZWN0aW5nRXJyb3JzID0gW10sXG4gIHJlamVjdGlvbk1hcHBlciA9IG1pcnJvcjtcbiAgdmFyIGdsb2JhbFBTRCA9IHtcbiAgICAgIGlkOiAnZ2xvYmFsJyxcbiAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgIHJlZjogMCxcbiAgICAgIHVuaGFuZGxlZHM6IFtdLFxuICAgICAgb251bmhhbmRsZWQ6IG5vcCxcbiAgICAgIHBncDogZmFsc2UsXG4gICAgICBlbnY6IHt9LFxuICAgICAgZmluYWxpemU6IG5vcFxuICB9O1xuICB2YXIgUFNEID0gZ2xvYmFsUFNEO1xuICB2YXIgbWljcm90aWNrUXVldWUgPSBbXTtcbiAgdmFyIG51bVNjaGVkdWxlZENhbGxzID0gMDtcbiAgdmFyIHRpY2tGaW5hbGl6ZXJzID0gW107XG4gIGZ1bmN0aW9uIERleGllUHJvbWlzZShmbikge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JylcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKTtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgICAgdGhpcy5fbGliID0gZmFsc2U7XG4gICAgICB2YXIgcHNkID0gKHRoaXMuX1BTRCA9IFBTRCk7XG4gICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGZuICE9PSBJTlRFUk5BTClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICB0aGlzLl92YWx1ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICBoYW5kbGVSZWplY3Rpb24odGhpcywgdGhpcy5fdmFsdWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICsrcHNkLnJlZjtcbiAgICAgIGV4ZWN1dGVQcm9taXNlVGFzayh0aGlzLCBmbik7XG4gIH1cbiAgdmFyIHRoZW5Qcm9wID0ge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHBzZCA9IFBTRCwgbWljcm9UYXNrSWQgPSB0b3RhbEVjaG9lcztcbiAgICAgICAgICBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgIHZhciBwb3NzaWJsZUF3YWl0ID0gIXBzZC5nbG9iYWwgJiYgKHBzZCAhPT0gUFNEIHx8IG1pY3JvVGFza0lkICE9PSB0b3RhbEVjaG9lcyk7XG4gICAgICAgICAgICAgIHZhciBjbGVhbnVwID0gcG9zc2libGVBd2FpdCAmJiAhZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKF90aGlzLCBuZXcgTGlzdGVuZXIobmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvbkZ1bGZpbGxlZCwgcHNkLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSwgbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvblJlamVjdGVkLCBwc2QsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApLCByZXNvbHZlLCByZWplY3QsIHBzZCkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnNvbGVUYXNrKVxuICAgICAgICAgICAgICAgICAgcnYuX2NvbnNvbGVUYXNrID0gdGhpcy5fY29uc29sZVRhc2s7XG4gICAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhlbi5wcm90b3R5cGUgPSBJTlRFUk5BTDtcbiAgICAgICAgICByZXR1cm4gdGhlbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHNldFByb3AodGhpcywgJ3RoZW4nLCB2YWx1ZSAmJiB2YWx1ZS5wcm90b3R5cGUgPT09IElOVEVSTkFMID9cbiAgICAgICAgICAgICAgdGhlblByb3AgOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgc2V0OiB0aGVuUHJvcC5zZXRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICB9XG4gIH07XG4gIHByb3BzKERleGllUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAgIHRoZW46IHRoZW5Qcm9wLFxuICAgICAgX3RoZW46IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIodGhpcywgbmV3IExpc3RlbmVyKG51bGwsIG51bGwsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBQU0QpKTtcbiAgICAgIH0sXG4gICAgICBjYXRjaDogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXSwgaGFuZGxlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0aGlzLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgdHlwZSA/IGhhbmRsZXIoZXJyKSA6IFByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgICA6IHRoaXMudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZXJyICYmIGVyci5uYW1lID09PSB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmaW5hbGx5OiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlUmVqZWN0KGVycik7IH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHRpbWVvdXQ6IGZ1bmN0aW9uIChtcywgbXNnKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gbXMgPCBJbmZpbml0eSA/XG4gICAgICAgICAgICAgIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0KG5ldyBleGNlcHRpb25zLlRpbWVvdXQobXNnKSk7IH0sIG1zKTtcbiAgICAgICAgICAgICAgICAgIF90aGlzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KS5maW5hbGx5KGNsZWFyVGltZW91dC5iaW5kKG51bGwsIGhhbmRsZSkpO1xuICAgICAgICAgICAgICB9KSA6IHRoaXM7XG4gICAgICB9XG4gIH0pO1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKVxuICAgICAgc2V0UHJvcChEZXhpZVByb21pc2UucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsICdEZXhpZS5Qcm9taXNlJyk7XG4gIGdsb2JhbFBTRC5lbnYgPSBzbmFwU2hvdCgpO1xuICBmdW5jdGlvbiBMaXN0ZW5lcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0LCB6b25lKSB7XG4gICAgICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICAgICAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgIHRoaXMucHNkID0gem9uZTtcbiAgfVxuICBwcm9wcyhEZXhpZVByb21pc2UsIHtcbiAgICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChhLCBpKSB7IHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShhKS50aGVuKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSB4O1xuICAgICAgICAgICAgICAgICAgaWYgKCEtLXJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgICAgIH0sIHJlamVjdCk7IH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHJlc29sdmU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgcnYgPSBuZXcgRGV4aWVQcm9taXNlKElOVEVSTkFMLCB0cnVlLCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSxcbiAgICAgIHJlamVjdDogUHJvbWlzZVJlamVjdCxcbiAgICAgIHJhY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7IH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFBTRDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUFNEOyB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBQU0QgPSB2YWx1ZTsgfVxuICAgICAgfSxcbiAgICAgIHRvdGFsRWNob2VzOiB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdG90YWxFY2hvZXM7IH0gfSxcbiAgICAgIG5ld1BTRDogbmV3U2NvcGUsXG4gICAgICB1c2VQU0Q6IHVzZVBTRCxcbiAgICAgIHNjaGVkdWxlcjoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXNhcDsgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyBhc2FwID0gdmFsdWU7IH1cbiAgICAgIH0sXG4gICAgICByZWplY3Rpb25NYXBwZXI6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdGlvbk1hcHBlcjsgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZWplY3Rpb25NYXBwZXIgPSB2YWx1ZTsgfVxuICAgICAgfSxcbiAgICAgIGZvbGxvdzogZnVuY3Rpb24gKGZuLCB6b25lUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHNkID0gUFNEO1xuICAgICAgICAgICAgICAgICAgcHNkLnVuaGFuZGxlZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIHBzZC5vbnVuaGFuZGxlZCA9IHJlamVjdDtcbiAgICAgICAgICAgICAgICAgIHBzZC5maW5hbGl6ZSA9IGNhbGxCb3RoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51bmhhbmRsZWRzLmxlbmd0aCA9PT0gMCA/IHJlc29sdmUoKSA6IHJlamVjdChfdGhpcy51bmhhbmRsZWRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0sIHBzZC5maW5hbGl6ZSk7XG4gICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICB9LCB6b25lUHJvcHMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gIH0pO1xuICBpZiAoTmF0aXZlUHJvbWlzZSkge1xuICAgICAgaWYgKE5hdGl2ZVByb21pc2UuYWxsU2V0dGxlZClcbiAgICAgICAgICBzZXRQcm9wKERleGllUHJvbWlzZSwgXCJhbGxTZXR0bGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlUHJvbWlzZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocG9zc2libGVQcm9taXNlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gcG9zc2libGVQcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShyZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgcG9zc2libGVQcm9taXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShwKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gcmVzdWx0c1tpXSA9IHsgc3RhdHVzOiBcImZ1bGZpbGxlZFwiLCB2YWx1ZTogdmFsdWUgfTsgfSwgZnVuY3Rpb24gKHJlYXNvbikgeyByZXR1cm4gcmVzdWx0c1tpXSA9IHsgc3RhdHVzOiBcInJlamVjdGVkXCIsIHJlYXNvbjogcmVhc29uIH07IH0pXG4gICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gLS1yZW1haW5pbmcgfHwgcmVzb2x2ZShyZXN1bHRzKTsgfSk7IH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgIGlmIChOYXRpdmVQcm9taXNlLmFueSAmJiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgIHNldFByb3AoRGV4aWVQcm9taXNlLCBcImFueVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBwb3NzaWJsZVByb21pc2VzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAocG9zc2libGVQcm9taXNlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihbXSkpO1xuICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVzID0gbmV3IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICBwb3NzaWJsZVByb21pc2VzLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHApLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiByZXNvbHZlKHZhbHVlKTsgfSwgZnVuY3Rpb24gKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlc1tpXSA9IGZhaWx1cmU7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihmYWlsdXJlcykpO1xuICAgICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgIGlmIChOYXRpdmVQcm9taXNlLndpdGhSZXNvbHZlcnMpXG4gICAgICAgICAgRGV4aWVQcm9taXNlLndpdGhSZXNvbHZlcnMgPSBOYXRpdmVQcm9taXNlLndpdGhSZXNvbHZlcnM7XG4gIH1cbiAgZnVuY3Rpb24gZXhlY3V0ZVByb21pc2VUYXNrKHByb21pc2UsIGZuKSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGZuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcHJvbWlzZSlcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICAgICAgICAgIHZhciBzaG91bGRFeGVjdXRlVGljayA9IHByb21pc2UuX2xpYiAmJiBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgZXhlY3V0ZVByb21pc2VUYXNrKHByb21pc2UsIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl90aGVuKHJlc29sdmUsIHJlamVjdCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHByb21pc2UuX3N0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHByb21pc2UuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKVxuICAgICAgICAgICAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgICB9LCBoYW5kbGVSZWplY3Rpb24uYmluZChudWxsLCBwcm9taXNlKSk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBoYW5kbGVSZWplY3Rpb24ocHJvbWlzZSwgZXgpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVJlamVjdGlvbihwcm9taXNlLCByZWFzb24pIHtcbiAgICAgIHJlamVjdGluZ0Vycm9ycy5wdXNoKHJlYXNvbik7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgdmFyIHNob3VsZEV4ZWN1dGVUaWNrID0gcHJvbWlzZS5fbGliICYmIGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgIHJlYXNvbiA9IHJlamVjdGlvbk1hcHBlcihyZWFzb24pO1xuICAgICAgcHJvbWlzZS5fc3RhdGUgPSBmYWxzZTtcbiAgICAgIHByb21pc2UuX3ZhbHVlID0gcmVhc29uO1xuICAgICAgYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcihwcm9taXNlKTtcbiAgICAgIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKTtcbiAgICAgIGlmIChzaG91bGRFeGVjdXRlVGljaylcbiAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICB9XG4gIGZ1bmN0aW9uIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gcHJvbWlzZS5fbGlzdGVuZXJzO1xuICAgICAgcHJvbWlzZS5fbGlzdGVuZXJzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgICAgdmFyIHBzZCA9IHByb21pc2UuX1BTRDtcbiAgICAgIC0tcHNkLnJlZiB8fCBwc2QuZmluYWxpemUoKTtcbiAgICAgIGlmIChudW1TY2hlZHVsZWRDYWxscyA9PT0gMCkge1xuICAgICAgICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG4gICAgICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuICAgICAgICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgICB9LCBbXSk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgcHJvbWlzZS5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjYiA9IHByb21pc2UuX3N0YXRlID8gbGlzdGVuZXIub25GdWxmaWxsZWQgOiBsaXN0ZW5lci5vblJlamVjdGVkO1xuICAgICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIChwcm9taXNlLl9zdGF0ZSA/IGxpc3RlbmVyLnJlc29sdmUgOiBsaXN0ZW5lci5yZWplY3QpKHByb21pc2UuX3ZhbHVlKTtcbiAgICAgIH1cbiAgICAgICsrbGlzdGVuZXIucHNkLnJlZjtcbiAgICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG4gICAgICBhc2FwKGNhbGxMaXN0ZW5lciwgW2NiLCBwcm9taXNlLCBsaXN0ZW5lcl0pO1xuICB9XG4gIGZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihjYiwgcHJvbWlzZSwgbGlzdGVuZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHJldCwgdmFsdWUgPSBwcm9taXNlLl92YWx1ZTtcbiAgICAgICAgICBpZiAoIXByb21pc2UuX3N0YXRlICYmIHJlamVjdGluZ0Vycm9ycy5sZW5ndGgpXG4gICAgICAgICAgICAgIHJlamVjdGluZ0Vycm9ycyA9IFtdO1xuICAgICAgICAgIHJldCA9IGRlYnVnICYmIHByb21pc2UuX2NvbnNvbGVUYXNrID8gcHJvbWlzZS5fY29uc29sZVRhc2sucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNiKHZhbHVlKTsgfSkgOiBjYih2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFwcm9taXNlLl9zdGF0ZSAmJiByZWplY3RpbmdFcnJvcnMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGlzdGVuZXIucmVzb2x2ZShyZXQpO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsaXN0ZW5lci5yZWplY3QoZSk7XG4gICAgICB9XG4gICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcbiAgICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgICAtLWxpc3RlbmVyLnBzZC5yZWYgfHwgbGlzdGVuZXIucHNkLmZpbmFsaXplKCk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGh5c2ljYWxUaWNrKCkge1xuICAgICAgdXNlUFNEKGdsb2JhbFBTRCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGJlZ2luTWljcm9UaWNrU2NvcGUoKSAmJiBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYmVnaW5NaWNyb1RpY2tTY29wZSgpIHtcbiAgICAgIHZhciB3YXNSb290RXhlYyA9IGlzT3V0c2lkZU1pY3JvVGljaztcbiAgICAgIGlzT3V0c2lkZU1pY3JvVGljayA9IGZhbHNlO1xuICAgICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcbiAgICAgIHJldHVybiB3YXNSb290RXhlYztcbiAgfVxuICBmdW5jdGlvbiBlbmRNaWNyb1RpY2tTY29wZSgpIHtcbiAgICAgIHZhciBjYWxsYmFja3MsIGksIGw7XG4gICAgICBkbyB7XG4gICAgICAgICAgd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2tzID0gbWljcm90aWNrUXVldWU7XG4gICAgICAgICAgICAgIG1pY3JvdGlja1F1ZXVlID0gW107XG4gICAgICAgICAgICAgIGwgPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGNhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgICAgICAgIGl0ZW1bMF0uYXBwbHkobnVsbCwgaXRlbVsxXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9IHdoaWxlIChtaWNyb3RpY2tRdWV1ZS5sZW5ndGggPiAwKTtcbiAgICAgIGlzT3V0c2lkZU1pY3JvVGljayA9IHRydWU7XG4gICAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gZmluYWxpemVQaHlzaWNhbFRpY2soKSB7XG4gICAgICB2YXIgdW5oYW5kbGVkRXJycyA9IHVuaGFuZGxlZEVycm9ycztcbiAgICAgIHVuaGFuZGxlZEVycm9ycyA9IFtdO1xuICAgICAgdW5oYW5kbGVkRXJycy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcC5fUFNELm9udW5oYW5kbGVkLmNhbGwobnVsbCwgcC5fdmFsdWUsIHApO1xuICAgICAgfSk7XG4gICAgICB2YXIgZmluYWxpemVycyA9IHRpY2tGaW5hbGl6ZXJzLnNsaWNlKDApO1xuICAgICAgdmFyIGkgPSBmaW5hbGl6ZXJzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpKVxuICAgICAgICAgIGZpbmFsaXplcnNbLS1pXSgpO1xuICB9XG4gIGZ1bmN0aW9uIHJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2soZm4pIHtcbiAgICAgIGZ1bmN0aW9uIGZpbmFsaXplcigpIHtcbiAgICAgICAgICBmbigpO1xuICAgICAgICAgIHRpY2tGaW5hbGl6ZXJzLnNwbGljZSh0aWNrRmluYWxpemVycy5pbmRleE9mKGZpbmFsaXplciksIDEpO1xuICAgICAgfVxuICAgICAgdGlja0ZpbmFsaXplcnMucHVzaChmaW5hbGl6ZXIpO1xuICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuICAgICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuICAgICAgfSwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IocHJvbWlzZSkge1xuICAgICAgaWYgKCF1bmhhbmRsZWRFcnJvcnMuc29tZShmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlOyB9KSlcbiAgICAgICAgICB1bmhhbmRsZWRFcnJvcnMucHVzaChwcm9taXNlKTtcbiAgfVxuICBmdW5jdGlvbiBtYXJrRXJyb3JBc0hhbmRsZWQocHJvbWlzZSkge1xuICAgICAgdmFyIGkgPSB1bmhhbmRsZWRFcnJvcnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkpXG4gICAgICAgICAgaWYgKHVuaGFuZGxlZEVycm9yc1stLWldLl92YWx1ZSA9PT0gcHJvbWlzZS5fdmFsdWUpIHtcbiAgICAgICAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBQcm9taXNlUmVqZWN0KHJlYXNvbikge1xuICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIGZhbHNlLCByZWFzb24pO1xuICB9XG4gIGZ1bmN0aW9uIHdyYXAoZm4sIGVycm9yQ2F0Y2hlcikge1xuICAgICAgdmFyIHBzZCA9IFBTRDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpLCBvdXRlclNjb3BlID0gUFNEO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN3aXRjaFRvWm9uZShwc2QsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgZXJyb3JDYXRjaGVyICYmIGVycm9yQ2F0Y2hlcihlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGlmICh3YXNSb290RXhlYylcbiAgICAgICAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgfVxuICB2YXIgdGFzayA9IHsgYXdhaXRzOiAwLCBlY2hvZXM6IDAsIGlkOiAwIH07XG4gIHZhciB0YXNrQ291bnRlciA9IDA7XG4gIHZhciB6b25lU3RhY2sgPSBbXTtcbiAgdmFyIHpvbmVFY2hvZXMgPSAwO1xuICB2YXIgdG90YWxFY2hvZXMgPSAwO1xuICB2YXIgem9uZV9pZF9jb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gbmV3U2NvcGUoZm4sIHByb3BzLCBhMSwgYTIpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBQU0QsIHBzZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAgIHBzZC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICBwc2QucmVmID0gMDtcbiAgICAgIHBzZC5nbG9iYWwgPSBmYWxzZTtcbiAgICAgIHBzZC5pZCA9ICsrem9uZV9pZF9jb3VudGVyO1xuICAgICAgZ2xvYmFsUFNELmVudjtcbiAgICAgIHBzZC5lbnYgPSBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG4gICAgICAgICAgUHJvbWlzZTogRGV4aWVQcm9taXNlLFxuICAgICAgICAgIFByb21pc2VQcm9wOiB7IHZhbHVlOiBEZXhpZVByb21pc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICAgICAgICBhbGw6IERleGllUHJvbWlzZS5hbGwsXG4gICAgICAgICAgcmFjZTogRGV4aWVQcm9taXNlLnJhY2UsXG4gICAgICAgICAgYWxsU2V0dGxlZDogRGV4aWVQcm9taXNlLmFsbFNldHRsZWQsXG4gICAgICAgICAgYW55OiBEZXhpZVByb21pc2UuYW55LFxuICAgICAgICAgIHJlc29sdmU6IERleGllUHJvbWlzZS5yZXNvbHZlLFxuICAgICAgICAgIHJlamVjdDogRGV4aWVQcm9taXNlLnJlamVjdCxcbiAgICAgIH0gOiB7fTtcbiAgICAgIGlmIChwcm9wcylcbiAgICAgICAgICBleHRlbmQocHNkLCBwcm9wcyk7XG4gICAgICArK3BhcmVudC5yZWY7XG4gICAgICBwc2QuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLS10aGlzLnBhcmVudC5yZWYgfHwgdGhpcy5wYXJlbnQuZmluYWxpemUoKTtcbiAgICAgIH07XG4gICAgICB2YXIgcnYgPSB1c2VQU0QocHNkLCBmbiwgYTEsIGEyKTtcbiAgICAgIGlmIChwc2QucmVmID09PSAwKVxuICAgICAgICAgIHBzZC5maW5hbGl6ZSgpO1xuICAgICAgcmV0dXJuIHJ2O1xuICB9XG4gIGZ1bmN0aW9uIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCkge1xuICAgICAgaWYgKCF0YXNrLmlkKVxuICAgICAgICAgIHRhc2suaWQgPSArK3Rhc2tDb3VudGVyO1xuICAgICAgKyt0YXNrLmF3YWl0cztcbiAgICAgIHRhc2suZWNob2VzICs9IFpPTkVfRUNIT19MSU1JVDtcbiAgICAgIHJldHVybiB0YXNrLmlkO1xuICB9XG4gIGZ1bmN0aW9uIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCkge1xuICAgICAgaWYgKCF0YXNrLmF3YWl0cylcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoLS10YXNrLmF3YWl0cyA9PT0gMClcbiAgICAgICAgICB0YXNrLmlkID0gMDtcbiAgICAgIHRhc2suZWNob2VzID0gdGFzay5hd2FpdHMgKiBaT05FX0VDSE9fTElNSVQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoKCcnICsgbmF0aXZlUHJvbWlzZVRoZW4pLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSA9PT0gLTEpIHtcbiAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMgPSBub3A7XG4gIH1cbiAgZnVuY3Rpb24gb25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKHBvc3NpYmxlUHJvbWlzZSkge1xuICAgICAgaWYgKHRhc2suZWNob2VzICYmIHBvc3NpYmxlUHJvbWlzZSAmJiBwb3NzaWJsZVByb21pc2UuY29uc3RydWN0b3IgPT09IE5hdGl2ZVByb21pc2UpIHtcbiAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgIHJldHVybiBwb3NzaWJsZVByb21pc2UudGhlbihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZTtcbiAgfVxuICBmdW5jdGlvbiB6b25lRW50ZXJFY2hvKHRhcmdldFpvbmUpIHtcbiAgICAgICsrdG90YWxFY2hvZXM7XG4gICAgICBpZiAoIXRhc2suZWNob2VzIHx8IC0tdGFzay5lY2hvZXMgPT09IDApIHtcbiAgICAgICAgICB0YXNrLmVjaG9lcyA9IHRhc2suYXdhaXRzID0gdGFzay5pZCA9IDA7XG4gICAgICB9XG4gICAgICB6b25lU3RhY2sucHVzaChQU0QpO1xuICAgICAgc3dpdGNoVG9ab25lKHRhcmdldFpvbmUsIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIHpvbmVMZWF2ZUVjaG8oKSB7XG4gICAgICB2YXIgem9uZSA9IHpvbmVTdGFja1t6b25lU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB6b25lU3RhY2sucG9wKCk7XG4gICAgICBzd2l0Y2hUb1pvbmUoem9uZSwgZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIHN3aXRjaFRvWm9uZSh0YXJnZXRab25lLCBiRW50ZXJpbmdab25lKSB7XG4gICAgICB2YXIgY3VycmVudFpvbmUgPSBQU0Q7XG4gICAgICBpZiAoYkVudGVyaW5nWm9uZSA/IHRhc2suZWNob2VzICYmICghem9uZUVjaG9lcysrIHx8IHRhcmdldFpvbmUgIT09IFBTRCkgOiB6b25lRWNob2VzICYmICghLS16b25lRWNob2VzIHx8IHRhcmdldFpvbmUgIT09IFBTRCkpIHtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhiRW50ZXJpbmdab25lID8gem9uZUVudGVyRWNoby5iaW5kKG51bGwsIHRhcmdldFpvbmUpIDogem9uZUxlYXZlRWNobyk7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0Wm9uZSA9PT0gUFNEKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIFBTRCA9IHRhcmdldFpvbmU7XG4gICAgICBpZiAoY3VycmVudFpvbmUgPT09IGdsb2JhbFBTRClcbiAgICAgICAgICBnbG9iYWxQU0QuZW52ID0gc25hcFNob3QoKTtcbiAgICAgIGlmIChwYXRjaEdsb2JhbFByb21pc2UpIHtcbiAgICAgICAgICB2YXIgR2xvYmFsUHJvbWlzZSA9IGdsb2JhbFBTRC5lbnYuUHJvbWlzZTtcbiAgICAgICAgICB2YXIgdGFyZ2V0RW52ID0gdGFyZ2V0Wm9uZS5lbnY7XG4gICAgICAgICAgaWYgKGN1cnJlbnRab25lLmdsb2JhbCB8fCB0YXJnZXRab25lLmdsb2JhbCkge1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2dsb2JhbCwgJ1Byb21pc2UnLCB0YXJnZXRFbnYuUHJvbWlzZVByb3ApO1xuICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFsbCA9IHRhcmdldEVudi5hbGw7XG4gICAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmFjZSA9IHRhcmdldEVudi5yYWNlO1xuICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJlc29sdmUgPSB0YXJnZXRFbnYucmVzb2x2ZTtcbiAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZWplY3QgPSB0YXJnZXRFbnYucmVqZWN0O1xuICAgICAgICAgICAgICBpZiAodGFyZ2V0RW52LmFsbFNldHRsZWQpXG4gICAgICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFsbFNldHRsZWQgPSB0YXJnZXRFbnYuYWxsU2V0dGxlZDtcbiAgICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbnkpXG4gICAgICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFueSA9IHRhcmdldEVudi5hbnk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNuYXBTaG90KCkge1xuICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBfZ2xvYmFsLlByb21pc2U7XG4gICAgICByZXR1cm4gcGF0Y2hHbG9iYWxQcm9taXNlID8ge1xuICAgICAgICAgIFByb21pc2U6IEdsb2JhbFByb21pc2UsXG4gICAgICAgICAgUHJvbWlzZVByb3A6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2dsb2JhbCwgXCJQcm9taXNlXCIpLFxuICAgICAgICAgIGFsbDogR2xvYmFsUHJvbWlzZS5hbGwsXG4gICAgICAgICAgcmFjZTogR2xvYmFsUHJvbWlzZS5yYWNlLFxuICAgICAgICAgIGFsbFNldHRsZWQ6IEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCxcbiAgICAgICAgICBhbnk6IEdsb2JhbFByb21pc2UuYW55LFxuICAgICAgICAgIHJlc29sdmU6IEdsb2JhbFByb21pc2UucmVzb2x2ZSxcbiAgICAgICAgICByZWplY3Q6IEdsb2JhbFByb21pc2UucmVqZWN0LFxuICAgICAgfSA6IHt9O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVBTRChwc2QsIGZuLCBhMSwgYTIsIGEzKSB7XG4gICAgICB2YXIgb3V0ZXJTY29wZSA9IFBTRDtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgc3dpdGNoVG9ab25lKHBzZCwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIGZuKGExLCBhMiwgYTMpO1xuICAgICAgfVxuICAgICAgZmluYWxseSB7XG4gICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKGZuLCB6b25lLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nID8gZm4gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG91dGVyWm9uZSA9IFBTRDtcbiAgICAgICAgICBpZiAocG9zc2libGVBd2FpdClcbiAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICBzd2l0Y2hUb1pvbmUoem9uZSwgdHJ1ZSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICBzd2l0Y2hUb1pvbmUob3V0ZXJab25lLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGlmIChjbGVhbnVwKVxuICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZXhlY0luR2xvYmFsQ29udGV4dChjYikge1xuICAgICAgaWYgKFByb21pc2UgPT09IE5hdGl2ZVByb21pc2UgJiYgdGFzay5lY2hvZXMgPT09IDApIHtcbiAgICAgICAgICBpZiAoem9uZUVjaG9lcyA9PT0gMCkge1xuICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZW5xdWV1ZU5hdGl2ZU1pY3JvVGFzayhjYik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICB9XG4gIH1cbiAgdmFyIHJlamVjdGlvbiA9IERleGllUHJvbWlzZS5yZWplY3Q7XG5cbiAgZnVuY3Rpb24gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikge1xuICAgICAgaWYgKCFkYi5pZGJkYiB8fCAoIWRiLl9zdGF0ZS5vcGVuQ29tcGxldGUgJiYgKCFQU0QubGV0VGhyb3VnaCAmJiAhZGIuX3ZpcCkpKSB7XG4gICAgICAgICAgaWYgKGRiLl9zdGF0ZS5vcGVuQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZChkYi5fc3RhdGUuZGJPcGVuRXJyb3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkYi5fc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICBpZiAoIWRiLl9zdGF0ZS5hdXRvT3BlbilcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKSk7XG4gICAgICAgICAgICAgIGRiLm9wZW4oKS5jYXRjaChub3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGIuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbik7IH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdHJhbnMuY3JlYXRlKCk7XG4gICAgICAgICAgICAgIGRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA9IDM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICBpZiAoZXgubmFtZSA9PT0gZXJybmFtZXMuSW52YWxpZFN0YXRlICYmIGRiLmlzT3BlbigpICYmIC0tZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID4gMCkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogTmVlZCB0byByZW9wZW4gZGInKTtcbiAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKHsgZGlzYWJsZUF1dG9PcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkYi5vcGVuKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB0ZW1wVHJhbnNhY3Rpb24oZGIsIG1vZGUsIHN0b3JlTmFtZXMsIGZuKTsgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBQU0QudHJhbnMgPSB0cmFucztcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJylcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnMuaWRidHJhbnMuY29tbWl0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgICByZXR1cm4gbW9kZSA9PT0gJ3JlYWRvbmx5JyA/IHJlc3VsdCA6IHRyYW5zLl9jb21wbGV0aW9uLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzdWx0OyB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgfVxuXG4gIHZhciBERVhJRV9WRVJTSU9OID0gJzQuMy4wJztcbiAgdmFyIG1heFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzUpO1xuICB2YXIgbWluS2V5ID0gLUluZmluaXR5O1xuICB2YXIgSU5WQUxJRF9LRVlfQVJHVU1FTlQgPSBcIkludmFsaWQga2V5IHByb3ZpZGVkLiBLZXlzIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcsIG51bWJlciwgRGF0ZSBvciBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBEYXRlPi5cIjtcbiAgdmFyIFNUUklOR19FWFBFQ1RFRCA9IFwiU3RyaW5nIGV4cGVjdGVkLlwiO1xuICB2YXIgY29ubmVjdGlvbnMgPSBbXTtcbiAgdmFyIERCTkFNRVNfREIgPSAnX19kYm5hbWVzJztcbiAgdmFyIFJFQURPTkxZID0gJ3JlYWRvbmx5JztcbiAgdmFyIFJFQURXUklURSA9ICdyZWFkd3JpdGUnO1xuXG4gIGZ1bmN0aW9uIGNvbWJpbmUoZmlsdGVyMSwgZmlsdGVyMikge1xuICAgICAgcmV0dXJuIGZpbHRlcjEgP1xuICAgICAgICAgIGZpbHRlcjIgP1xuICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXIxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgJiYgZmlsdGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IDpcbiAgICAgICAgICAgICAgZmlsdGVyMSA6XG4gICAgICAgICAgZmlsdGVyMjtcbiAgfVxuXG4gIHZhciBBbnlSYW5nZSA9IHtcbiAgICAgIHR5cGU6IDMgLFxuICAgICAgbG93ZXI6IC1JbmZpbml0eSxcbiAgICAgIGxvd2VyT3BlbjogZmFsc2UsXG4gICAgICB1cHBlcjogW1tdXSxcbiAgICAgIHVwcGVyT3BlbjogZmFsc2VcbiAgfTtcblxuICBmdW5jdGlvbiB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09IFwic3RyaW5nXCIgJiYgIS9cXC4vLnRlc3Qoa2V5UGF0aClcbiAgICAgICAgICA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgaWYgKG9ialtrZXlQYXRoXSA9PT0gdW5kZWZpbmVkICYmIChrZXlQYXRoIGluIG9iaikpIHtcbiAgICAgICAgICAgICAgICAgIG9iaiA9IGRlZXBDbG9uZShvYmopO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXlQYXRoXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgIH1cbiAgICAgICAgICA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iajsgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEVudGl0eSgpIHtcbiAgICAgIHRocm93IGV4Y2VwdGlvbnMuVHlwZShcIkVudGl0eSBpbnN0YW5jZXMgbXVzdCBuZXZlciBiZSBuZXc6ZWQuIEluc3RhbmNlcyBhcmUgZ2VuZXJhdGVkIGJ5IHRoZSBmcmFtZXdvcmsgYnlwYXNzaW5nIHRoZSBjb25zdHJ1Y3Rvci5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBjbXAoYSwgYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgdGEgPSB0eXBlKGEpO1xuICAgICAgICAgIHZhciB0YiA9IHR5cGUoYik7XG4gICAgICAgICAgaWYgKHRhICE9PSB0Yikge1xuICAgICAgICAgICAgICBpZiAodGEgPT09ICdBcnJheScpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgaWYgKHRiID09PSAnQXJyYXknKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICBpZiAodGEgPT09ICdiaW5hcnknKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgIGlmICh0YiA9PT0gJ2JpbmFyeScpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgIGlmICh0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgaWYgKHRiID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgaWYgKHRhID09PSAnRGF0ZScpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgaWYgKHRiICE9PSAnRGF0ZScpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodGEpIHtcbiAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG4gICAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlVWludDhBcnJheXMoZ2V0VWludDhBcnJheShhKSwgZ2V0VWludDhBcnJheShiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVBcnJheXMoYSwgYik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgIHJldHVybiBOYU47XG4gIH1cbiAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgICB2YXIgYWwgPSBhLmxlbmd0aDtcbiAgICAgIHZhciBibCA9IGIubGVuZ3RoO1xuICAgICAgdmFyIGwgPSBhbCA8IGJsID8gYWwgOiBibDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IGNtcChhW2ldLCBiW2ldKTtcbiAgICAgICAgICBpZiAocmVzICE9PSAwKVxuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsID09PSBibCA/IDAgOiBhbCA8IGJsID8gLTEgOiAxO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBhcmVVaW50OEFycmF5cyhhLCBiKSB7XG4gICAgICB2YXIgYWwgPSBhLmxlbmd0aDtcbiAgICAgIHZhciBibCA9IGIubGVuZ3RoO1xuICAgICAgdmFyIGwgPSBhbCA8IGJsID8gYWwgOiBibDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgIHJldHVybiBhW2ldIDwgYltpXSA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbCA9PT0gYmwgPyAwIDogYWwgPCBibCA/IC0xIDogMTtcbiAgfVxuICBmdW5jdGlvbiB0eXBlKHgpIHtcbiAgICAgIHZhciB0ID0gdHlwZW9mIHg7XG4gICAgICBpZiAodCAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHgpKVxuICAgICAgICAgIHJldHVybiAnYmluYXJ5JztcbiAgICAgIHZhciB0c1RhZyA9IHRvU3RyaW5nVGFnKHgpO1xuICAgICAgcmV0dXJuIHRzVGFnID09PSAnQXJyYXlCdWZmZXInID8gJ2JpbmFyeScgOiB0c1RhZztcbiAgfVxuICBmdW5jdGlvbiBnZXRVaW50OEFycmF5KGEpIHtcbiAgICAgIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkpXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSk7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsdEluRGVsZXRpb25UcmlnZ2VyKHRhYmxlLCBrZXlzLCByZXMpIHtcbiAgICAgIHZhciB5UHJvcHMgPSB0YWJsZS5zY2hlbWEueVByb3BzO1xuICAgICAgaWYgKCF5UHJvcHMpXG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIGlmIChrZXlzICYmIHJlcy5udW1GYWlsdXJlcyA+IDApXG4gICAgICAgICAga2V5cyA9IGtleXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiAhcmVzLmZhaWx1cmVzW2ldOyB9KTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh5UHJvcHMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgIHZhciB1cGRhdGVzVGFibGUgPSBfYS51cGRhdGVzVGFibGU7XG4gICAgICAgICAgcmV0dXJuIGtleXNcbiAgICAgICAgICAgICAgPyB0YWJsZS5kYi50YWJsZSh1cGRhdGVzVGFibGUpLndoZXJlKCdrJykuYW55T2Yoa2V5cykuZGVsZXRlKClcbiAgICAgICAgICAgICAgOiB0YWJsZS5kYi50YWJsZSh1cGRhdGVzVGFibGUpLmNsZWFyKCk7XG4gICAgICB9KSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXM7IH0pO1xuICB9XG5cbiAgdmFyIFByb3BNb2RpZmljYXRpb24gPSAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFByb3BNb2RpZmljYXRpb24oc3BlYykge1xuICAgICAgICAgIHRoaXNbXCJAQHByb3Btb2RcIl0gPSBzcGVjO1xuICAgICAgfVxuICAgICAgUHJvcE1vZGlmaWNhdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICB2YXIgc3BlYyA9IHRoaXNbXCJAQHByb3Btb2RcIl07XG4gICAgICAgICAgaWYgKHNwZWMuYWRkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHRlcm0gPSBzcGVjLmFkZDtcbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkodGVybSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIChpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10pLCB0cnVlKSwgdGVybSwgdHJ1ZSkuc29ydCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVybSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gKE51bWJlcih2YWx1ZSkgfHwgMCkgKyB0ZXJtO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlcm0gPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpICsgdGVybTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQoMCkgKyB0ZXJtO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRlcm0gXCIuY29uY2F0KHRlcm0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNwZWMucmVtb3ZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHN1YnRyYWhlbmRfMSA9IHNwZWMucmVtb3ZlO1xuICAgICAgICAgICAgICBpZiAoaXNBcnJheShzdWJ0cmFoZW5kXzEpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICFzdWJ0cmFoZW5kXzEuaW5jbHVkZXMoaXRlbSk7IH0pLnNvcnQoKSA6IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3VidHJhaGVuZF8xID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpIC0gc3VidHJhaGVuZF8xO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHN1YnRyYWhlbmRfMSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkgLSBzdWJ0cmFoZW5kXzE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXRjaCAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KDApIC0gc3VidHJhaGVuZF8xO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHN1YnRyYWhlbmQgXCIuY29uY2F0KHN1YnRyYWhlbmRfMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJlZml4VG9SZXBsYWNlID0gKF9hID0gc3BlYy5yZXBsYWNlUHJlZml4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF07XG4gICAgICAgICAgaWYgKHByZWZpeFRvUmVwbGFjZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnN0YXJ0c1dpdGgocHJlZml4VG9SZXBsYWNlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc3BlYy5yZXBsYWNlUHJlZml4WzFdICsgdmFsdWUuc3Vic3RyaW5nKHByZWZpeFRvUmVwbGFjZS5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFByb3BNb2RpZmljYXRpb247XG4gIH0oKSk7XG5cbiAgZnVuY3Rpb24gYXBwbHlVcGRhdGVTcGVjKG9iaiwgY2hhbmdlcykge1xuICAgICAgdmFyIGtleVBhdGhzID0ga2V5cyhjaGFuZ2VzKTtcbiAgICAgIHZhciBudW1LZXlzID0ga2V5UGF0aHMubGVuZ3RoO1xuICAgICAgdmFyIGFueXRoaW5nTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgICAgICAgdmFyIGtleVBhdGggPSBrZXlQYXRoc1tpXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjaGFuZ2VzW2tleVBhdGhdO1xuICAgICAgICAgIHZhciBvcmlnVmFsdWUgPSBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoKTtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9wTW9kaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlLmV4ZWN1dGUob3JpZ1ZhbHVlKSk7XG4gICAgICAgICAgICAgIGFueXRoaW5nTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChvcmlnVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgYW55dGhpbmdNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFueXRoaW5nTW9kaWZpZWQ7XG4gIH1cblxuICB2YXIgVGFibGUgPSAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRhYmxlKCkge1xuICAgICAgfVxuICAgICAgVGFibGUucHJvdG90eXBlLl90cmFucyA9IGZ1bmN0aW9uIChtb2RlLCBmbiwgd3JpdGVMb2NrZWQpIHtcbiAgICAgICAgICB2YXIgdHJhbnMgPSB0aGlzLl90eCB8fCBQU0QudHJhbnM7XG4gICAgICAgICAgdmFyIHRhYmxlTmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgICB2YXIgdGFzayA9IGRlYnVnICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmNyZWF0ZVRhc2sgJiYgY29uc29sZS5jcmVhdGVUYXNrKFwiRGV4aWU6IFwiLmNvbmNhdChtb2RlID09PSAncmVhZG9ubHknID8gJ3JlYWQnIDogJ3dyaXRlJywgXCIgXCIpLmNvbmNhdCh0aGlzLm5hbWUpKTtcbiAgICAgICAgICBmdW5jdGlvbiBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKSB7XG4gICAgICAgICAgICAgIGlmICghdHJhbnMuc2NoZW1hW3RhYmxlTmFtZV0pXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Ob3RGb3VuZChcIlRhYmxlIFwiICsgdGFibGVOYW1lICsgXCIgbm90IHBhcnQgb2YgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgIHJldHVybiBmbih0cmFucy5pZGJ0cmFucywgdHJhbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIHAgPSB0cmFucyAmJiB0cmFucy5kYi5fbm92aXAgPT09IHRoaXMuZGIuX25vdmlwID9cbiAgICAgICAgICAgICAgICAgIHRyYW5zID09PSBQU0QudHJhbnMgP1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLl9wcm9taXNlKG1vZGUsIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uLCB3cml0ZUxvY2tlZCkgOlxuICAgICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zLl9wcm9taXNlKG1vZGUsIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uLCB3cml0ZUxvY2tlZCk7IH0sIHsgdHJhbnM6IHRyYW5zLCB0cmFuc2xlc3M6IFBTRC50cmFuc2xlc3MgfHwgUFNEIH0pIDpcbiAgICAgICAgICAgICAgICAgIHRlbXBUcmFuc2FjdGlvbih0aGlzLmRiLCBtb2RlLCBbdGhpcy5uYW1lXSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgICAgcC5fY29uc29sZVRhc2sgPSB0YXNrO1xuICAgICAgICAgICAgICAgICAgcCA9IHAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGVycik7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmICh3YXNSb290RXhlYylcbiAgICAgICAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5T3JDcml0LCBjYikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKGtleU9yQ3JpdCAmJiBrZXlPckNyaXQuY29uc3RydWN0b3IgPT09IE9iamVjdClcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoa2V5T3JDcml0KS5maXJzdChjYik7XG4gICAgICAgICAgaWYgKGtleU9yQ3JpdCA9PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlR5cGUoXCJJbnZhbGlkIGFyZ3VtZW50IHRvIFRhYmxlLmdldCgpXCIpKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWRvbmx5JywgZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLmdldCh7IHRyYW5zOiB0cmFucywga2V5OiBrZXlPckNyaXQgfSlcbiAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIF90aGlzLmhvb2sucmVhZGluZy5maXJlKHJlcyk7IH0pO1xuICAgICAgICAgIH0pLnRoZW4oY2IpO1xuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uIChpbmRleE9yQ3JpdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhPckNyaXQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgaW5kZXhPckNyaXQpO1xuICAgICAgICAgIGlmIChpc0FycmF5KGluZGV4T3JDcml0KSlcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIFwiW1wiLmNvbmNhdChpbmRleE9yQ3JpdC5qb2luKCcrJyksIFwiXVwiKSk7XG4gICAgICAgICAgdmFyIGtleVBhdGhzID0ga2V5cyhpbmRleE9yQ3JpdCk7XG4gICAgICAgICAgaWYgKGtleVBhdGhzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICAgIC53aGVyZShrZXlQYXRoc1swXSlcbiAgICAgICAgICAgICAgICAgIC5lcXVhbHMoaW5kZXhPckNyaXRba2V5UGF0aHNbMF1dKTtcbiAgICAgICAgICB2YXIgY29tcG91bmRJbmRleCA9IHRoaXMuc2NoZW1hLmluZGV4ZXMuY29uY2F0KHRoaXMuc2NoZW1hLnByaW1LZXkpLmZpbHRlcihmdW5jdGlvbiAoaXgpIHtcbiAgICAgICAgICAgICAgaWYgKGl4LmNvbXBvdW5kICYmXG4gICAgICAgICAgICAgICAgICBrZXlQYXRocy5ldmVyeShmdW5jdGlvbiAoa2V5UGF0aCkgeyByZXR1cm4gaXgua2V5UGF0aC5pbmRleE9mKGtleVBhdGgpID49IDA7IH0pKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleVBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVBhdGhzLmluZGV4T2YoaXgua2V5UGF0aFtpXSkgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5rZXlQYXRoLmxlbmd0aCAtIGIua2V5UGF0aC5sZW5ndGg7IH0pWzBdO1xuICAgICAgICAgIGlmIChjb21wb3VuZEluZGV4ICYmIHRoaXMuZGIuX21heEtleSAhPT0gbWF4U3RyaW5nKSB7XG4gICAgICAgICAgICAgIHZhciBrZXlQYXRoc0luVmFsaWRPcmRlciA9IGNvbXBvdW5kSW5kZXgua2V5UGF0aC5zbGljZSgwLCBrZXlQYXRocy5sZW5ndGgpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgICAgLndoZXJlKGtleVBhdGhzSW5WYWxpZE9yZGVyKVxuICAgICAgICAgICAgICAgICAgLmVxdWFscyhrZXlQYXRoc0luVmFsaWRPcmRlci5tYXAoZnVuY3Rpb24gKGtwKSB7IHJldHVybiBpbmRleE9yQ3JpdFtrcF07IH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb21wb3VuZEluZGV4ICYmIGRlYnVnKVxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgcXVlcnkgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGluZGV4T3JDcml0KSwgXCIgb24gXCIpLmNvbmNhdCh0aGlzLm5hbWUsIFwiIHdvdWxkIGJlbmVmaXQgZnJvbSBhIFwiKSArXG4gICAgICAgICAgICAgICAgICBcImNvbXBvdW5kIGluZGV4IFtcIi5jb25jYXQoa2V5UGF0aHMuam9pbignKycpLCBcIl1cIikpO1xuICAgICAgICAgIHZhciBpZHhCeU5hbWUgPSB0aGlzLnNjaGVtYS5pZHhCeU5hbWU7XG4gICAgICAgICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNtcChhLCBiKSA9PT0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9hID0ga2V5UGF0aHMucmVkdWNlKGZ1bmN0aW9uIChfYSwga2V5UGF0aCkge1xuICAgICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gX2FbMF0sIHByZXZGaWx0ZXJGbiA9IF9hWzFdO1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBpZHhCeU5hbWVba2V5UGF0aF07XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluZGV4T3JDcml0W2tleVBhdGhdO1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgcHJldkluZGV4IHx8IGluZGV4LFxuICAgICAgICAgICAgICAgICAgcHJldkluZGV4IHx8ICFpbmRleCA/XG4gICAgICAgICAgICAgICAgICAgICAgY29tYmluZShwcmV2RmlsdGVyRm4sIGluZGV4ICYmIGluZGV4Lm11bHRpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wID0gZ2V0QnlLZXlQYXRoKHgsIGtleVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkocHJvcCkgJiYgcHJvcC5zb21lKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBlcXVhbHModmFsdWUsIGl0ZW0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBlcXVhbHModmFsdWUsIGdldEJ5S2V5UGF0aCh4LCBrZXlQYXRoKSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBwcmV2RmlsdGVyRm5cbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICB9LCBbbnVsbCwgbnVsbF0pLCBpZHggPSBfYVswXSwgZmlsdGVyRnVuY3Rpb24gPSBfYVsxXTtcbiAgICAgICAgICByZXR1cm4gaWR4ID9cbiAgICAgICAgICAgICAgdGhpcy53aGVyZShpZHgubmFtZSkuZXF1YWxzKGluZGV4T3JDcml0W2lkeC5rZXlQYXRoXSlcbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZmlsdGVyRnVuY3Rpb24pIDpcbiAgICAgICAgICAgICAgY29tcG91bmRJbmRleCA/XG4gICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcihmaWx0ZXJGdW5jdGlvbikgOlxuICAgICAgICAgICAgICAgICAgdGhpcy53aGVyZShrZXlQYXRocykuZXF1YWxzKCcnKTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuYW5kKGZpbHRlckZ1bmN0aW9uKTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAodGhlblNob3J0Y3V0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuY291bnQodGhlblNob3J0Y3V0KTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLm9mZnNldChvZmZzZXQpO1xuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS5saW1pdCA9IGZ1bmN0aW9uIChudW1Sb3dzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkubGltaXQobnVtUm93cyk7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5lYWNoKGNhbGxiYWNrKTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICh0aGVuU2hvcnRjdXQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS50b0FycmF5KHRoZW5TaG9ydGN1dCk7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLnRvQ29sbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuQ29sbGVjdGlvbihuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzKSk7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLm9yZGVyQnkgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuQ29sbGVjdGlvbihuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBpc0FycmF5KGluZGV4KSA/XG4gICAgICAgICAgICAgIFwiW1wiLmNvbmNhdChpbmRleC5qb2luKCcrJyksIFwiXVwiKSA6XG4gICAgICAgICAgICAgIGluZGV4KSk7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS5tYXBUb0NsYXNzID0gZnVuY3Rpb24gKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgdmFyIF9hID0gdGhpcywgZGIgPSBfYS5kYiwgdGFibGVOYW1lID0gX2EubmFtZTtcbiAgICAgICAgICB0aGlzLnNjaGVtYS5tYXBwZWRDbGFzcyA9IGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmIChjb25zdHJ1Y3Rvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBFbnRpdHkpIHtcbiAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSAgKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwiZGJcIiwge1xuICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGI7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGFibGVOYW1lOyB9O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgICAgICAgICAgIH0oY29uc3RydWN0b3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluaGVyaXRlZFByb3BzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGZvciAodmFyIHByb3RvID0gY29uc3RydWN0b3IucHJvdG90eXBlOyBwcm90bzsgcHJvdG8gPSBnZXRQcm90byhwcm90bykpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7IHJldHVybiBpbmhlcml0ZWRQcm9wcy5hZGQocHJvcE5hbWUpOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlYWRIb29rID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICBpZiAoIW9iailcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgIGZvciAodmFyIG0gaW4gb2JqKVxuICAgICAgICAgICAgICAgICAgaWYgKCFpbmhlcml0ZWRQcm9wcy5oYXMobSkpXG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW21dID0gb2JqW21dO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAodGhpcy5zY2hlbWEucmVhZEhvb2spIHtcbiAgICAgICAgICAgICAgdGhpcy5ob29rLnJlYWRpbmcudW5zdWJzY3JpYmUodGhpcy5zY2hlbWEucmVhZEhvb2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNjaGVtYS5yZWFkSG9vayA9IHJlYWRIb29rO1xuICAgICAgICAgIHRoaXMuaG9vayhcInJlYWRpbmdcIiwgcmVhZEhvb2spO1xuICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUuZGVmaW5lQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZnVuY3Rpb24gQ2xhc3MoY29udGVudCkge1xuICAgICAgICAgICAgICBleHRlbmQodGhpcywgY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLm1hcFRvQ2xhc3MoQ2xhc3MpO1xuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBfYSA9IHRoaXMuc2NoZW1hLnByaW1LZXksIGF1dG8gPSBfYS5hdXRvLCBrZXlQYXRoID0gX2Eua2V5UGF0aDtcbiAgICAgICAgICB2YXIgb2JqVG9BZGQgPSBvYmo7XG4gICAgICAgICAgaWYgKGtleVBhdGggJiYgYXV0bykge1xuICAgICAgICAgICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2FkZCcsIGtleXM6IGtleSAhPSBudWxsID8gW2tleV0gOiBudWxsLCB2YWx1ZXM6IFtvYmpUb0FkZF0gfSk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdDsgfSlcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxhc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgaWYgKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgbGFzdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLnVwc2VydCA9IGZ1bmN0aW9uIChrZXksIG1vZGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBrZXlQYXRoID0gdGhpcy5zY2hlbWEucHJpbUtleS5rZXlQYXRoO1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLmdldCh7IHRyYW5zOiB0cmFucywga2V5OiBrZXkgfSkudGhlbihmdW5jdGlvbiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBleGlzdGluZyAhPT0gbnVsbCAmJiBleGlzdGluZyAhPT0gdm9pZCAwID8gZXhpc3RpbmcgOiB7fTtcbiAgICAgICAgICAgICAgICAgIGFwcGx5VXBkYXRlU3BlYyhvYmosIG1vZGlmaWNhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwga2V5KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwdXQnLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogW29ial0sXG4gICAgICAgICAgICAgICAgICAgICAga2V5czogW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgdXBzZXJ0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXM6IHsga2V5czogW2tleV0sIGNoYW5nZVNwZWNzOiBbbW9kaWZpY2F0aW9uc10gfVxuICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiAhIWV4aXN0aW5nOyB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChrZXlPck9iamVjdCwgbW9kaWZpY2F0aW9ucykge1xuICAgICAgICAgIGlmICh0eXBlb2Yga2V5T3JPYmplY3QgPT09ICdvYmplY3QnICYmICFpc0FycmF5KGtleU9yT2JqZWN0KSkge1xuICAgICAgICAgICAgICB2YXIga2V5ID0gZ2V0QnlLZXlQYXRoKGtleU9yT2JqZWN0LCB0aGlzLnNjaGVtYS5wcmltS2V5LmtleVBhdGgpO1xuICAgICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkdpdmVuIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGl0cyBwcmltYXJ5IGtleVwiKSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlKFwiOmlkXCIpLmVxdWFscyhrZXkpLm1vZGlmeShtb2RpZmljYXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlKFwiOmlkXCIpLmVxdWFscyhrZXlPck9iamVjdCkubW9kaWZ5KG1vZGlmaWNhdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgX2EgPSB0aGlzLnNjaGVtYS5wcmltS2V5LCBhdXRvID0gX2EuYXV0bywga2V5UGF0aCA9IF9hLmtleVBhdGg7XG4gICAgICAgICAgdmFyIG9ialRvQWRkID0gb2JqO1xuICAgICAgICAgIGlmIChrZXlQYXRoICYmIGF1dG8pIHtcbiAgICAgICAgICAgICAgb2JqVG9BZGQgPSB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKShvYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdwdXQnLCB2YWx1ZXM6IFtvYmpUb0FkZF0sIGtleXM6IGtleSAhPSBudWxsID8gW2tleV0gOiBudWxsIH0pOyB9KVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdDsgfSlcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxhc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgaWYgKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgbGFzdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7IHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2RlbGV0ZScsIGtleXM6IFtrZXldIH0pXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIGJ1aWx0SW5EZWxldGlvblRyaWdnZXIoX3RoaXMsIFtrZXldLCByZXMpOyB9KVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiB1bmRlZmluZWQ7IH0pOyB9KTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdkZWxldGVSYW5nZScsIHJhbmdlOiBBbnlSYW5nZSB9KVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiBidWlsdEluRGVsZXRpb25UcmlnZ2VyKF90aGlzLCBudWxsLCByZXMpOyB9KTsgfSlcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLm51bUZhaWx1cmVzID8gRGV4aWVQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogdW5kZWZpbmVkOyB9KTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa0dldCA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWRvbmx5JywgZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLmdldE1hbnkoe1xuICAgICAgICAgICAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFuc1xuICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5tYXAoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gX3RoaXMuaG9vay5yZWFkaW5nLmZpcmUocmVzKTsgfSk7IH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS5idWxrQWRkID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleXNPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBrZXlzID0gQXJyYXkuaXNBcnJheShrZXlzT3JPcHRpb25zKSA/IGtleXNPck9wdGlvbnMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgKGtleXMgPyB1bmRlZmluZWQgOiBrZXlzT3JPcHRpb25zKTtcbiAgICAgICAgICB2YXIgd2FudFJlc3VsdHMgPSBvcHRpb25zID8gb3B0aW9ucy5hbGxLZXlzIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnNjaGVtYS5wcmltS2V5LCBhdXRvID0gX2EuYXV0bywga2V5UGF0aCA9IF9hLmtleVBhdGg7XG4gICAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJidWxrQWRkKCk6IGtleXMgYXJndW1lbnQgaW52YWxpZCBvbiB0YWJsZXMgd2l0aCBpbmJvdW5kIGtleXNcIik7XG4gICAgICAgICAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgICAgICAgIHZhciBudW1PYmplY3RzID0gb2JqZWN0cy5sZW5ndGg7XG4gICAgICAgICAgICAgIHZhciBvYmplY3RzVG9BZGQgPSBrZXlQYXRoICYmIGF1dG8gP1xuICAgICAgICAgICAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgICAgICAgICAgIG9iamVjdHM7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2FkZCcsIGtleXM6IGtleXMsIHZhbHVlczogb2JqZWN0c1RvQWRkLCB3YW50UmVzdWx0czogd2FudFJlc3VsdHMgfSlcbiAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG51bUZhaWx1cmVzID0gX2EubnVtRmFpbHVyZXMsIHJlc3VsdHMgPSBfYS5yZXN1bHRzLCBsYXN0UmVzdWx0ID0gX2EubGFzdFJlc3VsdCwgZmFpbHVyZXMgPSBfYS5mYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB3YW50UmVzdWx0cyA/IHJlc3VsdHMgOiBsYXN0UmVzdWx0O1xuICAgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLmJ1bGtBZGQoKTogXCIpLmNvbmNhdChudW1GYWlsdXJlcywgXCIgb2YgXCIpLmNvbmNhdChudW1PYmplY3RzLCBcIiBvcGVyYXRpb25zIGZhaWxlZFwiKSwgZmFpbHVyZXMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa1B1dCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXlzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5c09yT3B0aW9ucykgPyBrZXlzT3JPcHRpb25zIDogdW5kZWZpbmVkO1xuICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyk7XG4gICAgICAgICAgdmFyIHdhbnRSZXN1bHRzID0gb3B0aW9ucyA/IG9wdGlvbnMuYWxsS2V5cyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zY2hlbWEucHJpbUtleSwgYXV0byA9IF9hLmF1dG8sIGtleVBhdGggPSBfYS5rZXlQYXRoO1xuICAgICAgICAgICAgICBpZiAoa2V5UGF0aCAmJiBrZXlzKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiYnVsa1B1dCgpOiBrZXlzIGFyZ3VtZW50IGludmFsaWQgb24gdGFibGVzIHdpdGggaW5ib3VuZCBrZXlzXCIpO1xuICAgICAgICAgICAgICBpZiAoa2V5cyAmJiBrZXlzLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJBcmd1bWVudHMgb2JqZWN0cyBhbmQga2V5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgICB2YXIgbnVtT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuICAgICAgICAgICAgICB2YXIgb2JqZWN0c1RvUHV0ID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgICAgICAgICAgIG9iamVjdHMubWFwKHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKSA6XG4gICAgICAgICAgICAgICAgICBvYmplY3RzO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdwdXQnLCBrZXlzOiBrZXlzLCB2YWx1ZXM6IG9iamVjdHNUb1B1dCwgd2FudFJlc3VsdHM6IHdhbnRSZXN1bHRzIH0pXG4gICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBudW1GYWlsdXJlcyA9IF9hLm51bUZhaWx1cmVzLCByZXN1bHRzID0gX2EucmVzdWx0cywgbGFzdFJlc3VsdCA9IF9hLmxhc3RSZXN1bHQsIGZhaWx1cmVzID0gX2EuZmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gd2FudFJlc3VsdHMgPyByZXN1bHRzIDogbGFzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi5idWxrUHV0KCk6IFwiKS5jb25jYXQobnVtRmFpbHVyZXMsIFwiIG9mIFwiKS5jb25jYXQobnVtT2JqZWN0cywgXCIgb3BlcmF0aW9ucyBmYWlsZWRcIiksIGZhaWx1cmVzKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLmJ1bGtVcGRhdGUgPSBmdW5jdGlvbiAoa2V5c0FuZENoYW5nZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBjb3JlVGFibGUgPSB0aGlzLmNvcmU7XG4gICAgICAgICAgdmFyIGtleXMgPSBrZXlzQW5kQ2hhbmdlcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS5rZXk7IH0pO1xuICAgICAgICAgIHZhciBjaGFuZ2VTcGVjcyA9IGtleXNBbmRDaGFuZ2VzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LmNoYW5nZXM7IH0pO1xuICAgICAgICAgIHZhciBvZmZzZXRNYXAgPSBbXTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgICByZXR1cm4gY29yZVRhYmxlLmdldE1hbnkoeyB0cmFuczogdHJhbnMsIGtleXM6IGtleXMsIGNhY2hlOiAnY2xvbmUnIH0pLnRoZW4oZnVuY3Rpb24gKG9ianMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRLZXlzID0gW107XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0T2JqcyA9IFtdO1xuICAgICAgICAgICAgICAgICAga2V5c0FuZENoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYS5rZXksIGNoYW5nZXMgPSBfYS5jaGFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBvYmpzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IF9iW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNoYW5nZXNba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aCA9PT0gX3RoaXMuc2NoZW1hLnByaW1LZXkua2V5UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbXAodmFsdWUsIGtleSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuQ29uc3RyYWludChcIkNhbm5vdCB1cGRhdGUgcHJpbWFyeSBrZXkgaW4gYnVsa1VwZGF0ZSgpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRNYXAucHVzaChpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0T2Jqcy5wdXNoKG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB2YXIgbnVtRW50cmllcyA9IHJlc3VsdEtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZVxuICAgICAgICAgICAgICAgICAgICAgIC5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICBrZXlzOiByZXN1bHRLZXlzLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogcmVzdWx0T2JqcyxcbiAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVNwZWNzOiBjaGFuZ2VTcGVjc1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG51bUZhaWx1cmVzID0gX2EubnVtRmFpbHVyZXMsIGZhaWx1cmVzID0gX2EuZmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtRW50cmllcztcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gT2JqZWN0LmtleXMoZmFpbHVyZXMpOyBfaSA8IF9iLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX2JbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFwcGVkT2Zmc2V0ID0gb2Zmc2V0TWFwW051bWJlcihvZmZzZXQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHBlZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZSA9IGZhaWx1cmVzW29mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZmFpbHVyZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzW21hcHBlZE9mZnNldF0gPSBmYWlsdXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCIuYnVsa1VwZGF0ZSgpOiBcIikuY29uY2F0KG51bUZhaWx1cmVzLCBcIiBvZiBcIikuY29uY2F0KG51bUVudHJpZXMsIFwiIG9wZXJhdGlvbnMgZmFpbGVkXCIpLCBmYWlsdXJlcyk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLmJ1bGtEZWxldGUgPSBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdkZWxldGUnLCBrZXlzOiBrZXlzIH0pXG4gICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiBidWlsdEluRGVsZXRpb25UcmlnZ2VyKF90aGlzLCBrZXlzLCByZXMpOyB9KTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgbGFzdFJlc3VsdCA9IF9hLmxhc3RSZXN1bHQsIGZhaWx1cmVzID0gX2EuZmFpbHVyZXM7XG4gICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLmJ1bGtEZWxldGUoKTogXCIpLmNvbmNhdChudW1GYWlsdXJlcywgXCIgb2YgXCIpLmNvbmNhdChudW1LZXlzLCBcIiBvcGVyYXRpb25zIGZhaWxlZFwiKSwgZmFpbHVyZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBUYWJsZTtcbiAgfSgpKTtcblxuICBmdW5jdGlvbiBFdmVudHMoY3R4KSB7XG4gICAgICB2YXIgZXZzID0ge307XG4gICAgICB2YXIgcnYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgICAgICAgICAgICAgd2hpbGUgKC0taSlcbiAgICAgICAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICBldnNbZXZlbnROYW1lXS5zdWJzY3JpYmUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV2c1tldmVudE5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBydi5hZGRFdmVudFR5cGUgPSBhZGQ7XG4gICAgICBmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICBhZGQoYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydjtcbiAgICAgIGZ1bmN0aW9uIGFkZChldmVudE5hbWUsIGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbikge1xuICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgcmV0dXJuIGFkZENvbmZpZ3VyZWRFdmVudHMoZXZlbnROYW1lKTtcbiAgICAgICAgICBpZiAoIWNoYWluRnVuY3Rpb24pXG4gICAgICAgICAgICAgIGNoYWluRnVuY3Rpb24gPSByZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbjtcbiAgICAgICAgICBpZiAoIWRlZmF1bHRGdW5jdGlvbilcbiAgICAgICAgICAgICAgZGVmYXVsdEZ1bmN0aW9uID0gbm9wO1xuICAgICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgICAgICAgIGZpcmU6IGRlZmF1bHRGdW5jdGlvbixcbiAgICAgICAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN1YnNjcmliZXJzLmluZGV4T2YoY2IpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMucHVzaChjYik7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maXJlID0gY2hhaW5GdW5jdGlvbihjb250ZXh0LmZpcmUsIGNiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycyA9IGNvbnRleHQuc3Vic2NyaWJlcnMuZmlsdGVyKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4gIT09IGNiOyB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyZSA9IGNvbnRleHQuc3Vic2NyaWJlcnMucmVkdWNlKGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGV2c1tldmVudE5hbWVdID0gcnZbZXZlbnROYW1lXSA9IGNvbnRleHQ7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhZGRDb25maWd1cmVkRXZlbnRzKGNmZykge1xuICAgICAgICAgIGtleXMoY2ZnKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBjZmdbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgICAgICAgICAgIGFkZChldmVudE5hbWUsIGNmZ1tldmVudE5hbWVdWzBdLCBjZmdbZXZlbnROYW1lXVsxXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYXJncyA9PT0gJ2FzYXAnKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGFkZChldmVudE5hbWUsIG1pcnJvciwgZnVuY3Rpb24gZmlyZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFzYXAkMShmdW5jdGlvbiBmaXJlRXZlbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJJbnZhbGlkIGV2ZW50IGNvbmZpZ1wiKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VDbGFzc0NvbnN0cnVjdG9yKHByb3RvdHlwZSwgY29uc3RydWN0b3IpIHtcbiAgICAgIGRlcml2ZShjb25zdHJ1Y3RvcikuZnJvbSh7IHByb3RvdHlwZTogcHJvdG90eXBlIH0pO1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGFibGVDb25zdHJ1Y3RvcihkYikge1xuICAgICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFRhYmxlLnByb3RvdHlwZSwgZnVuY3Rpb24gVGFibGUobmFtZSwgdGFibGVTY2hlbWEsIHRyYW5zKSB7XG4gICAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICAgIHRoaXMuX3R4ID0gdHJhbnM7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnNjaGVtYSA9IHRhYmxlU2NoZW1hO1xuICAgICAgICAgIHRoaXMuaG9vayA9IGRiLl9hbGxUYWJsZXNbbmFtZV0gPyBkYi5fYWxsVGFibGVzW25hbWVdLmhvb2sgOiBFdmVudHMobnVsbCwge1xuICAgICAgICAgICAgICBcImNyZWF0aW5nXCI6IFtob29rQ3JlYXRpbmdDaGFpbiwgbm9wXSxcbiAgICAgICAgICAgICAgXCJyZWFkaW5nXCI6IFtwdXJlRnVuY3Rpb25DaGFpbiwgbWlycm9yXSxcbiAgICAgICAgICAgICAgXCJ1cGRhdGluZ1wiOiBbaG9va1VwZGF0aW5nQ2hhaW4sIG5vcF0sXG4gICAgICAgICAgICAgIFwiZGVsZXRpbmdcIjogW2hvb2tEZWxldGluZ0NoYWluLCBub3BdXG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGxhaW5LZXlSYW5nZShjdHgsIGlnbm9yZUxpbWl0RmlsdGVyKSB7XG4gICAgICByZXR1cm4gIShjdHguZmlsdGVyIHx8IGN0eC5hbGdvcml0aG0gfHwgY3R4Lm9yKSAmJlxuICAgICAgICAgIChpZ25vcmVMaW1pdEZpbHRlciA/IGN0eC5qdXN0TGltaXQgOiAhY3R4LnJlcGxheUZpbHRlcik7XG4gIH1cbiAgZnVuY3Rpb24gYWRkRmlsdGVyKGN0eCwgZm4pIHtcbiAgICAgIGN0eC5maWx0ZXIgPSBjb21iaW5lKGN0eC5maWx0ZXIsIGZuKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRSZXBsYXlGaWx0ZXIoY3R4LCBmYWN0b3J5LCBpc0xpbWl0RmlsdGVyKSB7XG4gICAgICB2YXIgY3VyciA9IGN0eC5yZXBsYXlGaWx0ZXI7XG4gICAgICBjdHgucmVwbGF5RmlsdGVyID0gY3VyciA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbWJpbmUoY3VycigpLCBmYWN0b3J5KCkpOyB9IDogZmFjdG9yeTtcbiAgICAgIGN0eC5qdXN0TGltaXQgPSBpc0xpbWl0RmlsdGVyICYmICFjdXJyO1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hdGNoRmlsdGVyKGN0eCwgZm4pIHtcbiAgICAgIGN0eC5pc01hdGNoID0gY29tYmluZShjdHguaXNNYXRjaCwgZm4pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVTY2hlbWEpIHtcbiAgICAgIGlmIChjdHguaXNQcmltS2V5KVxuICAgICAgICAgIHJldHVybiBjb3JlU2NoZW1hLnByaW1hcnlLZXk7XG4gICAgICB2YXIgaW5kZXggPSBjb3JlU2NoZW1hLmdldEluZGV4QnlLZXlQYXRoKGN0eC5pbmRleCk7XG4gICAgICBpZiAoIWluZGV4KVxuICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIktleVBhdGggXCIgKyBjdHguaW5kZXggKyBcIiBvbiBvYmplY3Qgc3RvcmUgXCIgKyBjb3JlU2NoZW1hLm5hbWUgKyBcIiBpcyBub3QgaW5kZXhlZFwiKTtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgfVxuICBmdW5jdGlvbiBvcGVuQ3Vyc29yKGN0eCwgY29yZVRhYmxlLCB0cmFucykge1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY29yZVRhYmxlLnNjaGVtYSk7XG4gICAgICByZXR1cm4gY29yZVRhYmxlLm9wZW5DdXJzb3Ioe1xuICAgICAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgICAgICB2YWx1ZXM6ICFjdHgua2V5c09ubHksXG4gICAgICAgICAgcmV2ZXJzZTogY3R4LmRpciA9PT0gJ3ByZXYnLFxuICAgICAgICAgIHVuaXF1ZTogISFjdHgudW5pcXVlLFxuICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGl0ZXIoY3R4LCBmbiwgY29yZVRyYW5zLCBjb3JlVGFibGUpIHtcbiAgICAgIHZhciBmaWx0ZXIgPSBjdHgucmVwbGF5RmlsdGVyID8gY29tYmluZShjdHguZmlsdGVyLCBjdHgucmVwbGF5RmlsdGVyKCkpIDogY3R4LmZpbHRlcjtcbiAgICAgIGlmICghY3R4Lm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGUob3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgY29yZVRyYW5zKSwgY29tYmluZShjdHguYWxnb3JpdGhtLCBmaWx0ZXIpLCBmbiwgIWN0eC5rZXlzT25seSAmJiBjdHgudmFsdWVNYXBwZXIpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHNldF8xID0ge307XG4gICAgICAgICAgdmFyIHVuaW9uID0gZnVuY3Rpb24gKGl0ZW0sIGN1cnNvciwgYWR2YW5jZSkge1xuICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoY3Vyc29yLCBhZHZhbmNlLCBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBjdXJzb3Iuc3RvcChyZXN1bHQpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBjdXJzb3IuZmFpbChlcnIpOyB9KSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBjdXJzb3IucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSAnJyArIHByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKVxuICAgICAgICAgICAgICAgICAgICAgIGtleSA9ICcnICsgbmV3IFVpbnQ4QXJyYXkocHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIWhhc093bihzZXRfMSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHNldF8xW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIGZuKGl0ZW0sIGN1cnNvciwgYWR2YW5jZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgIGN0eC5vci5faXRlcmF0ZSh1bmlvbiwgY29yZVRyYW5zKSxcbiAgICAgICAgICAgICAgaXRlcmF0ZShvcGVuQ3Vyc29yKGN0eCwgY29yZVRhYmxlLCBjb3JlVHJhbnMpLCBjdHguYWxnb3JpdGhtLCB1bmlvbiwgIWN0eC5rZXlzT25seSAmJiBjdHgudmFsdWVNYXBwZXIpXG4gICAgICAgICAgXSk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXRlcmF0ZShjdXJzb3JQcm9taXNlLCBmaWx0ZXIsIGZuLCB2YWx1ZU1hcHBlcikge1xuICAgICAgdmFyIG1hcHBlZEZuID0gdmFsdWVNYXBwZXIgPyBmdW5jdGlvbiAoeCwgYywgYSkgeyByZXR1cm4gZm4odmFsdWVNYXBwZXIoeCksIGMsIGEpOyB9IDogZm47XG4gICAgICB2YXIgd3JhcHBlZEZuID0gd3JhcChtYXBwZWRGbik7XG4gICAgICByZXR1cm4gY3Vyc29yUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjdXJzb3Iuc3RhcnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJzb3IuY29udGludWUoKTsgfTtcbiAgICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihjdXJzb3IsIGZ1bmN0aW9uIChhZHZhbmNlcikgeyByZXR1cm4gYyA9IGFkdmFuY2VyOyB9LCBmdW5jdGlvbiAodmFsKSB7IGN1cnNvci5zdG9wKHZhbCk7IGMgPSBub3A7IH0sIGZ1bmN0aW9uIChlKSB7IGN1cnNvci5mYWlsKGUpOyBjID0gbm9wOyB9KSlcbiAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRm4oY3Vyc29yLnZhbHVlLCBjdXJzb3IsIGZ1bmN0aW9uIChhZHZhbmNlcikgeyByZXR1cm4gYyA9IGFkdmFuY2VyOyB9KTtcbiAgICAgICAgICAgICAgICAgIGMoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICB2YXIgQ29sbGVjdGlvbiA9ICAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29sbGVjdGlvbigpIHtcbiAgICAgIH1cbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKGZuLCBjYikge1xuICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgcmV0dXJuIGN0eC5lcnJvciA/XG4gICAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMobnVsbCwgcmVqZWN0aW9uLmJpbmQobnVsbCwgY3R4LmVycm9yKSkgOlxuICAgICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKCdyZWFkb25seScsIGZuKS50aGVuKGNiKTtcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgIHJldHVybiBjdHguZXJyb3IgP1xuICAgICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKG51bGwsIHJlamVjdGlvbi5iaW5kKG51bGwsIGN0eC5lcnJvcikpIDpcbiAgICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucygncmVhZHdyaXRlJywgZm4sIFwibG9ja2VkXCIpO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl9hZGRBbGdvcml0aG0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgIGN0eC5hbGdvcml0aG0gPSBjb21iaW5lKGN0eC5hbGdvcml0aG0sIGZuKTtcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgY29yZVRyYW5zKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXIodGhpcy5fY3R4LCBmbiwgY29yZVRyYW5zLCB0aGlzLl9jdHgudGFibGUuY29yZSk7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICB2YXIgcnYgPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKSwgY3R4ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLl9jdHgpO1xuICAgICAgICAgIGlmIChwcm9wcylcbiAgICAgICAgICAgICAgZXh0ZW5kKGN0eCwgcHJvcHMpO1xuICAgICAgICAgIHJ2Ll9jdHggPSBjdHg7XG4gICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9jdHgudmFsdWVNYXBwZXIgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gaXRlcihjdHgsIGZuLCB0cmFucywgY3R4LnRhYmxlLmNvcmUpOyB9KTtcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgIHZhciBjdHggPSBfdGhpcy5fY3R4O1xuICAgICAgICAgICAgICB2YXIgY29yZVRhYmxlID0gY3R4LnRhYmxlLmNvcmU7XG4gICAgICAgICAgICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5jb3VudCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlVGFibGUuc2NoZW1hKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvdW50KSB7IHJldHVybiBNYXRoLm1pbihjb3VudCwgY3R4LmxpbWl0KTsgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCBmdW5jdGlvbiAoKSB7ICsrY291bnQ7IHJldHVybiBmYWxzZTsgfSwgdHJhbnMsIGNvcmVUYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjb3VudDsgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS50aGVuKGNiKTtcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbiAoa2V5UGF0aCwgY2IpIHtcbiAgICAgICAgICB2YXIgcGFydHMgPSBrZXlQYXRoLnNwbGl0KCcuJykucmV2ZXJzZSgpLCBsYXN0UGFydCA9IHBhcnRzWzBdLCBsYXN0SW5kZXggPSBwYXJ0cy5sZW5ndGggLSAxO1xuICAgICAgICAgIGZ1bmN0aW9uIGdldHZhbChvYmosIGkpIHtcbiAgICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dmFsKG9ialtwYXJ0c1tpXV0sIGkgLSAxKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9ialtsYXN0UGFydF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvcmRlciA9IHRoaXMuX2N0eC5kaXIgPT09IFwibmV4dFwiID8gMSA6IC0xO1xuICAgICAgICAgIGZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gICAgICAgICAgICAgIHZhciBhVmFsID0gZ2V0dmFsKGEsIGxhc3RJbmRleCksIGJWYWwgPSBnZXR2YWwoYiwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNtcChhVmFsLCBiVmFsKSAqIG9yZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5KGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLnNvcnQoc29ydGVyKTtcbiAgICAgICAgICB9KS50aGVuKGNiKTtcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgdmFyIGN0eCA9IF90aGlzLl9jdHg7XG4gICAgICAgICAgICAgIGlmIChjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlTWFwcGVyXzEgPSBjdHgudmFsdWVNYXBwZXI7XG4gICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjdHgudGFibGUuY29yZS5zY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgbGltaXQ6IGN0eC5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2EucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZU1hcHBlcl8xID8gcmVzdWx0Lm1hcCh2YWx1ZU1hcHBlcl8xKSA6IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGFfMSA9IFtdO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gYV8xLnB1c2goaXRlbSk7IH0sIHRyYW5zLCBjdHgudGFibGUuY29yZSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBhXzE7IH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSwgY2IpO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgIGlmIChvZmZzZXQgPD0gMClcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgY3R4Lm9mZnNldCArPSBvZmZzZXQ7XG4gICAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgpKSB7XG4gICAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLS1vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZShvZmZzZXRMZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBhZGRSZXBsYXlGaWx0ZXIoY3R4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiAoLS1vZmZzZXRMZWZ0IDwgMCk7IH07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5saW1pdCA9IGZ1bmN0aW9uIChudW1Sb3dzKSB7XG4gICAgICAgICAgdGhpcy5fY3R4LmxpbWl0ID0gTWF0aC5taW4odGhpcy5fY3R4LmxpbWl0LCBudW1Sb3dzKTtcbiAgICAgICAgICBhZGRSZXBsYXlGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciByb3dzTGVmdCA9IG51bVJvd3M7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoLS1yb3dzTGVmdCA8PSAwKVxuICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcm93c0xlZnQgPj0gMDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS51bnRpbCA9IGZ1bmN0aW9uIChmaWx0ZXJGdW5jdGlvbiwgYkluY2x1ZGVTdG9wRW50cnkpIHtcbiAgICAgICAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgIGlmIChmaWx0ZXJGdW5jdGlvbihjdXJzb3IudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGJJbmNsdWRlU3RvcEVudHJ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5maXJzdCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3QoY2IpO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXJGdW5jdGlvbikge1xuICAgICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlckZ1bmN0aW9uKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWRkTWF0Y2hGaWx0ZXIodGhpcy5fY3R4LCBmaWx0ZXJGdW5jdGlvbik7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmaWx0ZXIpO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKGluZGV4TmFtZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLl9jdHgudGFibGUsIGluZGV4TmFtZSwgdGhpcyk7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9jdHguZGlyID0gKHRoaXMuX2N0eC5kaXIgPT09IFwicHJldlwiID8gXCJuZXh0XCIgOiBcInByZXZcIik7XG4gICAgICAgICAgaWYgKHRoaXMuX29uZGlyZWN0aW9uY2hhbmdlKVxuICAgICAgICAgICAgICB0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSh0aGlzLl9jdHguZGlyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5kZXNjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoS2V5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodmFsLCBjdXJzb3IpIHsgY2IoY3Vyc29yLmtleSwgY3Vyc29yKTsgfSk7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZWFjaFVuaXF1ZUtleSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIHRoaXMuX2N0eC51bmlxdWUgPSBcInVuaXF1ZVwiO1xuICAgICAgICAgIHJldHVybiB0aGlzLmVhY2hLZXkoY2IpO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2hQcmltYXJ5S2V5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodmFsLCBjdXJzb3IpIHsgY2IoY3Vyc29yLnByaW1hcnlLZXksIGN1cnNvcik7IH0pO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGl0ZW0sIGN1cnNvcikge1xuICAgICAgICAgICAgICBhLnB1c2goY3Vyc29yLmtleSk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgIH0pLnRoZW4oY2IpO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnByaW1hcnlLZXlzID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICBpZiAoY3R4LmRpciA9PT0gJ25leHQnICYmIGlzUGxhaW5LZXlSYW5nZShjdHgsIHRydWUpICYmIGN0eC5saW1pdCA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjdHgudGFibGUuY29yZS5zY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICBsaW1pdDogY3R4LmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9hLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH0pLnRoZW4oY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgICAgICAgICAgYS5wdXNoKGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgfSkudGhlbihjYik7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudW5pcXVlS2V5cyA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIHRoaXMuX2N0eC51bmlxdWUgPSBcInVuaXF1ZVwiO1xuICAgICAgICAgIHJldHVybiB0aGlzLmtleXMoY2IpO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmZpcnN0S2V5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGltaXQoMSkua2V5cyhmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVswXTsgfSkudGhlbihjYik7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubGFzdEtleSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maXJzdEtleShjYik7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eCwgaWR4ID0gY3R4LmluZGV4ICYmIGN0eC50YWJsZS5zY2hlbWEuaWR4QnlOYW1lW2N0eC5pbmRleF07XG4gICAgICAgICAgaWYgKCFpZHggfHwgIWlkeC5tdWx0aSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgdmFyIHNldCA9IHt9O1xuICAgICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgdmFyIHN0cktleSA9IGN1cnNvci5wcmltYXJ5S2V5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIHZhciBmb3VuZCA9IGhhc093bihzZXQsIHN0cktleSk7XG4gICAgICAgICAgICAgIHNldFtzdHJLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuICFmb3VuZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5tb2RpZnkgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGUoZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgIHZhciBtb2RpZnllcjtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICBtb2RpZnllciA9IGNoYW5nZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtb2RpZnllciA9IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBhcHBseVVwZGF0ZVNwZWMoaXRlbSwgY2hhbmdlcyk7IH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGNvcmVUYWJsZSA9IGN0eC50YWJsZS5jb3JlO1xuICAgICAgICAgICAgICB2YXIgX2EgPSBjb3JlVGFibGUuc2NoZW1hLnByaW1hcnlLZXksIG91dGJvdW5kID0gX2Eub3V0Ym91bmQsIGV4dHJhY3RLZXkgPSBfYS5leHRyYWN0S2V5O1xuICAgICAgICAgICAgICB2YXIgbGltaXQgPSAyMDA7XG4gICAgICAgICAgICAgIHZhciBtb2RpZnlDaHVua1NpemUgPSBfdGhpcy5kYi5fb3B0aW9ucy5tb2RpZnlDaHVua1NpemU7XG4gICAgICAgICAgICAgIGlmIChtb2RpZnlDaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZ5Q2h1bmtTaXplID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGltaXQgPSBtb2RpZnlDaHVua1NpemVbY29yZVRhYmxlLm5hbWVdIHx8IG1vZGlmeUNodW5rU2l6ZVsnKiddIHx8IDIwMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGxpbWl0ID0gbW9kaWZ5Q2h1bmtTaXplO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciB0b3RhbEZhaWx1cmVzID0gW107XG4gICAgICAgICAgICAgIHZhciBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgICAgICAgICB2YXIgZmFpbGVkS2V5cyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgYXBwbHlNdXRhdGVSZXN1bHQgPSBmdW5jdGlvbiAoZXhwZWN0ZWRDb3VudCwgcmVzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZXMgPSByZXMuZmFpbHVyZXMsIG51bUZhaWx1cmVzID0gcmVzLm51bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50ICs9IGV4cGVjdGVkQ291bnQgLSBudW1GYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBrZXlzKGZhaWx1cmVzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsRmFpbHVyZXMucHVzaChmYWlsdXJlc1twb3NdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIGlzVW5jb25kaXRpb25hbERlbGV0ZSA9IGNoYW5nZXMgPT09IGRlbGV0ZUNhbGxiYWNrO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY2xvbmUoKS5wcmltYXJ5S2V5cygpLnRoZW4oZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjcml0ZXJpYSA9IGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbWl0ID09PSBJbmZpbml0eSAmJlxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgY2hhbmdlcyAhPT0gJ2Z1bmN0aW9uJyB8fCBpc1VuY29uZGl0aW9uYWxEZWxldGUpICYmIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY3R4LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB2YXIgbmV4dENodW5rID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IE1hdGgubWluKGxpbWl0LCBrZXlzLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXNJbkNodW5rID0ga2V5cy5zbGljZShvZmZzZXQsIG9mZnNldCArIGNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGlzVW5jb25kaXRpb25hbERlbGV0ZSA/IFByb21pc2UucmVzb2x2ZShbXSkgOiBjb3JlVGFibGUuZ2V0TWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czoga2V5c0luQ2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBcImltbXV0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkVmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdXRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB1dEtleXMgPSBvdXRib3VuZCA/IFtdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZUtleXMgPSBpc1VuY29uZGl0aW9uYWxEZWxldGUgPyBrZXlzSW5DaHVuayA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVW5jb25kaXRpb25hbERlbGV0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnVmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0eF8xID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGVlcENsb25lKG9yaWdWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1LZXk6IGtleXNbb2Zmc2V0ICsgaV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZnllci5jYWxsKGN0eF8xLCBjdHhfMS52YWx1ZSwgY3R4XzEpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4XzEudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5wdXNoKGtleXNbb2Zmc2V0ICsgaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFvdXRib3VuZCAmJiBjbXAoZXh0cmFjdEtleShvcmlnVmFsdWUpLCBleHRyYWN0S2V5KGN0eF8xLnZhbHVlKSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMucHVzaChrZXlzW29mZnNldCArIGldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFZhbHVlcy5wdXNoKGN0eF8xLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhbHVlcy5wdXNoKGN0eF8xLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRib3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRLZXlzLnB1c2goa2V5c1tvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWRkVmFsdWVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdhZGQnLCB2YWx1ZXM6IGFkZFZhbHVlcyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwb3MgaW4gcmVzLmZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMuc3BsaWNlKHBhcnNlSW50KHBvcyksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseU11dGF0ZVJlc3VsdChhZGRWYWx1ZXMubGVuZ3RoLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gKHB1dFZhbHVlcy5sZW5ndGggPiAwIHx8IChjcml0ZXJpYSAmJiB0eXBlb2YgY2hhbmdlcyA9PT0gJ29iamVjdCcpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IHB1dEtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBwdXRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JpdGVyaWE6IGNyaXRlcmlhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVNwZWM6IHR5cGVvZiBjaGFuZ2VzICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBZGRpdGlvbmFsQ2h1bms6IG9mZnNldCA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gYXBwbHlNdXRhdGVSZXN1bHQocHV0VmFsdWVzLmxlbmd0aCwgcmVzKTsgfSk7IH0pLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gKGRlbGV0ZUtleXMubGVuZ3RoID4gMCB8fCAoY3JpdGVyaWEgJiYgaXNVbmNvbmRpdGlvbmFsRGVsZXRlKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBkZWxldGVLZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyaXRlcmlhOiBjcml0ZXJpYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FkZGl0aW9uYWxDaHVuazogb2Zmc2V0ID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiBidWlsdEluRGVsZXRpb25UcmlnZ2VyKGN0eC50YWJsZSwgZGVsZXRlS2V5cywgcmVzKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiBhcHBseU11dGF0ZVJlc3VsdChkZWxldGVLZXlzLmxlbmd0aCwgcmVzKTsgfSk7IH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoID4gb2Zmc2V0ICsgY291bnQgJiYgbmV4dENodW5rKG9mZnNldCArIGxpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDaHVuaygwKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxGYWlsdXJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTW9kaWZ5RXJyb3IoXCJFcnJvciBtb2RpZnlpbmcgb25lIG9yIG1vcmUgb2JqZWN0c1wiLCB0b3RhbEZhaWx1cmVzLCBzdWNjZXNzQ291bnQsIGZhaWxlZEtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eCwgcmFuZ2UgPSBjdHgucmFuZ2U7XG4gICAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG4gICAgICAgICAgICAgICFjdHgudGFibGUuc2NoZW1hLnlQcm9wcyAmJlxuICAgICAgICAgICAgICAoY3R4LmlzUHJpbUtleSB8fCByYW5nZS50eXBlID09PSAzICkpXG4gICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlKGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBjdHgudGFibGUuY29yZS5zY2hlbWEucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgIHZhciBjb3JlUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5jb3VudCh7IHRyYW5zOiB0cmFucywgcXVlcnk6IHsgaW5kZXg6IHByaW1hcnlLZXksIHJhbmdlOiBjb3JlUmFuZ2UgfSB9KS50aGVuKGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdkZWxldGVSYW5nZScsIHJhbmdlOiBjb3JlUmFuZ2UgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzLCBudW1GYWlsdXJlcyA9IF9hLm51bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTW9kaWZ5RXJyb3IoXCJDb3VsZCBub3QgZGVsZXRlIHNvbWUgdmFsdWVzXCIsIE9iamVjdC5rZXlzKGZhaWx1cmVzKS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gZmFpbHVyZXNbcG9zXTsgfSksIGNvdW50IC0gbnVtRmFpbHVyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnQgLSBudW1GYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMubW9kaWZ5KGRlbGV0ZUNhbGxiYWNrKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29sbGVjdGlvbjtcbiAgfSgpKTtcbiAgdmFyIGRlbGV0ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbHVlLCBjdHgpIHsgcmV0dXJuIGN0eC52YWx1ZSA9IG51bGw7IH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbkNvbnN0cnVjdG9yKGRiKSB7XG4gICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoQ29sbGVjdGlvbi5wcm90b3R5cGUsIGZ1bmN0aW9uIENvbGxlY3Rpb24od2hlcmVDbGF1c2UsIGtleVJhbmdlR2VuZXJhdG9yKSB7XG4gICAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICAgIHZhciBrZXlSYW5nZSA9IEFueVJhbmdlLCBlcnJvciA9IG51bGw7XG4gICAgICAgICAgaWYgKGtleVJhbmdlR2VuZXJhdG9yKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAga2V5UmFuZ2UgPSBrZXlSYW5nZUdlbmVyYXRvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIHZhciB3aGVyZUN0eCA9IHdoZXJlQ2xhdXNlLl9jdHg7XG4gICAgICAgICAgdmFyIHRhYmxlID0gd2hlcmVDdHgudGFibGU7XG4gICAgICAgICAgdmFyIHJlYWRpbmdIb29rID0gdGFibGUuaG9vay5yZWFkaW5nLmZpcmU7XG4gICAgICAgICAgdGhpcy5fY3R4ID0ge1xuICAgICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICAgIGluZGV4OiB3aGVyZUN0eC5pbmRleCxcbiAgICAgICAgICAgICAgaXNQcmltS2V5OiAoIXdoZXJlQ3R4LmluZGV4IHx8ICh0YWJsZS5zY2hlbWEucHJpbUtleS5rZXlQYXRoICYmIHdoZXJlQ3R4LmluZGV4ID09PSB0YWJsZS5zY2hlbWEucHJpbUtleS5uYW1lKSksXG4gICAgICAgICAgICAgIHJhbmdlOiBrZXlSYW5nZSxcbiAgICAgICAgICAgICAga2V5c09ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICBkaXI6IFwibmV4dFwiLFxuICAgICAgICAgICAgICB1bmlxdWU6IFwiXCIsXG4gICAgICAgICAgICAgIGFsZ29yaXRobTogbnVsbCxcbiAgICAgICAgICAgICAgZmlsdGVyOiBudWxsLFxuICAgICAgICAgICAgICByZXBsYXlGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICAgIGp1c3RMaW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgaXNNYXRjaDogbnVsbCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICBsaW1pdDogSW5maW5pdHksXG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgb3I6IHdoZXJlQ3R4Lm9yLFxuICAgICAgICAgICAgICB2YWx1ZU1hcHBlcjogcmVhZGluZ0hvb2sgIT09IG1pcnJvciA/IHJlYWRpbmdIb29rIDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpbXBsZUNvbXBhcmUoYSwgYikge1xuICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG4gIH1cbiAgZnVuY3Rpb24gc2ltcGxlQ29tcGFyZVJldmVyc2UoYSwgYikge1xuICAgICAgcmV0dXJuIGEgPiBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG4gIH1cblxuICBmdW5jdGlvbiBmYWlsKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlLCBlcnIsIFQpIHtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UgaW5zdGFuY2VvZiBXaGVyZUNsYXVzZSA/XG4gICAgICAgICAgbmV3IGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlLkNvbGxlY3Rpb24oY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UpIDpcbiAgICAgICAgICBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZTtcbiAgICAgIGNvbGxlY3Rpb24uX2N0eC5lcnJvciA9IFQgPyBuZXcgVChlcnIpIDogbmV3IFR5cGVFcnJvcihlcnIpO1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH1cbiAgZnVuY3Rpb24gZW1wdHlDb2xsZWN0aW9uKHdoZXJlQ2xhdXNlKSB7XG4gICAgICByZXR1cm4gbmV3IHdoZXJlQ2xhdXNlLkNvbGxlY3Rpb24od2hlcmVDbGF1c2UsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhbmdlRXF1YWwoXCJcIik7IH0pLmxpbWl0KDApO1xuICB9XG4gIGZ1bmN0aW9uIHVwcGVyRmFjdG9yeShkaXIpIHtcbiAgICAgIHJldHVybiBkaXIgPT09IFwibmV4dFwiID9cbiAgICAgICAgICBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b1VwcGVyQ2FzZSgpOyB9IDpcbiAgICAgICAgICBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b0xvd2VyQ2FzZSgpOyB9O1xuICB9XG4gIGZ1bmN0aW9uIGxvd2VyRmFjdG9yeShkaXIpIHtcbiAgICAgIHJldHVybiBkaXIgPT09IFwibmV4dFwiID9cbiAgICAgICAgICBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b0xvd2VyQ2FzZSgpOyB9IDpcbiAgICAgICAgICBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b1VwcGVyQ2FzZSgpOyB9O1xuICB9XG4gIGZ1bmN0aW9uIG5leHRDYXNpbmcoa2V5LCBsb3dlcktleSwgdXBwZXJOZWVkbGUsIGxvd2VyTmVlZGxlLCBjbXAsIGRpcikge1xuICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGtleS5sZW5ndGgsIGxvd2VyTmVlZGxlLmxlbmd0aCk7XG4gICAgICB2YXIgbGxwID0gLTE7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGx3cktleUNoYXIgPSBsb3dlcktleVtpXTtcbiAgICAgICAgICBpZiAobHdyS2V5Q2hhciAhPT0gbG93ZXJOZWVkbGVbaV0pIHtcbiAgICAgICAgICAgICAgaWYgKGNtcChrZXlbaV0sIHVwcGVyTmVlZGxlW2ldKSA8IDApXG4gICAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBpKSArIHVwcGVyTmVlZGxlW2ldICsgdXBwZXJOZWVkbGUuc3Vic3RyKGkgKyAxKTtcbiAgICAgICAgICAgICAgaWYgKGNtcChrZXlbaV0sIGxvd2VyTmVlZGxlW2ldKSA8IDApXG4gICAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBpKSArIGxvd2VyTmVlZGxlW2ldICsgdXBwZXJOZWVkbGUuc3Vic3RyKGkgKyAxKTtcbiAgICAgICAgICAgICAgaWYgKGxscCA+PSAwKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgbGxwKSArIGxvd2VyS2V5W2xscF0gKyB1cHBlck5lZWRsZS5zdWJzdHIobGxwICsgMSk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY21wKGtleVtpXSwgbHdyS2V5Q2hhcikgPCAwKVxuICAgICAgICAgICAgICBsbHAgPSBpO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA8IGxvd2VyTmVlZGxlLmxlbmd0aCAmJiBkaXIgPT09IFwibmV4dFwiKVxuICAgICAgICAgIHJldHVybiBrZXkgKyB1cHBlck5lZWRsZS5zdWJzdHIoa2V5Lmxlbmd0aCk7XG4gICAgICBpZiAobGVuZ3RoIDwga2V5Lmxlbmd0aCAmJiBkaXIgPT09IFwicHJldlwiKVxuICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIHVwcGVyTmVlZGxlLmxlbmd0aCk7XG4gICAgICByZXR1cm4gKGxscCA8IDAgPyBudWxsIDoga2V5LnN1YnN0cigwLCBsbHApICsgbG93ZXJOZWVkbGVbbGxwXSArIHVwcGVyTmVlZGxlLnN1YnN0cihsbHAgKyAxKSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh3aGVyZUNsYXVzZSwgbWF0Y2gsIG5lZWRsZXMsIHN1ZmZpeCkge1xuICAgICAgdmFyIHVwcGVyLCBsb3dlciwgY29tcGFyZSwgdXBwZXJOZWVkbGVzLCBsb3dlck5lZWRsZXMsIGRpcmVjdGlvbiwgbmV4dEtleVN1ZmZpeCwgbmVlZGxlc0xlbiA9IG5lZWRsZXMubGVuZ3RoO1xuICAgICAgaWYgKCFuZWVkbGVzLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZyc7IH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhaWwod2hlcmVDbGF1c2UsIFNUUklOR19FWFBFQ1RFRCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpbml0RGlyZWN0aW9uKGRpcikge1xuICAgICAgICAgIHVwcGVyID0gdXBwZXJGYWN0b3J5KGRpcik7XG4gICAgICAgICAgbG93ZXIgPSBsb3dlckZhY3RvcnkoZGlyKTtcbiAgICAgICAgICBjb21wYXJlID0gKGRpciA9PT0gXCJuZXh0XCIgPyBzaW1wbGVDb21wYXJlIDogc2ltcGxlQ29tcGFyZVJldmVyc2UpO1xuICAgICAgICAgIHZhciBuZWVkbGVCb3VuZHMgPSBuZWVkbGVzLm1hcChmdW5jdGlvbiAobmVlZGxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGxvd2VyOiBsb3dlcihuZWVkbGUpLCB1cHBlcjogdXBwZXIobmVlZGxlKSB9O1xuICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoYS5sb3dlciwgYi5sb3dlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdXBwZXJOZWVkbGVzID0gbmVlZGxlQm91bmRzLm1hcChmdW5jdGlvbiAobmIpIHsgcmV0dXJuIG5iLnVwcGVyOyB9KTtcbiAgICAgICAgICBsb3dlck5lZWRsZXMgPSBuZWVkbGVCb3VuZHMubWFwKGZ1bmN0aW9uIChuYikgeyByZXR1cm4gbmIubG93ZXI7IH0pO1xuICAgICAgICAgIGRpcmVjdGlvbiA9IGRpcjtcbiAgICAgICAgICBuZXh0S2V5U3VmZml4ID0gKGRpciA9PT0gXCJuZXh0XCIgPyBcIlwiIDogc3VmZml4KTtcbiAgICAgIH1cbiAgICAgIGluaXREaXJlY3Rpb24oXCJuZXh0XCIpO1xuICAgICAgdmFyIGMgPSBuZXcgd2hlcmVDbGF1c2UuQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UodXBwZXJOZWVkbGVzWzBdLCBsb3dlck5lZWRsZXNbbmVlZGxlc0xlbiAtIDFdICsgc3VmZml4KTsgfSk7XG4gICAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICBpbml0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICB9O1xuICAgICAgdmFyIGZpcnN0UG9zc2libGVOZWVkbGUgPSAwO1xuICAgICAgYy5fYWRkQWxnb3JpdGhtKGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB2YXIgbG93ZXJLZXkgPSBsb3dlcihrZXkpO1xuICAgICAgICAgIGlmIChtYXRjaChsb3dlcktleSwgbG93ZXJOZWVkbGVzLCBmaXJzdFBvc3NpYmxlTmVlZGxlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBsb3dlc3RQb3NzaWJsZUNhc2luZyA9IG51bGw7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBmaXJzdFBvc3NpYmxlTmVlZGxlOyBpIDwgbmVlZGxlc0xlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FzaW5nID0gbmV4dENhc2luZyhrZXksIGxvd2VyS2V5LCB1cHBlck5lZWRsZXNbaV0sIGxvd2VyTmVlZGxlc1tpXSwgY29tcGFyZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjYXNpbmcgPT09IG51bGwgJiYgbG93ZXN0UG9zc2libGVDYXNpbmcgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgZmlyc3RQb3NzaWJsZU5lZWRsZSA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobG93ZXN0UG9zc2libGVDYXNpbmcgPT09IG51bGwgfHwgY29tcGFyZShsb3dlc3RQb3NzaWJsZUNhc2luZywgY2FzaW5nKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RQb3NzaWJsZUNhc2luZyA9IGNhc2luZztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobG93ZXN0UG9zc2libGVDYXNpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkgeyBjdXJzb3IuY29udGludWUobG93ZXN0UG9zc2libGVDYXNpbmcgKyBuZXh0S2V5U3VmZml4KTsgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGxvd2VyLCB1cHBlciwgbG93ZXJPcGVuLCB1cHBlck9wZW4pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogMiAsXG4gICAgICAgICAgbG93ZXI6IGxvd2VyLFxuICAgICAgICAgIHVwcGVyOiB1cHBlcixcbiAgICAgICAgICBsb3dlck9wZW46IGxvd2VyT3BlbixcbiAgICAgICAgICB1cHBlck9wZW46IHVwcGVyT3BlblxuICAgICAgfTtcbiAgfVxuICBmdW5jdGlvbiByYW5nZUVxdWFsKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IDEgLFxuICAgICAgICAgIGxvd2VyOiB2YWx1ZSxcbiAgICAgICAgICB1cHBlcjogdmFsdWVcbiAgICAgIH07XG4gIH1cblxuICB2YXIgV2hlcmVDbGF1c2UgPSAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFdoZXJlQ2xhdXNlKCkge1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdoZXJlQ2xhdXNlLnByb3RvdHlwZSwgXCJDb2xsZWN0aW9uXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC50YWJsZS5kYi5Db2xsZWN0aW9uO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5iZXR3ZWVuID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlciwgaW5jbHVkZUxvd2VyLCBpbmNsdWRlVXBwZXIpIHtcbiAgICAgICAgICBpbmNsdWRlTG93ZXIgPSBpbmNsdWRlTG93ZXIgIT09IGZhbHNlO1xuICAgICAgICAgIGluY2x1ZGVVcHBlciA9IGluY2x1ZGVVcHBlciA9PT0gdHJ1ZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoKHRoaXMuX2NtcChsb3dlciwgdXBwZXIpID4gMCkgfHxcbiAgICAgICAgICAgICAgICAgICh0aGlzLl9jbXAobG93ZXIsIHVwcGVyKSA9PT0gMCAmJiAoaW5jbHVkZUxvd2VyIHx8IGluY2x1ZGVVcHBlcikgJiYgIShpbmNsdWRlTG93ZXIgJiYgaW5jbHVkZVVwcGVyKSkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZShsb3dlciwgdXBwZXIsICFpbmNsdWRlTG93ZXIsICFpbmNsdWRlVXBwZXIpOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiByYW5nZUVxdWFsKHZhbHVlKTsgfSk7XG4gICAgICB9O1xuICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmFib3ZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZSh2YWx1ZSwgdW5kZWZpbmVkLCB0cnVlKTsgfSk7XG4gICAgICB9O1xuICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmFib3ZlT3JFcXVhbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UodmFsdWUsIHVuZGVmaW5lZCwgZmFsc2UpOyB9KTtcbiAgICAgIH07XG4gICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYmVsb3cgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHVuZGVmaW5lZCwgdmFsdWUsIGZhbHNlLCB0cnVlKTsgfSk7XG4gICAgICB9O1xuICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmJlbG93T3JFcXVhbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UodW5kZWZpbmVkLCB2YWx1ZSk7IH0pO1xuICAgICAgfTtcbiAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5zdGFydHNXaXRoID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgU1RSSU5HX0VYUEVDVEVEKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iZXR3ZWVuKHN0ciwgc3RyICsgbWF4U3RyaW5nLCB0cnVlLCB0cnVlKTtcbiAgICAgIH07XG4gICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuc3RhcnRzV2l0aElnbm9yZUNhc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgaWYgKHN0ciA9PT0gXCJcIilcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRzV2l0aChzdHIpO1xuICAgICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsIGZ1bmN0aW9uICh4LCBhKSB7IHJldHVybiB4LmluZGV4T2YoYVswXSkgPT09IDA7IH0sIFtzdHJdLCBtYXhTdHJpbmcpO1xuICAgICAgfTtcbiAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5lcXVhbHNJZ25vcmVDYXNlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsIGZ1bmN0aW9uICh4LCBhKSB7IHJldHVybiB4ID09PSBhWzBdOyB9LCBbc3RyXSwgXCJcIik7XG4gICAgICB9O1xuICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmFueU9mSWdub3JlQ2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsIGZ1bmN0aW9uICh4LCBhKSB7IHJldHVybiBhLmluZGV4T2YoeCkgIT09IC0xOyB9LCBzZXQsIFwiXCIpO1xuICAgICAgfTtcbiAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5zdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgZnVuY3Rpb24gKHgsIGEpIHsgcmV0dXJuIGEuc29tZShmdW5jdGlvbiAobikgeyByZXR1cm4geC5pbmRleE9mKG4pID09PSAwOyB9KTsgfSwgc2V0LCBtYXhTdHJpbmcpO1xuICAgICAgfTtcbiAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5hbnlPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jbXA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc2V0LnNvcnQoY29tcGFyZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgdmFyIGMgPSBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHNldFswXSwgc2V0W3NldC5sZW5ndGggLSAxXSk7IH0pO1xuICAgICAgICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICBjb21wYXJlID0gKGRpcmVjdGlvbiA9PT0gXCJuZXh0XCIgP1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX2FzY2VuZGluZyA6XG4gICAgICAgICAgICAgICAgICBfdGhpcy5fZGVzY2VuZGluZyk7XG4gICAgICAgICAgICAgIHNldC5zb3J0KGNvbXBhcmUpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZShrZXksIHNldFtpXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb21wYXJlKGtleSwgc2V0W2ldKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhZHZhbmNlKGZ1bmN0aW9uICgpIHsgY3Vyc29yLmNvbnRpbnVlKHNldFtpXSk7IH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9O1xuICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLm5vdEVxdWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShbW21pbktleSwgdmFsdWVdLCBbdmFsdWUsIHRoaXMuZGIuX21heEtleV1dLCB7IGluY2x1ZGVMb3dlcnM6IGZhbHNlLCBpbmNsdWRlVXBwZXJzOiBmYWxzZSB9KTtcbiAgICAgIH07XG4gICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUubm9uZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHNldC5zb3J0KHRoaXMuX2FzY2VuZGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJhbmdlcyA9IHNldC5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgdmFsKSB7IHJldHVybiByZXMgP1xuICAgICAgICAgICAgICByZXMuY29uY2F0KFtbcmVzW3Jlcy5sZW5ndGggLSAxXVsxXSwgdmFsXV0pIDpcbiAgICAgICAgICAgICAgW1ttaW5LZXksIHZhbF1dOyB9LCBudWxsKTtcbiAgICAgICAgICByYW5nZXMucHVzaChbc2V0W3NldC5sZW5ndGggLSAxXSwgdGhpcy5kYi5fbWF4S2V5XSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShyYW5nZXMsIHsgaW5jbHVkZUxvd2VyczogZmFsc2UsIGluY2x1ZGVVcHBlcnM6IGZhbHNlIH0pO1xuICAgICAgfTtcbiAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5pbkFueVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlcywgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGNtcCA9IHRoaXMuX2NtcCwgYXNjZW5kaW5nID0gdGhpcy5fYXNjZW5kaW5nLCBkZXNjZW5kaW5nID0gdGhpcy5fZGVzY2VuZGluZywgbWluID0gdGhpcy5fbWluLCBtYXggPSB0aGlzLl9tYXg7XG4gICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgaWYgKCFyYW5nZXMuZXZlcnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiByYW5nZVswXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICByYW5nZVsxXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICBhc2NlbmRpbmcocmFuZ2VbMF0sIHJhbmdlWzFdKSA8PSAwO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwiRmlyc3QgYXJndW1lbnQgdG8gaW5BbnlSYW5nZSgpIG11c3QgYmUgYW4gQXJyYXkgb2YgdHdvLXZhbHVlIEFycmF5cyBbbG93ZXIsdXBwZXJdIHdoZXJlIHVwcGVyIG11c3Qgbm90IGJlIGxvd2VyIHRoYW4gbG93ZXJcIiwgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5jbHVkZUxvd2VycyA9ICFvcHRpb25zIHx8IG9wdGlvbnMuaW5jbHVkZUxvd2VycyAhPT0gZmFsc2U7XG4gICAgICAgICAgdmFyIGluY2x1ZGVVcHBlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZVVwcGVycyA9PT0gdHJ1ZTtcbiAgICAgICAgICBmdW5jdGlvbiBhZGRSYW5nZShyYW5nZXMsIG5ld1JhbmdlKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gMCwgbCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICBpZiAoY21wKG5ld1JhbmdlWzBdLCByYW5nZVsxXSkgPCAwICYmIGNtcChuZXdSYW5nZVsxXSwgcmFuZ2VbMF0pID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJhbmdlWzBdID0gbWluKHJhbmdlWzBdLCBuZXdSYW5nZVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMV0gPSBtYXgocmFuZ2VbMV0sIG5ld1JhbmdlWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaSA9PT0gbClcbiAgICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ld1JhbmdlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNvcnREaXJlY3Rpb24gPSBhc2NlbmRpbmc7XG4gICAgICAgICAgZnVuY3Rpb24gcmFuZ2VTb3J0ZXIoYSwgYikgeyByZXR1cm4gc29ydERpcmVjdGlvbihhWzBdLCBiWzBdKTsgfVxuICAgICAgICAgIHZhciBzZXQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc2V0ID0gcmFuZ2VzLnJlZHVjZShhZGRSYW5nZSwgW10pO1xuICAgICAgICAgICAgICBzZXQuc29ydChyYW5nZVNvcnRlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByYW5nZVBvcyA9IDA7XG4gICAgICAgICAgdmFyIGtleUlzQmV5b25kQ3VycmVudEVudHJ5ID0gaW5jbHVkZVVwcGVycyA/XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMV0pID4gMDsgfSA6XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMV0pID49IDA7IH07XG4gICAgICAgICAgdmFyIGtleUlzQmVmb3JlQ3VycmVudEVudHJ5ID0gaW5jbHVkZUxvd2VycyA/XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGRlc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA+IDA7IH0gOlxuICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkZXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPj0gMDsgfTtcbiAgICAgICAgICBmdW5jdGlvbiBrZXlXaXRoaW5DdXJyZW50UmFuZ2Uoa2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiAha2V5SXNCZXlvbmRDdXJyZW50RW50cnkoa2V5KSAmJiAha2V5SXNCZWZvcmVDdXJyZW50RW50cnkoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNoZWNrS2V5ID0ga2V5SXNCZXlvbmRDdXJyZW50RW50cnk7XG4gICAgICAgICAgdmFyIGMgPSBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHNldFswXVswXSwgc2V0W3NldC5sZW5ndGggLSAxXVsxXSwgIWluY2x1ZGVMb3dlcnMsICFpbmNsdWRlVXBwZXJzKTsgfSk7XG4gICAgICAgICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgICAgICBjaGVja0tleSA9IGtleUlzQmV5b25kQ3VycmVudEVudHJ5O1xuICAgICAgICAgICAgICAgICAgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZWZvcmVDdXJyZW50RW50cnk7XG4gICAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uID0gZGVzY2VuZGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZXQuc29ydChyYW5nZVNvcnRlcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjLl9hZGRBbGdvcml0aG0oZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICAgICAgd2hpbGUgKGNoZWNrS2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICsrcmFuZ2VQb3M7XG4gICAgICAgICAgICAgICAgICBpZiAocmFuZ2VQb3MgPT09IHNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoa2V5V2l0aGluQ3VycmVudFJhbmdlKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLl9jbXAoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA9PT0gMCB8fCBfdGhpcy5fY21wKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3J0RGlyZWN0aW9uID09PSBhc2NlbmRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShzZXRbcmFuZ2VQb3NdWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShzZXRbcmFuZ2VQb3NdWzFdKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9O1xuICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLnN0YXJ0c1dpdGhBbnlPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmICghc2V0LmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZyc7IH0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwic3RhcnRzV2l0aEFueU9mKCkgb25seSB3b3JrcyB3aXRoIHN0cmluZ3NcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2Uoc2V0Lm1hcChmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBbc3RyLCBzdHIgKyBtYXhTdHJpbmddOyB9KSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFdoZXJlQ2xhdXNlO1xuICB9KCkpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdoZXJlQ2xhdXNlQ29uc3RydWN0b3IoZGIpIHtcbiAgICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihXaGVyZUNsYXVzZS5wcm90b3R5cGUsIGZ1bmN0aW9uIFdoZXJlQ2xhdXNlKHRhYmxlLCBpbmRleCwgb3JDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICAgIHRoaXMuX2N0eCA9IHtcbiAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgICBpbmRleDogaW5kZXggPT09IFwiOmlkXCIgPyBudWxsIDogaW5kZXgsXG4gICAgICAgICAgICAgIG9yOiBvckNvbGxlY3Rpb25cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX2NtcCA9IHRoaXMuX2FzY2VuZGluZyA9IGNtcDtcbiAgICAgICAgICB0aGlzLl9kZXNjZW5kaW5nID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNtcChiLCBhKTsgfTtcbiAgICAgICAgICB0aGlzLl9tYXggPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gY21wKGEsIGIpID4gMCA/IGEgOiBiOyB9O1xuICAgICAgICAgIHRoaXMuX21pbiA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjbXAoYSwgYikgPCAwID8gYSA6IGI7IH07XG4gICAgICAgICAgdGhpcy5fSURCS2V5UmFuZ2UgPSBkYi5fZGVwcy5JREJLZXlSYW5nZTtcbiAgICAgICAgICBpZiAoIXRoaXMuX0lEQktleVJhbmdlKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpIHtcbiAgICAgIHJldHVybiB3cmFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgdmFyIERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FID0gJ3N0b3JhZ2VtdXRhdGVkJztcbiAgdmFyIFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSA9ICd4LXN0b3JhZ2VtdXRhdGVkLTEnO1xuICB2YXIgZ2xvYmFsRXZlbnRzID0gRXZlbnRzKG51bGwsIERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FKTtcblxuICB2YXIgVHJhbnNhY3Rpb24gPSAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uKCkge1xuICAgICAgfVxuICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9sb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGFzc2VydCghUFNELmdsb2JhbCk7XG4gICAgICAgICAgKyt0aGlzLl9yZWN1bG9jaztcbiAgICAgICAgICBpZiAodGhpcy5fcmVjdWxvY2sgPT09IDEgJiYgIVBTRC5nbG9iYWwpXG4gICAgICAgICAgICAgIFBTRC5sb2NrT3duZXJGb3IgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fdW5sb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGFzc2VydCghUFNELmdsb2JhbCk7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fcmVjdWxvY2sgPT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKCFQU0QuZ2xvYmFsKVxuICAgICAgICAgICAgICAgICAgUFNELmxvY2tPd25lckZvciA9IG51bGw7XG4gICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9ibG9ja2VkRnVuY3MubGVuZ3RoID4gMCAmJiAhdGhpcy5fbG9ja2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBmbkFuZFBTRCA9IHRoaXMuX2Jsb2NrZWRGdW5jcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICB1c2VQU0QoZm5BbmRQU0RbMV0sIGZuQW5kUFNEWzBdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX2xvY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjdWxvY2sgJiYgUFNELmxvY2tPd25lckZvciAhPT0gdGhpcztcbiAgICAgIH07XG4gICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGlkYnRyYW5zKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAoIXRoaXMubW9kZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgdmFyIGlkYmRiID0gdGhpcy5kYi5pZGJkYjtcbiAgICAgICAgICB2YXIgZGJPcGVuRXJyb3IgPSB0aGlzLmRiLl9zdGF0ZS5kYk9wZW5FcnJvcjtcbiAgICAgICAgICBhc3NlcnQoIXRoaXMuaWRidHJhbnMpO1xuICAgICAgICAgIGlmICghaWRidHJhbnMgJiYgIWlkYmRiKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZGJPcGVuRXJyb3IgJiYgZGJPcGVuRXJyb3IubmFtZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIkRhdGFiYXNlQ2xvc2VkRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZChkYk9wZW5FcnJvcik7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiTWlzc2luZ0FQSUVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSShkYk9wZW5FcnJvci5tZXNzYWdlLCBkYk9wZW5FcnJvcik7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk9wZW5GYWlsZWQoZGJPcGVuRXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKTtcbiAgICAgICAgICBhc3NlcnQodGhpcy5fY29tcGxldGlvbi5fc3RhdGUgPT09IG51bGwpO1xuICAgICAgICAgIGlkYnRyYW5zID0gdGhpcy5pZGJ0cmFucyA9IGlkYnRyYW5zIHx8XG4gICAgICAgICAgICAgICh0aGlzLmRiLmNvcmVcbiAgICAgICAgICAgICAgICAgID8gdGhpcy5kYi5jb3JlLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlLCB7IGR1cmFiaWxpdHk6IHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5IH0pXG4gICAgICAgICAgICAgICAgICA6IGlkYmRiLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlLCB7IGR1cmFiaWxpdHk6IHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5IH0pKTtcbiAgICAgICAgICBpZGJ0cmFucy5vbmVycm9yID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXYpO1xuICAgICAgICAgICAgICBfdGhpcy5fcmVqZWN0KGlkYnRyYW5zLmVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZGJ0cmFucy5vbmFib3J0ID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXYpO1xuICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgJiYgX3RoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydChpZGJ0cmFucy5lcnJvcikpO1xuICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgX3RoaXMub24oXCJhYm9ydFwiKS5maXJlKGV2KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZGJ0cmFucy5vbmNvbXBsZXRlID0gd3JhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICBpZiAoJ211dGF0ZWRQYXJ0cycgaW4gaWRidHJhbnMpIHtcbiAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKGlkYnRyYW5zW1wibXV0YXRlZFBhcnRzXCJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fcHJvbWlzZSA9IGZ1bmN0aW9uIChtb2RlLCBmbiwgYldyaXRlTG9jaykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkd3JpdGUnICYmIHRoaXMubW9kZSAhPT0gJ3JlYWR3cml0ZScpXG4gICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuUmVhZE9ubHkoXCJUcmFuc2FjdGlvbiBpcyByZWFkb25seVwiKSk7XG4gICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5UcmFuc2FjdGlvbkluYWN0aXZlKCkpO1xuICAgICAgICAgIGlmICh0aGlzLl9sb2NrZWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5fYmxvY2tlZEZ1bmNzLnB1c2goW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Byb21pc2UobW9kZSwgZm4sIGJXcml0ZUxvY2spLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCBQU0RdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGJXcml0ZUxvY2spIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcnYgPSBmbihyZXNvbHZlLCByZWplY3QsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBwLmZpbmFsbHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3VubG9jaygpOyB9KTtcbiAgICAgICAgICAgICAgICAgIHAuX2xpYiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gZm4ocmVzb2x2ZSwgcmVqZWN0LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbilcbiAgICAgICAgICAgICAgICAgICAgICBydi50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBwLl9saWIgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9yb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50Ll9yb290KCkgOiB0aGlzO1xuICAgICAgfTtcbiAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS53YWl0Rm9yID0gZnVuY3Rpb24gKHByb21pc2VMaWtlKSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290KCk7XG4gICAgICAgICAgdmFyIHByb21pc2UgPSBEZXhpZVByb21pc2UucmVzb2x2ZShwcm9taXNlTGlrZSk7XG4gICAgICAgICAgaWYgKHJvb3QuX3dhaXRpbmdGb3IpIHtcbiAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IHJvb3QuX3dhaXRpbmdGb3IudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9taXNlOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSBwcm9taXNlO1xuICAgICAgICAgICAgICByb290Ll93YWl0aW5nUXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIHN0b3JlID0gcm9vdC5pZGJ0cmFucy5vYmplY3RTdG9yZShyb290LnN0b3JlTmFtZXNbMF0pO1xuICAgICAgICAgICAgICAoZnVuY3Rpb24gc3BpbigpIHtcbiAgICAgICAgICAgICAgICAgICsrcm9vdC5fc3BpbkNvdW50O1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHJvb3QuX3dhaXRpbmdRdWV1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgKHJvb3QuX3dhaXRpbmdRdWV1ZS5zaGlmdCgpKSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJvb3QuX3dhaXRpbmdGb3IpXG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0KC1JbmZpbml0eSkub25zdWNjZXNzID0gc3BpbjtcbiAgICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGN1cnJlbnRXYWl0UHJvbWlzZSA9IHJvb3QuX3dhaXRpbmdGb3I7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZXNvbHZlLmJpbmQobnVsbCwgcmVzKSkpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByb290Ll93YWl0aW5nUXVldWUucHVzaCh3cmFwKHJlamVjdC5iaW5kKG51bGwsIGVycikpKTsgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0ZvciA9PT0gY3VycmVudFdhaXRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaWRidHJhbnMpXG4gICAgICAgICAgICAgICAgICB0aGlzLmlkYnRyYW5zLmFib3J0KCk7XG4gICAgICAgICAgICAgIHRoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydCgpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgIHZhciBtZW1vaXplZFRhYmxlcyA9ICh0aGlzLl9tZW1vaXplZFRhYmxlcyB8fCAodGhpcy5fbWVtb2l6ZWRUYWJsZXMgPSB7fSkpO1xuICAgICAgICAgIGlmIChoYXNPd24obWVtb2l6ZWRUYWJsZXMsIHRhYmxlTmFtZSkpXG4gICAgICAgICAgICAgIHJldHVybiBtZW1vaXplZFRhYmxlc1t0YWJsZU5hbWVdO1xuICAgICAgICAgIHZhciB0YWJsZVNjaGVtYSA9IHRoaXMuc2NoZW1hW3RhYmxlTmFtZV07XG4gICAgICAgICAgaWYgKCF0YWJsZVNjaGVtYSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Ob3RGb3VuZChcIlRhYmxlIFwiICsgdGFibGVOYW1lICsgXCIgbm90IHBhcnQgb2YgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0cmFuc2FjdGlvbkJvdW5kVGFibGUgPSBuZXcgdGhpcy5kYi5UYWJsZSh0YWJsZU5hbWUsIHRhYmxlU2NoZW1hLCB0aGlzKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbkJvdW5kVGFibGUuY29yZSA9IHRoaXMuZGIuY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgIG1lbW9pemVkVGFibGVzW3RhYmxlTmFtZV0gPSB0cmFuc2FjdGlvbkJvdW5kVGFibGU7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uQm91bmRUYWJsZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gVHJhbnNhY3Rpb247XG4gIH0oKSk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3RvcihkYikge1xuICAgICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAobW9kZSAhPT0gJ3JlYWRvbmx5JylcbiAgICAgICAgICAgICAgc3RvcmVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgIHZhciB5UHJvcHMgPSAoX2EgPSBkYnNjaGVtYVtzdG9yZU5hbWVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EueVByb3BzO1xuICAgICAgICAgICAgICAgICAgaWYgKHlQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWVzID0gc3RvcmVOYW1lcy5jb25jYXQoeVByb3BzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC51cGRhdGVzVGFibGU7IH0pKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgICAgdGhpcy5zdG9yZU5hbWVzID0gc3RvcmVOYW1lcztcbiAgICAgICAgICB0aGlzLnNjaGVtYSA9IGRic2NoZW1hO1xuICAgICAgICAgIHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5ID0gY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5O1xuICAgICAgICAgIHRoaXMuaWRidHJhbnMgPSBudWxsO1xuICAgICAgICAgIHRoaXMub24gPSBFdmVudHModGhpcywgXCJjb21wbGV0ZVwiLCBcImVycm9yXCIsIFwiYWJvcnRcIik7XG4gICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fcmVjdWxvY2sgPSAwO1xuICAgICAgICAgIHRoaXMuX2Jsb2NrZWRGdW5jcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX3JlamVjdCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fd2FpdGluZ0ZvciA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fd2FpdGluZ1F1ZXVlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9zcGluQ291bnQgPSAwO1xuICAgICAgICAgIHRoaXMuX2NvbXBsZXRpb24gPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICBfdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX2NvbXBsZXRpb24udGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBfdGhpcy5vbi5jb21wbGV0ZS5maXJlKCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgdmFyIHdhc0FjdGl2ZSA9IF90aGlzLmFjdGl2ZTtcbiAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIF90aGlzLm9uLmVycm9yLmZpcmUoZSk7XG4gICAgICAgICAgICAgIF90aGlzLnBhcmVudCA/XG4gICAgICAgICAgICAgICAgICBfdGhpcy5wYXJlbnQuX3JlamVjdChlKSA6XG4gICAgICAgICAgICAgICAgICB3YXNBY3RpdmUgJiYgX3RoaXMuaWRidHJhbnMgJiYgX3RoaXMuaWRidHJhbnMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5kZXhTcGVjKG5hbWUsIGtleVBhdGgsIHVuaXF1ZSwgbXVsdGksIGF1dG8sIGNvbXBvdW5kLCBpc1ByaW1LZXksIHR5cGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBrZXlQYXRoOiBrZXlQYXRoLFxuICAgICAgICAgIHVuaXF1ZTogdW5pcXVlLFxuICAgICAgICAgIG11bHRpOiBtdWx0aSxcbiAgICAgICAgICBhdXRvOiBhdXRvLFxuICAgICAgICAgIGNvbXBvdW5kOiBjb21wb3VuZCxcbiAgICAgICAgICBzcmM6ICh1bmlxdWUgJiYgIWlzUHJpbUtleSA/ICcmJyA6ICcnKSArIChtdWx0aSA/ICcqJyA6ICcnKSArIChhdXRvID8gXCIrK1wiIDogXCJcIikgKyBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aCksXG4gICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcbiAgfVxuICBmdW5jdGlvbiBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAga2V5UGF0aCA6XG4gICAgICAgICAga2V5UGF0aCA/ICgnWycgKyBbXS5qb2luLmNhbGwoa2V5UGF0aCwgJysnKSArICddJykgOiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGFibGVTY2hlbWEobmFtZSwgcHJpbUtleSwgaW5kZXhlcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHByaW1LZXk6IHByaW1LZXksXG4gICAgICAgICAgaW5kZXhlczogaW5kZXhlcyxcbiAgICAgICAgICBtYXBwZWRDbGFzczogbnVsbCxcbiAgICAgICAgICBpZHhCeU5hbWU6IGFycmF5VG9PYmplY3QoaW5kZXhlcywgZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBbaW5kZXgubmFtZSwgaW5kZXhdOyB9KSxcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzYWZhcmlNdWx0aVN0b3JlRml4KHN0b3JlTmFtZXMpIHtcbiAgICAgIHJldHVybiBzdG9yZU5hbWVzLmxlbmd0aCA9PT0gMSA/IHN0b3JlTmFtZXNbMF0gOiBzdG9yZU5hbWVzO1xuICB9XG4gIHZhciBnZXRNYXhLZXkgPSBmdW5jdGlvbiAoSWRiS2V5UmFuZ2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgSWRiS2V5UmFuZ2Uub25seShbW11dKTtcbiAgICAgICAgICBnZXRNYXhLZXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbW11dOyB9O1xuICAgICAgICAgIHJldHVybiBbW11dO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICBnZXRNYXhLZXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhTdHJpbmc7IH07XG4gICAgICAgICAgcmV0dXJuIG1heFN0cmluZztcbiAgICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aCkge1xuICAgICAgaWYgKGtleVBhdGggPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0U2luZ2xlUGF0aEtleUV4dHJhY3RvcihrZXlQYXRoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoKTsgfTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTaW5nbGVQYXRoS2V5RXh0cmFjdG9yKGtleVBhdGgpIHtcbiAgICAgIHZhciBzcGxpdCA9IGtleVBhdGguc3BsaXQoJy4nKTtcbiAgICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqW2tleVBhdGhdOyB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpOyB9O1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlpZnkoYXJyYXlMaWtlKSB7XG4gICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChhcnJheUxpa2UpO1xuICB9XG4gIHZhciBfaWRfY291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIGdldEtleVBhdGhBbGlhcyhrZXlQYXRoKSB7XG4gICAgICByZXR1cm4ga2V5UGF0aCA9PSBudWxsID9cbiAgICAgICAgICBcIjppZFwiIDpcbiAgICAgICAgICB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICBrZXlQYXRoIDpcbiAgICAgICAgICAgICAgXCJbXCIuY29uY2F0KGtleVBhdGguam9pbignKycpLCBcIl1cIik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlREJDb3JlKGRiLCBJZGJLZXlSYW5nZSwgdG1wVHJhbnMpIHtcbiAgICAgIGZ1bmN0aW9uIGV4dHJhY3RTY2hlbWEoZGIsIHRyYW5zKSB7XG4gICAgICAgICAgdmFyIHRhYmxlcyA9IGFycmF5aWZ5KGRiLm9iamVjdFN0b3JlTmFtZXMpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgICAgICAgbmFtZTogZGIubmFtZSxcbiAgICAgICAgICAgICAgICAgIHRhYmxlczogdGFibGVzLm1hcChmdW5jdGlvbiAodGFibGUpIHsgcmV0dXJuIHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlKTsgfSkubWFwKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gc3RvcmUua2V5UGF0aCwgYXV0b0luY3JlbWVudCA9IHN0b3JlLmF1dG9JbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvdW5kID0gaXNBcnJheShrZXlQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0Ym91bmQgPSBrZXlQYXRoID09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4QnlLZXlQYXRoID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3RvcmUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJpbWFyeUtleTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGJvdW5kOiBvdXRib3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kOiBjb21wb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvSW5jcmVtZW50OiBhdXRvSW5jcmVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IGFycmF5aWZ5KHN0b3JlLmluZGV4TmFtZXMpLm1hcChmdW5jdGlvbiAoaW5kZXhOYW1lKSB7IHJldHVybiBzdG9yZS5pbmRleChpbmRleE5hbWUpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gaW5kZXgubmFtZSwgdW5pcXVlID0gaW5kZXgudW5pcXVlLCBtdWx0aUVudHJ5ID0gaW5kZXgubXVsdGlFbnRyeSwga2V5UGF0aCA9IGluZGV4LmtleVBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG91bmQgPSBpc0FycmF5KGtleVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kOiBjb21wb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoOiBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZTogdW5pcXVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpRW50cnk6IG11bHRpRW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRJbmRleEJ5S2V5UGF0aDogZnVuY3Rpb24gKGtleVBhdGgpIHsgcmV0dXJuIGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV07IH1cbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW1wiOmlkXCJdID0gcmVzdWx0LnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldID0gcmVzdWx0LnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBoYXNHZXRBbGw6IHRhYmxlcy5sZW5ndGggPiAwICYmICgnZ2V0QWxsJyBpbiB0cmFucy5vYmplY3RTdG9yZSh0YWJsZXNbMF0pKSAmJlxuICAgICAgICAgICAgICAgICAgISh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgIS8oQ2hyb21lXFwvfEVkZ2VcXC8pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgW10uY29uY2F0KG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQqKS8pKVsxXSA8IDYwNClcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbWFrZUlEQktleVJhbmdlKHJhbmdlKSB7XG4gICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDMgKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gNCApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5ldmVyIHR5cGUgdG8gSURCS2V5UmFuZ2VcIik7XG4gICAgICAgICAgdmFyIGxvd2VyID0gcmFuZ2UubG93ZXIsIHVwcGVyID0gcmFuZ2UudXBwZXIsIGxvd2VyT3BlbiA9IHJhbmdlLmxvd2VyT3BlbiwgdXBwZXJPcGVuID0gcmFuZ2UudXBwZXJPcGVuO1xuICAgICAgICAgIHZhciBpZGJSYW5nZSA9IGxvd2VyID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgICAgICAgSWRiS2V5UmFuZ2UudXBwZXJCb3VuZCh1cHBlciwgISF1cHBlck9wZW4pIDpcbiAgICAgICAgICAgICAgdXBwZXIgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICBJZGJLZXlSYW5nZS5sb3dlckJvdW5kKGxvd2VyLCAhIWxvd2VyT3BlbikgOlxuICAgICAgICAgICAgICAgICAgSWRiS2V5UmFuZ2UuYm91bmQobG93ZXIsIHVwcGVyLCAhIWxvd2VyT3BlbiwgISF1cHBlck9wZW4pO1xuICAgICAgICAgIHJldHVybiBpZGJSYW5nZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZURiQ29yZVRhYmxlKHRhYmxlU2NoZW1hKSB7XG4gICAgICAgICAgdmFyIHRhYmxlTmFtZSA9IHRhYmxlU2NoZW1hLm5hbWU7XG4gICAgICAgICAgZnVuY3Rpb24gbXV0YXRlKF9hKSB7XG4gICAgICAgICAgICAgIHZhciB0cmFucyA9IF9hLnRyYW5zLCB0eXBlID0gX2EudHlwZSwga2V5cyA9IF9hLmtleXMsIHZhbHVlcyA9IF9hLnZhbHVlcywgcmFuZ2UgPSBfYS5yYW5nZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgIHZhciBvdXRib3VuZCA9IHN0b3JlLmtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHZhciBpc0FkZE9yUHV0ID0gdHlwZSA9PT0gXCJwdXRcIiB8fCB0eXBlID09PSBcImFkZFwiO1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc0FkZE9yUHV0ICYmIHR5cGUgIT09ICdkZWxldGUnICYmIHR5cGUgIT09ICdkZWxldGVSYW5nZScpXG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGVyYXRpb24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSAoa2V5cyB8fCB2YWx1ZXMgfHwgeyBsZW5ndGg6IDEgfSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgaWYgKGtleXMgJiYgdmFsdWVzICYmIGtleXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2l2ZW4ga2V5cyBhcnJheSBtdXN0IGhhdmUgc2FtZSBsZW5ndGggYXMgZ2l2ZW4gdmFsdWVzIGFycmF5LlwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBudW1GYWlsdXJlczogMCwgZmFpbHVyZXM6IHt9LCByZXN1bHRzOiBbXSwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgICAgdmFyIHJlcTtcbiAgICAgICAgICAgICAgICAgIHZhciByZXFzID0gW107XG4gICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIHZhciBudW1GYWlsdXJlcyA9IDA7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgKytudW1GYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdkZWxldGVSYW5nZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gNCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgbnVtRmFpbHVyZXM6IG51bUZhaWx1cmVzLCBmYWlsdXJlczogZmFpbHVyZXMsIHJlc3VsdHM6IFtdLCBsYXN0UmVzdWx0OiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDMgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmUuY2xlYXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmUuZGVsZXRlKG1ha2VJREJLZXlSYW5nZShyYW5nZSkpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGlzQWRkT3JQdXQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRib3VuZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVzLCBrZXlzXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVzLCBudWxsXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtrZXlzLCBudWxsXSwgYXJnczEgPSBfYVswXSwgYXJnczIgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBZGRPclB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gKGFyZ3MyICYmIGFyZ3MyW2ldICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldLCBhcmdzMltpXSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZVt0eXBlXShhcmdzMVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0UmVzdWx0ID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICByZXFzLmZvckVhY2goZnVuY3Rpb24gKHJlcSwgaSkgeyByZXR1cm4gcmVxLmVycm9yICE9IG51bGwgJiYgKGZhaWx1cmVzW2ldID0gcmVxLmVycm9yKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bUZhaWx1cmVzOiBudW1GYWlsdXJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXM6IGZhaWx1cmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzOiB0eXBlID09PSBcImRlbGV0ZVwiID8ga2V5cyA6IHJlcXMubWFwKGZ1bmN0aW9uIChyZXEpIHsgcmV0dXJuIHJlcS5yZXN1bHQ7IH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVzdWx0OiBsYXN0UmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBkb25lO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gb3BlbkN1cnNvcihfYSkge1xuICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBfYS50cmFucywgdmFsdWVzID0gX2EudmFsdWVzLCBxdWVyeSA9IF9hLnF1ZXJ5LCByZXZlcnNlID0gX2EucmV2ZXJzZSwgdW5pcXVlID0gX2EudW5pcXVlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBxdWVyeS5pbmRleCwgcmFuZ2UgPSBxdWVyeS5yYW5nZTtcbiAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gaW5kZXguaXNQcmltYXJ5S2V5ID9cbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZSA6XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gcmV2ZXJzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgdW5pcXVlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcmV2dW5pcXVlXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInByZXZcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgdW5pcXVlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXh0dW5pcXVlXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5leHRcIjtcbiAgICAgICAgICAgICAgICAgIHZhciByZXEgPSB2YWx1ZXMgfHwgISgnb3BlbktleUN1cnNvcicgaW4gc291cmNlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5DdXJzb3IobWFrZUlEQktleVJhbmdlKHJhbmdlKSwgZGlyZWN0aW9uKSA6XG4gICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5LZXlDdXJzb3IobWFrZUlEQktleVJhbmdlKHJhbmdlKSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5fX19pZCA9ICsrX2lkX2NvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2N1cnNvckNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlLmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkgPSBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5LmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2N1cnNvckFkdmFuY2UgPSBjdXJzb3IuYWR2YW5jZS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGRvVGhyb3dDdXJzb3JJc05vdFN0YXJ0ZWQgPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcihcIkN1cnNvciBub3Qgc3RhcnRlZFwiKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9UaHJvd0N1cnNvcklzU3RvcHBlZCA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIG5vdCBzdG9wcGVkXCIpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci50cmFucyA9IHRyYW5zO1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gY3Vyc29yLmNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5hZHZhbmNlID0gZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZDtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbCA9IHdyYXAocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdvdE9uZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdvdE9uZS0tID8gX3RoaXMuY29udGludWUoKSA6IF90aGlzLnN0b3AoKTsgfSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpczsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RhcnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZXJhdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZUl0ZXJhdGlvbiwgcmVqZWN0SXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSXRlcmF0aW9uID0gd3JhcChyZXNvbHZlSXRlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdEl0ZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbCA9IHJlamVjdEl0ZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSBjdXJzb3IuY29udGludWUgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmFkdmFuY2UgPSBkb1Rocm93Q3Vyc29ySXNTdG9wcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRpb24odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBndWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmZhaWwoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0YXJ0ID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3IgYmVoaW5kIGxhc3QgZW50cnlcIik7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZ3VhcmRlZENhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3VhcmRlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUgPSBfY3Vyc29yQ29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkgPSBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZSA9IF9jdXJzb3JBZHZhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBndWFyZGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGlvblByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gcXVlcnkoaGFzR2V0QWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSByZXF1ZXN0LnRyYW5zLCB2YWx1ZXMgPSByZXF1ZXN0LnZhbHVlcywgbGltaXQgPSByZXF1ZXN0LmxpbWl0LCBxdWVyeSA9IHJlcXVlc3QucXVlcnk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG5vbkluZmluaXRMaW1pdCA9IGxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IGxpbWl0O1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHF1ZXJ5LmluZGV4LCByYW5nZSA9IHF1ZXJ5LnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGlkYktleVJhbmdlID0gbWFrZUlEQktleVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgcmVzdWx0OiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzR2V0QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSB2YWx1ZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmdldEFsbChpZGJLZXlSYW5nZSwgbm9uSW5maW5pdExpbWl0KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuZ2V0QWxsS2V5cyhpZGJLZXlSYW5nZSwgbm9uSW5maW5pdExpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gcmVzb2x2ZSh7IHJlc3VsdDogZXZlbnQudGFyZ2V0LnJlc3VsdCB9KTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudF8xID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcV8xID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5DdXJzb3IoaWRiS2V5UmFuZ2UpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5vcGVuS2V5Q3Vyc29yKGlkYktleVJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdF8xID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcV8xLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IHJlcV8xLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgcmVzdWx0OiByZXN1bHRfMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8xLnB1c2godmFsdWVzID8gY3Vyc29yLnZhbHVlIDogY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY291bnRfMSA9PT0gbGltaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQ6IHJlc3VsdF8xIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcV8xLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbmFtZTogdGFibGVOYW1lLFxuICAgICAgICAgICAgICBzY2hlbWE6IHRhYmxlU2NoZW1hLFxuICAgICAgICAgICAgICBtdXRhdGU6IG11dGF0ZSxcbiAgICAgICAgICAgICAgZ2V0TWFueTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBfYS50cmFucywga2V5cyA9IF9hLmtleXM7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdFtyZXEuX3Bvc10gPSByZXEucmVzdWx0KSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytjYWxsYmFja0NvdW50ID09PSBrZXlDb3VudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IHN0b3JlLmdldChrZXlzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5fcG9zID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBzdWNjZXNzSGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytrZXlDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5Q291bnQgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gX2EudHJhbnMsIGtleSA9IF9hLmtleTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeShoYXNHZXRBbGwpLFxuICAgICAgICAgICAgICBvcGVuQ3Vyc29yOiBvcGVuQ3Vyc29yLFxuICAgICAgICAgICAgICBjb3VudDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBfYS5xdWVyeSwgdHJhbnMgPSBfYS50cmFucztcbiAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHF1ZXJ5LmluZGV4LCByYW5nZSA9IHF1ZXJ5LnJhbmdlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgPyBzdG9yZSA6IHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBpZGJLZXlSYW5nZSA9IG1ha2VJREJLZXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGlkYktleVJhbmdlID8gc291cmNlLmNvdW50KGlkYktleVJhbmdlKSA6IHNvdXJjZS5jb3VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGZ1bmN0aW9uIChldikgeyByZXR1cm4gcmVzb2x2ZShldi50YXJnZXQucmVzdWx0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBfYSA9IGV4dHJhY3RTY2hlbWEoZGIsIHRtcFRyYW5zKSwgc2NoZW1hID0gX2Euc2NoZW1hLCBoYXNHZXRBbGwgPSBfYS5oYXNHZXRBbGw7XG4gICAgICB2YXIgdGFibGVzID0gc2NoZW1hLnRhYmxlcy5tYXAoZnVuY3Rpb24gKHRhYmxlU2NoZW1hKSB7IHJldHVybiBjcmVhdGVEYkNvcmVUYWJsZSh0YWJsZVNjaGVtYSk7IH0pO1xuICAgICAgdmFyIHRhYmxlTWFwID0ge307XG4gICAgICB0YWJsZXMuZm9yRWFjaChmdW5jdGlvbiAodGFibGUpIHsgcmV0dXJuIHRhYmxlTWFwW3RhYmxlLm5hbWVdID0gdGFibGU7IH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICAgICAgICB0cmFuc2FjdGlvbjogZGIudHJhbnNhY3Rpb24uYmluZChkYiksXG4gICAgICAgICAgdGFibGU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YWJsZU1hcFtuYW1lXTtcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYWJsZSAnXCIuY29uY2F0KG5hbWUsIFwiJyBub3QgZm91bmRcIikpO1xuICAgICAgICAgICAgICByZXR1cm4gdGFibGVNYXBbbmFtZV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBNSU5fS0VZOiAtSW5maW5pdHksXG4gICAgICAgICAgTUFYX0tFWTogZ2V0TWF4S2V5KElkYktleVJhbmdlKSxcbiAgICAgICAgICBzY2hlbWE6IHNjaGVtYVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVTdGFjayhzdGFja0ltcGwsIG1pZGRsZXdhcmVzKSB7XG4gICAgICByZXR1cm4gbWlkZGxld2FyZXMucmVkdWNlKGZ1bmN0aW9uIChkb3duLCBfYSkge1xuICAgICAgICAgIHZhciBjcmVhdGUgPSBfYS5jcmVhdGU7XG4gICAgICAgICAgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG93biksIGNyZWF0ZShkb3duKSkpO1xuICAgICAgfSwgc3RhY2tJbXBsKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlU3RhY2tzKG1pZGRsZXdhcmVzLCBpZGJkYiwgX2EsIHRtcFRyYW5zKSB7XG4gICAgICB2YXIgSURCS2V5UmFuZ2UgPSBfYS5JREJLZXlSYW5nZTsgX2EuaW5kZXhlZERCO1xuICAgICAgdmFyIGRiY29yZSA9IGNyZWF0ZU1pZGRsZXdhcmVTdGFjayhjcmVhdGVEQkNvcmUoaWRiZGIsIElEQktleVJhbmdlLCB0bXBUcmFucyksIG1pZGRsZXdhcmVzLmRiY29yZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIGRiY29yZTogZGJjb3JlXG4gICAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgdG1wVHJhbnMpIHtcbiAgICAgIHZhciBpZGJkYiA9IHRtcFRyYW5zLmRiO1xuICAgICAgdmFyIHN0YWNrcyA9IGNyZWF0ZU1pZGRsZXdhcmVTdGFja3MoZGIuX21pZGRsZXdhcmVzLCBpZGJkYiwgZGIuX2RlcHMsIHRtcFRyYW5zKTtcbiAgICAgIGRiLmNvcmUgPSBzdGFja3MuZGJjb3JlO1xuICAgICAgZGIudGFibGVzLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlKSB7XG4gICAgICAgICAgdmFyIHRhYmxlTmFtZSA9IHRhYmxlLm5hbWU7XG4gICAgICAgICAgaWYgKGRiLmNvcmUuc2NoZW1hLnRhYmxlcy5zb21lKGZ1bmN0aW9uICh0YmwpIHsgcmV0dXJuIHRibC5uYW1lID09PSB0YWJsZU5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgIHRhYmxlLmNvcmUgPSBkYi5jb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgIGlmIChkYlt0YWJsZU5hbWVdIGluc3RhbmNlb2YgZGIuVGFibGUpIHtcbiAgICAgICAgICAgICAgICAgIGRiW3RhYmxlTmFtZV0uY29yZSA9IHRhYmxlLmNvcmU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEFwaU9uUGxhY2UoZGIsIG9ianMsIHRhYmxlTmFtZXMsIGRic2NoZW1hKSB7XG4gICAgICB0YWJsZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgIHZhciBzY2hlbWEgPSBkYnNjaGVtYVt0YWJsZU5hbWVdO1xuICAgICAgICAgIG9ianMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wRGVzYyA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmosIHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgIGlmICghcHJvcERlc2MgfHwgKFwidmFsdWVcIiBpbiBwcm9wRGVzYyAmJiBwcm9wRGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlIHx8IG9iaiBpbnN0YW5jZW9mIGRiLlRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChvYmosIHRhYmxlTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGFibGUodGFibGVOYW1lKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIHRhYmxlTmFtZSwgeyB2YWx1ZTogdmFsdWUsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG9ialt0YWJsZU5hbWVdID0gbmV3IGRiLlRhYmxlKHRhYmxlTmFtZSwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlVGFibGVzQXBpKGRiLCBvYmpzKSB7XG4gICAgICBvYmpzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgaWYgKG9ialtrZXldIGluc3RhbmNlb2YgZGIuVGFibGUpXG4gICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gbG93ZXJWZXJzaW9uRmlyc3QoYSwgYikge1xuICAgICAgcmV0dXJuIGEuX2NmZy52ZXJzaW9uIC0gYi5fY2ZnLnZlcnNpb247XG4gIH1cbiAgZnVuY3Rpb24gcnVuVXBncmFkZXJzKGRiLCBvbGRWZXJzaW9uLCBpZGJVcGdyYWRlVHJhbnMsIHJlamVjdCkge1xuICAgICAgdmFyIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYTtcbiAgICAgIGlmIChpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnJG1ldGEnKSAmJiAhZ2xvYmFsU2NoZW1hLiRtZXRhKSB7XG4gICAgICAgICAgZ2xvYmFsU2NoZW1hLiRtZXRhID0gY3JlYXRlVGFibGVTY2hlbWEoXCIkbWV0YVwiLCBwYXJzZUluZGV4U3ludGF4KFwiXCIpWzBdLCBbXSk7XG4gICAgICAgICAgZGIuX3N0b3JlTmFtZXMucHVzaCgnJG1ldGEnKTtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbigncmVhZHdyaXRlJywgZGIuX3N0b3JlTmFtZXMsIGdsb2JhbFNjaGVtYSk7XG4gICAgICB0cmFucy5jcmVhdGUoaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgIHRyYW5zLl9jb21wbGV0aW9uLmNhdGNoKHJlamVjdCk7XG4gICAgICB2YXIgcmVqZWN0VHJhbnNhY3Rpb24gPSB0cmFucy5fcmVqZWN0LmJpbmQodHJhbnMpO1xuICAgICAgdmFyIHRyYW5zbGVzcyA9IFBTRC50cmFuc2xlc3MgfHwgUFNEO1xuICAgICAgbmV3U2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIFBTRC50cmFucyA9IHRyYW5zO1xuICAgICAgICAgIFBTRC50cmFuc2xlc3MgPSB0cmFuc2xlc3M7XG4gICAgICAgICAgaWYgKG9sZFZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAga2V5cyhnbG9iYWxTY2hlbWEpLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRiVXBncmFkZVRyYW5zLCB0YWJsZU5hbWUsIGdsb2JhbFNjaGVtYVt0YWJsZU5hbWVdLnByaW1LZXksIGdsb2JhbFNjaGVtYVt0YWJsZU5hbWVdLmluZGV4ZXMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgICBEZXhpZVByb21pc2UuZm9sbG93KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRiLm9uLnBvcHVsYXRlLmZpcmUodHJhbnMpOyB9KS5jYXRjaChyZWplY3RUcmFuc2FjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFeGlzdGluZ1ZlcnNpb24oZGIsIHRyYW5zLCBvbGRWZXJzaW9uKVxuICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9sZFZlcnNpb24pIHsgcmV0dXJuIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMoZGIsIG9sZFZlcnNpb24sIHRyYW5zLCBpZGJVcGdyYWRlVHJhbnMpOyB9KVxuICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBwYXRjaEN1cnJlbnRWZXJzaW9uKGRiLCBpZGJVcGdyYWRlVHJhbnMpIHtcbiAgICAgIGNyZWF0ZU1pc3NpbmdUYWJsZXMoZGIuX2RiU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgaWYgKGlkYlVwZ3JhZGVUcmFucy5kYi52ZXJzaW9uICUgMTAgPT09IDAgJiYgIWlkYlVwZ3JhZGVUcmFucy5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCckbWV0YScpKSB7XG4gICAgICAgICAgaWRiVXBncmFkZVRyYW5zLmRiLmNyZWF0ZU9iamVjdFN0b3JlKCckbWV0YScpLmFkZChNYXRoLmNlaWwoKGlkYlVwZ3JhZGVUcmFucy5kYi52ZXJzaW9uIC8gMTApIC0gMSksICd2ZXJzaW9uJyk7XG4gICAgICB9XG4gICAgICB2YXIgZ2xvYmFsU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGRiLmlkYmRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIGRiLl9kYlNjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgIHZhciBkaWZmID0gZ2V0U2NoZW1hRGlmZihnbG9iYWxTY2hlbWEsIGRiLl9kYlNjaGVtYSk7XG4gICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICh0YWJsZUNoYW5nZSkge1xuICAgICAgICAgIGlmICh0YWJsZUNoYW5nZS5jaGFuZ2UubGVuZ3RoIHx8IHRhYmxlQ2hhbmdlLnJlY3JlYXRlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuYWJsZSB0byBwYXRjaCBpbmRleGVzIG9mIHRhYmxlIFwiLmNvbmNhdCh0YWJsZUNoYW5nZS5uYW1lLCBcIiBiZWNhdXNlIGl0IGhhcyBjaGFuZ2VzIG9uIHRoZSB0eXBlIG9mIGluZGV4IG9yIHByaW1hcnkga2V5LlwiKSk7XG4gICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2b2lkIDAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0b3JlID0gaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlKHRhYmxlQ2hhbmdlLm5hbWUpO1xuICAgICAgICAgIHRhYmxlQ2hhbmdlLmFkZC5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIkRleGllIHVwZ3JhZGUgcGF0Y2g6IENyZWF0aW5nIG1pc3NpbmcgaW5kZXggXCIuY29uY2F0KHRhYmxlQ2hhbmdlLm5hbWUsIFwiLlwiKS5jb25jYXQoaWR4LnNyYykpO1xuICAgICAgICAgICAgICBhZGRJbmRleChzdG9yZSwgaWR4KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZGlmZi5jaGFuZ2U7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIHRhYmxlQ2hhbmdlID0gX2FbX2ldO1xuICAgICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMSh0YWJsZUNoYW5nZSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8xID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICByZXR1cm4gc3RhdGVfMS52YWx1ZTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRFeGlzdGluZ1ZlcnNpb24oZGIsIHRyYW5zLCBvbGRWZXJzaW9uKSB7XG4gICAgICBpZiAodHJhbnMuc3RvcmVOYW1lcy5pbmNsdWRlcygnJG1ldGEnKSkge1xuICAgICAgICAgIHJldHVybiB0cmFucy50YWJsZSgnJG1ldGEnKS5nZXQoJ3ZlcnNpb24nKS50aGVuKGZ1bmN0aW9uIChtZXRhVmVyc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gbWV0YVZlcnNpb24gIT0gbnVsbCA/IG1ldGFWZXJzaW9uIDogb2xkVmVyc2lvbjtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShvbGRWZXJzaW9uKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVUYWJsZXNBbmRJbmRleGVzKGRiLCBvbGRWZXJzaW9uLCB0cmFucywgaWRiVXBncmFkZVRyYW5zKSB7XG4gICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgIHZhciB2ZXJzaW9ucyA9IGRiLl92ZXJzaW9ucztcbiAgICAgIHZhciBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICB2YXIgdmVyc1RvUnVuID0gdmVyc2lvbnMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2Ll9jZmcudmVyc2lvbiA+PSBvbGRWZXJzaW9uOyB9KTtcbiAgICAgIGlmICh2ZXJzVG9SdW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICB2ZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgb2xkU2NoZW1hID0gZ2xvYmFsU2NoZW1hO1xuICAgICAgICAgICAgICB2YXIgbmV3U2NoZW1hID0gdmVyc2lvbi5fY2ZnLmRic2NoZW1hO1xuICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgb2xkU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgbmV3U2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgICBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBuZXdTY2hlbWE7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gZ2V0U2NoZW1hRGlmZihvbGRTY2hlbWEsIG5ld1NjaGVtYSk7XG4gICAgICAgICAgICAgIGRpZmYuYWRkLmZvckVhY2goZnVuY3Rpb24gKHR1cGxlKSB7XG4gICAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJVcGdyYWRlVHJhbnMsIHR1cGxlWzBdLCB0dXBsZVsxXS5wcmltS2V5LCB0dXBsZVsxXS5pbmRleGVzKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGRpZmYuY2hhbmdlLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5yZWNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlVwZ3JhZGUoXCJOb3QgeWV0IHN1cHBvcnQgZm9yIGNoYW5naW5nIHByaW1hcnkga2V5XCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlXzEgPSBpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmUoY2hhbmdlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5hZGQuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBhZGRJbmRleChzdG9yZV8xLCBpZHgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuY2hhbmdlLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZV8xLmRlbGV0ZUluZGV4KGlkeC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW5kZXgoc3RvcmVfMSwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuZGVsLmZvckVhY2goZnVuY3Rpb24gKGlkeE5hbWUpIHsgcmV0dXJuIHN0b3JlXzEuZGVsZXRlSW5kZXgoaWR4TmFtZSk7IH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdmFyIGNvbnRlbnRVcGdyYWRlID0gdmVyc2lvbi5fY2ZnLmNvbnRlbnRVcGdyYWRlO1xuICAgICAgICAgICAgICBpZiAoY29udGVudFVwZ3JhZGUgJiYgdmVyc2lvbi5fY2ZnLnZlcnNpb24gPiBvbGRWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgICAgICAgICAgICB0cmFucy5fbWVtb2l6ZWRUYWJsZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgIHZhciB1cGdyYWRlU2NoZW1hXzEgPSBzaGFsbG93Q2xvbmUobmV3U2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgIGRpZmYuZGVsLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdXBncmFkZVNjaGVtYV8xW3RhYmxlXSA9IG9sZFNjaGVtYVt0YWJsZV07XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgICAgICAgICAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGtleXModXBncmFkZVNjaGVtYV8xKSwgdXBncmFkZVNjaGVtYV8xKTtcbiAgICAgICAgICAgICAgICAgIHRyYW5zLnNjaGVtYSA9IHVwZ3JhZGVTY2hlbWFfMTtcbiAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VXBncmFkZUlzQXN5bmNfMSA9IGlzQXN5bmNGdW5jdGlvbihjb250ZW50VXBncmFkZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoY29udGVudFVwZ3JhZGVJc0FzeW5jXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlXzE7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZUZvbGxvd2VkID0gRGV4aWVQcm9taXNlLmZvbGxvdyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWVfMSA9IGNvbnRlbnRVcGdyYWRlKHRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWVfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFVwZ3JhZGVJc0FzeW5jXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNyZW1lbnRvciA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLmJpbmQobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZV8xLnRoZW4oZGVjcmVtZW50b3IsIGRlY3JlbWVudG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChyZXR1cm5WYWx1ZV8xICYmIHR5cGVvZiByZXR1cm5WYWx1ZV8xLnRoZW4gPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlXzEpIDogcHJvbWlzZUZvbGxvd2VkLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmV0dXJuVmFsdWVfMTsgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcXVldWUucHVzaChmdW5jdGlvbiAoaWRidHJhbnMpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgICAgICAgZGVsZXRlUmVtb3ZlZFRhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKTtcbiAgICAgICAgICAgICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG4gICAgICAgICAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdLCBkYi5fc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hKTtcbiAgICAgICAgICAgICAgdHJhbnMuc2NoZW1hID0gZGIuX2RiU2NoZW1hO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKGlkYnRyYW5zKSB7XG4gICAgICAgICAgICAgIGlmIChkYi5pZGJkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCckbWV0YScpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoTWF0aC5jZWlsKGRiLmlkYmRiLnZlcnNpb24gLyAxMCkgPT09IHZlcnNpb24uX2NmZy52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGIuaWRiZGIuZGVsZXRlT2JqZWN0U3RvcmUoJyRtZXRhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRiLl9kYlNjaGVtYS4kbWV0YTtcbiAgICAgICAgICAgICAgICAgICAgICBkYi5fc3RvcmVOYW1lcyA9IGRiLl9zdG9yZU5hbWVzLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZSAhPT0gJyRtZXRhJzsgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZGJ0cmFucy5vYmplY3RTdG9yZSgnJG1ldGEnKS5wdXQodmVyc2lvbi5fY2ZnLnZlcnNpb24sICd2ZXJzaW9uJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZnVuY3Rpb24gcnVuUXVldWUoKSB7XG4gICAgICAgICAgcmV0dXJuIHF1ZXVlLmxlbmd0aCA/IERleGllUHJvbWlzZS5yZXNvbHZlKHF1ZXVlLnNoaWZ0KCkodHJhbnMuaWRidHJhbnMpKS50aGVuKHJ1blF1ZXVlKSA6XG4gICAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnVuUXVldWUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjcmVhdGVNaXNzaW5nVGFibGVzKGdsb2JhbFNjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldFNjaGVtYURpZmYob2xkU2NoZW1hLCBuZXdTY2hlbWEpIHtcbiAgICAgIHZhciBkaWZmID0ge1xuICAgICAgICAgIGRlbDogW10sXG4gICAgICAgICAgYWRkOiBbXSxcbiAgICAgICAgICBjaGFuZ2U6IFtdXG4gICAgICB9O1xuICAgICAgdmFyIHRhYmxlO1xuICAgICAgZm9yICh0YWJsZSBpbiBvbGRTY2hlbWEpIHtcbiAgICAgICAgICBpZiAoIW5ld1NjaGVtYVt0YWJsZV0pXG4gICAgICAgICAgICAgIGRpZmYuZGVsLnB1c2godGFibGUpO1xuICAgICAgfVxuICAgICAgZm9yICh0YWJsZSBpbiBuZXdTY2hlbWEpIHtcbiAgICAgICAgICB2YXIgb2xkRGVmID0gb2xkU2NoZW1hW3RhYmxlXSwgbmV3RGVmID0gbmV3U2NoZW1hW3RhYmxlXTtcbiAgICAgICAgICBpZiAoIW9sZERlZikge1xuICAgICAgICAgICAgICBkaWZmLmFkZC5wdXNoKFt0YWJsZSwgbmV3RGVmXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgY2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdGFibGUsXG4gICAgICAgICAgICAgICAgICBkZWY6IG5ld0RlZixcbiAgICAgICAgICAgICAgICAgIHJlY3JlYXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGRlbDogW10sXG4gICAgICAgICAgICAgICAgICBhZGQ6IFtdLFxuICAgICAgICAgICAgICAgICAgY2hhbmdlOiBbXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoKFxuICAgICAgICAgICAgICAnJyArIChvbGREZWYucHJpbUtleS5rZXlQYXRoIHx8ICcnKSkgIT09ICgnJyArIChuZXdEZWYucHJpbUtleS5rZXlQYXRoIHx8ICcnKSkgfHxcbiAgICAgICAgICAgICAgICAgIChvbGREZWYucHJpbUtleS5hdXRvICE9PSBuZXdEZWYucHJpbUtleS5hdXRvKSkge1xuICAgICAgICAgICAgICAgICAgY2hhbmdlLnJlY3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGRpZmYuY2hhbmdlLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBvbGRJbmRleGVzID0gb2xkRGVmLmlkeEJ5TmFtZTtcbiAgICAgICAgICAgICAgICAgIHZhciBuZXdJbmRleGVzID0gbmV3RGVmLmlkeEJ5TmFtZTtcbiAgICAgICAgICAgICAgICAgIHZhciBpZHhOYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgZm9yIChpZHhOYW1lIGluIG9sZEluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld0luZGV4ZXNbaWR4TmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5kZWwucHVzaChpZHhOYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZvciAoaWR4TmFtZSBpbiBuZXdJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZElkeCA9IG9sZEluZGV4ZXNbaWR4TmFtZV0sIG5ld0lkeCA9IG5ld0luZGV4ZXNbaWR4TmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRJZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5hZGQucHVzaChuZXdJZHgpO1xuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9sZElkeC5zcmMgIT09IG5ld0lkeC5zcmMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5jaGFuZ2UucHVzaChuZXdJZHgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5kZWwubGVuZ3RoID4gMCB8fCBjaGFuZ2UuYWRkLmxlbmd0aCA+IDAgfHwgY2hhbmdlLmNoYW5nZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRpZmY7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgcHJpbUtleSwgaW5kZXhlcykge1xuICAgICAgdmFyIHN0b3JlID0gaWRidHJhbnMuZGIuY3JlYXRlT2JqZWN0U3RvcmUodGFibGVOYW1lLCBwcmltS2V5LmtleVBhdGggP1xuICAgICAgICAgIHsga2V5UGF0aDogcHJpbUtleS5rZXlQYXRoLCBhdXRvSW5jcmVtZW50OiBwcmltS2V5LmF1dG8gfSA6XG4gICAgICAgICAgeyBhdXRvSW5jcmVtZW50OiBwcmltS2V5LmF1dG8gfSk7XG4gICAgICBpbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gYWRkSW5kZXgoc3RvcmUsIGlkeCk7IH0pO1xuICAgICAgcmV0dXJuIHN0b3JlO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdUYWJsZXMobmV3U2NoZW1hLCBpZGJ0cmFucykge1xuICAgICAga2V5cyhuZXdTY2hlbWEpLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgIGlmICghaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyh0YWJsZU5hbWUpKSB7XG4gICAgICAgICAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0RleGllOiBDcmVhdGluZyBtaXNzaW5nIHRhYmxlJywgdGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVsZXRlUmVtb3ZlZFRhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKSB7XG4gICAgICBbXS5zbGljZS5jYWxsKGlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXMpLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgICAgICAgIHJldHVybiBuZXdTY2hlbWFbc3RvcmVOYW1lXSA9PSBudWxsICYmIGlkYnRyYW5zLmRiLmRlbGV0ZU9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhZGRJbmRleChzdG9yZSwgaWR4KSB7XG4gICAgICBzdG9yZS5jcmVhdGVJbmRleChpZHgubmFtZSwgaWR4LmtleVBhdGgsIHsgdW5pcXVlOiBpZHgudW5pcXVlLCBtdWx0aUVudHJ5OiBpZHgubXVsdGkgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucykge1xuICAgICAgdmFyIGdsb2JhbFNjaGVtYSA9IHt9O1xuICAgICAgdmFyIGRiU3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMsIDApO1xuICAgICAgZGJTdG9yZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgICAgICAgIHZhciBzdG9yZSA9IHRtcFRyYW5zLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgdmFyIGtleVBhdGggPSBzdG9yZS5rZXlQYXRoO1xuICAgICAgICAgIHZhciBwcmltS2V5ID0gY3JlYXRlSW5kZXhTcGVjKG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKSwga2V5UGF0aCB8fCBcIlwiLCB0cnVlLCBmYWxzZSwgISFzdG9yZS5hdXRvSW5jcmVtZW50LCBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSBcInN0cmluZ1wiLCB0cnVlKTtcbiAgICAgICAgICB2YXIgaW5kZXhlcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RvcmUuaW5kZXhOYW1lcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICB2YXIgaWRiaW5kZXggPSBzdG9yZS5pbmRleChzdG9yZS5pbmRleE5hbWVzW2pdKTtcbiAgICAgICAgICAgICAga2V5UGF0aCA9IGlkYmluZGV4LmtleVBhdGg7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IGNyZWF0ZUluZGV4U3BlYyhpZGJpbmRleC5uYW1lLCBrZXlQYXRoLCAhIWlkYmluZGV4LnVuaXF1ZSwgISFpZGJpbmRleC5tdWx0aUVudHJ5LCBmYWxzZSwga2V5UGF0aCAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gXCJzdHJpbmdcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnbG9iYWxTY2hlbWFbc3RvcmVOYW1lXSA9IGNyZWF0ZVRhYmxlU2NoZW1hKHN0b3JlTmFtZSwgcHJpbUtleSwgaW5kZXhlcyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBnbG9iYWxTY2hlbWE7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKSB7XG4gICAgICBkYi52ZXJubyA9IGlkYmRiLnZlcnNpb24gLyAxMDtcbiAgICAgIHZhciBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKTtcbiAgICAgIGRiLl9zdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcywgMCk7XG4gICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuX2FsbFRhYmxlc10sIGtleXMoZ2xvYmFsU2NoZW1hKSwgZ2xvYmFsU2NoZW1hKTtcbiAgfVxuICBmdW5jdGlvbiB2ZXJpZnlJbnN0YWxsZWRTY2hlbWEoZGIsIHRtcFRyYW5zKSB7XG4gICAgICB2YXIgaW5zdGFsbGVkU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGRiLmlkYmRiLCB0bXBUcmFucyk7XG4gICAgICB2YXIgZGlmZiA9IGdldFNjaGVtYURpZmYoaW5zdGFsbGVkU2NoZW1hLCBkYi5fZGJTY2hlbWEpO1xuICAgICAgcmV0dXJuICEoZGlmZi5hZGQubGVuZ3RoIHx8IGRpZmYuY2hhbmdlLnNvbWUoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBjaC5hZGQubGVuZ3RoIHx8IGNoLmNoYW5nZS5sZW5ndGg7IH0pKTtcbiAgfVxuICBmdW5jdGlvbiBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgc2NoZW1hLCBpZGJ0cmFucykge1xuICAgICAgdmFyIHN0b3JlTmFtZXMgPSBpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yZU5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIHN0b3JlTmFtZSA9IHN0b3JlTmFtZXNbaV07XG4gICAgICAgICAgdmFyIHN0b3JlID0gaWRidHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgICBkYi5faGFzR2V0QWxsID0gJ2dldEFsbCcgaW4gc3RvcmU7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdG9yZS5pbmRleE5hbWVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleE5hbWUgPSBzdG9yZS5pbmRleE5hbWVzW2pdO1xuICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IHN0b3JlLmluZGV4KGluZGV4TmFtZSkua2V5UGF0aDtcbiAgICAgICAgICAgICAgdmFyIGRleGllTmFtZSA9IHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/IGtleVBhdGggOiBcIltcIiArIHNsaWNlKGtleVBhdGgpLmpvaW4oJysnKSArIFwiXVwiO1xuICAgICAgICAgICAgICBpZiAoc2NoZW1hW3N0b3JlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbmRleFNwZWMgPSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcbiAgICAgICAgICAgICAgICAgIGlmIChpbmRleFNwZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleFNwZWMubmFtZSA9IGluZGV4TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2RleGllTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2luZGV4TmFtZV0gPSBpbmRleFNwZWM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAgICEvKENocm9tZVxcL3xFZGdlXFwvKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAgIF9nbG9iYWwuV29ya2VyR2xvYmFsU2NvcGUgJiYgX2dsb2JhbCBpbnN0YW5jZW9mIF9nbG9iYWwuV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICAgICAgICBbXS5jb25jYXQobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCopLykpWzFdIDwgNjA0KSB7XG4gICAgICAgICAgZGIuX2hhc0dldEFsbCA9IGZhbHNlO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlSW5kZXhTeW50YXgocHJpbUtleUFuZEluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBwcmltS2V5QW5kSW5kZXhlcy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoaW5kZXgsIGluZGV4TnVtKSB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHZhciB0eXBlU3BsaXQgPSBpbmRleC5zcGxpdCgnOicpO1xuICAgICAgICAgIHZhciB0eXBlID0gKF9hID0gdHlwZVNwbGl0WzFdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJpbSgpO1xuICAgICAgICAgIGluZGV4ID0gdHlwZVNwbGl0WzBdLnRyaW0oKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGluZGV4LnJlcGxhY2UoLyhbJipdfFxcK1xcKykvZywgXCJcIik7XG4gICAgICAgICAgdmFyIGtleVBhdGggPSAvXlxcWy8udGVzdChuYW1lKSA/IG5hbWUubWF0Y2goL15cXFsoLiopXFxdJC8pWzFdLnNwbGl0KCcrJykgOiBuYW1lO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVJbmRleFNwZWMobmFtZSwga2V5UGF0aCB8fCBudWxsLCAvXFwmLy50ZXN0KGluZGV4KSwgL1xcKi8udGVzdChpbmRleCksIC9cXCtcXCsvLnRlc3QoaW5kZXgpLCBpc0FycmF5KGtleVBhdGgpLCBpbmRleE51bSA9PT0gMCwgdHlwZSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHZhciBWZXJzaW9uID0gIChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWZXJzaW9uKCkge1xuICAgICAgfVxuICAgICAgVmVyc2lvbi5wcm90b3R5cGUuX2NyZWF0ZVRhYmxlU2NoZW1hID0gZnVuY3Rpb24gKG5hbWUsIHByaW1LZXksIGluZGV4ZXMpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlVGFibGVTY2hlbWEobmFtZSwgcHJpbUtleSwgaW5kZXhlcyk7XG4gICAgICB9O1xuICAgICAgVmVyc2lvbi5wcm90b3R5cGUuX3BhcnNlSW5kZXhTeW50YXggPSBmdW5jdGlvbiAocHJpbUtleUFuZEluZGV4ZXMpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VJbmRleFN5bnRheChwcmltS2V5QW5kSW5kZXhlcyk7XG4gICAgICB9O1xuICAgICAgVmVyc2lvbi5wcm90b3R5cGUuX3BhcnNlU3RvcmVzU3BlYyA9IGZ1bmN0aW9uIChzdG9yZXMsIG91dFNjaGVtYSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAga2V5cyhzdG9yZXMpLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICBpZiAoc3RvcmVzW3RhYmxlTmFtZV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbmRleGVzID0gX3RoaXMuX3BhcnNlSW5kZXhTeW50YXgoc3RvcmVzW3RhYmxlTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgdmFyIHByaW1LZXkgPSBpbmRleGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIXByaW1LZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoJ0ludmFsaWQgc2NoZW1hIGZvciB0YWJsZSAnICsgdGFibGVOYW1lICsgJzogJyArIHN0b3Jlc1t0YWJsZU5hbWVdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHByaW1LZXkudW5pcXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmltS2V5Lm11bHRpKVxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYSgnUHJpbWFyeSBrZXkgY2Fubm90IGJlIG11bHRpRW50cnkqJyk7XG4gICAgICAgICAgICAgICAgICBpbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHguYXV0bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKCdPbmx5IHByaW1hcnkga2V5IGNhbiBiZSBtYXJrZWQgYXMgYXV0b0luY3JlbWVudCAoKyspJyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFpZHgua2V5UGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKCdJbmRleCBtdXN0IGhhdmUgYSBuYW1lIGFuZCBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHZhciB0YmxTY2hlbWEgPSBfdGhpcy5fY3JlYXRlVGFibGVTY2hlbWEodGFibGVOYW1lLCBwcmltS2V5LCBpbmRleGVzKTtcbiAgICAgICAgICAgICAgICAgIG91dFNjaGVtYVt0YWJsZU5hbWVdID0gdGJsU2NoZW1hO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVmVyc2lvbi5wcm90b3R5cGUuc3RvcmVzID0gZnVuY3Rpb24gKHN0b3Jlcykge1xuICAgICAgICAgIHZhciBkYiA9IHRoaXMuZGI7XG4gICAgICAgICAgdGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSA9IHRoaXMuX2NmZy5zdG9yZXNTb3VyY2VcbiAgICAgICAgICAgICAgPyBleHRlbmQodGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSwgc3RvcmVzKVxuICAgICAgICAgICAgICA6IHN0b3JlcztcbiAgICAgICAgICB2YXIgdmVyc2lvbnMgPSBkYi5fdmVyc2lvbnM7XG4gICAgICAgICAgdmFyIHN0b3Jlc1NwZWMgPSB7fTtcbiAgICAgICAgICB2YXIgZGJzY2hlbWEgPSB7fTtcbiAgICAgICAgICB2ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgIGV4dGVuZChzdG9yZXNTcGVjLCB2ZXJzaW9uLl9jZmcuc3RvcmVzU291cmNlKTtcbiAgICAgICAgICAgICAgZGJzY2hlbWEgPSB2ZXJzaW9uLl9jZmcuZGJzY2hlbWEgPSB7fTtcbiAgICAgICAgICAgICAgdmVyc2lvbi5fcGFyc2VTdG9yZXNTcGVjKHN0b3Jlc1NwZWMsIGRic2NoZW1hKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkYi5fZGJTY2hlbWEgPSBkYnNjaGVtYTtcbiAgICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5fYWxsVGFibGVzLCBkYiwgZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG4gICAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLl9hbGxUYWJsZXMsIGRiLCBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGUsIHRoaXMuX2NmZy50YWJsZXNdLCBrZXlzKGRic2NoZW1hKSwgZGJzY2hlbWEpO1xuICAgICAgICAgIGRiLl9zdG9yZU5hbWVzID0ga2V5cyhkYnNjaGVtYSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgVmVyc2lvbi5wcm90b3R5cGUudXBncmFkZSA9IGZ1bmN0aW9uICh1cGdyYWRlRnVuY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLl9jZmcuY29udGVudFVwZ3JhZGUgPSBwcm9taXNhYmxlQ2hhaW4odGhpcy5fY2ZnLmNvbnRlbnRVcGdyYWRlIHx8IG5vcCwgdXBncmFkZUZ1bmN0aW9uKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICByZXR1cm4gVmVyc2lvbjtcbiAgfSgpKTtcblxuICBmdW5jdGlvbiBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IoZGIpIHtcbiAgICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihWZXJzaW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gVmVyc2lvbih2ZXJzaW9uTnVtYmVyKSB7XG4gICAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICAgIHRoaXMuX2NmZyA9IHtcbiAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbk51bWJlcixcbiAgICAgICAgICAgICAgc3RvcmVzU291cmNlOiBudWxsLFxuICAgICAgICAgICAgICBkYnNjaGVtYToge30sXG4gICAgICAgICAgICAgIHRhYmxlczoge30sXG4gICAgICAgICAgICAgIGNvbnRlbnRVcGdyYWRlOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpIHtcbiAgICAgIHZhciBkYk5hbWVzREIgPSBpbmRleGVkREJbXCJfZGJOYW1lc0RCXCJdO1xuICAgICAgaWYgKCFkYk5hbWVzREIpIHtcbiAgICAgICAgICBkYk5hbWVzREIgPSBpbmRleGVkREJbXCJfZGJOYW1lc0RCXCJdID0gbmV3IERleGllJDEoREJOQU1FU19EQiwge1xuICAgICAgICAgICAgICBhZGRvbnM6IFtdLFxuICAgICAgICAgICAgICBpbmRleGVkREI6IGluZGV4ZWREQixcbiAgICAgICAgICAgICAgSURCS2V5UmFuZ2U6IElEQktleVJhbmdlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRiTmFtZXNEQi52ZXJzaW9uKDEpLnN0b3Jlcyh7IGRibmFtZXM6IFwibmFtZVwiIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRiTmFtZXNEQi50YWJsZShcImRibmFtZXNcIik7XG4gIH1cbiAgZnVuY3Rpb24gaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikge1xuICAgICAgcmV0dXJuIGluZGV4ZWREQiAmJiB0eXBlb2YgaW5kZXhlZERCLmRhdGFiYXNlcyA9PT0gXCJmdW5jdGlvblwiO1xuICB9XG4gIGZ1bmN0aW9uIGdldERhdGFiYXNlTmFtZXMoX2EpIHtcbiAgICAgIHZhciBpbmRleGVkREIgPSBfYS5pbmRleGVkREIsIElEQktleVJhbmdlID0gX2EuSURCS2V5UmFuZ2U7XG4gICAgICByZXR1cm4gaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQilcbiAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZShpbmRleGVkREIuZGF0YWJhc2VzKCkpLnRoZW4oZnVuY3Rpb24gKGluZm9zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbmZvc1xuICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gaW5mby5uYW1lOyB9KVxuICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZSAhPT0gREJOQU1FU19EQjsgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICA6IGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS50b0NvbGxlY3Rpb24oKS5wcmltYXJ5S2V5cygpO1xuICB9XG4gIGZ1bmN0aW9uIF9vbkRhdGFiYXNlQ3JlYXRlZChfYSwgbmFtZSkge1xuICAgICAgdmFyIGluZGV4ZWREQiA9IF9hLmluZGV4ZWREQiwgSURCS2V5UmFuZ2UgPSBfYS5JREJLZXlSYW5nZTtcbiAgICAgICFoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSAmJlxuICAgICAgICAgIG5hbWUgIT09IERCTkFNRVNfREIgJiZcbiAgICAgICAgICBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkucHV0KHsgbmFtZTogbmFtZSB9KS5jYXRjaChub3ApO1xuICB9XG4gIGZ1bmN0aW9uIF9vbkRhdGFiYXNlRGVsZXRlZChfYSwgbmFtZSkge1xuICAgICAgdmFyIGluZGV4ZWREQiA9IF9hLmluZGV4ZWREQiwgSURCS2V5UmFuZ2UgPSBfYS5JREJLZXlSYW5nZTtcbiAgICAgICFoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSAmJlxuICAgICAgICAgIG5hbWUgIT09IERCTkFNRVNfREIgJiZcbiAgICAgICAgICBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkuZGVsZXRlKG5hbWUpLmNhdGNoKG5vcCk7XG4gIH1cblxuICBmdW5jdGlvbiB2aXAoZm4pIHtcbiAgICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgUFNELmxldFRocm91Z2ggPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpZGJSZWFkeSgpIHtcbiAgICAgIHZhciBpc1NhZmFyaSA9ICFuYXZpZ2F0b3IudXNlckFnZW50RGF0YSAmJlxuICAgICAgICAgIC9TYWZhcmlcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAhL0Nocm9tKGV8aXVtKVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIGlmICghaXNTYWZhcmkgfHwgIWluZGV4ZWREQi5kYXRhYmFzZXMpXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgdmFyIGludGVydmFsSWQ7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICB2YXIgdHJ5SWRiID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhlZERCLmRhdGFiYXNlcygpLmZpbmFsbHkocmVzb2x2ZSk7IH07XG4gICAgICAgICAgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRyeUlkYiwgMTAwKTtcbiAgICAgICAgICB0cnlJZGIoKTtcbiAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTsgfSk7XG4gIH1cblxuICB2YXIgX2E7XG4gIGZ1bmN0aW9uIGlzRW1wdHlSYW5nZShub2RlKSB7XG4gICAgICByZXR1cm4gIShcImZyb21cIiBpbiBub2RlKTtcbiAgfVxuICB2YXIgUmFuZ2VTZXQgPSBmdW5jdGlvbiAoZnJvbU9yVHJlZSwgdG8pIHtcbiAgICAgIGlmICh0aGlzKSB7XG4gICAgICAgICAgZXh0ZW5kKHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyB7IGQ6IDEsIGZyb206IGZyb21PclRyZWUsIHRvOiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHRvIDogZnJvbU9yVHJlZSB9IDogeyBkOiAwIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHJ2ID0gbmV3IFJhbmdlU2V0KCk7XG4gICAgICAgICAgaWYgKGZyb21PclRyZWUgJiYgKFwiZFwiIGluIGZyb21PclRyZWUpKSB7XG4gICAgICAgICAgICAgIGV4dGVuZChydiwgZnJvbU9yVHJlZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBydjtcbiAgICAgIH1cbiAgfTtcbiAgcHJvcHMoUmFuZ2VTZXQucHJvdG90eXBlLCAoX2EgPSB7XG4gICAgICAgICAgYWRkOiBmdW5jdGlvbiAocmFuZ2VTZXQpIHtcbiAgICAgICAgICAgICAgbWVyZ2VSYW5nZXModGhpcywgcmFuZ2VTZXQpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFkZEtleTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICBhZGRSYW5nZSh0aGlzLCBrZXksIGtleSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkS2V5czogZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFkZFJhbmdlKF90aGlzLCBrZXksIGtleSk7IH0pO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhc0tleTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IGdldFJhbmdlU2V0SXRlcmF0b3IodGhpcykubmV4dChrZXkpLnZhbHVlO1xuICAgICAgICAgICAgICByZXR1cm4gbm9kZSAmJiBjbXAobm9kZS5mcm9tLCBrZXkpIDw9IDAgJiYgY21wKG5vZGUudG8sIGtleSkgPj0gMDtcbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2FbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXRSYW5nZVNldEl0ZXJhdG9yKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIF9hKSk7XG4gIGZ1bmN0aW9uIGFkZFJhbmdlKHRhcmdldCwgZnJvbSwgdG8pIHtcbiAgICAgIHZhciBkaWZmID0gY21wKGZyb20sIHRvKTtcbiAgICAgIGlmIChpc05hTihkaWZmKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICBpZiAoZGlmZiA+IDApXG4gICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigpO1xuICAgICAgaWYgKGlzRW1wdHlSYW5nZSh0YXJnZXQpKVxuICAgICAgICAgIHJldHVybiBleHRlbmQodGFyZ2V0LCB7IGZyb206IGZyb20sIHRvOiB0bywgZDogMSB9KTtcbiAgICAgIHZhciBsZWZ0ID0gdGFyZ2V0Lmw7XG4gICAgICB2YXIgcmlnaHQgPSB0YXJnZXQucjtcbiAgICAgIGlmIChjbXAodG8sIHRhcmdldC5mcm9tKSA8IDApIHtcbiAgICAgICAgICBsZWZ0XG4gICAgICAgICAgICAgID8gYWRkUmFuZ2UobGVmdCwgZnJvbSwgdG8pXG4gICAgICAgICAgICAgIDogKHRhcmdldC5sID0geyBmcm9tOiBmcm9tLCB0bzogdG8sIGQ6IDEsIGw6IG51bGwsIHI6IG51bGwgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlYmFsYW5jZSh0YXJnZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGNtcChmcm9tLCB0YXJnZXQudG8pID4gMCkge1xuICAgICAgICAgIHJpZ2h0XG4gICAgICAgICAgICAgID8gYWRkUmFuZ2UocmlnaHQsIGZyb20sIHRvKVxuICAgICAgICAgICAgICA6ICh0YXJnZXQuciA9IHsgZnJvbTogZnJvbSwgdG86IHRvLCBkOiAxLCBsOiBudWxsLCByOiBudWxsIH0pO1xuICAgICAgICAgIHJldHVybiByZWJhbGFuY2UodGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChjbXAoZnJvbSwgdGFyZ2V0LmZyb20pIDwgMCkge1xuICAgICAgICAgIHRhcmdldC5mcm9tID0gZnJvbTtcbiAgICAgICAgICB0YXJnZXQubCA9IG51bGw7XG4gICAgICAgICAgdGFyZ2V0LmQgPSByaWdodCA/IHJpZ2h0LmQgKyAxIDogMTtcbiAgICAgIH1cbiAgICAgIGlmIChjbXAodG8sIHRhcmdldC50bykgPiAwKSB7XG4gICAgICAgICAgdGFyZ2V0LnRvID0gdG87XG4gICAgICAgICAgdGFyZ2V0LnIgPSBudWxsO1xuICAgICAgICAgIHRhcmdldC5kID0gdGFyZ2V0LmwgPyB0YXJnZXQubC5kICsgMSA6IDE7XG4gICAgICB9XG4gICAgICB2YXIgcmlnaHRXYXNDdXRPZmYgPSAhdGFyZ2V0LnI7XG4gICAgICBpZiAobGVmdCAmJiAhdGFyZ2V0LmwpIHtcbiAgICAgICAgICBtZXJnZVJhbmdlcyh0YXJnZXQsIGxlZnQpO1xuICAgICAgfVxuICAgICAgaWYgKHJpZ2h0ICYmIHJpZ2h0V2FzQ3V0T2ZmKSB7XG4gICAgICAgICAgbWVyZ2VSYW5nZXModGFyZ2V0LCByaWdodCk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VSYW5nZXModGFyZ2V0LCBuZXdTZXQpIHtcbiAgICAgIGZ1bmN0aW9uIF9hZGRSYW5nZVNldCh0YXJnZXQsIF9hKSB7XG4gICAgICAgICAgdmFyIGZyb20gPSBfYS5mcm9tLCB0byA9IF9hLnRvLCBsID0gX2EubCwgciA9IF9hLnI7XG4gICAgICAgICAgYWRkUmFuZ2UodGFyZ2V0LCBmcm9tLCB0byk7XG4gICAgICAgICAgaWYgKGwpXG4gICAgICAgICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIGwpO1xuICAgICAgICAgIGlmIChyKVxuICAgICAgICAgICAgICBfYWRkUmFuZ2VTZXQodGFyZ2V0LCByKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNFbXB0eVJhbmdlKG5ld1NldCkpXG4gICAgICAgICAgX2FkZFJhbmdlU2V0KHRhcmdldCwgbmV3U2V0KTtcbiAgfVxuICBmdW5jdGlvbiByYW5nZXNPdmVybGFwKHJhbmdlU2V0MSwgcmFuZ2VTZXQyKSB7XG4gICAgICB2YXIgaTEgPSBnZXRSYW5nZVNldEl0ZXJhdG9yKHJhbmdlU2V0Mik7XG4gICAgICB2YXIgbmV4dFJlc3VsdDEgPSBpMS5uZXh0KCk7XG4gICAgICBpZiAobmV4dFJlc3VsdDEuZG9uZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgYSA9IG5leHRSZXN1bHQxLnZhbHVlO1xuICAgICAgdmFyIGkyID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcihyYW5nZVNldDEpO1xuICAgICAgdmFyIG5leHRSZXN1bHQyID0gaTIubmV4dChhLmZyb20pO1xuICAgICAgdmFyIGIgPSBuZXh0UmVzdWx0Mi52YWx1ZTtcbiAgICAgIHdoaWxlICghbmV4dFJlc3VsdDEuZG9uZSAmJiAhbmV4dFJlc3VsdDIuZG9uZSkge1xuICAgICAgICAgIGlmIChjbXAoYi5mcm9tLCBhLnRvKSA8PSAwICYmIGNtcChiLnRvLCBhLmZyb20pID49IDApXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIGNtcChhLmZyb20sIGIuZnJvbSkgPCAwXG4gICAgICAgICAgICAgID8gKGEgPSAobmV4dFJlc3VsdDEgPSBpMS5uZXh0KGIuZnJvbSkpLnZhbHVlKVxuICAgICAgICAgICAgICA6IChiID0gKG5leHRSZXN1bHQyID0gaTIubmV4dChhLmZyb20pKS52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmFuZ2VTZXRJdGVyYXRvcihub2RlKSB7XG4gICAgICB2YXIgc3RhdGUgPSBpc0VtcHR5UmFuZ2Uobm9kZSkgPyBudWxsIDogeyBzOiAwLCBuOiBub2RlIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgdmFyIGtleVByb3ZpZGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgIHdoaWxlIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZS5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVByb3ZpZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUubi5sICYmIGNtcChrZXksIHN0YXRlLm4uZnJvbSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4ubCwgczogMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLm4ubClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLmwsIHM6IDEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucyA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5UHJvdmlkZWQgfHwgY21wKGtleSwgc3RhdGUubi50bykgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBzdGF0ZS5uLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm4ucikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucyA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLnIsIHM6IDAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLnVwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgICB9LFxuICAgICAgfTtcbiAgfVxuICBmdW5jdGlvbiByZWJhbGFuY2UodGFyZ2V0KSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgdmFyIGRpZmYgPSAoKChfYSA9IHRhcmdldC5yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZCkgfHwgMCkgLSAoKChfYiA9IHRhcmdldC5sKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZCkgfHwgMCk7XG4gICAgICB2YXIgciA9IGRpZmYgPiAxID8gXCJyXCIgOiBkaWZmIDwgLTEgPyBcImxcIiA6IFwiXCI7XG4gICAgICBpZiAocikge1xuICAgICAgICAgIHZhciBsID0gciA9PT0gXCJyXCIgPyBcImxcIiA6IFwiclwiO1xuICAgICAgICAgIHZhciByb290Q2xvbmUgPSBfX2Fzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgICB2YXIgb2xkUm9vdFJpZ2h0ID0gdGFyZ2V0W3JdO1xuICAgICAgICAgIHRhcmdldC5mcm9tID0gb2xkUm9vdFJpZ2h0LmZyb207XG4gICAgICAgICAgdGFyZ2V0LnRvID0gb2xkUm9vdFJpZ2h0LnRvO1xuICAgICAgICAgIHRhcmdldFtyXSA9IG9sZFJvb3RSaWdodFtyXTtcbiAgICAgICAgICByb290Q2xvbmVbcl0gPSBvbGRSb290UmlnaHRbbF07XG4gICAgICAgICAgdGFyZ2V0W2xdID0gcm9vdENsb25lO1xuICAgICAgICAgIHJvb3RDbG9uZS5kID0gY29tcHV0ZURlcHRoKHJvb3RDbG9uZSk7XG4gICAgICB9XG4gICAgICB0YXJnZXQuZCA9IGNvbXB1dGVEZXB0aCh0YXJnZXQpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXB1dGVEZXB0aChfYSkge1xuICAgICAgdmFyIHIgPSBfYS5yLCBsID0gX2EubDtcbiAgICAgIHJldHVybiAociA/IChsID8gTWF0aC5tYXgoci5kLCBsLmQpIDogci5kKSA6IGwgPyBsLmQgOiAwKSArIDE7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KHRhcmdldCwgbmV3U2V0KSB7XG4gICAgICBrZXlzKG5ld1NldCkuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgIGlmICh0YXJnZXRbcGFydF0pXG4gICAgICAgICAgICAgIG1lcmdlUmFuZ2VzKHRhcmdldFtwYXJ0XSwgbmV3U2V0W3BhcnRdKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHRhcmdldFtwYXJ0XSA9IGNsb25lU2ltcGxlT2JqZWN0VHJlZShuZXdTZXRbcGFydF0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gb2JzU2V0c092ZXJsYXAob3MxLCBvczIpIHtcbiAgICAgIHJldHVybiBvczEuYWxsIHx8IG9zMi5hbGwgfHwgT2JqZWN0LmtleXMob3MxKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG9zMltrZXldICYmIHJhbmdlc092ZXJsYXAob3MyW2tleV0sIG9zMVtrZXldKTsgfSk7XG4gIH1cblxuICB2YXIgY2FjaGUgPSB7fTtcblxuICB2YXIgdW5zaWduYWxlZFBhcnRzID0ge307XG4gIHZhciBpc1Rhc2tFbnF1ZXVlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShwYXJ0LCBvcHRpbWlzdGljKSB7XG4gICAgICBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KHVuc2lnbmFsZWRQYXJ0cywgcGFydCk7XG4gICAgICBpZiAoIWlzVGFza0VucXVldWVkKSB7XG4gICAgICAgICAgaXNUYXNrRW5xdWV1ZWQgPSB0cnVlO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpc1Rhc2tFbnF1ZXVlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgcGFydHMgPSB1bnNpZ25hbGVkUGFydHM7XG4gICAgICAgICAgICAgIHVuc2lnbmFsZWRQYXJ0cyA9IHt9O1xuICAgICAgICAgICAgICBzaWduYWxTdWJzY3JpYmVyc05vdyhwYXJ0cywgZmFsc2UpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNpZ25hbFN1YnNjcmliZXJzTm93KHVwZGF0ZWRQYXJ0cywgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpIHtcbiAgICAgIGlmIChkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcyA9PT0gdm9pZCAwKSB7IGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzID0gZmFsc2U7IH1cbiAgICAgIHZhciBxdWVyaWVzVG9TaWduYWwgPSBuZXcgU2V0KCk7XG4gICAgICBpZiAodXBkYXRlZFBhcnRzLmFsbCkge1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QudmFsdWVzKGNhY2hlKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgdmFyIHRibENhY2hlID0gX2FbX2ldO1xuICAgICAgICAgICAgICBjb2xsZWN0VGFibGVTdWJzY3JpYmVycyh0YmxDYWNoZSwgdXBkYXRlZFBhcnRzLCBxdWVyaWVzVG9TaWduYWwsIGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdXBkYXRlZFBhcnRzKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0cyA9IC9eaWRiXFw6XFwvXFwvKC4qKVxcLyguKilcXC8vLmV4ZWMoa2V5KTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGJOYW1lID0gcGFydHNbMV0sIHRhYmxlTmFtZSA9IHBhcnRzWzJdO1xuICAgICAgICAgICAgICAgICAgdmFyIHRibENhY2hlID0gY2FjaGVbXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSldO1xuICAgICAgICAgICAgICAgICAgaWYgKHRibENhY2hlKVxuICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RUYWJsZVN1YnNjcmliZXJzKHRibENhY2hlLCB1cGRhdGVkUGFydHMsIHF1ZXJpZXNUb1NpZ25hbCwgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcXVlcmllc1RvU2lnbmFsLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIHJlcXVlcnkoKTsgfSk7XG4gIH1cbiAgZnVuY3Rpb24gY29sbGVjdFRhYmxlU3Vic2NyaWJlcnModGJsQ2FjaGUsIHVwZGF0ZWRQYXJ0cywgb3V0UXVlcmllc1RvU2lnbmFsLCBkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcykge1xuICAgICAgdmFyIHVwZGF0ZWRFbnRyeUxpc3RzID0gW107XG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXModGJsQ2FjaGUucXVlcmllcy5xdWVyeSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBpbmRleE5hbWUgPSBfYlswXSwgZW50cmllcyA9IF9iWzFdO1xuICAgICAgICAgIHZhciBmaWx0ZXJlZEVudHJpZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfYyA9IDAsIGVudHJpZXNfMSA9IGVudHJpZXM7IF9jIDwgZW50cmllc18xLmxlbmd0aDsgX2MrKykge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzXzFbX2NdO1xuICAgICAgICAgICAgICBpZiAob2JzU2V0c092ZXJsYXAodXBkYXRlZFBhcnRzLCBlbnRyeS5vYnNTZXQpKSB7XG4gICAgICAgICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiBvdXRRdWVyaWVzVG9TaWduYWwuYWRkKHJlcXVlcnkpOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcykge1xuICAgICAgICAgICAgICAgICAgZmlsdGVyZWRFbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcylcbiAgICAgICAgICAgICAgdXBkYXRlZEVudHJ5TGlzdHMucHVzaChbaW5kZXhOYW1lLCBmaWx0ZXJlZEVudHJpZXNdKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcykge1xuICAgICAgICAgIGZvciAodmFyIF9kID0gMCwgdXBkYXRlZEVudHJ5TGlzdHNfMSA9IHVwZGF0ZWRFbnRyeUxpc3RzOyBfZCA8IHVwZGF0ZWRFbnRyeUxpc3RzXzEubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgICAgICAgIHZhciBfZSA9IHVwZGF0ZWRFbnRyeUxpc3RzXzFbX2RdLCBpbmRleE5hbWUgPSBfZVswXSwgZmlsdGVyZWRFbnRyaWVzID0gX2VbMV07XG4gICAgICAgICAgICAgIHRibENhY2hlLnF1ZXJpZXMucXVlcnlbaW5kZXhOYW1lXSA9IGZpbHRlcmVkRW50cmllcztcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXhpZU9wZW4oZGIpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGRiLl9zdGF0ZTtcbiAgICAgIHZhciBpbmRleGVkREIgPSBkYi5fZGVwcy5pbmRleGVkREI7XG4gICAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZCB8fCBkYi5pZGJkYilcbiAgICAgICAgICByZXR1cm4gc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZS5kYk9wZW5FcnJvciA/XG4gICAgICAgICAgICAgIHJlamVjdGlvbihzdGF0ZS5kYk9wZW5FcnJvcikgOlxuICAgICAgICAgICAgICBkYjsgfSk7XG4gICAgICBzdGF0ZS5pc0JlaW5nT3BlbmVkID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbnVsbDtcbiAgICAgIHN0YXRlLm9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgdmFyIG9wZW5DYW5jZWxsZXIgPSBzdGF0ZS5vcGVuQ2FuY2VsbGVyO1xuICAgICAgdmFyIG5hdGl2ZVZlclRvT3BlbiA9IE1hdGgucm91bmQoZGIudmVybm8gKiAxMCk7XG4gICAgICB2YXIgc2NoZW1hUGF0Y2hNb2RlID0gZmFsc2U7XG4gICAgICBmdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGVkKCkge1xuICAgICAgICAgIGlmIChzdGF0ZS5vcGVuQ2FuY2VsbGVyICE9PSBvcGVuQ2FuY2VsbGVyKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgnZGIub3BlbigpIHdhcyBjYW5jZWxsZWQnKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXNvbHZlRGJSZWFkeSA9IHN0YXRlLmRiUmVhZHlSZXNvbHZlLFxuICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gbnVsbCwgd2FzQ3JlYXRlZCA9IGZhbHNlO1xuICAgICAgdmFyIHRyeU9wZW5EQiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoKTtcbiAgICAgICAgICBpZiAoIWluZGV4ZWREQilcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpO1xuICAgICAgICAgIHZhciBkYk5hbWUgPSBkYi5uYW1lO1xuICAgICAgICAgIHZhciByZXEgPSBzdGF0ZS5hdXRvU2NoZW1hIHx8ICFuYXRpdmVWZXJUb09wZW4gP1xuICAgICAgICAgICAgICBpbmRleGVkREIub3BlbihkYk5hbWUpIDpcbiAgICAgICAgICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lLCBuYXRpdmVWZXJUb09wZW4pO1xuICAgICAgICAgIGlmICghcmVxKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7XG4gICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICByZXEub25ibG9ja2VkID0gd3JhcChkYi5fZmlyZU9uQmxvY2tlZCk7XG4gICAgICAgICAgcmVxLm9udXBncmFkZW5lZWRlZCA9IHdyYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gcmVxLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuYXV0b1NjaGVtYSAmJiAhZGIuX29wdGlvbnMuYWxsb3dFbXB0eURCKSB7XG4gICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IHByZXZlbnREZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICByZXEucmVzdWx0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgZGVscmVxID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKGRiTmFtZSk7XG4gICAgICAgICAgICAgICAgICBkZWxyZXEub25zdWNjZXNzID0gZGVscmVxLm9uZXJyb3IgPSB3cmFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGV4Y2VwdGlvbnMuTm9TdWNoRGF0YWJhc2UoXCJEYXRhYmFzZSBcIi5jb25jYXQoZGJOYW1lLCBcIiBkb2VzbnQgZXhpc3RcIikpKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgIHZhciBvbGRWZXIgPSBlLm9sZFZlcnNpb24gPiBNYXRoLnBvdygyLCA2MikgPyAwIDogZS5vbGRWZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgd2FzQ3JlYXRlZCA9IG9sZFZlciA8IDE7XG4gICAgICAgICAgICAgICAgICBkYi5pZGJkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hUGF0Y2hNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGF0Y2hDdXJyZW50VmVyc2lvbihkYiwgdXBncmFkZVRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJ1blVwZ3JhZGVycyhkYiwgb2xkVmVyIC8gMTAsIHVwZ3JhZGVUcmFuc2FjdGlvbiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgaWRiZGIgPSBkYi5pZGJkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgIHZhciBvYmplY3RTdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcyk7XG4gICAgICAgICAgICAgIGlmIChvYmplY3RTdG9yZU5hbWVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBUcmFucyA9IGlkYmRiLnRyYW5zYWN0aW9uKHNhZmFyaU11bHRpU3RvcmVGaXgob2JqZWN0U3RvcmVOYW1lcyksICdyZWFkb25seScpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hdXRvU2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgZGIuX2RiU2NoZW1hLCB0bXBUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmVyaWZ5SW5zdGFsbGVkU2NoZW1hKGRiLCB0bXBUcmFucykgJiYgIXNjaGVtYVBhdGNoTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGV4aWUgU2NoZW1hRGlmZjogU2NoZW1hIHdhcyBleHRlbmRlZCB3aXRob3V0IGluY3JlYXNpbmcgdGhlIG51bWJlciBwYXNzZWQgdG8gZGIudmVyc2lvbigpLiBEZXhpZSB3aWxsIGFkZCBtaXNzaW5nIHBhcnRzIGFuZCBpbmNyZW1lbnQgbmF0aXZlIHZlcnNpb24gbnVtYmVyIHRvIHdvcmthcm91bmQgdGhpcy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGJkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlVmVyVG9PcGVuID0gaWRiZGIudmVyc2lvbiArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQYXRjaE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ5T3BlbkRCKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgdG1wVHJhbnMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29ubmVjdGlvbnMucHVzaChkYik7XG4gICAgICAgICAgICAgIGlkYmRiLm9udmVyc2lvbmNoYW5nZSA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS52Y0ZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGRiLm9uKFwidmVyc2lvbmNoYW5nZVwiKS5maXJlKGV2KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlkYmRiLm9uY2xvc2UgPSB3cmFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKHsgZGlzYWJsZUF1dG9PcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmICh3YXNDcmVhdGVkKVxuICAgICAgICAgICAgICAgICAgX29uRGF0YWJhc2VDcmVhdGVkKGRiLl9kZXBzLCBkYk5hbWUpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBzd2l0Y2ggKGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5uYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJVbmtub3duRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5QUjEzOThfbWF4TG9vcC0tO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IFdvcmthcm91bmQgZm9yIENocm9tZSBVbmtub3duRXJyb3Igb24gb3BlbigpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU9wZW5EQigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJWZXJzaW9uRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVWZXJUb09wZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmF0aXZlVmVyVG9PcGVuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5T3BlbkRCKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgIH0pOyB9O1xuICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICBvcGVuQ2FuY2VsbGVyLFxuICAgICAgICAgICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyA/IERleGllUHJvbWlzZS5yZXNvbHZlKCkgOiBpZGJSZWFkeSgpKS50aGVuKHRyeU9wZW5EQilcbiAgICAgIF0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoKTtcbiAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCA9IFtdO1xuICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSh2aXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGIub24ucmVhZHkuZmlyZShkYi52aXApOyB9KSkudGhlbihmdW5jdGlvbiBmaXJlUmVtYWluZGVycygpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZW1haW5kZXJzXzEgPSBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5yZWR1Y2UocHJvbWlzYWJsZUNoYWluLCBub3ApO1xuICAgICAgICAgICAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSh2aXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtYWluZGVyc18xKGRiLnZpcCk7IH0pKS50aGVuKGZpcmVSZW1haW5kZXJzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLm9wZW5DYW5jZWxsZXIgPT09IG9wZW5DYW5jZWxsZXIpIHtcbiAgICAgICAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBudWxsO1xuICAgICAgICAgICAgICBzdGF0ZS5pc0JlaW5nT3BlbmVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gZXJyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiAmJiB1cGdyYWRlVHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICBpZiAob3BlbkNhbmNlbGxlciA9PT0gc3RhdGUub3BlbkNhbmNlbGxlcikge1xuICAgICAgICAgICAgICBkYi5fY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlcnIpO1xuICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGUub3BlbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlRGJSZWFkeSgpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHdhc0NyZWF0ZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGV2ZXJ5dGhpbmdfMSA9IHt9O1xuICAgICAgICAgICAgICBkYi50YWJsZXMuZm9yRWFjaChmdW5jdGlvbiAodGFibGUpIHtcbiAgICAgICAgICAgICAgICAgIHRhYmxlLnNjaGVtYS5pbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHgubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlcnl0aGluZ18xW1wiaWRiOi8vXCIuY29uY2F0KGRiLm5hbWUsIFwiL1wiKS5jb25jYXQodGFibGUubmFtZSwgXCIvXCIpLmNvbmNhdChpZHgubmFtZSldID0gbmV3IFJhbmdlU2V0KC1JbmZpbml0eSwgW1tbXV1dKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgZXZlcnl0aGluZ18xW1wiaWRiOi8vXCIuY29uY2F0KGRiLm5hbWUsIFwiL1wiKS5jb25jYXQodGFibGUubmFtZSwgXCIvXCIpXSA9IGV2ZXJ5dGhpbmdfMVtcImlkYjovL1wiLmNvbmNhdChkYi5uYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlLm5hbWUsIFwiLzpkZWxzXCIpXSA9IG5ldyBSYW5nZVNldCgtSW5maW5pdHksIFtbW11dXSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUpLmZpcmUoZXZlcnl0aGluZ18xKTtcbiAgICAgICAgICAgICAgc2lnbmFsU3Vic2NyaWJlcnNOb3coZXZlcnl0aGluZ18xLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRiO1xuICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhd2FpdEl0ZXJhdG9yKGl0ZXJhdG9yKSB7XG4gICAgICB2YXIgY2FsbE5leHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBpdGVyYXRvci5uZXh0KHJlc3VsdCk7IH0sIGRvVGhyb3cgPSBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGl0ZXJhdG9yLnRocm93KGVycm9yKTsgfSwgb25TdWNjZXNzID0gc3RlcChjYWxsTmV4dCksIG9uRXJyb3IgPSBzdGVwKGRvVGhyb3cpO1xuICAgICAgZnVuY3Rpb24gc3RlcChnZXROZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgdmFyIG5leHQgPSBnZXROZXh0KHZhbCksIHZhbHVlID0gbmV4dC52YWx1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9uZSA/IHZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlLnRoZW4gIT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgICAgICAgIGlzQXJyYXkodmFsdWUpID8gUHJvbWlzZS5hbGwodmFsdWUpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKSA6IG9uU3VjY2Vzcyh2YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKSk7XG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGVwKGNhbGxOZXh0KSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdFRyYW5zYWN0aW9uQXJncyhtb2RlLCBfdGFibGVBcmdzXywgc2NvcGVGdW5jKSB7XG4gICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoaSA8IDIpXG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiVG9vIGZldyBhcmd1bWVudHNcIik7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpIC0gMSk7XG4gICAgICB3aGlsZSAoLS1pKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgc2NvcGVGdW5jID0gYXJncy5wb3AoKTtcbiAgICAgIHZhciB0YWJsZXMgPSBmbGF0dGVuKGFyZ3MpO1xuICAgICAgcmV0dXJuIFttb2RlLCB0YWJsZXMsIHNjb3BlRnVuY107XG4gIH1cbiAgZnVuY3Rpb24gZW50ZXJUcmFuc2FjdGlvblNjb3BlKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBwYXJlbnRUcmFuc2FjdGlvbiwgc2NvcGVGdW5jKSB7XG4gICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gICAgICAgICAgdmFyIHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSwgcGFyZW50VHJhbnNhY3Rpb24pO1xuICAgICAgICAgIHRyYW5zLmV4cGxpY2l0ID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgem9uZVByb3BzID0ge1xuICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgIHRyYW5zbGVzczogdHJhbnNsZXNzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgdHJhbnMuaWRidHJhbnMgPSBwYXJlbnRUcmFuc2FjdGlvbi5pZGJ0cmFucztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0cmFucy5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zLl9leHBsaWNpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBkYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT09IGVycm5hbWVzLkludmFsaWRTdGF0ZSAmJiBkYi5pc09wZW4oKSAmJiAtLWRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBOZWVkIHRvIHJlb3BlbiBkYicpO1xuICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKHsgZGlzYWJsZUF1dG9PcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIub3BlbigpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZW50ZXJUcmFuc2FjdGlvblNjb3BlKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBudWxsLCBzY29wZUZ1bmMpOyB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzY29wZUZ1bmNJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKHNjb3BlRnVuYyk7XG4gICAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJldHVyblZhbHVlO1xuICAgICAgICAgIHZhciBwcm9taXNlRm9sbG93ZWQgPSBEZXhpZVByb21pc2UuZm9sbG93KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBzY29wZUZ1bmMuY2FsbCh0cmFucywgdHJhbnMpO1xuICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3JlbWVudG9yID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMuYmluZChudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKGRlY3JlbWVudG9yLCBkZWNyZW1lbnRvcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUubmV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhyb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGF3YWl0SXRlcmF0b3IocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSwgem9uZVByb3BzKTtcbiAgICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWUpLnRoZW4oZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHRyYW5zLmFjdGl2ZSA/XG4gICAgICAgICAgICAgICAgICB4XG4gICAgICAgICAgICAgICAgICA6IHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5QcmVtYXR1cmVDb21taXQoXCJUcmFuc2FjdGlvbiBjb21taXR0ZWQgdG9vIGVhcmx5LiBTZWUgaHR0cDovL2JpdC5seS8ya2Rja01uXCIpKTsgfSlcbiAgICAgICAgICAgICAgOiBwcm9taXNlRm9sbG93ZWQudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXR1cm5WYWx1ZTsgfSkpLnRoZW4oZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgdHJhbnMuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zLl9jb21wbGV0aW9uLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfSk7XG4gICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgdHJhbnMuX3JlamVjdChlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFkKGEsIHZhbHVlLCBjb3VudCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGlzQXJyYXkoYSkgPyBhLnNsaWNlKCkgOiBbYV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpXG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlKGRvd24pIHtcbiAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG93biksIHsgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHRhYmxlID0gZG93bi50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gdGFibGUuc2NoZW1hO1xuICAgICAgICAgICAgICB2YXIgaW5kZXhMb29rdXAgPSB7fTtcbiAgICAgICAgICAgICAgdmFyIGFsbFZpcnR1YWxJbmRleGVzID0gW107XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFZpcnR1YWxJbmRleGVzKGtleVBhdGgsIGtleVRhaWwsIGxvd0xldmVsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoQWxpYXMgPSBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICB2YXIgaW5kZXhMaXN0ID0gKGluZGV4TG9va3VwW2tleVBhdGhBbGlhc10gPSBpbmRleExvb2t1cFtrZXlQYXRoQWxpYXNdIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXlMZW5ndGggPSBrZXlQYXRoID09IG51bGwgPyAwIDogdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8gMSA6IGtleVBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgdmFyIGlzVmlydHVhbCA9IGtleVRhaWwgPiAwO1xuICAgICAgICAgICAgICAgICAgdmFyIHZpcnR1YWxJbmRleCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBsb3dMZXZlbEluZGV4KSwgeyBuYW1lOiBpc1ZpcnR1YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlwiLmNvbmNhdChrZXlQYXRoQWxpYXMsIFwiKHZpcnR1YWwtZnJvbTpcIikuY29uY2F0KGxvd0xldmVsSW5kZXgubmFtZSwgXCIpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbG93TGV2ZWxJbmRleC5uYW1lLCBsb3dMZXZlbEluZGV4OiBsb3dMZXZlbEluZGV4LCBpc1ZpcnR1YWw6IGlzVmlydHVhbCwga2V5VGFpbDoga2V5VGFpbCwga2V5TGVuZ3RoOiBrZXlMZW5ndGgsIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKSwgdW5pcXVlOiAhaXNWaXJ0dWFsICYmIGxvd0xldmVsSW5kZXgudW5pcXVlIH0pO1xuICAgICAgICAgICAgICAgICAgaW5kZXhMaXN0LnB1c2godmlydHVhbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmICghdmlydHVhbEluZGV4LmlzUHJpbWFyeUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgIGFsbFZpcnR1YWxJbmRleGVzLnB1c2godmlydHVhbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChrZXlMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHZpcnR1YWxLZXlQYXRoID0ga2V5TGVuZ3RoID09PSAyID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aFswXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGguc2xpY2UoMCwga2V5TGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkVmlydHVhbEluZGV4ZXModmlydHVhbEtleVBhdGgsIGtleVRhaWwgKyAxLCBsb3dMZXZlbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGluZGV4TGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmtleVRhaWwgLSBiLmtleVRhaWw7IH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpcnR1YWxJbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGFkZFZpcnR1YWxJbmRleGVzKHNjaGVtYS5wcmltYXJ5S2V5LmtleVBhdGgsIDAsIHNjaGVtYS5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgaW5kZXhMb29rdXBbXCI6aWRcIl0gPSBbcHJpbWFyeUtleV07XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzY2hlbWEuaW5kZXhlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgIGFkZFZpcnR1YWxJbmRleGVzKGluZGV4LmtleVBhdGgsIDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiBmaW5kQmVzdEluZGV4KGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbmRleExvb2t1cFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHRbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNsYXRlUmFuZ2UocmFuZ2UsIGtleVRhaWwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogcmFuZ2UudHlwZSA9PT0gMSAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAyICA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgbG93ZXI6IHBhZChyYW5nZS5sb3dlciwgcmFuZ2UubG93ZXJPcGVuID8gZG93bi5NQVhfS0VZIDogZG93bi5NSU5fS0VZLCBrZXlUYWlsKSxcbiAgICAgICAgICAgICAgICAgICAgICBsb3dlck9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgdXBwZXI6IHBhZChyYW5nZS51cHBlciwgcmFuZ2UudXBwZXJPcGVuID8gZG93bi5NSU5fS0VZIDogZG93bi5NQVhfS0VZLCBrZXlUYWlsKSxcbiAgICAgICAgICAgICAgICAgICAgICB1cHBlck9wZW46IHRydWVcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNsYXRlUmVxdWVzdChyZXEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHJlcS5xdWVyeS5pbmRleDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleC5pc1ZpcnR1YWwgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVxKSwgeyBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgubG93TGV2ZWxJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHRyYW5zbGF0ZVJhbmdlKHJlcS5xdWVyeS5yYW5nZSwgaW5kZXgua2V5VGFpbClcbiAgICAgICAgICAgICAgICAgICAgICB9IH0pIDogcmVxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGFibGUpLCB7IHNjaGVtYTogX19hc3NpZ24oX19hc3NpZ24oe30sIHNjaGVtYSksIHsgcHJpbWFyeUtleTogcHJpbWFyeUtleSwgaW5kZXhlczogYWxsVmlydHVhbEluZGV4ZXMsIGdldEluZGV4QnlLZXlQYXRoOiBmaW5kQmVzdEluZGV4IH0pLCBjb3VudDogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5jb3VudCh0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpO1xuICAgICAgICAgICAgICAgICAgfSwgcXVlcnk6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUucXVlcnkodHJhbnNsYXRlUmVxdWVzdChyZXEpKTtcbiAgICAgICAgICAgICAgICAgIH0sIG9wZW5DdXJzb3I6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSByZXEucXVlcnkuaW5kZXgsIGtleVRhaWwgPSBfYS5rZXlUYWlsLCBpc1ZpcnR1YWwgPSBfYS5pc1ZpcnR1YWwsIGtleUxlbmd0aCA9IF9hLmtleUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmlydHVhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBfY29udGludWUoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHBhZChrZXksIHJlcS5yZXZlcnNlID8gZG93bi5NQVhfS0VZIDogZG93bi5NSU5fS0VZLCBrZXlUYWlsKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS51bmlxdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoY3Vyc29yLmtleS5zbGljZSgwLCBrZXlMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHJlcS5yZXZlcnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRvd24uTUlOX0tFWVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aXJ0dWFsQ3Vyc29yID0gT2JqZWN0LmNyZWF0ZShjdXJzb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOiB7IHZhbHVlOiBfY29udGludWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlUHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoa2V5LCBwcmltYXJ5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkocGFkKGtleSwgZG93bi5NQVhfS0VZLCBrZXlUYWlsKSwgcHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlMZW5ndGggPT09IDEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5WzBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleS5zbGljZSgwLCBrZXlMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXJ0dWFsQ3Vyc29yO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUub3BlbkN1cnNvcih0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjdXJzb3IpIHsgcmV0dXJuIGN1cnNvciAmJiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcik7IH0pO1xuICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9IH0pO1xuICB9XG4gIHZhciB2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlID0ge1xuICAgICAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gICAgICBuYW1lOiBcIlZpcnR1YWxJbmRleE1pZGRsZXdhcmVcIixcbiAgICAgIGxldmVsOiAxLFxuICAgICAgY3JlYXRlOiBjcmVhdGVWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0T2JqZWN0RGlmZihhLCBiLCBydiwgcHJmeCkge1xuICAgICAgcnYgPSBydiB8fCB7fTtcbiAgICAgIHByZnggPSBwcmZ4IHx8ICcnO1xuICAgICAga2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgaWYgKCFoYXNPd24oYiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGFwID0gYVtwcm9wXSwgYnAgPSBiW3Byb3BdO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGFwID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYnAgPT09ICdvYmplY3QnICYmIGFwICYmIGJwKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGFwKTtcbiAgICAgICAgICAgICAgICAgIHZhciBicFR5cGVOYW1lID0gdG9TdHJpbmdUYWcoYnApO1xuICAgICAgICAgICAgICAgICAgaWYgKGFwVHlwZU5hbWUgIT09IGJwVHlwZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXBUeXBlTmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBnZXRPYmplY3REaWZmKGFwLCBicCwgcnYsIHByZnggKyBwcm9wICsgJy4nKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFwICE9PSBicCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYXAgIT09IGJwKVxuICAgICAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGtleXMoYikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgIGlmICghaGFzT3duKGEsIHByb3ApKSB7XG4gICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcnY7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFZmZlY3RpdmVLZXlzKHByaW1hcnlLZXksIHJlcSkge1xuICAgICAgaWYgKHJlcS50eXBlID09PSAnZGVsZXRlJylcbiAgICAgICAgICByZXR1cm4gcmVxLmtleXM7XG4gICAgICByZXR1cm4gcmVxLmtleXMgfHwgcmVxLnZhbHVlcy5tYXAocHJpbWFyeUtleS5leHRyYWN0S2V5KTtcbiAgfVxuXG4gIHZhciBob29rc01pZGRsZXdhcmUgPSB7XG4gICAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICAgIG5hbWU6IFwiSG9va3NNaWRkbGV3YXJlXCIsXG4gICAgICBsZXZlbDogMixcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGRvd25Db3JlKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGRvd25Db3JlKSwgeyB0YWJsZTogZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgZG93blRhYmxlID0gZG93bkNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBkb3duVGFibGUuc2NoZW1hLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgIHZhciB0YWJsZU1pZGRsZXdhcmUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG93blRhYmxlKSwgeyBtdXRhdGU6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZHhUcmFucyA9IFBTRC50cmFucztcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBkeFRyYW5zLnRhYmxlKHRhYmxlTmFtZSkuaG9vaywgZGVsZXRpbmcgPSBfYS5kZWxldGluZywgY3JlYXRpbmcgPSBfYS5jcmVhdGluZywgdXBkYXRpbmcgPSBfYS51cGRhdGluZztcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlcS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRpbmcuZmlyZSA9PT0gbm9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHJlcSk7IH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwdXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0aW5nLmZpcmUgPT09IG5vcCAmJiB1cGRhdGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkUHV0T3JEZWxldGUocmVxKTsgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRpbmcuZmlyZSA9PT0gbm9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHJlcSk7IH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGVSYW5nZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRpbmcuZmlyZSA9PT0gbm9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlbGV0ZVJhbmdlKHJlcSk7IH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFB1dE9yRGVsZXRlKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHhUcmFucyA9IFBTRC50cmFucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSByZXEua2V5cyB8fCBnZXRFZmZlY3RpdmVLZXlzKHByaW1hcnlLZXksIHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gcmVxLnR5cGUgPT09ICdhZGQnIHx8IHJlcS50eXBlID09PSAncHV0JyA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXEpLCB7IGtleXM6IGtleXMgfSkgOiBfX2Fzc2lnbih7fSwgcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS50eXBlICE9PSAnZGVsZXRlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXMgPSBfX3NwcmVhZEFycmF5KFtdLCByZXEudmFsdWVzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5rZXlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmtleXMgPSBfX3NwcmVhZEFycmF5KFtdLCByZXEua2V5cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRFeGlzdGluZ1ZhbHVlcyhkb3duVGFibGUsIHJlcSwga2V5cykudGhlbihmdW5jdGlvbiAoZXhpc3RpbmdWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0cyA9IGtleXMubWFwKGZ1bmN0aW9uIChrZXksIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IGV4aXN0aW5nVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB7IG9uZXJyb3I6IG51bGwsIG9uc3VjY2VzczogbnVsbCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRpbmcuZmlyZS5jYWxsKGN0eCwga2V5LCBleGlzdGluZ1ZhbHVlLCBkeFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVxLnR5cGUgPT09ICdhZGQnIHx8IGV4aXN0aW5nVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2VuZXJhdGVkUHJpbWFyeUtleSA9IGNyZWF0aW5nLmZpcmUuY2FsbChjdHgsIGtleSwgcmVxLnZhbHVlc1tpXSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gbnVsbCAmJiBnZW5lcmF0ZWRQcmltYXJ5S2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGdlbmVyYXRlZFByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEua2V5c1tpXSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJpbWFyeUtleS5vdXRib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChyZXEudmFsdWVzW2ldLCBwcmltYXJ5S2V5LmtleVBhdGgsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3REaWZmID0gZ2V0T2JqZWN0RGlmZihleGlzdGluZ1ZhbHVlLCByZXEudmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uYWxDaGFuZ2VzXzEgPSB1cGRhdGluZy5maXJlLmNhbGwoY3R4LCBvYmplY3REaWZmLCBrZXksIGV4aXN0aW5nVmFsdWUsIGR4VHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbENoYW5nZXNfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RlZFZhbHVlXzEgPSByZXEudmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYWRkaXRpb25hbENoYW5nZXNfMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24ocmVxdWVzdGVkVmFsdWVfMSwga2V5UGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkVmFsdWVfMVtrZXlQYXRoXSA9IGFkZGl0aW9uYWxDaGFuZ2VzXzFba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgocmVxdWVzdGVkVmFsdWVfMSwga2V5UGF0aCwgYWRkaXRpb25hbENoYW5nZXNfMVtrZXlQYXRoXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKS50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzLCByZXN1bHRzID0gX2EucmVzdWx0cywgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgbGFzdFJlc3VsdCA9IF9hLmxhc3RSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmltS2V5ID0gcmVzdWx0cyA/IHJlc3VsdHNbaV0gOiBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY29udGV4dHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmltS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5vbmVycm9yICYmIGN0eC5vbmVycm9yKGZhaWx1cmVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5vbnN1Y2Nlc3MgJiYgY3R4Lm9uc3VjY2VzcyhyZXEudHlwZSA9PT0gJ3B1dCcgJiYgZXhpc3RpbmdWYWx1ZXNbaV0gP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXNbaV0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1LZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZmFpbHVyZXM6IGZhaWx1cmVzLCByZXN1bHRzOiByZXN1bHRzLCBudW1GYWlsdXJlczogbnVtRmFpbHVyZXMsIGxhc3RSZXN1bHQ6IGxhc3RSZXN1bHQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRzLmZvckVhY2goZnVuY3Rpb24gKGN0eCkgeyByZXR1cm4gY3R4Lm9uZXJyb3IgJiYgY3R4Lm9uZXJyb3IoZXJyb3IpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWxldGVSYW5nZShyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZU5leHRDaHVuayhyZXEudHJhbnMsIHJlcS5yYW5nZSwgMTAwMDApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWxldGVOZXh0Q2h1bmsodHJhbnMsIHJhbmdlLCBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLnF1ZXJ5KHsgdHJhbnM6IHRyYW5zLCB2YWx1ZXM6IGZhbHNlLCBxdWVyeTogeyBpbmRleDogcHJpbWFyeUtleSwgcmFuZ2U6IHJhbmdlIH0sIGxpbWl0OiBsaW1pdCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2EucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHsgdHlwZTogJ2RlbGV0ZScsIGtleXM6IHJlc3VsdCwgdHJhbnM6IHRyYW5zIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMubnVtRmFpbHVyZXMgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZhaWx1cmVzOiBbXSwgbnVtRmFpbHVyZXM6IDAsIGxhc3RSZXN1bHQ6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZU5leHRDaHVuayh0cmFucywgX19hc3NpZ24oX19hc3NpZ24oe30sIHJhbmdlKSwgeyBsb3dlcjogcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgbG93ZXJPcGVuOiB0cnVlIH0pLCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICAgIHJldHVybiB0YWJsZU1pZGRsZXdhcmU7XG4gICAgICAgICAgfSB9KSk7IH1cbiAgfTtcbiAgZnVuY3Rpb24gZ2V0RXhpc3RpbmdWYWx1ZXModGFibGUsIHJlcSwgZWZmZWN0aXZlS2V5cykge1xuICAgICAgcmV0dXJuIHJlcS50eXBlID09PSBcImFkZFwiXG4gICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoW10pXG4gICAgICAgICAgOiB0YWJsZS5nZXRNYW55KHsgdHJhbnM6IHJlcS50cmFucywga2V5czogZWZmZWN0aXZlS2V5cywgY2FjaGU6IFwiaW1tdXRhYmxlXCIgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShrZXlzLCBjYWNoZSwgY2xvbmUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFjYWNoZSlcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgaWYgKGNhY2hlLmtleXMubGVuZ3RoIDwga2V5cy5sZW5ndGgpXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBjYWNoZS5rZXlzLmxlbmd0aCAmJiBqIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAoY21wKGNhY2hlLmtleXNbaV0sIGtleXNbal0pICE9PSAwKVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNsb25lID8gZGVlcENsb25lKGNhY2hlLnZhbHVlc1tpXSkgOiBjYWNoZS52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSBrZXlzLmxlbmd0aCA/IHJlc3VsdCA6IG51bGw7XG4gICAgICB9XG4gICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgfVxuICB2YXIgY2FjaGVFeGlzdGluZ1ZhbHVlc01pZGRsZXdhcmUgPSB7XG4gICAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICAgIGxldmVsOiAtMSxcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0YWJsZTogZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0YWJsZSksIHsgZ2V0TWFueTogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcS5jYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmdldE1hbnkocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUocmVxLmtleXMsIHJlcS50cmFuc1tcIl9jYWNoZVwiXSwgcmVxLmNhY2hlID09PSBcImNsb25lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoY2FjaGVkUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUuZ2V0TWFueShyZXEpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRyYW5zW1wiX2NhY2hlXCJdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IHJlcS5rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogcmVxLmNhY2hlID09PSBcImNsb25lXCIgPyBkZWVwQ2xvbmUocmVzKSA6IHJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCBtdXRhdGU6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS50eXBlICE9PSBcImFkZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRyYW5zW1wiX2NhY2hlXCJdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgIH0sXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNDYWNoYWJsZUNvbnRleHQoY3R4LCB0YWJsZSkge1xuICAgICAgcmV0dXJuIChjdHgudHJhbnMubW9kZSA9PT0gJ3JlYWRvbmx5JyAmJlxuICAgICAgICAgICEhY3R4LnN1YnNjciAmJlxuICAgICAgICAgICFjdHgudHJhbnMuZXhwbGljaXQgJiZcbiAgICAgICAgICBjdHgudHJhbnMuZGIuX29wdGlvbnMuY2FjaGUgIT09ICdkaXNhYmxlZCcgJiZcbiAgICAgICAgICAhdGFibGUuc2NoZW1hLnByaW1hcnlLZXkub3V0Ym91bmQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDYWNoYWJsZVJlcXVlc3QodHlwZSwgcmVxKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdxdWVyeSc6XG4gICAgICAgICAgICAgIHJldHVybiByZXEudmFsdWVzICYmICFyZXEudW5pcXVlO1xuICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjYXNlICdnZXRNYW55JzpcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNhc2UgJ2NvdW50JzpcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNhc2UgJ29wZW5DdXJzb3InOlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICB2YXIgb2JzZXJ2YWJpbGl0eU1pZGRsZXdhcmUgPSB7XG4gICAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICAgIGxldmVsOiAwLFxuICAgICAgbmFtZTogXCJPYnNlcnZhYmlsaXR5XCIsXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIChjb3JlKSB7XG4gICAgICAgICAgdmFyIGRiTmFtZSA9IGNvcmUuc2NoZW1hLm5hbWU7XG4gICAgICAgICAgdmFyIEZVTExfUkFOR0UgPSBuZXcgUmFuZ2VTZXQoY29yZS5NSU5fS0VZLCBjb3JlLk1BWF9LRVkpO1xuICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29yZSksIHsgdHJhbnNhY3Rpb246IGZ1bmN0aW9uIChzdG9yZXMsIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChQU0Quc3Vic2NyICYmIG1vZGUgIT09ICdyZWFkb25seScpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlJlYWR3cml0ZSB0cmFuc2FjdGlvbiBpbiBsaXZlUXVlcnkgY29udGV4dC4gUXVlcmllciBzb3VyY2U6IFwiLmNvbmNhdChQU0QucXVlcmllcikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUudHJhbnNhY3Rpb24oc3RvcmVzLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgfSwgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgIHZhciBzY2hlbWEgPSB0YWJsZS5zY2hlbWE7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IHNjaGVtYS5wcmltYXJ5S2V5LCBpbmRleGVzID0gc2NoZW1hLmluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICB2YXIgZXh0cmFjdEtleSA9IHByaW1hcnlLZXkuZXh0cmFjdEtleSwgb3V0Ym91bmQgPSBwcmltYXJ5S2V5Lm91dGJvdW5kO1xuICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ZXNXaXRoQXV0b0luY1BLID0gcHJpbWFyeUtleS5hdXRvSW5jcmVtZW50ICYmIGluZGV4ZXMuZmlsdGVyKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gaW5kZXguY29tcG91bmQgJiYgaW5kZXgua2V5UGF0aC5pbmNsdWRlcyhwcmltYXJ5S2V5LmtleVBhdGgpOyB9KTtcbiAgICAgICAgICAgICAgICAgIHZhciB0YWJsZUNsb25lID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRhYmxlKSwgeyBtdXRhdGU6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gcmVxLnRyYW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZFBhcnRzID0gcmVxLm11dGF0ZWRQYXJ0cyB8fCAocmVxLm11dGF0ZWRQYXJ0cyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdldFJhbmdlU2V0ID0gZnVuY3Rpb24gKGluZGV4TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQodGFibGVOYW1lLCBcIi9cIikuY29uY2F0KGluZGV4TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG11dGF0ZWRQYXJ0c1twYXJ0XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtdXRhdGVkUGFydHNbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGtSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsc1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCI6ZGVsc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSByZXEudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gcmVxLnR5cGUgPT09IFwiZGVsZXRlUmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcmVxLnJhbmdlXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXEudHlwZSA9PT0gXCJkZWxldGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW3JlcS5rZXlzXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVxLnZhbHVlcy5sZW5ndGggPCA1MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtnZXRFZmZlY3RpdmVLZXlzKHByaW1hcnlLZXksIHJlcSkuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQ7IH0pLCByZXEudmFsdWVzXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtdLCBrZXlzID0gX2NbMF0sIG5ld09ianMgPSBfY1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZENhY2hlID0gcmVxLnRyYW5zW1wiX2NhY2hlXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShrZXlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKGtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZE9ianMgPSB0eXBlID09PSAnZGVsZXRlJyB8fCBrZXlzLmxlbmd0aCA9PT0gbmV3T2Jqcy5sZW5ndGggPyBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShrZXlzLCBvbGRDYWNoZSkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRPYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZEtleXMoa2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkT2JqcyB8fCBuZXdPYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tBZmZlY3RlZEluZGV4ZXMoZ2V0UmFuZ2VTZXQsIHNjaGVtYSwgb2xkT2JqcywgbmV3T2Jqcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IChfYSA9IGtleXMubG93ZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvcmUuTUlOX0tFWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogKF9iID0ga2V5cy51cHBlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29yZS5NQVhfS0VZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEuaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIGdldFJhbmdlU2V0KGlkeC5uYW1lKS5hZGQoRlVMTF9SQU5HRSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5tdXRhdGUocmVxKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlzICYmIChyZXEudHlwZSA9PT0gJ2FkZCcgfHwgcmVxLnR5cGUgPT09ICdwdXQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkS2V5cyhyZXMucmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ZXNXaXRoQXV0b0luY1BLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXNXaXRoQXV0b0luY1BLLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeFZhbHMgPSByZXEudmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gaWR4LmV4dHJhY3RLZXkodik7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBrUG9zID0gaWR4LmtleVBhdGguZmluZEluZGV4KGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwcm9wID09PSBwcmltYXJ5S2V5LmtleVBhdGg7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlcy5yZXN1bHRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4VmFsc1tpXVtwa1Bvc10gPSByZXMucmVzdWx0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJhbmdlU2V0KGlkeC5uYW1lKS5hZGRLZXlzKGlkeFZhbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFucy5tdXRhdGVkUGFydHMgPSBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KHRyYW5zLm11dGF0ZWRQYXJ0cyB8fCB7fSwgbXV0YXRlZFBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICAgICAgICB2YXIgZ2V0UmFuZ2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfZCA9IF9hLnF1ZXJ5LCBpbmRleCA9IF9kLmluZGV4LCByYW5nZSA9IF9kLnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUmFuZ2VTZXQoKF9iID0gcmFuZ2UubG93ZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvcmUuTUlOX0tFWSwgKF9jID0gcmFuZ2UudXBwZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGNvcmUuTUFYX0tFWSksXG4gICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB2YXIgcmVhZFN1YnNjcmliZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKHJlcSkgeyByZXR1cm4gW3ByaW1hcnlLZXksIG5ldyBSYW5nZVNldChyZXEua2V5KV07IH0sXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0TWFueTogZnVuY3Rpb24gKHJlcSkgeyByZXR1cm4gW3ByaW1hcnlLZXksIG5ldyBSYW5nZVNldCgpLmFkZEtleXMocmVxLmtleXMpXTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICBjb3VudDogZ2V0UmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGdldFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgIG9wZW5DdXJzb3I6IGdldFJhbmdlLFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGtleXMocmVhZFN1YnNjcmliZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0YWJsZUNsb25lW21ldGhvZF0gPSBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJzY3IgPSBQU0Quc3Vic2NyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNMaXZlUXVlcnkgPSAhIXN1YnNjcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hhYmxlID0gaXNDYWNoYWJsZUNvbnRleHQoUFNELCB0YWJsZSkgJiYgaXNDYWNoYWJsZVJlcXVlc3QobWV0aG9kLCByZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JzU2V0ID0gY2FjaGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVxLm9ic1NldCA9IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHN1YnNjcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGl2ZVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UmFuZ2VTZXQgPSBmdW5jdGlvbiAoaW5kZXhOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQodGFibGVOYW1lLCBcIi9cIikuY29uY2F0KGluZGV4TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChvYnNTZXRbcGFydF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9ic1NldFtwYXJ0XSA9IG5ldyBSYW5nZVNldCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBrUmFuZ2VTZXRfMSA9IGdldFJhbmdlU2V0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHNSYW5nZVNldF8xID0gZ2V0UmFuZ2VTZXQoXCI6ZGVsc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHJlYWRTdWJzY3JpYmVyc1ttZXRob2RdKHJlcSksIHF1ZXJpZWRJbmRleCA9IF9hWzBdLCBxdWVyaWVkUmFuZ2VzID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAncXVlcnknICYmIHF1ZXJpZWRJbmRleC5pc1ByaW1hcnlLZXkgJiYgIXJlcS52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXRfMS5hZGQocXVlcmllZFJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRSYW5nZVNldChxdWVyaWVkSW5kZXgubmFtZSB8fCBcIlwiKS5hZGQocXVlcmllZFJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXF1ZXJpZWRJbmRleC5pc1ByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcImNvdW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0XzEuYWRkKEZVTExfUkFOR0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXNQcm9taXNlXzEgPSBtZXRob2QgPT09IFwicXVlcnlcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLnF1ZXJ5KF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXEpLCB7IHZhbHVlczogZmFsc2UgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJxdWVyeVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kICYmIHJlcS52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXNQcm9taXNlXzEudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRpbmdLZXlzID0gX2EucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldF8xLmFkZEtleXMocmVzdWx0aW5nS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBLZXlzID0gcmVxLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlcy5yZXN1bHQubWFwKGV4dHJhY3RLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0XzEuYWRkS2V5cyhwS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXRfMS5hZGRLZXlzKHBLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRob2QgPT09IFwib3BlbkN1cnNvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvcl8xID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3YW50VmFsdWVzXzEgPSByZXEudmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3Vyc29yXzEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShjdXJzb3JfMSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZEtleShjdXJzb3JfMS5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvcl8xLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBrZXkgPSBjdXJzb3JfMS5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXRfMS5hZGRLZXkocGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwa2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FudFZhbHVlc18xICYmIHBrUmFuZ2VTZXRfMS5hZGRLZXkoY3Vyc29yXzEucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3JfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlQ2xvbmU7XG4gICAgICAgICAgICAgIH0gfSk7XG4gICAgICB9LFxuICB9O1xuICBmdW5jdGlvbiB0cmFja0FmZmVjdGVkSW5kZXhlcyhnZXRSYW5nZVNldCwgc2NoZW1hLCBvbGRPYmpzLCBuZXdPYmpzKSB7XG4gICAgICBmdW5jdGlvbiBhZGRBZmZlY3RlZEluZGV4KGl4KSB7XG4gICAgICAgICAgdmFyIHJhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoaXgubmFtZSB8fCBcIlwiKTtcbiAgICAgICAgICBmdW5jdGlvbiBleHRyYWN0S2V5KG9iaikge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqICE9IG51bGwgPyBpeC5leHRyYWN0S2V5KG9iaikgOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYWRkS2V5T3JLZXlzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gaXgubXVsdGlFbnRyeSAmJiBpc0FycmF5KGtleSlcbiAgICAgICAgICAgICAgPyBrZXkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiByYW5nZVNldC5hZGRLZXkoa2V5KTsgfSlcbiAgICAgICAgICAgICAgOiByYW5nZVNldC5hZGRLZXkoa2V5KTsgfTtcbiAgICAgICAgICAob2xkT2JqcyB8fCBuZXdPYmpzKS5mb3JFYWNoKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgICAgICAgIHZhciBvbGRLZXkgPSBvbGRPYmpzICYmIGV4dHJhY3RLZXkob2xkT2Jqc1tpXSk7XG4gICAgICAgICAgICAgIHZhciBuZXdLZXkgPSBuZXdPYmpzICYmIGV4dHJhY3RLZXkobmV3T2Jqc1tpXSk7XG4gICAgICAgICAgICAgIGlmIChjbXAob2xkS2V5LCBuZXdLZXkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICBpZiAob2xkS2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgYWRkS2V5T3JLZXlzKG9sZEtleSk7XG4gICAgICAgICAgICAgICAgICBpZiAobmV3S2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgYWRkS2V5T3JLZXlzKG5ld0tleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHNjaGVtYS5pbmRleGVzLmZvckVhY2goYWRkQWZmZWN0ZWRJbmRleCk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGp1c3RPcHRpbWlzdGljRnJvbUZhaWx1cmVzKHRibENhY2hlLCByZXEsIHJlcykge1xuICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA9PT0gMClcbiAgICAgICAgICByZXR1cm4gcmVxO1xuICAgICAgaWYgKHJlcS50eXBlID09PSAnZGVsZXRlUmFuZ2UnKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbnVtQnVsa09wcyA9IHJlcS5rZXlzXG4gICAgICAgICAgPyByZXEua2V5cy5sZW5ndGhcbiAgICAgICAgICA6ICd2YWx1ZXMnIGluIHJlcSAmJiByZXEudmFsdWVzXG4gICAgICAgICAgICAgID8gcmVxLnZhbHVlcy5sZW5ndGhcbiAgICAgICAgICAgICAgOiAxO1xuICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA9PT0gbnVtQnVsa09wcykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGNsb25lID0gX19hc3NpZ24oe30sIHJlcSk7XG4gICAgICBpZiAoaXNBcnJheShjbG9uZS5rZXlzKSkge1xuICAgICAgICAgIGNsb25lLmtleXMgPSBjbG9uZS5rZXlzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gIShpIGluIHJlcy5mYWlsdXJlcyk7IH0pO1xuICAgICAgfVxuICAgICAgaWYgKCd2YWx1ZXMnIGluIGNsb25lICYmIGlzQXJyYXkoY2xvbmUudmFsdWVzKSkge1xuICAgICAgICAgIGNsb25lLnZhbHVlcyA9IGNsb25lLnZhbHVlcy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuICEoaSBpbiByZXMuZmFpbHVyZXMpOyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQWJvdmVMb3dlcihrZXksIHJhbmdlKSB7XG4gICAgICByZXR1cm4gcmFuZ2UubG93ZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgIDogcmFuZ2UubG93ZXJPcGVuXG4gICAgICAgICAgICAgID8gY21wKGtleSwgcmFuZ2UubG93ZXIpID4gMFxuICAgICAgICAgICAgICA6IGNtcChrZXksIHJhbmdlLmxvd2VyKSA+PSAwO1xuICB9XG4gIGZ1bmN0aW9uIGlzQmVsb3dVcHBlcihrZXksIHJhbmdlKSB7XG4gICAgICByZXR1cm4gcmFuZ2UudXBwZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgIDogcmFuZ2UudXBwZXJPcGVuXG4gICAgICAgICAgICAgID8gY21wKGtleSwgcmFuZ2UudXBwZXIpIDwgMFxuICAgICAgICAgICAgICA6IGNtcChrZXksIHJhbmdlLnVwcGVyKSA8PSAwO1xuICB9XG4gIGZ1bmN0aW9uIGlzV2l0aGluUmFuZ2Uoa2V5LCByYW5nZSkge1xuICAgICAgcmV0dXJuIGlzQWJvdmVMb3dlcihrZXksIHJhbmdlKSAmJiBpc0JlbG93VXBwZXIoa2V5LCByYW5nZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseU9wdGltaXN0aWNPcHMocmVzdWx0LCByZXEsIG9wcywgdGFibGUsIGNhY2hlRW50cnksIGltbXV0YWJsZSkge1xuICAgICAgaWYgKCFvcHMgfHwgb3BzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgdmFyIGluZGV4ID0gcmVxLnF1ZXJ5LmluZGV4O1xuICAgICAgdmFyIG11bHRpRW50cnkgPSBpbmRleC5tdWx0aUVudHJ5O1xuICAgICAgdmFyIHF1ZXJ5UmFuZ2UgPSByZXEucXVlcnkucmFuZ2U7XG4gICAgICB2YXIgcHJpbWFyeUtleSA9IHRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5O1xuICAgICAgdmFyIGV4dHJhY3RQcmltS2V5ID0gcHJpbWFyeUtleS5leHRyYWN0S2V5O1xuICAgICAgdmFyIGV4dHJhY3RJbmRleCA9IGluZGV4LmV4dHJhY3RLZXk7XG4gICAgICB2YXIgZXh0cmFjdExvd0xldmVsSW5kZXggPSAoaW5kZXgubG93TGV2ZWxJbmRleCB8fCBpbmRleCkuZXh0cmFjdEtleTtcbiAgICAgIHZhciBmaW5hbFJlc3VsdCA9IG9wcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgb3ApIHtcbiAgICAgICAgICB2YXIgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICB2YXIgaW5jbHVkZWRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gJ2FkZCcgfHwgb3AudHlwZSA9PT0gJ3B1dCcpIHtcbiAgICAgICAgICAgICAgdmFyIGluY2x1ZGVkUEtzID0gbmV3IFJhbmdlU2V0KCk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBvcC52YWx1ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9wLnZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgIHZhciBwayA9IGV4dHJhY3RQcmltS2V5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlZFBLcy5oYXNLZXkocGspKVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGV4dHJhY3RJbmRleCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBpZiAobXVsdGlFbnRyeSAmJiBpc0FycmF5KGtleSlcbiAgICAgICAgICAgICAgICAgICAgICA/IGtleS5zb21lKGZ1bmN0aW9uIChrKSB7IHJldHVybiBpc1dpdGhpblJhbmdlKGssIHF1ZXJ5UmFuZ2UpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgIDogaXNXaXRoaW5SYW5nZShrZXksIHF1ZXJ5UmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZWRQS3MuYWRkS2V5KHBrKTtcbiAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnYWRkJzoge1xuICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nS2V5c18xID0gbmV3IFJhbmdlU2V0KCkuYWRkS2V5cyhyZXEudmFsdWVzID8gcmVzdWx0Lm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gZXh0cmFjdFByaW1LZXkodik7IH0pIDogcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIG1vZGlmZWRSZXN1bHQgPSByZXN1bHQuY29uY2F0KHJlcS52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICA/IGluY2x1ZGVkVmFsdWVzLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZXh0cmFjdFByaW1LZXkodik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0tleXNfMS5oYXNLZXkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdLZXlzXzEuYWRkS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlZFZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBleHRyYWN0UHJpbUtleSh2KTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdLZXlzXzEuaGFzS2V5KGspKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0tleXNfMS5hZGRLZXkoayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJ3B1dCc6IHtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXlTZXRfMSA9IG5ldyBSYW5nZVNldCgpLmFkZEtleXMob3AudmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gZXh0cmFjdFByaW1LZXkodik7IH0pKTtcbiAgICAgICAgICAgICAgICAgIG1vZGlmZWRSZXN1bHQgPSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICFrZXlTZXRfMS5oYXNLZXkocmVxLnZhbHVlcyA/IGV4dHJhY3RQcmltS2V5KGl0ZW0pIDogaXRlbSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICA/IGluY2x1ZGVkVmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlZFZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGV4dHJhY3RQcmltS2V5KHYpOyB9KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgICAgdmFyIGtleXNUb0RlbGV0ZV8xID0gbmV3IFJhbmdlU2V0KCkuYWRkS2V5cyhvcC5rZXlzKTtcbiAgICAgICAgICAgICAgICAgIG1vZGlmZWRSZXN1bHQgPSByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFrZXlzVG9EZWxldGVfMS5oYXNLZXkocmVxLnZhbHVlcyA/IGV4dHJhY3RQcmltS2V5KGl0ZW0pIDogaXRlbSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdkZWxldGVSYW5nZSc6XG4gICAgICAgICAgICAgICAgICB2YXIgcmFuZ2VfMSA9IG9wLnJhbmdlO1xuICAgICAgICAgICAgICAgICAgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICFpc1dpdGhpblJhbmdlKGV4dHJhY3RQcmltS2V5KGl0ZW0pLCByYW5nZV8xKTsgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1vZGlmZWRSZXN1bHQ7XG4gICAgICB9LCByZXN1bHQpO1xuICAgICAgaWYgKGZpbmFsUmVzdWx0ID09PSByZXN1bHQpXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGZpbmFsUmVzdWx0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gY21wKGV4dHJhY3RMb3dMZXZlbEluZGV4KGEpLCBleHRyYWN0TG93TGV2ZWxJbmRleChiKSkgfHxcbiAgICAgICAgICAgICAgY21wKGV4dHJhY3RQcmltS2V5KGEpLCBleHRyYWN0UHJpbUtleShiKSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChyZXEubGltaXQgJiYgcmVxLmxpbWl0IDwgSW5maW5pdHkpIHtcbiAgICAgICAgICBpZiAoZmluYWxSZXN1bHQubGVuZ3RoID4gcmVxLmxpbWl0KSB7XG4gICAgICAgICAgICAgIGZpbmFsUmVzdWx0Lmxlbmd0aCA9IHJlcS5saW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gcmVxLmxpbWl0ICYmIGZpbmFsUmVzdWx0Lmxlbmd0aCA8IHJlcS5saW1pdCkge1xuICAgICAgICAgICAgICBjYWNoZUVudHJ5LmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1tdXRhYmxlID8gT2JqZWN0LmZyZWV6ZShmaW5hbFJlc3VsdCkgOiBmaW5hbFJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZVJhbmdlc0VxdWFsKHIxLCByMikge1xuICAgICAgcmV0dXJuIChjbXAocjEubG93ZXIsIHIyLmxvd2VyKSA9PT0gMCAmJlxuICAgICAgICAgIGNtcChyMS51cHBlciwgcjIudXBwZXIpID09PSAwICYmXG4gICAgICAgICAgISFyMS5sb3dlck9wZW4gPT09ICEhcjIubG93ZXJPcGVuICYmXG4gICAgICAgICAgISFyMS51cHBlck9wZW4gPT09ICEhcjIudXBwZXJPcGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVMb3dlcnMobG93ZXIxLCBsb3dlcjIsIGxvd2VyT3BlbjEsIGxvd2VyT3BlbjIpIHtcbiAgICAgIGlmIChsb3dlcjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gbG93ZXIyICE9PSB1bmRlZmluZWQgPyAtMSA6IDA7XG4gICAgICBpZiAobG93ZXIyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICB2YXIgYyA9IGNtcChsb3dlcjEsIGxvd2VyMik7XG4gICAgICBpZiAoYyA9PT0gMCkge1xuICAgICAgICAgIGlmIChsb3dlck9wZW4xICYmIGxvd2VyT3BlbjIpXG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGlmIChsb3dlck9wZW4xKVxuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICBpZiAobG93ZXJPcGVuMilcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGFyZVVwcGVycyh1cHBlcjEsIHVwcGVyMiwgdXBwZXJPcGVuMSwgdXBwZXJPcGVuMikge1xuICAgICAgaWYgKHVwcGVyMSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiB1cHBlcjIgIT09IHVuZGVmaW5lZCA/IDEgOiAwO1xuICAgICAgaWYgKHVwcGVyMiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgIHZhciBjID0gY21wKHVwcGVyMSwgdXBwZXIyKTtcbiAgICAgIGlmIChjID09PSAwKSB7XG4gICAgICAgICAgaWYgKHVwcGVyT3BlbjEgJiYgdXBwZXJPcGVuMilcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgaWYgKHVwcGVyT3BlbjEpXG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICBpZiAodXBwZXJPcGVuMilcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgfVxuICBmdW5jdGlvbiBpc1N1cGVyUmFuZ2UocjEsIHIyKSB7XG4gICAgICByZXR1cm4gKGNvbXBhcmVMb3dlcnMocjEubG93ZXIsIHIyLmxvd2VyLCByMS5sb3dlck9wZW4sIHIyLmxvd2VyT3BlbikgPD0gMCAmJlxuICAgICAgICAgIGNvbXBhcmVVcHBlcnMocjEudXBwZXIsIHIyLnVwcGVyLCByMS51cHBlck9wZW4sIHIyLnVwcGVyT3BlbikgPj0gMCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQ29tcGF0aWJsZVF1ZXJ5KGRiTmFtZSwgdGFibGVOYW1lLCB0eXBlLCByZXEpIHtcbiAgICAgIHZhciB0YmxDYWNoZSA9IGNhY2hlW1wiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUpXTtcbiAgICAgIGlmICghdGJsQ2FjaGUpXG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgdmFyIHF1ZXJpZXMgPSB0YmxDYWNoZS5xdWVyaWVzW3R5cGVdO1xuICAgICAgaWYgKCFxdWVyaWVzKVxuICAgICAgICAgIHJldHVybiBbbnVsbCwgZmFsc2UsIHRibENhY2hlLCBudWxsXTtcbiAgICAgIHZhciBpbmRleE5hbWUgPSByZXEucXVlcnkgPyByZXEucXVlcnkuaW5kZXgubmFtZSA6IG51bGw7XG4gICAgICB2YXIgZW50cmllcyA9IHF1ZXJpZXNbaW5kZXhOYW1lIHx8ICcnXTtcbiAgICAgIGlmICghZW50cmllcylcbiAgICAgICAgICByZXR1cm4gW251bGwsIGZhbHNlLCB0YmxDYWNoZSwgbnVsbF07XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdxdWVyeSc6XG4gICAgICAgICAgICAgIHZhciBlcXVhbEVudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnJlcS5saW1pdCA9PT0gcmVxLmxpbWl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgZW50cnkucmVxLnZhbHVlcyA9PT0gcmVxLnZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGFyZVJhbmdlc0VxdWFsKGVudHJ5LnJlcS5xdWVyeS5yYW5nZSwgcmVxLnF1ZXJ5LnJhbmdlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChlcXVhbEVudHJ5KVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICBlcXVhbEVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgZW50cmllcyxcbiAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIHZhciBzdXBlckVudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gJ2xpbWl0JyBpbiBlbnRyeS5yZXEgPyBlbnRyeS5yZXEubGltaXQgOiBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAobGltaXQgPj0gcmVxLmxpbWl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHJlcS52YWx1ZXMgPyBlbnRyeS5yZXEudmFsdWVzIDogdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICBpc1N1cGVyUmFuZ2UoZW50cnkucmVxLnF1ZXJ5LnJhbmdlLCByZXEucXVlcnkucmFuZ2UpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBbc3VwZXJFbnRyeSwgZmFsc2UsIHRibENhY2hlLCBlbnRyaWVzXTtcbiAgICAgICAgICBjYXNlICdjb3VudCc6XG4gICAgICAgICAgICAgIHZhciBjb3VudFF1ZXJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZVJhbmdlc0VxdWFsKGVudHJ5LnJlcS5xdWVyeS5yYW5nZSwgcmVxLnF1ZXJ5LnJhbmdlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBbY291bnRRdWVyeSwgISFjb3VudFF1ZXJ5LCB0YmxDYWNoZSwgZW50cmllc107XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdWJzY3JpYmVUb0NhY2hlRW50cnkoY2FjaGVFbnRyeSwgY29udGFpbmVyLCByZXF1ZXJ5LCBzaWduYWwpIHtcbiAgICAgIGNhY2hlRW50cnkuc3Vic2NyaWJlcnMuYWRkKHJlcXVlcnkpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FjaGVFbnRyeS5zdWJzY3JpYmVycy5kZWxldGUocmVxdWVyeSk7XG4gICAgICAgICAgaWYgKGNhY2hlRW50cnkuc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICBlbnF1ZUZvckRlbGV0aW9uKGNhY2hlRW50cnksIGNvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZW5xdWVGb3JEZWxldGlvbihjYWNoZUVudHJ5LCBjb250YWluZXIpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChjYWNoZUVudHJ5LnN1YnNjcmliZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGNvbnRhaW5lciwgY2FjaGVFbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgfSwgMzAwMCk7XG4gIH1cblxuICB2YXIgY2FjaGVNaWRkbGV3YXJlID0ge1xuICAgICAgc3RhY2s6ICdkYmNvcmUnLFxuICAgICAgbGV2ZWw6IDAsXG4gICAgICBuYW1lOiAnQ2FjaGUnLFxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoY29yZSkge1xuICAgICAgICAgIHZhciBkYk5hbWUgPSBjb3JlLnNjaGVtYS5uYW1lO1xuICAgICAgICAgIHZhciBjb3JlTVcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29yZSksIHsgdHJhbnNhY3Rpb246IGZ1bmN0aW9uIChzdG9yZXMsIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpZGJ0cmFucyA9IGNvcmUudHJhbnNhY3Rpb24oc3RvcmVzLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBhY18xID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduYWwgPSBhY18xLnNpZ25hbDtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAod2FzQ29tbWl0dGVkKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFjXzEuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkd3JpdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRTdWJzY3JpYmVyc18xID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzdG9yZXNfMSA9IHN0b3JlczsgX2kgPCBzdG9yZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVOYW1lID0gc3RvcmVzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YmxDYWNoZSA9IGNhY2hlW1wiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdChzdG9yZU5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGJsQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gY29yZS50YWJsZShzdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BzID0gdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC50cmFucyA9PT0gaWRidHJhbnM7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWRidHJhbnMuX2V4cGxpY2l0ICYmIHdhc0NvbW1pdHRlZCAmJiBpZGJ0cmFucy5tdXRhdGVkUGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSBPYmplY3QudmFsdWVzKHRibENhY2hlLnF1ZXJpZXMucXVlcnkpOyBfYSA8IF9iLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gX2JbX2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gMCwgX2QgPSBlbnRyaWVzLnNsaWNlKCk7IF9jIDwgX2QubGVuZ3RoOyBfYysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9kW19jXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ic1NldHNPdmVybGFwKGVudHJ5Lm9ic1NldCwgaWRidHJhbnMubXV0YXRlZFBhcnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGVudHJpZXMsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIGFmZmVjdGVkU3Vic2NyaWJlcnNfMS5hZGQocmVxdWVyeSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZS5vcHRpbWlzdGljT3BzID0gdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC50cmFucyAhPT0gaWRidHJhbnM7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2UgPSAwLCBfZiA9IE9iamVjdC52YWx1ZXModGJsQ2FjaGUucXVlcmllcy5xdWVyeSk7IF9lIDwgX2YubGVuZ3RoOyBfZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBfZltfZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2cgPSAwLCBfaCA9IGVudHJpZXMuc2xpY2UoKTsgX2cgPCBfaC5sZW5ndGg7IF9nKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2hbX2ddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkucmVzICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkYnRyYW5zLm11dGF0ZWRQYXJ0c1xuICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YXNDb21taXR0ZWQgJiYgIWVudHJ5LmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyZWV6ZVJlc3VsdHMgPSBPYmplY3QuaXNGcm96ZW4oZW50cnkucmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kUmVzID0gYXBwbHlPcHRpbWlzdGljT3BzKGVudHJ5LnJlcywgZW50cnkucmVxLCBvcHMsIHRhYmxlLCBlbnRyeSwgZnJlZXplUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbShlbnRyaWVzLCBlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIGFmZmVjdGVkU3Vic2NyaWJlcnNfMS5hZGQocmVxdWVyeSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RSZXMgIT09IGVudHJ5LnJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZXMgPSBtb2RSZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnByb21pc2UgPSBEZXhpZVByb21pc2UucmVzb2x2ZSh7IHJlc3VsdDogbW9kUmVzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oZW50cmllcywgZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiBhZmZlY3RlZFN1YnNjcmliZXJzXzEuYWRkKHJlcXVlcnkpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkU3Vic2NyaWJlcnNfMS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiByZXF1ZXJ5KCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICBpZGJ0cmFucy5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGVuZFRyYW5zYWN0aW9uKGZhbHNlKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IHNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZGJ0cmFucy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVuZFRyYW5zYWN0aW9uKGZhbHNlKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IHNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZGJ0cmFucy5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIGVuZFRyYW5zYWN0aW9uKHRydWUpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkYnRyYW5zO1xuICAgICAgICAgICAgICB9LCB0YWJsZTogZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRvd25UYWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgIHZhciBwcmltS2V5ID0gZG93blRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlTVcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG93blRhYmxlKSwgeyBtdXRhdGU6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gUFNELnRyYW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJpbUtleS5vdXRib3VuZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMuZGIuX29wdGlvbnMuY2FjaGUgPT09ICdkaXNhYmxlZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLmV4cGxpY2l0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFucy5pZGJ0cmFucy5tb2RlICE9PSAncmVhZHdyaXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRibENhY2hlID0gY2FjaGVbXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRibENhY2hlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBkb3duVGFibGUubXV0YXRlKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVxLnR5cGUgPT09ICdhZGQnIHx8IHJlcS50eXBlID09PSAncHV0JykgJiYgKHJlcS52YWx1ZXMubGVuZ3RoID49IDUwIHx8IGdldEVmZmVjdGl2ZUtleXMocHJpbUtleSwgcmVxKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleSA9PSBudWxsOyB9KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcVdpdGhSZXNvbHZlZEtleXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVxKSwgeyB2YWx1ZXM6IHJlcS52YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5mYWlsdXJlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVXaXRoS2V5ID0gKChfYSA9IHByaW1LZXkua2V5UGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCcuJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBkZWVwQ2xvbmUodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfX2Fzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHZhbHVlV2l0aEtleSwgcHJpbUtleS5rZXlQYXRoLCByZXMucmVzdWx0c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVXaXRoS2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRqdXN0ZWRSZXEgPSBhZGp1c3RPcHRpbWlzdGljRnJvbUZhaWx1cmVzKHRibENhY2hlLCByZXFXaXRoUmVzb2x2ZWRLZXlzLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlLm9wdGltaXN0aWNPcHMucHVzaChhZGp1c3RlZFJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxLm11dGF0ZWRQYXJ0cyAmJiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShyZXEubXV0YXRlZFBhcnRzKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlLm9wdGltaXN0aWNPcHMucHVzaChyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm11dGF0ZWRQYXJ0cyAmJiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShyZXEubXV0YXRlZFBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKHRibENhY2hlLm9wdGltaXN0aWNPcHMsIHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGp1c3RlZFJlcSA9IGFkanVzdE9wdGltaXN0aWNGcm9tRmFpbHVyZXModGJsQ2FjaGUsIHJlcSwgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkanVzdGVkUmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLnB1c2goYWRqdXN0ZWRSZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5tdXRhdGVkUGFydHMgJiYgc2lnbmFsU3Vic2NyaWJlcnNMYXppbHkocmVxLm11dGF0ZWRQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0odGJsQ2FjaGUub3B0aW1pc3RpY09wcywgcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEubXV0YXRlZFBhcnRzICYmIHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5KHJlcS5tdXRhdGVkUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgfSwgcXVlcnk6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2FjaGFibGVDb250ZXh0KFBTRCwgZG93blRhYmxlKSB8fCAhaXNDYWNoYWJsZVJlcXVlc3QoXCJxdWVyeVwiLCByZXEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5xdWVyeShyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJlZXplUmVzdWx0cyA9ICgoX2EgPSBQU0QudHJhbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYi5fb3B0aW9ucy5jYWNoZSkgPT09ICdpbW11dGFibGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBQU0QsIHJlcXVlcnkgPSBfYi5yZXF1ZXJ5LCBzaWduYWwgPSBfYi5zaWduYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYyA9IGZpbmRDb21wYXRpYmxlUXVlcnkoZGJOYW1lLCB0YWJsZU5hbWUsICdxdWVyeScsIHJlcSksIGNhY2hlRW50cnkgPSBfY1swXSwgZXhhY3RNYXRjaCA9IF9jWzFdLCB0YmxDYWNoZSA9IF9jWzJdLCBjb250YWluZXIgPSBfY1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkgJiYgZXhhY3RNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVFbnRyeS5vYnNTZXQgPSByZXEub2JzU2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBkb3duVGFibGUucXVlcnkocmVxKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVFbnRyeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVFbnRyeS5yZXMgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyZWV6ZVJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSByZXN1bHQubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnJlc3VsdCA9IGRlZXBDbG9uZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lciAmJiBjYWNoZUVudHJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oY29udGFpbmVyLCBjYWNoZUVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic1NldDogcmVxLm9ic1NldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3F1ZXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXE6IHJlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJ0eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5wdXNoKGNhY2hlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gW2NhY2hlRW50cnldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGJsQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUgPSBjYWNoZVtcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQodGFibGVOYW1lKV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljT3BzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc2lnbmFsZWRQYXJ0czoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUucXVlcmllcy5xdWVyeVtyZXEucXVlcnkuaW5kZXgubmFtZSB8fCAnJ10gPSBjb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlVG9DYWNoZUVudHJ5KGNhY2hlRW50cnksIGNvbnRhaW5lciwgcmVxdWVyeSwgc2lnbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkucHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhcHBseU9wdGltaXN0aWNPcHMocmVzLnJlc3VsdCwgcmVxLCB0YmxDYWNoZSA9PT0gbnVsbCB8fCB0YmxDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGJsQ2FjaGUub3B0aW1pc3RpY09wcywgZG93blRhYmxlLCBjYWNoZUVudHJ5LCBmcmVlemVSZXN1bHRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVNVztcbiAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICByZXR1cm4gY29yZU1XO1xuICAgICAgfSxcbiAgfTtcblxuICBmdW5jdGlvbiB2aXBpZnkodGFyZ2V0LCB2aXBEYikge1xuICAgICAgcmV0dXJuIG5ldyBQcm94eSh0YXJnZXQsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9wID09PSAnZGInKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpcERiO1xuICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICB2YXIgRGV4aWUkMSA9ICAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRGV4aWUobmFtZSwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5fbWlkZGxld2FyZXMgPSB7fTtcbiAgICAgICAgICB0aGlzLnZlcm5vID0gMDtcbiAgICAgICAgICB2YXIgZGVwcyA9IERleGllLmRlcGVuZGVuY2llcztcbiAgICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyA9IF9fYXNzaWduKHtcbiAgICAgICAgICAgICAgYWRkb25zOiBEZXhpZS5hZGRvbnMsIGF1dG9PcGVuOiB0cnVlLFxuICAgICAgICAgICAgICBpbmRleGVkREI6IGRlcHMuaW5kZXhlZERCLCBJREJLZXlSYW5nZTogZGVwcy5JREJLZXlSYW5nZSwgY2FjaGU6ICdjbG9uZWQnIH0sIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuX2RlcHMgPSB7XG4gICAgICAgICAgICAgIGluZGV4ZWREQjogb3B0aW9ucy5pbmRleGVkREIsXG4gICAgICAgICAgICAgIElEQktleVJhbmdlOiBvcHRpb25zLklEQktleVJhbmdlXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgYWRkb25zID0gb3B0aW9ucy5hZGRvbnM7XG4gICAgICAgICAgdGhpcy5fZGJTY2hlbWEgPSB7fTtcbiAgICAgICAgICB0aGlzLl92ZXJzaW9ucyA9IFtdO1xuICAgICAgICAgIHRoaXMuX3N0b3JlTmFtZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9hbGxUYWJsZXMgPSB7fTtcbiAgICAgICAgICB0aGlzLmlkYmRiID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9ub3ZpcCA9IHRoaXM7XG4gICAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgICBkYk9wZW5FcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgaXNCZWluZ09wZW5lZDogZmFsc2UsXG4gICAgICAgICAgICAgIG9uUmVhZHlCZWluZ0ZpcmVkOiBudWxsLFxuICAgICAgICAgICAgICBvcGVuQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICAgICAgICBkYlJlYWR5UmVzb2x2ZTogbm9wLFxuICAgICAgICAgICAgICBkYlJlYWR5UHJvbWlzZTogbnVsbCxcbiAgICAgICAgICAgICAgY2FuY2VsT3Blbjogbm9wLFxuICAgICAgICAgICAgICBvcGVuQ2FuY2VsbGVyOiBudWxsLFxuICAgICAgICAgICAgICBhdXRvU2NoZW1hOiB0cnVlLFxuICAgICAgICAgICAgICBQUjEzOThfbWF4TG9vcDogMyxcbiAgICAgICAgICAgICAgYXV0b09wZW46IG9wdGlvbnMuYXV0b09wZW4sXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZSA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXRlLm9wZW5DYW5jZWxsZXIgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2FuY2VsT3BlbiA9IHJlamVjdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcInBvcHVsYXRlXCIsIFwiYmxvY2tlZFwiLCBcInZlcnNpb25jaGFuZ2VcIiwgXCJjbG9zZVwiLCB7IHJlYWR5OiBbcHJvbWlzYWJsZUNoYWluLCBub3BdIH0pO1xuICAgICAgICAgIHRoaXMub25jZSA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX3RoaXMub24oZXZlbnQpLnVuc3Vic2NyaWJlKGZuKTtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9uKGV2ZW50LCBmbik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLm9uLnJlYWR5LnN1YnNjcmliZSA9IG92ZXJyaWRlKHRoaXMub24ucmVhZHkuc3Vic2NyaWJlLCBmdW5jdGlvbiAoc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3Vic2NyaWJlciwgYlN0aWNreSkge1xuICAgICAgICAgICAgICAgICAgRGV4aWUudmlwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBfdGhpcy5fc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmRiT3BlbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUoKS50aGVuKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYlN0aWNreSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUub25SZWFkeUJlaW5nRmlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJTdGlja3kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYl8xID0gX3RoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYlN0aWNreSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYl8xLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiXzEub24ucmVhZHkudW5zdWJzY3JpYmUodW5zdWJzY3JpYmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5Db2xsZWN0aW9uID0gY3JlYXRlQ29sbGVjdGlvbkNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgIHRoaXMuVGFibGUgPSBjcmVhdGVUYWJsZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgIHRoaXMuVHJhbnNhY3Rpb24gPSBjcmVhdGVUcmFuc2FjdGlvbkNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgIHRoaXMuVmVyc2lvbiA9IGNyZWF0ZVZlcnNpb25Db25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICB0aGlzLldoZXJlQ2xhdXNlID0gY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICB0aGlzLm9uKFwidmVyc2lvbmNoYW5nZVwiLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgaWYgKGV2Lm5ld1ZlcnNpb24gPiAwKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIHVwZ3JhZGUgZGF0YWJhc2UgJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicuIENsb3NpbmcgZGIgbm93IHRvIHJlc3VtZSB0aGUgdXBncmFkZS5cIikpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBbm90aGVyIGNvbm5lY3Rpb24gd2FudHMgdG8gZGVsZXRlIGRhdGFiYXNlICdcIi5jb25jYXQoX3RoaXMubmFtZSwgXCInLiBDbG9zaW5nIGRiIG5vdyB0byByZXN1bWUgdGhlIGRlbGV0ZSByZXF1ZXN0LlwiKSk7XG4gICAgICAgICAgICAgIF90aGlzLmNsb3NlKHsgZGlzYWJsZUF1dG9PcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLm9uKFwiYmxvY2tlZFwiLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgaWYgKCFldi5uZXdWZXJzaW9uIHx8IGV2Lm5ld1ZlcnNpb24gPCBldi5vbGRWZXJzaW9uKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGV4aWUuZGVsZXRlKCdcIi5jb25jYXQoX3RoaXMubmFtZSwgXCInKSB3YXMgYmxvY2tlZFwiKSk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVwZ3JhZGUgJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicgYmxvY2tlZCBieSBvdGhlciBjb25uZWN0aW9uIGhvbGRpbmcgdmVyc2lvbiBcIikuY29uY2F0KGV2Lm9sZFZlcnNpb24gLyAxMCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX21heEtleSA9IGdldE1heEtleShvcHRpb25zLklEQktleVJhbmdlKTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgcGFyZW50VHJhbnNhY3Rpb24pIHsgcmV0dXJuIG5ldyBfdGhpcy5UcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgX3RoaXMuX29wdGlvbnMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5LCBwYXJlbnRUcmFuc2FjdGlvbik7IH07XG4gICAgICAgICAgdGhpcy5fZmlyZU9uQmxvY2tlZCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBfdGhpcy5vbihcImJsb2NrZWRcIikuZmlyZShldik7XG4gICAgICAgICAgICAgIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLm5hbWUgPT09IF90aGlzLm5hbWUgJiYgYyAhPT0gX3RoaXMgJiYgIWMuX3N0YXRlLnZjRmlyZWQ7IH0pXG4gICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLm9uKFwidmVyc2lvbmNoYW5nZVwiKS5maXJlKGV2KTsgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLnVzZShjYWNoZUV4aXN0aW5nVmFsdWVzTWlkZGxld2FyZSk7XG4gICAgICAgICAgdGhpcy51c2UoY2FjaGVNaWRkbGV3YXJlKTtcbiAgICAgICAgICB0aGlzLnVzZShvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSk7XG4gICAgICAgICAgdGhpcy51c2UodmlydHVhbEluZGV4TWlkZGxld2FyZSk7XG4gICAgICAgICAgdGhpcy51c2UoaG9va3NNaWRkbGV3YXJlKTtcbiAgICAgICAgICB2YXIgdmlwREIgPSBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChfLCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdfdmlwJylcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAndGFibGUnKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFibGVOYW1lKSB7IHJldHVybiB2aXBpZnkoX3RoaXMudGFibGUodGFibGVOYW1lKSwgdmlwREIpOyB9O1xuICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gUmVmbGVjdC5nZXQoXywgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJ2IGluc3RhbmNlb2YgVGFibGUpXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpcGlmeShydiwgdmlwREIpO1xuICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICd0YWJsZXMnKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBydi5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHZpcGlmeSh0LCB2aXBEQik7IH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdfY3JlYXRlVHJhbnNhY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eCA9IHJ2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXBpZnkodHgsIHZpcERCKTtcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy52aXAgPSB2aXBEQjtcbiAgICAgICAgICBhZGRvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWRkb24pIHsgcmV0dXJuIGFkZG9uKF90aGlzKTsgfSk7XG4gICAgICB9XG4gICAgICBEZXhpZS5wcm90b3R5cGUudmVyc2lvbiA9IGZ1bmN0aW9uICh2ZXJzaW9uTnVtYmVyKSB7XG4gICAgICAgICAgaWYgKGlzTmFOKHZlcnNpb25OdW1iZXIpIHx8IHZlcnNpb25OdW1iZXIgPCAwLjEpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlR5cGUoXCJHaXZlbiB2ZXJzaW9uIGlzIG5vdCBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgICB2ZXJzaW9uTnVtYmVyID0gTWF0aC5yb3VuZCh2ZXJzaW9uTnVtYmVyICogMTApIC8gMTA7XG4gICAgICAgICAgaWYgKHRoaXMuaWRiZGIgfHwgdGhpcy5fc3RhdGUuaXNCZWluZ09wZW5lZClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiQ2Fubm90IGFkZCB2ZXJzaW9uIHdoZW4gZGF0YWJhc2UgaXMgb3BlblwiKTtcbiAgICAgICAgICB0aGlzLnZlcm5vID0gTWF0aC5tYXgodGhpcy52ZXJubywgdmVyc2lvbk51bWJlcik7XG4gICAgICAgICAgdmFyIHZlcnNpb25zID0gdGhpcy5fdmVyc2lvbnM7XG4gICAgICAgICAgdmFyIHZlcnNpb25JbnN0YW5jZSA9IHZlcnNpb25zLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gdi5fY2ZnLnZlcnNpb24gPT09IHZlcnNpb25OdW1iZXI7IH0pWzBdO1xuICAgICAgICAgIGlmICh2ZXJzaW9uSW5zdGFuY2UpXG4gICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uSW5zdGFuY2U7XG4gICAgICAgICAgdmVyc2lvbkluc3RhbmNlID0gbmV3IHRoaXMuVmVyc2lvbih2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICB2ZXJzaW9ucy5wdXNoKHZlcnNpb25JbnN0YW5jZSk7XG4gICAgICAgICAgdmVyc2lvbnMuc29ydChsb3dlclZlcnNpb25GaXJzdCk7XG4gICAgICAgICAgdmVyc2lvbkluc3RhbmNlLnN0b3Jlcyh7fSk7XG4gICAgICAgICAgdGhpcy5fc3RhdGUuYXV0b1NjaGVtYSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiB2ZXJzaW9uSW5zdGFuY2U7XG4gICAgICB9O1xuICAgICAgRGV4aWUucHJvdG90eXBlLl93aGVuUmVhZHkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiAodGhpcy5pZGJkYiAmJiAodGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlIHx8IFBTRC5sZXRUaHJvdWdoIHx8IHRoaXMuX3ZpcCkpID8gZm4oKSA6IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMuX3N0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZChfdGhpcy5fc3RhdGUuZGJPcGVuRXJyb3IpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIV90aGlzLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9zdGF0ZS5hdXRvT3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfdGhpcy5vcGVuKCkuY2F0Y2gobm9wKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfdGhpcy5fc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pLnRoZW4oZm4pO1xuICAgICAgfTtcbiAgICAgIERleGllLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBfYS5zdGFjaywgY3JlYXRlID0gX2EuY3JlYXRlLCBsZXZlbCA9IF9hLmxldmVsLCBuYW1lID0gX2EubmFtZTtcbiAgICAgICAgICBpZiAobmFtZSlcbiAgICAgICAgICAgICAgdGhpcy51bnVzZSh7IHN0YWNrOiBzdGFjaywgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgICB2YXIgbWlkZGxld2FyZXMgPSB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gfHwgKHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSA9IFtdKTtcbiAgICAgICAgICBtaWRkbGV3YXJlcy5wdXNoKHsgc3RhY2s6IHN0YWNrLCBjcmVhdGU6IGNyZWF0ZSwgbGV2ZWw6IGxldmVsID09IG51bGwgPyAxMCA6IGxldmVsLCBuYW1lOiBuYW1lIH0pO1xuICAgICAgICAgIG1pZGRsZXdhcmVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEubGV2ZWwgLSBiLmxldmVsOyB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBEZXhpZS5wcm90b3R5cGUudW51c2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBfYS5zdGFjaywgbmFtZSA9IF9hLm5hbWUsIGNyZWF0ZSA9IF9hLmNyZWF0ZTtcbiAgICAgICAgICBpZiAoc3RhY2sgJiYgdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSA9IHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXS5maWx0ZXIoZnVuY3Rpb24gKG13KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlID8gbXcuY3JlYXRlICE9PSBjcmVhdGUgOlxuICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPyBtdy5uYW1lICE9PSBuYW1lIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2U7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBEZXhpZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiB1c2VQU0QoZ2xvYmFsUFNELFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRleGllT3BlbihfdGhpcyk7IH0pO1xuICAgICAgfTtcbiAgICAgIERleGllLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5vbi5jbG9zZS5maXJlKG5ldyBDdXN0b21FdmVudCgnY2xvc2UnKSk7XG4gICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgICAgdmFyIGlkeCA9IGNvbm5lY3Rpb25zLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgaWYgKGlkeCA+PSAwKVxuICAgICAgICAgICAgICBjb25uZWN0aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICBpZiAodGhpcy5pZGJkYikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5pZGJkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgICAgdGhpcy5pZGJkYiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZSA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHN0YXRlLm9wZW5DYW5jZWxsZXIgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLmNhbmNlbE9wZW4gPSByZWplY3Q7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBEZXhpZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8geyBkaXNhYmxlQXV0b09wZW46IHRydWUgfSA6IF9hLCBkaXNhYmxlQXV0b09wZW4gPSBfYi5kaXNhYmxlQXV0b09wZW47XG4gICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgICAgaWYgKGRpc2FibGVBdXRvT3Blbikge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICAgICAgc3RhdGUuY2FuY2VsT3BlbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9jbG9zZSgpO1xuICAgICAgICAgICAgICBzdGF0ZS5hdXRvT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9jbG9zZSgpO1xuICAgICAgICAgICAgICBzdGF0ZS5hdXRvT3BlbiA9IHRoaXMuX29wdGlvbnMuYXV0b09wZW4gfHxcbiAgICAgICAgICAgICAgICAgIHN0YXRlLmlzQmVpbmdPcGVuZWQ7XG4gICAgICAgICAgICAgIHN0YXRlLm9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIERleGllLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoY2xvc2VPcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAoY2xvc2VPcHRpb25zID09PSB2b2lkIDApIHsgY2xvc2VPcHRpb25zID0geyBkaXNhYmxlQXV0b09wZW46IHRydWUgfTsgfVxuICAgICAgICAgIHZhciBoYXNJbnZhbGlkQXJndW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCc7XG4gICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICB2YXIgZG9EZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZShjbG9zZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IF90aGlzLl9kZXBzLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShfdGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfb25EYXRhYmFzZURlbGV0ZWQoX3RoaXMuX2RlcHMsIF90aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgIHJlcS5vbmJsb2NrZWQgPSBfdGhpcy5fZmlyZU9uQmxvY2tlZDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKGhhc0ludmFsaWRBcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJJbnZhbGlkIGNsb3NlT3B0aW9ucyBhcmd1bWVudCB0byBkYi5kZWxldGUoKVwiKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oZG9EZWxldGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZG9EZWxldGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIERleGllLnByb3RvdHlwZS5iYWNrZW5kREIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaWRiZGI7XG4gICAgICB9O1xuICAgICAgRGV4aWUucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pZGJkYiAhPT0gbnVsbDtcbiAgICAgIH07XG4gICAgICBEZXhpZS5wcm90b3R5cGUuaGFzQmVlbkNsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZGJPcGVuRXJyb3IgPSB0aGlzLl9zdGF0ZS5kYk9wZW5FcnJvcjtcbiAgICAgICAgICByZXR1cm4gZGJPcGVuRXJyb3IgJiYgKGRiT3BlbkVycm9yLm5hbWUgPT09ICdEYXRhYmFzZUNsb3NlZCcpO1xuICAgICAgfTtcbiAgICAgIERleGllLnByb3RvdHlwZS5oYXNGYWlsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yICE9PSBudWxsO1xuICAgICAgfTtcbiAgICAgIERleGllLnByb3RvdHlwZS5keW5hbWljYWxseU9wZW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuYXV0b1NjaGVtYTtcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGV4aWUucHJvdG90eXBlLCBcInRhYmxlc1wiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgIHJldHVybiBrZXlzKHRoaXMuX2FsbFRhYmxlcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5fYWxsVGFibGVzW25hbWVdOyB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBEZXhpZS5wcm90b3R5cGUudHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBleHRyYWN0VHJhbnNhY3Rpb25BcmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICAgIERleGllLnByb3RvdHlwZS5fdHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAobW9kZSwgdGFibGVzLCBzY29wZUZ1bmMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBwYXJlbnRUcmFuc2FjdGlvbiA9IFBTRC50cmFucztcbiAgICAgICAgICBpZiAoIXBhcmVudFRyYW5zYWN0aW9uIHx8IHBhcmVudFRyYW5zYWN0aW9uLmRiICE9PSB0aGlzIHx8IG1vZGUuaW5kZXhPZignIScpICE9PSAtMSlcbiAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgIHZhciBvbmx5SWZDb21wYXRpYmxlID0gbW9kZS5pbmRleE9mKCc/JykgIT09IC0xO1xuICAgICAgICAgIG1vZGUgPSBtb2RlLnJlcGxhY2UoJyEnLCAnJykucmVwbGFjZSgnPycsICcnKTtcbiAgICAgICAgICB2YXIgaWRiTW9kZSwgc3RvcmVOYW1lcztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZU5hbWVzID0gdGFibGVzLm1hcChmdW5jdGlvbiAodGFibGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSB0YWJsZSBpbnN0YW5jZW9mIF90aGlzLlRhYmxlID8gdGFibGUubmFtZSA6IHRhYmxlO1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZU5hbWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRhYmxlIGFyZ3VtZW50IHRvIERleGllLnRyYW5zYWN0aW9uKCkuIE9ubHkgVGFibGUgb3IgU3RyaW5nIGFyZSBhbGxvd2VkXCIpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlTmFtZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChtb2RlID09IFwiclwiIHx8IG1vZGUgPT09IFJFQURPTkxZKVxuICAgICAgICAgICAgICAgICAgaWRiTW9kZSA9IFJFQURPTkxZO1xuICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09IFwicndcIiB8fCBtb2RlID09IFJFQURXUklURSlcbiAgICAgICAgICAgICAgICAgIGlkYk1vZGUgPSBSRUFEV1JJVEU7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgdHJhbnNhY3Rpb24gbW9kZTogXCIgKyBtb2RlKTtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24ubW9kZSA9PT0gUkVBRE9OTFkgJiYgaWRiTW9kZSA9PT0gUkVBRFdSSVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiQ2Fubm90IGVudGVyIGEgc3ViLXRyYW5zYWN0aW9uIHdpdGggUkVBRFdSSVRFIG1vZGUgd2hlbiBwYXJlbnQgdHJhbnNhY3Rpb24gaXMgUkVBRE9OTFlcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24gJiYgcGFyZW50VHJhbnNhY3Rpb24uc3RvcmVOYW1lcy5pbmRleE9mKHN0b3JlTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TdWJUcmFuc2FjdGlvbihcIlRhYmxlIFwiICsgc3RvcmVOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgbm90IGluY2x1ZGVkIGluIHBhcmVudCB0cmFuc2FjdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlICYmIHBhcmVudFRyYW5zYWN0aW9uICYmICFwYXJlbnRUcmFuc2FjdGlvbi5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFRyYW5zYWN0aW9uID9cbiAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKG51bGwsIGZ1bmN0aW9uIChfLCByZWplY3QpIHsgcmVqZWN0KGUpOyB9KSA6XG4gICAgICAgICAgICAgICAgICByZWplY3Rpb24oZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbnRlclRyYW5zYWN0aW9uID0gZW50ZXJUcmFuc2FjdGlvblNjb3BlLmJpbmQobnVsbCwgdGhpcywgaWRiTW9kZSwgc3RvcmVOYW1lcywgcGFyZW50VHJhbnNhY3Rpb24sIHNjb3BlRnVuYyk7XG4gICAgICAgICAgcmV0dXJuIChwYXJlbnRUcmFuc2FjdGlvbiA/XG4gICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKGlkYk1vZGUsIGVudGVyVHJhbnNhY3Rpb24sIFwibG9ja1wiKSA6XG4gICAgICAgICAgICAgIFBTRC50cmFucyA/XG4gICAgICAgICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uKTsgfSkgOlxuICAgICAgICAgICAgICAgICAgdGhpcy5fd2hlblJlYWR5KGVudGVyVHJhbnNhY3Rpb24pKTtcbiAgICAgIH07XG4gICAgICBEZXhpZS5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNPd24odGhpcy5fYWxsVGFibGVzLCB0YWJsZU5hbWUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRUYWJsZShcIlRhYmxlIFwiLmNvbmNhdCh0YWJsZU5hbWUsIFwiIGRvZXMgbm90IGV4aXN0XCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FsbFRhYmxlc1t0YWJsZU5hbWVdO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBEZXhpZTtcbiAgfSgpKTtcblxuICB2YXIgc3ltYm9sT2JzZXJ2YWJsZSA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJvYnNlcnZhYmxlXCIgaW4gU3ltYm9sXG4gICAgICA/IFN5bWJvbC5vYnNlcnZhYmxlXG4gICAgICA6IFwiQEBvYnNlcnZhYmxlXCI7XG4gIHZhciBPYnNlcnZhYmxlID0gIChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgIH1cbiAgICAgIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICh4LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKCF4IHx8IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB7IG5leHQ6IHgsIGVycm9yOiBlcnJvciwgY29tcGxldGU6IGNvbXBsZXRlIH0gOiB4KTtcbiAgICAgIH07XG4gICAgICBPYnNlcnZhYmxlLnByb3RvdHlwZVtzeW1ib2xPYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICByZXR1cm4gT2JzZXJ2YWJsZTtcbiAgfSgpKTtcblxuICB2YXIgZG9tRGVwcztcbiAgdHJ5IHtcbiAgICAgIGRvbURlcHMgPSB7XG4gICAgICAgICAgaW5kZXhlZERCOiBfZ2xvYmFsLmluZGV4ZWREQiB8fCBfZ2xvYmFsLm1vekluZGV4ZWREQiB8fCBfZ2xvYmFsLndlYmtpdEluZGV4ZWREQiB8fCBfZ2xvYmFsLm1zSW5kZXhlZERCLFxuICAgICAgICAgIElEQktleVJhbmdlOiBfZ2xvYmFsLklEQktleVJhbmdlIHx8IF9nbG9iYWwud2Via2l0SURCS2V5UmFuZ2VcbiAgICAgIH07XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICAgIGRvbURlcHMgPSB7IGluZGV4ZWREQjogbnVsbCwgSURCS2V5UmFuZ2U6IG51bGwgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpdmVRdWVyeShxdWVyaWVyKSB7XG4gICAgICB2YXIgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgIHZhciBjdXJyZW50VmFsdWU7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgIHZhciBzY29wZUZ1bmNJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKHF1ZXJpZXIpO1xuICAgICAgICAgIGZ1bmN0aW9uIGV4ZWN1dGUoY3R4KSB7XG4gICAgICAgICAgICAgIHZhciB3YXNSb290RXhlYyA9IGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBydiA9IG5ld1Njb3BlKHF1ZXJpZXIsIGN0eCk7XG4gICAgICAgICAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgIHJ2ID0gcnYuZmluYWxseShkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICB3YXNSb290RXhlYyAmJiBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgYWJvcnRDb250cm9sbGVyO1xuICAgICAgICAgIHZhciBhY2N1bU11dHMgPSB7fTtcbiAgICAgICAgICB2YXIgY3VycmVudE9icyA9IHt9O1xuICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VkO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlZClcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlcilcbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzdGFydGVkTGlzdGVuaW5nKVxuICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC51bnN1YnNjcmliZShtdXRhdGlvbkxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIG9ic2VydmVyLnN0YXJ0ICYmIG9ic2VydmVyLnN0YXJ0KHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgdmFyIHN0YXJ0ZWRMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgZG9RdWVyeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4ZWNJbkdsb2JhbENvbnRleHQoX2RvUXVlcnkpOyB9O1xuICAgICAgICAgIGZ1bmN0aW9uIHNob3VsZE5vdGlmeSgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9ic1NldHNPdmVybGFwKGN1cnJlbnRPYnMsIGFjY3VtTXV0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtdXRhdGlvbkxpc3RlbmVyID0gZnVuY3Rpb24gKHBhcnRzKSB7XG4gICAgICAgICAgICAgIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQoYWNjdW1NdXRzLCBwYXJ0cyk7XG4gICAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnkoKSkge1xuICAgICAgICAgICAgICAgICAgZG9RdWVyeSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgX2RvUXVlcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChjbG9zZWQgfHxcbiAgICAgICAgICAgICAgICAgICFkb21EZXBzLmluZGV4ZWREQilcbiAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhY2N1bU11dHMgPSB7fTtcbiAgICAgICAgICAgICAgdmFyIHN1YnNjciA9IHt9O1xuICAgICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyKVxuICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgICAgdmFyIGN0eCA9IHtcbiAgICAgICAgICAgICAgICAgIHN1YnNjcjogc3Vic2NyLFxuICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgcmVxdWVyeTogZG9RdWVyeSxcbiAgICAgICAgICAgICAgICAgIHF1ZXJpZXI6IHF1ZXJpZXIsXG4gICAgICAgICAgICAgICAgICB0cmFuczogbnVsbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB2YXIgcmV0ID0gZXhlY3V0ZShjdHgpO1xuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUocmV0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIGlmIChjbG9zZWQgfHwgY3R4LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYWNjdW1NdXRzID0ge307XG4gICAgICAgICAgICAgICAgICBjdXJyZW50T2JzID0gc3Vic2NyO1xuICAgICAgICAgICAgICAgICAgaWYgKCFvYmplY3RJc0VtcHR5KGN1cnJlbnRPYnMpICYmICFzdGFydGVkTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCBtdXRhdGlvbkxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydGVkTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGV4ZWNJbkdsb2JhbENvbnRleHQoZnVuY3Rpb24gKCkgeyByZXR1cm4gIWNsb3NlZCAmJiBvYnNlcnZlci5uZXh0ICYmIG9ic2VydmVyLm5leHQocmVzdWx0KTsgfSk7XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBpZiAoIVsnRGF0YWJhc2VDbG9zZWRFcnJvcicsICdBYm9ydEVycm9yJ10uaW5jbHVkZXMoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNJbkdsb2JhbENvbnRleHQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvciAmJiBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGRvUXVlcnksIDApO1xuICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICB9KTtcbiAgICAgIG9ic2VydmFibGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNWYWx1ZTsgfTtcbiAgICAgIG9ic2VydmFibGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJyZW50VmFsdWU7IH07XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgfVxuXG4gIHZhciBEZXhpZSA9IERleGllJDE7XG4gIHByb3BzKERleGllLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZnVsbE5hbWVFeGNlcHRpb25zKSwge1xuICAgICAgZGVsZXRlOiBmdW5jdGlvbiAoZGF0YWJhc2VOYW1lKSB7XG4gICAgICAgICAgdmFyIGRiID0gbmV3IERleGllKGRhdGFiYXNlTmFtZSwgeyBhZGRvbnM6IFtdIH0pO1xuICAgICAgICAgIHJldHVybiBkYi5kZWxldGUoKTtcbiAgICAgIH0sXG4gICAgICBleGlzdHM6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZShuYW1lLCB7IGFkZG9uczogW10gfSkub3BlbigpLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0pLmNhdGNoKCdOb1N1Y2hEYXRhYmFzZUVycm9yJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuICAgICAgfSxcbiAgICAgIGdldERhdGFiYXNlTmFtZXM6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXREYXRhYmFzZU5hbWVzKERleGllLmRlcGVuZGVuY2llcykudGhlbihjYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKSk7XG4gICAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlZmluZUNsYXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZnVuY3Rpb24gQ2xhc3MoY29udGVudCkge1xuICAgICAgICAgICAgICBleHRlbmQodGhpcywgY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBDbGFzcztcbiAgICAgIH0sIGlnbm9yZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoc2NvcGVGdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIFBTRC50cmFucyA/XG4gICAgICAgICAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCBzY29wZUZ1bmMpIDpcbiAgICAgICAgICAgICAgc2NvcGVGdW5jKCk7XG4gICAgICB9LCB2aXA6IHZpcCwgYXN5bmM6IGZ1bmN0aW9uIChnZW5lcmF0b3JGbikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcnYgPSBhd2FpdEl0ZXJhdG9yKGdlbmVyYXRvckZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFydiB8fCB0eXBlb2YgcnYudGhlbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUocnYpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgIH0sIHNwYXduOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm4sIGFyZ3MsIHRoaXopIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgcnYgPSBhd2FpdEl0ZXJhdG9yKGdlbmVyYXRvckZuLmFwcGx5KHRoaXosIGFyZ3MgfHwgW10pKTtcbiAgICAgICAgICAgICAgaWYgKCFydiB8fCB0eXBlb2YgcnYudGhlbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShydik7XG4gICAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3VycmVudFRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQU0QudHJhbnMgfHwgbnVsbDsgfVxuICAgICAgfSwgd2FpdEZvcjogZnVuY3Rpb24gKHByb21pc2VPckZ1bmN0aW9uLCBvcHRpb25hbFRpbWVvdXQpIHtcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHR5cGVvZiBwcm9taXNlT3JGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKHByb21pc2VPckZ1bmN0aW9uKSA6XG4gICAgICAgICAgICAgIHByb21pc2VPckZ1bmN0aW9uKVxuICAgICAgICAgICAgICAudGltZW91dChvcHRpb25hbFRpbWVvdXQgfHwgNjAwMDApO1xuICAgICAgICAgIHJldHVybiBQU0QudHJhbnMgP1xuICAgICAgICAgICAgICBQU0QudHJhbnMud2FpdEZvcihwcm9taXNlKSA6XG4gICAgICAgICAgICAgIHByb21pc2U7XG4gICAgICB9LFxuICAgICAgUHJvbWlzZTogRGV4aWVQcm9taXNlLFxuICAgICAgZGVidWc6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlYnVnOyB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHNldERlYnVnKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVyaXZlOiBkZXJpdmUsIGV4dGVuZDogZXh0ZW5kLCBwcm9wczogcHJvcHMsIG92ZXJyaWRlOiBvdmVycmlkZSxcbiAgICAgIEV2ZW50czogRXZlbnRzLCBvbjogZ2xvYmFsRXZlbnRzLCBsaXZlUXVlcnk6IGxpdmVRdWVyeSwgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldDogZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCxcbiAgICAgIGdldEJ5S2V5UGF0aDogZ2V0QnlLZXlQYXRoLCBzZXRCeUtleVBhdGg6IHNldEJ5S2V5UGF0aCwgZGVsQnlLZXlQYXRoOiBkZWxCeUtleVBhdGgsIHNoYWxsb3dDbG9uZTogc2hhbGxvd0Nsb25lLCBkZWVwQ2xvbmU6IGRlZXBDbG9uZSwgZ2V0T2JqZWN0RGlmZjogZ2V0T2JqZWN0RGlmZiwgY21wOiBjbXAsIGFzYXA6IGFzYXAkMSxcbiAgICAgIG1pbktleTogbWluS2V5LFxuICAgICAgYWRkb25zOiBbXSxcbiAgICAgIGNvbm5lY3Rpb25zOiBjb25uZWN0aW9ucyxcbiAgICAgIGVycm5hbWVzOiBlcnJuYW1lcyxcbiAgICAgIGRlcGVuZGVuY2llczogZG9tRGVwcywgY2FjaGU6IGNhY2hlLFxuICAgICAgc2VtVmVyOiBERVhJRV9WRVJTSU9OLCB2ZXJzaW9uOiBERVhJRV9WRVJTSU9OLnNwbGl0KCcuJylcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBwYXJzZUludChuKTsgfSlcbiAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChwLCBjLCBpKSB7IHJldHVybiBwICsgKGMgLyBNYXRoLnBvdygxMCwgaSAqIDIpKTsgfSkgfSkpO1xuICBEZXhpZS5tYXhLZXkgPSBnZXRNYXhLZXkoRGV4aWUuZGVwZW5kZW5jaWVzLklEQktleVJhbmdlKTtcblxuICBpZiAodHlwZW9mIGRpc3BhdGNoRXZlbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCBmdW5jdGlvbiAodXBkYXRlZFBhcnRzKSB7XG4gICAgICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcbiAgICAgICAgICAgICAgdmFyIGV2ZW50XzE7XG4gICAgICAgICAgICAgIGV2ZW50XzEgPSBuZXcgQ3VzdG9tRXZlbnQoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCB7XG4gICAgICAgICAgICAgICAgICBkZXRhaWw6IHVwZGF0ZWRQYXJ0c1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudChldmVudF8xKTtcbiAgICAgICAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgdmFyIGRldGFpbCA9IF9hLmRldGFpbDtcbiAgICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICAgICAgICBwcm9wYWdhdGVMb2NhbGx5KGRldGFpbCk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvcGFnYXRlTG9jYWxseSh1cGRhdGVQYXJ0cykge1xuICAgICAgdmFyIHdhc01lID0gcHJvcGFnYXRpbmdMb2NhbGx5O1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB0cnVlO1xuICAgICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKHVwZGF0ZVBhcnRzKTtcbiAgICAgICAgICBzaWduYWxTdWJzY3JpYmVyc05vdyh1cGRhdGVQYXJ0cywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB3YXNNZTtcbiAgICAgIH1cbiAgfVxuICB2YXIgcHJvcGFnYXRpbmdMb2NhbGx5ID0gZmFsc2U7XG5cbiAgdmFyIGJjO1xuICB2YXIgY3JlYXRlQkMgPSBmdW5jdGlvbiAoKSB7IH07XG4gIGlmICh0eXBlb2YgQnJvYWRjYXN0Q2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNyZWF0ZUJDID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FKTtcbiAgICAgICAgICBiYy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIGV2LmRhdGEgJiYgcHJvcGFnYXRlTG9jYWxseShldi5kYXRhKTsgfTtcbiAgICAgIH07XG4gICAgICBjcmVhdGVCQygpO1xuICAgICAgaWYgKHR5cGVvZiBiYy51bnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGJjLnVucmVmKCk7XG4gICAgICB9XG4gICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIGZ1bmN0aW9uIChjaGFuZ2VkUGFydHMpIHtcbiAgICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICAgICAgICBiYy5wb3N0TWVzc2FnZShjaGFuZ2VkUGFydHMpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoIURleGllJDEuZGlzYWJsZUJmQ2FjaGUgJiYgZXZlbnQucGVyc2lzdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0RleGllOiBoYW5kbGluZyBwZXJzaXN0ZWQgcGFnZWhpZGUnKTtcbiAgICAgICAgICAgICAgYmMgPT09IG51bGwgfHwgYmMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJjLmNsb3NlKCk7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY29ubmVjdGlvbnNfMSA9IGNvbm5lY3Rpb25zOyBfaSA8IGNvbm5lY3Rpb25zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGIgPSBjb25uZWN0aW9uc18xW19pXTtcbiAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKHsgZGlzYWJsZUF1dG9PcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoIURleGllJDEuZGlzYWJsZUJmQ2FjaGUgJiYgZXZlbnQucGVyc2lzdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0RleGllOiBoYW5kbGluZyBwZXJzaXN0ZWQgcGFnZXNob3cnKTtcbiAgICAgICAgICAgICAgY3JlYXRlQkMoKTtcbiAgICAgICAgICAgICAgcHJvcGFnYXRlTG9jYWxseSh7IGFsbDogbmV3IFJhbmdlU2V0KC1JbmZpbml0eSwgW1tdXSkgfSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvcE1vZGlmaWNhdGlvbih7IGFkZDogdmFsdWUgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvcE1vZGlmaWNhdGlvbih7IHJlbW92ZTogdmFsdWUgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlUHJlZml4KGEsIGIpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvcE1vZGlmaWNhdGlvbih7IHJlcGxhY2VQcmVmaXg6IFthLCBiXSB9KTtcbiAgfVxuXG4gIERleGllUHJvbWlzZS5yZWplY3Rpb25NYXBwZXIgPSBtYXBFcnJvcjtcbiAgc2V0RGVidWcoZGVidWcpO1xuXG4gIHZhciBuYW1lZEV4cG9ydHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIERleGllOiBEZXhpZSQxLFxuICAgIEVudGl0eTogRW50aXR5LFxuICAgIFByb3BNb2RpZmljYXRpb246IFByb3BNb2RpZmljYXRpb24sXG4gICAgUmFuZ2VTZXQ6IFJhbmdlU2V0LFxuICAgIGFkZDogYWRkLFxuICAgIGNtcDogY21wLFxuICAgIGRlZmF1bHQ6IERleGllJDEsXG4gICAgbGl2ZVF1ZXJ5OiBsaXZlUXVlcnksXG4gICAgbWVyZ2VSYW5nZXM6IG1lcmdlUmFuZ2VzLFxuICAgIHJhbmdlc092ZXJsYXA6IHJhbmdlc092ZXJsYXAsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgcmVwbGFjZVByZWZpeDogcmVwbGFjZVByZWZpeFxuICB9KTtcblxuICBfX2Fzc2lnbihEZXhpZSQxLCBuYW1lZEV4cG9ydHMsIHsgZGVmYXVsdDogRGV4aWUkMSB9KTtcblxuICByZXR1cm4gRGV4aWUkMTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV4aWUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dexie/dist/dexie.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/dexie/import-wrapper.mjs":
/*!***********************************************!*\
  !*** ./node_modules/dexie/import-wrapper.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dexie: () => (/* binding */ Dexie),\n/* harmony export */   DexieYProvider: () => (/* binding */ DexieYProvider),\n/* harmony export */   Entity: () => (/* binding */ Entity),\n/* harmony export */   PropModification: () => (/* binding */ PropModification),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   cmp: () => (/* binding */ cmp),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   liveQuery: () => (/* binding */ liveQuery),\n/* harmony export */   mergeRanges: () => (/* binding */ mergeRanges),\n/* harmony export */   rangesOverlap: () => (/* binding */ rangesOverlap),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   replacePrefix: () => (/* binding */ replacePrefix)\n/* harmony export */ });\n/* harmony import */ var _dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/dexie.js */ \"(ssr)/./node_modules/dexie/dist/dexie.js\");\n// Making the module version consumable via require - to prohibit\n// multiple occurrancies of the same module in the same app\n// (dual package hazard, https://nodejs.org/api/packages.html#dual-package-hazard)\n\nconst DexieSymbol = Symbol.for(\"Dexie\");\nconst Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__);\nif (_dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__.semVer !== Dexie.semVer) {\n    throw new Error(`Two different versions of Dexie loaded in the same app: ${_dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__.semVer} and ${Dexie.semVer}`);\n}\nconst { liveQuery, mergeRanges, rangesOverlap, RangeSet, cmp, Entity,\n    PropModification, replacePrefix, add, remove,\n    DexieYProvider } = Dexie;\n\n    \n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dexie);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGV4aWUvaW1wb3J0LXdyYXBwZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ3FDO0FBQ3JDO0FBQ0Esb0VBQW9FLDJDQUFNO0FBQzFFLElBQUksa0RBQWE7QUFDakIsK0VBQStFLGtEQUFhLEVBQUUsTUFBTSxhQUFhO0FBQ2pIO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscUJBQXFCO0FBR0Q7QUFDcEI7QUFDQSxpRUFBZSxLQUFLLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy90aW1vdGh5ZWRpYm8vcHJvamVjdHMvcGVyc29uYWwvYmx1ZWNvdW50cy9mcm9udGVuZC9ub2RlX21vZHVsZXMvZGV4aWUvaW1wb3J0LXdyYXBwZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1ha2luZyB0aGUgbW9kdWxlIHZlcnNpb24gY29uc3VtYWJsZSB2aWEgcmVxdWlyZSAtIHRvIHByb2hpYml0XG4vLyBtdWx0aXBsZSBvY2N1cnJhbmNpZXMgb2YgdGhlIHNhbWUgbW9kdWxlIGluIHRoZSBzYW1lIGFwcFxuLy8gKGR1YWwgcGFja2FnZSBoYXphcmQsIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcGFja2FnZXMuaHRtbCNkdWFsLXBhY2thZ2UtaGF6YXJkKVxuaW1wb3J0IF9EZXhpZSBmcm9tIFwiLi9kaXN0L2RleGllLmpzXCI7XG5jb25zdCBEZXhpZVN5bWJvbCA9IFN5bWJvbC5mb3IoXCJEZXhpZVwiKTtcbmNvbnN0IERleGllID0gZ2xvYmFsVGhpc1tEZXhpZVN5bWJvbF0gfHwgKGdsb2JhbFRoaXNbRGV4aWVTeW1ib2xdID0gX0RleGllKTtcbmlmIChfRGV4aWUuc2VtVmVyICE9PSBEZXhpZS5zZW1WZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFR3byBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgRGV4aWUgbG9hZGVkIGluIHRoZSBzYW1lIGFwcDogJHtfRGV4aWUuc2VtVmVyfSBhbmQgJHtEZXhpZS5zZW1WZXJ9YCk7XG59XG5jb25zdCB7IGxpdmVRdWVyeSwgbWVyZ2VSYW5nZXMsIHJhbmdlc092ZXJsYXAsIFJhbmdlU2V0LCBjbXAsIEVudGl0eSxcbiAgICBQcm9wTW9kaWZpY2F0aW9uLCByZXBsYWNlUHJlZml4LCBhZGQsIHJlbW92ZSxcbiAgICBEZXhpZVlQcm92aWRlciB9ID0gRGV4aWU7XG5leHBvcnQgeyBsaXZlUXVlcnksIG1lcmdlUmFuZ2VzLCByYW5nZXNPdmVybGFwLCBSYW5nZVNldCwgY21wLCBEZXhpZSwgRW50aXR5LFxuICAgIFByb3BNb2RpZmljYXRpb24sIHJlcGxhY2VQcmVmaXgsIGFkZCwgcmVtb3ZlLFxuICAgIERleGllWVByb3ZpZGVyfTtcbiAgICBcbmV4cG9ydCBkZWZhdWx0IERleGllO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dexie/import-wrapper.mjs\n");

/***/ })

};
;