"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/inventory/page",{

/***/ "(app-pages-browser)/./src/hooks/useSyncManager.ts":
/*!*************************************!*\
  !*** ./src/hooks/useSyncManager.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSyncManager: () => (/* binding */ useSyncManager)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/db */ \"(app-pages-browser)/./src/lib/db.ts\");\n/* harmony import */ var _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/contexts/AuthContext */ \"(app-pages-browser)/./src/contexts/AuthContext.tsx\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ useSyncManager auto */ /**\n * useSyncManager - The Heart of Offline-First Sync.\n * - Listens to navigator.onLine; on reconnection runs pull then push.\n * - Pull: GET /sync/pull?tenant_id=&max_version_id= → apply delta to Dexie (server wins for products).\n * - Push: POST /sync with SyncQueue items → server processes in transaction, returns version_id.\n */ \n\n\nconst SYNC_META_KEY_MAX_VERSION = 'local_max_version_id';\nconst SIMULATE_OFFLINE_KEY = 'bluecounts_simulate_offline';\nconst API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';\nfunction getSimulateOffline() {\n    if (false) {}\n    return localStorage.getItem(SIMULATE_OFFLINE_KEY) === '1';\n}\nfunction authHeaders() {\n    const token = (0,_contexts_AuthContext__WEBPACK_IMPORTED_MODULE_2__.getAuthToken)();\n    const h = {\n        'Content-Type': 'application/json'\n    };\n    if (token) h['Authorization'] = \"Bearer \".concat(token);\n    return h;\n}\nfunction useSyncManager(param) {\n    let { tenantId, outletId, deviceId, enabled = true } = param;\n    const [simulateOffline, setSimulateOfflineState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useSyncManager.useState\": ()=> true && getSimulateOffline()\n    }[\"useSyncManager.useState\"]);\n    const [navigatorOnline, setNavigatorOnline] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)( true ? window.navigator.onLine : 0);\n    const isOnline = navigatorOnline && !simulateOffline;\n    const setSimulateOffline = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[setSimulateOffline]\": (value)=>{\n            if (false) {}\n            if (value) localStorage.setItem(SIMULATE_OFFLINE_KEY, '1');\n            else localStorage.removeItem(SIMULATE_OFFLINE_KEY);\n            setSimulateOfflineState(value);\n        }\n    }[\"useSyncManager.useCallback[setSimulateOffline]\"], []);\n    const [syncState, setSyncState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('idle');\n    const [lastError, setLastError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [pendingCount, setPendingCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const getMaxVersion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[getMaxVersion]\": async ()=>{\n            const row = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_meta.get(SYNC_META_KEY_MAX_VERSION);\n            const v = row === null || row === void 0 ? void 0 : row.value;\n            if (typeof v === 'number') return v;\n            if (typeof v === 'string') return parseInt(v, 10) || 0;\n            return 0;\n        }\n    }[\"useSyncManager.useCallback[getMaxVersion]\"], []);\n    const setMaxVersion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[setMaxVersion]\": async (version)=>{\n            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_meta.put({\n                key: SYNC_META_KEY_MAX_VERSION,\n                value: version\n            });\n        }\n    }[\"useSyncManager.useCallback[setMaxVersion]\"], []);\n    const pull = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[pull]\": async function() {\n            let forceFullSync = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n            if (!tenantId) return;\n            setSyncState('pulling');\n            setLastError(null);\n            try {\n                var _tables_products, _tables_inventory, _tables_sales, _tables_sale_items, _tables_pos_sessions;\n                let maxVer = await getMaxVersion();\n                if (forceFullSync) {\n                    maxVer = 0;\n                } else {\n                    const hasLocalData = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.products.where('tenant_id').equals(tenantId).count();\n                    if (hasLocalData === 0) {\n                        maxVer = 0;\n                    }\n                }\n                const url = \"\".concat(API_BASE, \"/sync/pull?tenant_id=\").concat(encodeURIComponent(tenantId), \"&max_version_id=\").concat(maxVer);\n                const res = await fetch(url, {\n                    headers: authHeaders()\n                });\n                if (!res.ok) throw new Error(\"Pull failed: \".concat(res.status));\n                const data = await res.json();\n                const { tables, server_max_version_id } = data;\n                if ((_tables_products = tables.products) === null || _tables_products === void 0 ? void 0 : _tables_products.length) {\n                    for (const row of tables.products){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.products.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_description, _row_deleted_at;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.products.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                sku: row.sku,\n                                name: row.name,\n                                description: (_row_description = row.description) !== null && _row_description !== void 0 ? _row_description : null,\n                                price: Number(row.price),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                updated_at: row.updated_at,\n                                deleted_at: (_row_deleted_at = row.deleted_at) !== null && _row_deleted_at !== void 0 ? _row_deleted_at : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_inventory = tables.inventory) === null || _tables_inventory === void 0 ? void 0 : _tables_inventory.length) {\n                    for (const row of tables.inventory){\n                        const productKey = [\n                            row.tenant_id,\n                            row.outlet_id,\n                            row.product_id\n                        ];\n                        const existing = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.where('[tenant_id+outlet_id+product_id]').equals(productKey).toArray();\n                        for (const e of existing){\n                            if (e.id !== row.id) await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.delete(e.id);\n                        }\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_deleted_at1;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                product_id: row.product_id,\n                                quantity: Number(row.quantity),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                updated_at: row.updated_at,\n                                deleted_at: (_row_deleted_at1 = row.deleted_at) !== null && _row_deleted_at1 !== void 0 ? _row_deleted_at1 : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_sales = tables.sales) === null || _tables_sales === void 0 ? void 0 : _tables_sales.length) {\n                    for (const row of tables.sales){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sales.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_session_id, _row_deleted_at2;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sales.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                device_id: row.device_id,\n                                session_id: (_row_session_id = row.session_id) !== null && _row_session_id !== void 0 ? _row_session_id : null,\n                                device_transaction_id: row.device_transaction_id,\n                                total_amount: Number(row.total_amount),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                updated_at: row.updated_at,\n                                deleted_at: (_row_deleted_at2 = row.deleted_at) !== null && _row_deleted_at2 !== void 0 ? _row_deleted_at2 : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_sale_items = tables.sale_items) === null || _tables_sale_items === void 0 ? void 0 : _tables_sale_items.length) {\n                    for (const row of tables.sale_items){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sale_items.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_deleted_at3;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sale_items.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                sale_id: row.sale_id,\n                                product_id: row.product_id,\n                                quantity: row.quantity,\n                                unit_price: Number(row.unit_price),\n                                line_total: Number(row.line_total),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                deleted_at: (_row_deleted_at3 = row.deleted_at) !== null && _row_deleted_at3 !== void 0 ? _row_deleted_at3 : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_pos_sessions = tables.pos_sessions) === null || _tables_pos_sessions === void 0 ? void 0 : _tables_pos_sessions.length) {\n                    for (const row of tables.pos_sessions){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.pos_sessions.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_device_id, _row_closed_at, _row_deleted_at4;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.pos_sessions.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                user_id: row.user_id,\n                                device_id: (_row_device_id = row.device_id) !== null && _row_device_id !== void 0 ? _row_device_id : null,\n                                opening_balance: Number(row.opening_balance),\n                                closing_balance: row.closing_balance != null ? Number(row.closing_balance) : null,\n                                expected_balance: row.expected_balance != null ? Number(row.expected_balance) : null,\n                                status: row.status === 'closed' ? 'closed' : 'open',\n                                opened_at: row.opened_at,\n                                closed_at: (_row_closed_at = row.closed_at) !== null && _row_closed_at !== void 0 ? _row_closed_at : null,\n                                version_id: row.version_id,\n                                deleted_at: (_row_deleted_at4 = row.deleted_at) !== null && _row_deleted_at4 !== void 0 ? _row_deleted_at4 : null\n                            });\n                        }\n                    }\n                }\n                if (typeof server_max_version_id === 'number') {\n                    await setMaxVersion(server_max_version_id);\n                }\n            } catch (e) {\n                const msg = e instanceof Error ? e.message : 'Pull failed';\n                setLastError(msg);\n                setSyncState('error');\n                return;\n            }\n            setSyncState('idle');\n        }\n    }[\"useSyncManager.useCallback[pull]\"], [\n        tenantId,\n        outletId,\n        getMaxVersion,\n        setMaxVersion\n    ]);\n    const push = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[push]\": async ()=>{\n            if (!tenantId || !outletId || !deviceId) return;\n            const pending = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').toArray();\n            if (pending.length === 0) {\n                setPendingCount(0);\n                return;\n            }\n            setSyncState('pushing');\n            setLastError(null);\n            try {\n                const items = pending.map({\n                    \"useSyncManager.useCallback[push].items\": (q)=>({\n                            id: q.id,\n                            action_type: q.action_type,\n                            payload: q.payload\n                        })\n                }[\"useSyncManager.useCallback[push].items\"]);\n                const res = await fetch(\"\".concat(API_BASE, \"/sync\"), {\n                    method: 'POST',\n                    headers: authHeaders(),\n                    body: JSON.stringify({\n                        tenant_id: tenantId,\n                        outlet_id: outletId,\n                        device_id: deviceId,\n                        items\n                    })\n                });\n                if (!res.ok) {\n                    const errBody = await res.text();\n                    throw new Error(errBody || \"Push failed: \".concat(res.status));\n                }\n                const data = await res.json();\n                if (data.version_id != null) await setMaxVersion(data.version_id);\n                for (const r of data.results || []){\n                    if (r.status === 'accepted' || r.status === 'synced') {\n                        await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.update(r.queue_id, {\n                            status: 'synced'\n                        });\n                    } else if (r.status === 'failed') {\n                        await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.update(r.queue_id, {\n                            status: 'failed',\n                            error_message: r.error\n                        });\n                    }\n                }\n                const stillPending = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count();\n                setPendingCount(stillPending);\n            } catch (e) {\n                const msg = e instanceof Error ? e.message : 'Push failed';\n                setLastError(msg);\n                setSyncState('error');\n                return;\n            }\n            setSyncState('idle');\n            const stillPending = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count();\n            setPendingCount(stillPending);\n        }\n    }[\"useSyncManager.useCallback[push]\"], [\n        tenantId,\n        outletId,\n        deviceId,\n        setMaxVersion\n    ]);\n    const sync = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[sync]\": async ()=>{\n            if (!enabled) return;\n            await pull(true);\n            await push();\n            await pull(true);\n        }\n    }[\"useSyncManager.useCallback[sync]\"], [\n        enabled,\n        pull,\n        push\n    ]);\n    // When online (and not simulating offline), do a full pull on page load.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncManager.useEffect\": ()=>{\n            if ( false || !enabled || !tenantId || !isOnline) return;\n            pull(true);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useSyncManager.useEffect\"], [\n        tenantId,\n        enabled,\n        isOnline\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncManager.useEffect\": ()=>{\n            if (false) {}\n            const handleOnline = {\n                \"useSyncManager.useEffect.handleOnline\": ()=>{\n                    setNavigatorOnline(true);\n                    if (!getSimulateOffline() && enabled && tenantId) sync();\n                }\n            }[\"useSyncManager.useEffect.handleOnline\"];\n            const handleOffline = {\n                \"useSyncManager.useEffect.handleOffline\": ()=>setNavigatorOnline(false)\n            }[\"useSyncManager.useEffect.handleOffline\"];\n            window.addEventListener('online', handleOnline);\n            window.addEventListener('offline', handleOffline);\n            return ({\n                \"useSyncManager.useEffect\": ()=>{\n                    window.removeEventListener('online', handleOnline);\n                    window.removeEventListener('offline', handleOffline);\n                }\n            })[\"useSyncManager.useEffect\"];\n        }\n    }[\"useSyncManager.useEffect\"], [\n        enabled,\n        tenantId,\n        sync\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncManager.useEffect\": ()=>{\n            let cancelled = false;\n            _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count().then({\n                \"useSyncManager.useEffect\": (c)=>{\n                    if (!cancelled) setPendingCount(c);\n                }\n            }[\"useSyncManager.useEffect\"]);\n            const interval = setInterval({\n                \"useSyncManager.useEffect.interval\": ()=>{\n                    _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count().then({\n                        \"useSyncManager.useEffect.interval\": (c)=>{\n                            if (!cancelled) setPendingCount(c);\n                        }\n                    }[\"useSyncManager.useEffect.interval\"]);\n                }\n            }[\"useSyncManager.useEffect.interval\"], 2000);\n            return ({\n                \"useSyncManager.useEffect\": ()=>{\n                    cancelled = true;\n                    clearInterval(interval);\n                }\n            })[\"useSyncManager.useEffect\"];\n        }\n    }[\"useSyncManager.useEffect\"], []);\n    return {\n        isOnline,\n        syncState,\n        lastError,\n        pendingCount,\n        sync,\n        pull,\n        push,\n        simulateOffline,\n        setSimulateOffline\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTeW5jTWFuYWdlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7b0VBRUE7Ozs7O0NBS0MsR0FFd0Q7QUFDTDtBQUNFO0FBRXRELE1BQU1LLDRCQUE0QjtBQUNsQyxNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTUMsV0FBV0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSTtBQUVwRCxTQUFTQztJQUNQLElBQUksS0FBNkIsRUFBRSxFQUFhO0lBQ2hELE9BQU9DLGFBQWFDLE9BQU8sQ0FBQ1AsMEJBQTBCO0FBQ3hEO0FBRUEsU0FBU1E7SUFDUCxNQUFNQyxRQUFRWCxtRUFBWUE7SUFDMUIsTUFBTVksSUFBaUI7UUFBRSxnQkFBZ0I7SUFBbUI7SUFDNUQsSUFBSUQsT0FBTyxDQUE2QixDQUFDLGdCQUFnQixHQUFHLFVBQWdCLE9BQU5BO0lBQ3RFLE9BQU9DO0FBQ1Q7QUFXTyxTQUFTQyxlQUFlLEtBQXVFO1FBQXZFLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsSUFBSSxFQUF5QixHQUF2RTtJQUM3QixNQUFNLENBQUNDLGlCQUFpQkMsd0JBQXdCLEdBQUdyQiwrQ0FBUUE7bUNBQ3pELElBQU0sS0FBNkIsSUFBSVM7O0lBRXpDLE1BQU0sQ0FBQ2EsaUJBQWlCQyxtQkFBbUIsR0FBR3ZCLCtDQUFRQSxDQUNwRCxLQUE2QixHQUFHd0IsT0FBT0MsU0FBUyxDQUFDQyxNQUFNLEdBQUcsQ0FBSTtJQUVoRSxNQUFNQyxXQUFXTCxtQkFBbUIsQ0FBQ0Y7SUFFckMsTUFBTVEscUJBQXFCOUIsa0RBQVdBOzBEQUFDLENBQUMrQjtZQUN0QyxJQUFJLEtBQTZCLEVBQUUsRUFBTztZQUMxQyxJQUFJQSxPQUFPbkIsYUFBYW9CLE9BQU8sQ0FBQzFCLHNCQUFzQjtpQkFDakRNLGFBQWFxQixVQUFVLENBQUMzQjtZQUM3QmlCLHdCQUF3QlE7UUFDMUI7eURBQUcsRUFBRTtJQUVM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O0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90aW1vdGh5ZWRpYm8vcHJvamVjdHMvcGVyc29uYWwvYmx1ZWNvdW50cy9mcm9udGVuZC9zcmMvaG9va3MvdXNlU3luY01hbmFnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG4vKipcbiAqIHVzZVN5bmNNYW5hZ2VyIC0gVGhlIEhlYXJ0IG9mIE9mZmxpbmUtRmlyc3QgU3luYy5cbiAqIC0gTGlzdGVucyB0byBuYXZpZ2F0b3Iub25MaW5lOyBvbiByZWNvbm5lY3Rpb24gcnVucyBwdWxsIHRoZW4gcHVzaC5cbiAqIC0gUHVsbDogR0VUIC9zeW5jL3B1bGw/dGVuYW50X2lkPSZtYXhfdmVyc2lvbl9pZD0g4oaSIGFwcGx5IGRlbHRhIHRvIERleGllIChzZXJ2ZXIgd2lucyBmb3IgcHJvZHVjdHMpLlxuICogLSBQdXNoOiBQT1NUIC9zeW5jIHdpdGggU3luY1F1ZXVlIGl0ZW1zIOKGkiBzZXJ2ZXIgcHJvY2Vzc2VzIGluIHRyYW5zYWN0aW9uLCByZXR1cm5zIHZlcnNpb25faWQuXG4gKi9cblxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBkYiwgdHlwZSBTeW5jUXVldWVSZWNvcmQgfSBmcm9tICdAL2xpYi9kYic7XG5pbXBvcnQgeyBnZXRBdXRoVG9rZW4gfSBmcm9tICdAL2NvbnRleHRzL0F1dGhDb250ZXh0JztcblxuY29uc3QgU1lOQ19NRVRBX0tFWV9NQVhfVkVSU0lPTiA9ICdsb2NhbF9tYXhfdmVyc2lvbl9pZCc7XG5jb25zdCBTSU1VTEFURV9PRkZMSU5FX0tFWSA9ICdibHVlY291bnRzX3NpbXVsYXRlX29mZmxpbmUnO1xuY29uc3QgQVBJX0JBU0UgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDEnO1xuXG5mdW5jdGlvbiBnZXRTaW11bGF0ZU9mZmxpbmUoKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU0lNVUxBVEVfT0ZGTElORV9LRVkpID09PSAnMSc7XG59XG5cbmZ1bmN0aW9uIGF1dGhIZWFkZXJzKCk6IEhlYWRlcnNJbml0IHtcbiAgY29uc3QgdG9rZW4gPSBnZXRBdXRoVG9rZW4oKTtcbiAgY29uc3QgaDogSGVhZGVyc0luaXQgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfTtcbiAgaWYgKHRva2VuKSAoaCBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KVsnQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2VufWA7XG4gIHJldHVybiBoO1xufVxuXG50eXBlIFN5bmNTdGF0ZSA9ICdpZGxlJyB8ICdwdWxsaW5nJyB8ICdwdXNoaW5nJyB8ICdlcnJvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU3luY01hbmFnZXJPcHRpb25zIHtcbiAgdGVuYW50SWQ6IHN0cmluZztcbiAgb3V0bGV0SWQ6IHN0cmluZztcbiAgZGV2aWNlSWQ6IHN0cmluZztcbiAgZW5hYmxlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTeW5jTWFuYWdlcih7IHRlbmFudElkLCBvdXRsZXRJZCwgZGV2aWNlSWQsIGVuYWJsZWQgPSB0cnVlIH06IFVzZVN5bmNNYW5hZ2VyT3B0aW9ucykge1xuICBjb25zdCBbc2ltdWxhdGVPZmZsaW5lLCBzZXRTaW11bGF0ZU9mZmxpbmVTdGF0ZV0gPSB1c2VTdGF0ZShcbiAgICAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBnZXRTaW11bGF0ZU9mZmxpbmUoKVxuICApO1xuICBjb25zdCBbbmF2aWdhdG9yT25saW5lLCBzZXROYXZpZ2F0b3JPbmxpbmVdID0gdXNlU3RhdGUoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubmF2aWdhdG9yLm9uTGluZSA6IHRydWVcbiAgKTtcbiAgY29uc3QgaXNPbmxpbmUgPSBuYXZpZ2F0b3JPbmxpbmUgJiYgIXNpbXVsYXRlT2ZmbGluZTtcblxuICBjb25zdCBzZXRTaW11bGF0ZU9mZmxpbmUgPSB1c2VDYWxsYmFjaygodmFsdWU6IGJvb2xlYW4pID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBpZiAodmFsdWUpIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNJTVVMQVRFX09GRkxJTkVfS0VZLCAnMScpO1xuICAgIGVsc2UgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oU0lNVUxBVEVfT0ZGTElORV9LRVkpO1xuICAgIHNldFNpbXVsYXRlT2ZmbGluZVN0YXRlKHZhbHVlKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IFtzeW5jU3RhdGUsIHNldFN5bmNTdGF0ZV0gPSB1c2VTdGF0ZTxTeW5jU3RhdGU+KCdpZGxlJyk7XG4gIGNvbnN0IFtsYXN0RXJyb3IsIHNldExhc3RFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3BlbmRpbmdDb3VudCwgc2V0UGVuZGluZ0NvdW50XSA9IHVzZVN0YXRlKDApO1xuXG4gIGNvbnN0IGdldE1heFZlcnNpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoKTogUHJvbWlzZTxudW1iZXI+ID0+IHtcbiAgICBjb25zdCByb3cgPSBhd2FpdCBkYi5zeW5jX21ldGEuZ2V0KFNZTkNfTUVUQV9LRVlfTUFYX1ZFUlNJT04pO1xuICAgIGNvbnN0IHYgPSByb3c/LnZhbHVlO1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHJldHVybiB2O1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHJldHVybiBwYXJzZUludCh2LCAxMCkgfHwgMDtcbiAgICByZXR1cm4gMDtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNldE1heFZlcnNpb24gPSB1c2VDYWxsYmFjayhhc3luYyAodmVyc2lvbjogbnVtYmVyKSA9PiB7XG4gICAgYXdhaXQgZGIuc3luY19tZXRhLnB1dCh7IGtleTogU1lOQ19NRVRBX0tFWV9NQVhfVkVSU0lPTiwgdmFsdWU6IHZlcnNpb24gfSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBwdWxsID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGZvcmNlRnVsbFN5bmMgPSBmYWxzZSkgPT4ge1xuICAgICAgaWYgKCF0ZW5hbnRJZCkgcmV0dXJuO1xuICAgICAgc2V0U3luY1N0YXRlKCdwdWxsaW5nJyk7XG4gICAgICBzZXRMYXN0RXJyb3IobnVsbCk7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgbWF4VmVyID0gYXdhaXQgZ2V0TWF4VmVyc2lvbigpO1xuICAgICAgICBpZiAoZm9yY2VGdWxsU3luYykge1xuICAgICAgICAgIG1heFZlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaGFzTG9jYWxEYXRhID0gYXdhaXQgZGIucHJvZHVjdHMud2hlcmUoJ3RlbmFudF9pZCcpLmVxdWFscyh0ZW5hbnRJZCkuY291bnQoKTtcbiAgICAgICAgICBpZiAoaGFzTG9jYWxEYXRhID09PSAwKSB7XG4gICAgICAgICAgICBtYXhWZXIgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBgJHtBUElfQkFTRX0vc3luYy9wdWxsP3RlbmFudF9pZD0ke2VuY29kZVVSSUNvbXBvbmVudCh0ZW5hbnRJZCl9Jm1heF92ZXJzaW9uX2lkPSR7bWF4VmVyfWA7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHsgaGVhZGVyczogYXV0aEhlYWRlcnMoKSB9KTtcbiAgICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoYFB1bGwgZmFpbGVkOiAke3Jlcy5zdGF0dXN9YCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgIGNvbnN0IHsgdGFibGVzLCBzZXJ2ZXJfbWF4X3ZlcnNpb25faWQgfSA9IGRhdGE7XG5cbiAgICAgIGlmICh0YWJsZXMucHJvZHVjdHM/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZXMucHJvZHVjdHMpIHtcbiAgICAgICAgICBpZiAocm93LmRlbGV0ZWRfYXQpIHtcbiAgICAgICAgICAgIGF3YWl0IGRiLnByb2R1Y3RzLnVwZGF0ZShyb3cuaWQsIHsgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQsIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5wcm9kdWN0cy5wdXQoe1xuICAgICAgICAgICAgICBpZDogcm93LmlkLFxuICAgICAgICAgICAgICB0ZW5hbnRfaWQ6IHJvdy50ZW5hbnRfaWQsXG4gICAgICAgICAgICAgIHNrdTogcm93LnNrdSxcbiAgICAgICAgICAgICAgbmFtZTogcm93Lm5hbWUsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiByb3cuZGVzY3JpcHRpb24gPz8gbnVsbCxcbiAgICAgICAgICAgICAgcHJpY2U6IE51bWJlcihyb3cucHJpY2UpLFxuICAgICAgICAgICAgICB2ZXJzaW9uX2lkOiByb3cudmVyc2lvbl9pZCxcbiAgICAgICAgICAgICAgY3JlYXRlZF9hdDogcm93LmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IHJvdy51cGRhdGVkX2F0LFxuICAgICAgICAgICAgICBkZWxldGVkX2F0OiByb3cuZGVsZXRlZF9hdCA/PyBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGFibGVzLmludmVudG9yeT8ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlcy5pbnZlbnRvcnkpIHtcbiAgICAgICAgICBjb25zdCBwcm9kdWN0S2V5ID0gW3Jvdy50ZW5hbnRfaWQsIHJvdy5vdXRsZXRfaWQsIHJvdy5wcm9kdWN0X2lkXSBhcyBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ107XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCBkYi5pbnZlbnRvcnkud2hlcmUoJ1t0ZW5hbnRfaWQrb3V0bGV0X2lkK3Byb2R1Y3RfaWRdJykuZXF1YWxzKHByb2R1Y3RLZXkpLnRvQXJyYXkoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGlmIChlLmlkICE9PSByb3cuaWQpIGF3YWl0IGRiLmludmVudG9yeS5kZWxldGUoZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb3cuZGVsZXRlZF9hdCkge1xuICAgICAgICAgICAgYXdhaXQgZGIuaW52ZW50b3J5LnVwZGF0ZShyb3cuaWQsIHsgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQsIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5pbnZlbnRvcnkucHV0KHtcbiAgICAgICAgICAgICAgaWQ6IHJvdy5pZCxcbiAgICAgICAgICAgICAgdGVuYW50X2lkOiByb3cudGVuYW50X2lkLFxuICAgICAgICAgICAgICBvdXRsZXRfaWQ6IHJvdy5vdXRsZXRfaWQsXG4gICAgICAgICAgICAgIHByb2R1Y3RfaWQ6IHJvdy5wcm9kdWN0X2lkLFxuICAgICAgICAgICAgICBxdWFudGl0eTogTnVtYmVyKHJvdy5xdWFudGl0eSksXG4gICAgICAgICAgICAgIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkLFxuICAgICAgICAgICAgICBjcmVhdGVkX2F0OiByb3cuY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgdXBkYXRlZF9hdDogcm93LnVwZGF0ZWRfYXQsXG4gICAgICAgICAgICAgIGRlbGV0ZWRfYXQ6IHJvdy5kZWxldGVkX2F0ID8/IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZXMuc2FsZXM/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZXMuc2FsZXMpIHtcbiAgICAgICAgICBpZiAocm93LmRlbGV0ZWRfYXQpIHtcbiAgICAgICAgICAgIGF3YWl0IGRiLnNhbGVzLnVwZGF0ZShyb3cuaWQsIHsgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQsIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5zYWxlcy5wdXQoe1xuICAgICAgICAgICAgICBpZDogcm93LmlkLFxuICAgICAgICAgICAgICB0ZW5hbnRfaWQ6IHJvdy50ZW5hbnRfaWQsXG4gICAgICAgICAgICAgIG91dGxldF9pZDogcm93Lm91dGxldF9pZCxcbiAgICAgICAgICAgICAgZGV2aWNlX2lkOiByb3cuZGV2aWNlX2lkLFxuICAgICAgICAgICAgICBzZXNzaW9uX2lkOiByb3cuc2Vzc2lvbl9pZCA/PyBudWxsLFxuICAgICAgICAgICAgICBkZXZpY2VfdHJhbnNhY3Rpb25faWQ6IHJvdy5kZXZpY2VfdHJhbnNhY3Rpb25faWQsXG4gICAgICAgICAgICAgIHRvdGFsX2Ftb3VudDogTnVtYmVyKHJvdy50b3RhbF9hbW91bnQpLFxuICAgICAgICAgICAgICB2ZXJzaW9uX2lkOiByb3cudmVyc2lvbl9pZCxcbiAgICAgICAgICAgICAgY3JlYXRlZF9hdDogcm93LmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IHJvdy51cGRhdGVkX2F0LFxuICAgICAgICAgICAgICBkZWxldGVkX2F0OiByb3cuZGVsZXRlZF9hdCA/PyBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGFibGVzLnNhbGVfaXRlbXM/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZXMuc2FsZV9pdGVtcykge1xuICAgICAgICAgIGlmIChyb3cuZGVsZXRlZF9hdCkge1xuICAgICAgICAgICAgYXdhaXQgZGIuc2FsZV9pdGVtcy51cGRhdGUocm93LmlkLCB7IGRlbGV0ZWRfYXQ6IHJvdy5kZWxldGVkX2F0LCB2ZXJzaW9uX2lkOiByb3cudmVyc2lvbl9pZCB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgZGIuc2FsZV9pdGVtcy5wdXQoe1xuICAgICAgICAgICAgICBpZDogcm93LmlkLFxuICAgICAgICAgICAgICB0ZW5hbnRfaWQ6IHJvdy50ZW5hbnRfaWQsXG4gICAgICAgICAgICAgIG91dGxldF9pZDogcm93Lm91dGxldF9pZCxcbiAgICAgICAgICAgICAgc2FsZV9pZDogcm93LnNhbGVfaWQsXG4gICAgICAgICAgICAgIHByb2R1Y3RfaWQ6IHJvdy5wcm9kdWN0X2lkLFxuICAgICAgICAgICAgICBxdWFudGl0eTogcm93LnF1YW50aXR5LFxuICAgICAgICAgICAgICB1bml0X3ByaWNlOiBOdW1iZXIocm93LnVuaXRfcHJpY2UpLFxuICAgICAgICAgICAgICBsaW5lX3RvdGFsOiBOdW1iZXIocm93LmxpbmVfdG90YWwpLFxuICAgICAgICAgICAgICB2ZXJzaW9uX2lkOiByb3cudmVyc2lvbl9pZCxcbiAgICAgICAgICAgICAgY3JlYXRlZF9hdDogcm93LmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgIGRlbGV0ZWRfYXQ6IHJvdy5kZWxldGVkX2F0ID8/IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZXMucG9zX3Nlc3Npb25zPy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGVzLnBvc19zZXNzaW9ucykge1xuICAgICAgICAgIGlmIChyb3cuZGVsZXRlZF9hdCkge1xuICAgICAgICAgICAgYXdhaXQgZGIucG9zX3Nlc3Npb25zLnVwZGF0ZShyb3cuaWQsIHsgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQsIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5wb3Nfc2Vzc2lvbnMucHV0KHtcbiAgICAgICAgICAgICAgaWQ6IHJvdy5pZCxcbiAgICAgICAgICAgICAgdGVuYW50X2lkOiByb3cudGVuYW50X2lkLFxuICAgICAgICAgICAgICBvdXRsZXRfaWQ6IHJvdy5vdXRsZXRfaWQsXG4gICAgICAgICAgICAgIHVzZXJfaWQ6IHJvdy51c2VyX2lkLFxuICAgICAgICAgICAgICBkZXZpY2VfaWQ6IHJvdy5kZXZpY2VfaWQgPz8gbnVsbCxcbiAgICAgICAgICAgICAgb3BlbmluZ19iYWxhbmNlOiBOdW1iZXIocm93Lm9wZW5pbmdfYmFsYW5jZSksXG4gICAgICAgICAgICAgIGNsb3NpbmdfYmFsYW5jZTogcm93LmNsb3NpbmdfYmFsYW5jZSAhPSBudWxsID8gTnVtYmVyKHJvdy5jbG9zaW5nX2JhbGFuY2UpIDogbnVsbCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWRfYmFsYW5jZTogcm93LmV4cGVjdGVkX2JhbGFuY2UgIT0gbnVsbCA/IE51bWJlcihyb3cuZXhwZWN0ZWRfYmFsYW5jZSkgOiBudWxsLFxuICAgICAgICAgICAgICBzdGF0dXM6IHJvdy5zdGF0dXMgPT09ICdjbG9zZWQnID8gJ2Nsb3NlZCcgOiAnb3BlbicsXG4gICAgICAgICAgICAgIG9wZW5lZF9hdDogcm93Lm9wZW5lZF9hdCxcbiAgICAgICAgICAgICAgY2xvc2VkX2F0OiByb3cuY2xvc2VkX2F0ID8/IG51bGwsXG4gICAgICAgICAgICAgIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkLFxuICAgICAgICAgICAgICBkZWxldGVkX2F0OiByb3cuZGVsZXRlZF9hdCA/PyBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VydmVyX21heF92ZXJzaW9uX2lkID09PSAnbnVtYmVyJykge1xuICAgICAgICBhd2FpdCBzZXRNYXhWZXJzaW9uKHNlcnZlcl9tYXhfdmVyc2lvbl9pZCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgbXNnID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogJ1B1bGwgZmFpbGVkJztcbiAgICAgIHNldExhc3RFcnJvcihtc2cpO1xuICAgICAgc2V0U3luY1N0YXRlKCdlcnJvcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRTeW5jU3RhdGUoJ2lkbGUnKTtcbiAgfSxcbiAgICBbdGVuYW50SWQsIG91dGxldElkLCBnZXRNYXhWZXJzaW9uLCBzZXRNYXhWZXJzaW9uXVxuICApO1xuXG4gIGNvbnN0IHB1c2ggPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF0ZW5hbnRJZCB8fCAhb3V0bGV0SWQgfHwgIWRldmljZUlkKSByZXR1cm47XG4gICAgY29uc3QgcGVuZGluZyA9IGF3YWl0IGRiLnN5bmNfcXVldWUud2hlcmUoJ3N0YXR1cycpLmVxdWFscygncGVuZGluZycpLnRvQXJyYXkoKTtcbiAgICBpZiAocGVuZGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHNldFBlbmRpbmdDb3VudCgwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0U3luY1N0YXRlKCdwdXNoaW5nJyk7XG4gICAgc2V0TGFzdEVycm9yKG51bGwpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpdGVtcyA9IHBlbmRpbmcubWFwKChxOiBTeW5jUXVldWVSZWNvcmQpID0+ICh7XG4gICAgICAgIGlkOiBxLmlkLFxuICAgICAgICBhY3Rpb25fdHlwZTogcS5hY3Rpb25fdHlwZSxcbiAgICAgICAgcGF5bG9hZDogcS5wYXlsb2FkLFxuICAgICAgfSkpO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0V9L3N5bmNgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycygpLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdGVuYW50X2lkOiB0ZW5hbnRJZCxcbiAgICAgICAgICBvdXRsZXRfaWQ6IG91dGxldElkLFxuICAgICAgICAgIGRldmljZV9pZDogZGV2aWNlSWQsXG4gICAgICAgICAgaXRlbXMsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICBjb25zdCBlcnJCb2R5ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyckJvZHkgfHwgYFB1c2ggZmFpbGVkOiAke3Jlcy5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgIGlmIChkYXRhLnZlcnNpb25faWQgIT0gbnVsbCkgYXdhaXQgc2V0TWF4VmVyc2lvbihkYXRhLnZlcnNpb25faWQpO1xuICAgICAgZm9yIChjb25zdCByIG9mIGRhdGEucmVzdWx0cyB8fCBbXSkge1xuICAgICAgICBpZiAoci5zdGF0dXMgPT09ICdhY2NlcHRlZCcgfHwgci5zdGF0dXMgPT09ICdzeW5jZWQnKSB7XG4gICAgICAgICAgYXdhaXQgZGIuc3luY19xdWV1ZS51cGRhdGUoci5xdWV1ZV9pZCwgeyBzdGF0dXM6ICdzeW5jZWQnIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHIuc3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgICAgIGF3YWl0IGRiLnN5bmNfcXVldWUudXBkYXRlKHIucXVldWVfaWQsIHsgc3RhdHVzOiAnZmFpbGVkJywgZXJyb3JfbWVzc2FnZTogci5lcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc3RpbGxQZW5kaW5nID0gYXdhaXQgZGIuc3luY19xdWV1ZS53aGVyZSgnc3RhdHVzJykuZXF1YWxzKCdwZW5kaW5nJykuY291bnQoKTtcbiAgICAgIHNldFBlbmRpbmdDb3VudChzdGlsbFBlbmRpbmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6ICdQdXNoIGZhaWxlZCc7XG4gICAgICBzZXRMYXN0RXJyb3IobXNnKTtcbiAgICAgIHNldFN5bmNTdGF0ZSgnZXJyb3InKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0U3luY1N0YXRlKCdpZGxlJyk7XG4gICAgY29uc3Qgc3RpbGxQZW5kaW5nID0gYXdhaXQgZGIuc3luY19xdWV1ZS53aGVyZSgnc3RhdHVzJykuZXF1YWxzKCdwZW5kaW5nJykuY291bnQoKTtcbiAgICBzZXRQZW5kaW5nQ291bnQoc3RpbGxQZW5kaW5nKTtcbiAgfSwgW3RlbmFudElkLCBvdXRsZXRJZCwgZGV2aWNlSWQsIHNldE1heFZlcnNpb25dKTtcblxuICBjb25zdCBzeW5jID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGF3YWl0IHB1bGwodHJ1ZSk7XG4gICAgYXdhaXQgcHVzaCgpO1xuICAgIGF3YWl0IHB1bGwodHJ1ZSk7XG4gIH0sIFtlbmFibGVkLCBwdWxsLCBwdXNoXSk7XG5cbiAgLy8gV2hlbiBvbmxpbmUgKGFuZCBub3Qgc2ltdWxhdGluZyBvZmZsaW5lKSwgZG8gYSBmdWxsIHB1bGwgb24gcGFnZSBsb2FkLlxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhZW5hYmxlZCB8fCAhdGVuYW50SWQgfHwgIWlzT25saW5lKSByZXR1cm47XG4gICAgcHVsbCh0cnVlKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFt0ZW5hbnRJZCwgZW5hYmxlZCwgaXNPbmxpbmVdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIGNvbnN0IGhhbmRsZU9ubGluZSA9ICgpID0+IHtcbiAgICAgIHNldE5hdmlnYXRvck9ubGluZSh0cnVlKTtcbiAgICAgIGlmICghZ2V0U2ltdWxhdGVPZmZsaW5lKCkgJiYgZW5hYmxlZCAmJiB0ZW5hbnRJZCkgc3luYygpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlT2ZmbGluZSA9ICgpID0+IHNldE5hdmlnYXRvck9ubGluZShmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGhhbmRsZU9ubGluZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBoYW5kbGVPZmZsaW5lKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGhhbmRsZU9ubGluZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGhhbmRsZU9mZmxpbmUpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCB0ZW5hbnRJZCwgc3luY10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGRiLnN5bmNfcXVldWUud2hlcmUoJ3N0YXR1cycpLmVxdWFscygncGVuZGluZycpLmNvdW50KCkudGhlbigoYykgPT4ge1xuICAgICAgaWYgKCFjYW5jZWxsZWQpIHNldFBlbmRpbmdDb3VudChjKTtcbiAgICB9KTtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGRiLnN5bmNfcXVldWUud2hlcmUoJ3N0YXR1cycpLmVxdWFscygncGVuZGluZycpLmNvdW50KCkudGhlbigoYykgPT4ge1xuICAgICAgICBpZiAoIWNhbmNlbGxlZCkgc2V0UGVuZGluZ0NvdW50KGMpO1xuICAgICAgfSk7XG4gICAgfSwgMjAwMCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpc09ubGluZSxcbiAgICBzeW5jU3RhdGUsXG4gICAgbGFzdEVycm9yLFxuICAgIHBlbmRpbmdDb3VudCxcbiAgICBzeW5jLFxuICAgIHB1bGwsXG4gICAgcHVzaCxcbiAgICBzaW11bGF0ZU9mZmxpbmUsXG4gICAgc2V0U2ltdWxhdGVPZmZsaW5lLFxuICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJkYiIsImdldEF1dGhUb2tlbiIsIlNZTkNfTUVUQV9LRVlfTUFYX1ZFUlNJT04iLCJTSU1VTEFURV9PRkZMSU5FX0tFWSIsIkFQSV9CQVNFIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJnZXRTaW11bGF0ZU9mZmxpbmUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiYXV0aEhlYWRlcnMiLCJ0b2tlbiIsImgiLCJ1c2VTeW5jTWFuYWdlciIsInRlbmFudElkIiwib3V0bGV0SWQiLCJkZXZpY2VJZCIsImVuYWJsZWQiLCJzaW11bGF0ZU9mZmxpbmUiLCJzZXRTaW11bGF0ZU9mZmxpbmVTdGF0ZSIsIm5hdmlnYXRvck9ubGluZSIsInNldE5hdmlnYXRvck9ubGluZSIsIndpbmRvdyIsIm5hdmlnYXRvciIsIm9uTGluZSIsImlzT25saW5lIiwic2V0U2ltdWxhdGVPZmZsaW5lIiwidmFsdWUiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsInN5bmNTdGF0ZSIsInNldFN5bmNTdGF0ZSIsImxhc3RFcnJvciIsInNldExhc3RFcnJvciIsInBlbmRpbmdDb3VudCIsInNldFBlbmRpbmdDb3VudCIsImdldE1heFZlcnNpb24iLCJyb3ciLCJzeW5jX21ldGEiLCJnZXQiLCJ2IiwicGFyc2VJbnQiLCJzZXRNYXhWZXJzaW9uIiwidmVyc2lvbiIsInB1dCIsImtleSIsInB1bGwiLCJmb3JjZUZ1bGxTeW5jIiwidGFibGVzIiwibWF4VmVyIiwiaGFzTG9jYWxEYXRhIiwicHJvZHVjdHMiLCJ3aGVyZSIsImVxdWFscyIsImNvdW50IiwidXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVzIiwiZmV0Y2giLCJoZWFkZXJzIiwib2siLCJFcnJvciIsInN0YXR1cyIsImRhdGEiLCJqc29uIiwic2VydmVyX21heF92ZXJzaW9uX2lkIiwibGVuZ3RoIiwiZGVsZXRlZF9hdCIsInVwZGF0ZSIsImlkIiwidmVyc2lvbl9pZCIsInRlbmFudF9pZCIsInNrdSIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInByaWNlIiwiTnVtYmVyIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJpbnZlbnRvcnkiLCJwcm9kdWN0S2V5Iiwib3V0bGV0X2lkIiwicHJvZHVjdF9pZCIsImV4aXN0aW5nIiwidG9BcnJheSIsImUiLCJkZWxldGUiLCJxdWFudGl0eSIsInNhbGVzIiwiZGV2aWNlX2lkIiwic2Vzc2lvbl9pZCIsImRldmljZV90cmFuc2FjdGlvbl9pZCIsInRvdGFsX2Ftb3VudCIsInNhbGVfaXRlbXMiLCJzYWxlX2lkIiwidW5pdF9wcmljZSIsImxpbmVfdG90YWwiLCJwb3Nfc2Vzc2lvbnMiLCJ1c2VyX2lkIiwib3BlbmluZ19iYWxhbmNlIiwiY2xvc2luZ19iYWxhbmNlIiwiZXhwZWN0ZWRfYmFsYW5jZSIsIm9wZW5lZF9hdCIsImNsb3NlZF9hdCIsIm1zZyIsIm1lc3NhZ2UiLCJwdXNoIiwicGVuZGluZyIsInN5bmNfcXVldWUiLCJpdGVtcyIsIm1hcCIsInEiLCJhY3Rpb25fdHlwZSIsInBheWxvYWQiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImVyckJvZHkiLCJ0ZXh0IiwiciIsInJlc3VsdHMiLCJxdWV1ZV9pZCIsImVycm9yX21lc3NhZ2UiLCJlcnJvciIsInN0aWxsUGVuZGluZyIsInN5bmMiLCJoYW5kbGVPbmxpbmUiLCJoYW5kbGVPZmZsaW5lIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxsZWQiLCJ0aGVuIiwiYyIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSyncManager.ts\n"));

/***/ })

});