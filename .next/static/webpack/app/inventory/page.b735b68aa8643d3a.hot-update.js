"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/inventory/page",{

/***/ "(app-pages-browser)/./src/hooks/useSyncManager.ts":
/*!*************************************!*\
  !*** ./src/hooks/useSyncManager.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSyncManager: () => (/* binding */ useSyncManager)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/db */ \"(app-pages-browser)/./src/lib/db.ts\");\n/* harmony import */ var _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/contexts/AuthContext */ \"(app-pages-browser)/./src/contexts/AuthContext.tsx\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ useSyncManager auto */ /**\n * useSyncManager - The Heart of Offline-First Sync.\n * - Listens to navigator.onLine; on reconnection runs pull then push.\n * - Pull: GET /sync/pull?tenant_id=&max_version_id= → apply delta to Dexie (server wins for products).\n * - Push: POST /sync with SyncQueue items → server processes in transaction, returns version_id.\n */ \n\n\nconst SYNC_META_KEY_MAX_VERSION = 'local_max_version_id';\nconst SIMULATE_OFFLINE_KEY = 'bluecounts_simulate_offline';\nconst API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';\nfunction getSimulateOffline() {\n    if (false) {}\n    return localStorage.getItem(SIMULATE_OFFLINE_KEY) === '1';\n}\nfunction authHeaders() {\n    const token = (0,_contexts_AuthContext__WEBPACK_IMPORTED_MODULE_2__.getAuthToken)();\n    const h = {\n        'Content-Type': 'application/json'\n    };\n    if (token) h['Authorization'] = \"Bearer \".concat(token);\n    return h;\n}\nfunction useSyncManager(param) {\n    let { tenantId, outletId, deviceId, enabled = true } = param;\n    const [simulateOffline, setSimulateOfflineState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useSyncManager.useState\": ()=> true && getSimulateOffline()\n    }[\"useSyncManager.useState\"]);\n    const actuallyOnline =  true ? window.navigator.onLine : 0;\n    const isOnline = actuallyOnline && !simulateOffline;\n    const setSimulateOffline = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[setSimulateOffline]\": (value)=>{\n            if (false) {}\n            if (value) localStorage.setItem(SIMULATE_OFFLINE_KEY, '1');\n            else localStorage.removeItem(SIMULATE_OFFLINE_KEY);\n            setSimulateOfflineState(value);\n        }\n    }[\"useSyncManager.useCallback[setSimulateOffline]\"], []);\n    const [syncState, setSyncState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('idle');\n    const [lastError, setLastError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [pendingCount, setPendingCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const getMaxVersion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[getMaxVersion]\": async ()=>{\n            const row = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_meta.get(SYNC_META_KEY_MAX_VERSION);\n            const v = row === null || row === void 0 ? void 0 : row.value;\n            if (typeof v === 'number') return v;\n            if (typeof v === 'string') return parseInt(v, 10) || 0;\n            return 0;\n        }\n    }[\"useSyncManager.useCallback[getMaxVersion]\"], []);\n    const setMaxVersion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[setMaxVersion]\": async (version)=>{\n            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_meta.put({\n                key: SYNC_META_KEY_MAX_VERSION,\n                value: version\n            });\n        }\n    }[\"useSyncManager.useCallback[setMaxVersion]\"], []);\n    const pull = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[pull]\": async function() {\n            let forceFullSync = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n            if (!tenantId) return;\n            setSyncState('pulling');\n            setLastError(null);\n            try {\n                var _tables_products, _tables_inventory, _tables_sales, _tables_sale_items, _tables_pos_sessions;\n                let maxVer = await getMaxVersion();\n                if (forceFullSync) {\n                    maxVer = 0;\n                } else {\n                    const hasLocalData = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.products.where('tenant_id').equals(tenantId).count();\n                    if (hasLocalData === 0) {\n                        maxVer = 0;\n                    }\n                }\n                const url = \"\".concat(API_BASE, \"/sync/pull?tenant_id=\").concat(encodeURIComponent(tenantId), \"&max_version_id=\").concat(maxVer);\n                const res = await fetch(url, {\n                    headers: authHeaders()\n                });\n                if (!res.ok) throw new Error(\"Pull failed: \".concat(res.status));\n                const data = await res.json();\n                const { tables, server_max_version_id } = data;\n                if ((_tables_products = tables.products) === null || _tables_products === void 0 ? void 0 : _tables_products.length) {\n                    for (const row of tables.products){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.products.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_description, _row_deleted_at;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.products.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                sku: row.sku,\n                                name: row.name,\n                                description: (_row_description = row.description) !== null && _row_description !== void 0 ? _row_description : null,\n                                price: Number(row.price),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                updated_at: row.updated_at,\n                                deleted_at: (_row_deleted_at = row.deleted_at) !== null && _row_deleted_at !== void 0 ? _row_deleted_at : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_inventory = tables.inventory) === null || _tables_inventory === void 0 ? void 0 : _tables_inventory.length) {\n                    for (const row of tables.inventory){\n                        const productKey = [\n                            row.tenant_id,\n                            row.outlet_id,\n                            row.product_id\n                        ];\n                        const existing = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.where('[tenant_id+outlet_id+product_id]').equals(productKey).toArray();\n                        for (const e of existing){\n                            if (e.id !== row.id) await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.delete(e.id);\n                        }\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_deleted_at1;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                product_id: row.product_id,\n                                quantity: Number(row.quantity),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                updated_at: row.updated_at,\n                                deleted_at: (_row_deleted_at1 = row.deleted_at) !== null && _row_deleted_at1 !== void 0 ? _row_deleted_at1 : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_sales = tables.sales) === null || _tables_sales === void 0 ? void 0 : _tables_sales.length) {\n                    for (const row of tables.sales){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sales.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_session_id, _row_deleted_at2;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sales.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                device_id: row.device_id,\n                                session_id: (_row_session_id = row.session_id) !== null && _row_session_id !== void 0 ? _row_session_id : null,\n                                device_transaction_id: row.device_transaction_id,\n                                total_amount: Number(row.total_amount),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                updated_at: row.updated_at,\n                                deleted_at: (_row_deleted_at2 = row.deleted_at) !== null && _row_deleted_at2 !== void 0 ? _row_deleted_at2 : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_sale_items = tables.sale_items) === null || _tables_sale_items === void 0 ? void 0 : _tables_sale_items.length) {\n                    for (const row of tables.sale_items){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sale_items.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_deleted_at3;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sale_items.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                sale_id: row.sale_id,\n                                product_id: row.product_id,\n                                quantity: row.quantity,\n                                unit_price: Number(row.unit_price),\n                                line_total: Number(row.line_total),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                deleted_at: (_row_deleted_at3 = row.deleted_at) !== null && _row_deleted_at3 !== void 0 ? _row_deleted_at3 : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_pos_sessions = tables.pos_sessions) === null || _tables_pos_sessions === void 0 ? void 0 : _tables_pos_sessions.length) {\n                    for (const row of tables.pos_sessions){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.pos_sessions.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_device_id, _row_closed_at, _row_deleted_at4;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.pos_sessions.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                user_id: row.user_id,\n                                device_id: (_row_device_id = row.device_id) !== null && _row_device_id !== void 0 ? _row_device_id : null,\n                                opening_balance: Number(row.opening_balance),\n                                closing_balance: row.closing_balance != null ? Number(row.closing_balance) : null,\n                                expected_balance: row.expected_balance != null ? Number(row.expected_balance) : null,\n                                status: row.status === 'closed' ? 'closed' : 'open',\n                                opened_at: row.opened_at,\n                                closed_at: (_row_closed_at = row.closed_at) !== null && _row_closed_at !== void 0 ? _row_closed_at : null,\n                                version_id: row.version_id,\n                                deleted_at: (_row_deleted_at4 = row.deleted_at) !== null && _row_deleted_at4 !== void 0 ? _row_deleted_at4 : null\n                            });\n                        }\n                    }\n                }\n                if (typeof server_max_version_id === 'number') {\n                    await setMaxVersion(server_max_version_id);\n                }\n            } catch (e) {\n                const msg = e instanceof Error ? e.message : 'Pull failed';\n                setLastError(msg);\n                setSyncState('error');\n                return;\n            }\n            setSyncState('idle');\n        }\n    }[\"useSyncManager.useCallback[pull]\"], [\n        tenantId,\n        outletId,\n        getMaxVersion,\n        setMaxVersion\n    ]);\n    const push = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[push]\": async ()=>{\n            if (!tenantId || !outletId || !deviceId) return;\n            const pending = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').toArray();\n            if (pending.length === 0) {\n                setPendingCount(0);\n                return;\n            }\n            setSyncState('pushing');\n            setLastError(null);\n            try {\n                const items = pending.map({\n                    \"useSyncManager.useCallback[push].items\": (q)=>({\n                            id: q.id,\n                            action_type: q.action_type,\n                            payload: q.payload\n                        })\n                }[\"useSyncManager.useCallback[push].items\"]);\n                const res = await fetch(\"\".concat(API_BASE, \"/sync\"), {\n                    method: 'POST',\n                    headers: authHeaders(),\n                    body: JSON.stringify({\n                        tenant_id: tenantId,\n                        outlet_id: outletId,\n                        device_id: deviceId,\n                        items\n                    })\n                });\n                if (!res.ok) {\n                    const errBody = await res.text();\n                    throw new Error(errBody || \"Push failed: \".concat(res.status));\n                }\n                const data = await res.json();\n                if (data.version_id != null) await setMaxVersion(data.version_id);\n                for (const r of data.results || []){\n                    if (r.status === 'accepted' || r.status === 'synced') {\n                        await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.update(r.queue_id, {\n                            status: 'synced'\n                        });\n                    } else if (r.status === 'failed') {\n                        await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.update(r.queue_id, {\n                            status: 'failed',\n                            error_message: r.error\n                        });\n                    }\n                }\n                const stillPending = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count();\n                setPendingCount(stillPending);\n            } catch (e) {\n                const msg = e instanceof Error ? e.message : 'Push failed';\n                setLastError(msg);\n                setSyncState('error');\n                return;\n            }\n            setSyncState('idle');\n            const stillPending = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count();\n            setPendingCount(stillPending);\n        }\n    }[\"useSyncManager.useCallback[push]\"], [\n        tenantId,\n        outletId,\n        deviceId,\n        setMaxVersion\n    ]);\n    const sync = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[sync]\": async ()=>{\n            if (!enabled) return;\n            await pull(true);\n            await push();\n            await pull(true);\n        }\n    }[\"useSyncManager.useCallback[sync]\"], [\n        enabled,\n        pull,\n        push\n    ]);\n    // When online (and not simulating offline), do a full pull on page load.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncManager.useEffect\": ()=>{\n            if ( false || !enabled || !tenantId || !isOnline) return;\n            pull(true);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useSyncManager.useEffect\"], [\n        tenantId,\n        enabled,\n        isOnline\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncManager.useEffect\": ()=>{\n            if (false) {}\n            const handleOnline = {\n                \"useSyncManager.useEffect.handleOnline\": ()=>{\n                    setIsOnline(true);\n                    if (enabled && tenantId) sync();\n                }\n            }[\"useSyncManager.useEffect.handleOnline\"];\n            const handleOffline = {\n                \"useSyncManager.useEffect.handleOffline\": ()=>setIsOnline(false)\n            }[\"useSyncManager.useEffect.handleOffline\"];\n            window.addEventListener('online', handleOnline);\n            window.addEventListener('offline', handleOffline);\n            return ({\n                \"useSyncManager.useEffect\": ()=>{\n                    window.removeEventListener('online', handleOnline);\n                    window.removeEventListener('offline', handleOffline);\n                }\n            })[\"useSyncManager.useEffect\"];\n        }\n    }[\"useSyncManager.useEffect\"], [\n        enabled,\n        tenantId,\n        sync\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncManager.useEffect\": ()=>{\n            let cancelled = false;\n            _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count().then({\n                \"useSyncManager.useEffect\": (c)=>{\n                    if (!cancelled) setPendingCount(c);\n                }\n            }[\"useSyncManager.useEffect\"]);\n            const interval = setInterval({\n                \"useSyncManager.useEffect.interval\": ()=>{\n                    _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count().then({\n                        \"useSyncManager.useEffect.interval\": (c)=>{\n                            if (!cancelled) setPendingCount(c);\n                        }\n                    }[\"useSyncManager.useEffect.interval\"]);\n                }\n            }[\"useSyncManager.useEffect.interval\"], 2000);\n            return ({\n                \"useSyncManager.useEffect\": ()=>{\n                    cancelled = true;\n                    clearInterval(interval);\n                }\n            })[\"useSyncManager.useEffect\"];\n        }\n    }[\"useSyncManager.useEffect\"], []);\n    return {\n        isOnline,\n        syncState,\n        lastError,\n        pendingCount,\n        sync,\n        pull,\n        push\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTeW5jTWFuYWdlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7b0VBRUE7Ozs7O0NBS0MsR0FFd0Q7QUFDTDtBQUNFO0FBRXRELE1BQU1LLDRCQUE0QjtBQUNsQyxNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTUMsV0FBV0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSTtBQUVwRCxTQUFTQztJQUNQLElBQUksS0FBNkIsRUFBRSxFQUFhO0lBQ2hELE9BQU9DLGFBQWFDLE9BQU8sQ0FBQ1AsMEJBQTBCO0FBQ3hEO0FBRUEsU0FBU1E7SUFDUCxNQUFNQyxRQUFRWCxtRUFBWUE7SUFDMUIsTUFBTVksSUFBaUI7UUFBRSxnQkFBZ0I7SUFBbUI7SUFDNUQsSUFBSUQsT0FBTyxDQUE2QixDQUFDLGdCQUFnQixHQUFHLFVBQWdCLE9BQU5BO0lBQ3RFLE9BQU9DO0FBQ1Q7QUFXTyxTQUFTQyxlQUFlLEtBQXVFO1FBQXZFLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsSUFBSSxFQUF5QixHQUF2RTtJQUM3QixNQUFNLENBQUNDLGlCQUFpQkMsd0JBQXdCLEdBQUdyQiwrQ0FBUUE7bUNBQ3pELElBQU0sS0FBNkIsSUFBSVM7O0lBRXpDLE1BQU1hLGlCQUFpQixLQUE2QixHQUFHQyxPQUFPQyxTQUFTLENBQUNDLE1BQU0sR0FBRyxDQUFJO0lBQ3JGLE1BQU1DLFdBQVdKLGtCQUFrQixDQUFDRjtJQUVwQyxNQUFNTyxxQkFBcUI3QixrREFBV0E7MERBQUMsQ0FBQzhCO1lBQ3RDLElBQUksS0FBNkIsRUFBRSxFQUFPO1lBQzFDLElBQUlBLE9BQU9sQixhQUFhbUIsT0FBTyxDQUFDekIsc0JBQXNCO2lCQUNqRE0sYUFBYW9CLFVBQVUsQ0FBQzFCO1lBQzdCaUIsd0JBQXdCTztRQUMxQjt5REFBRyxFQUFFO0lBRUwsTUFBTSxDQUFDRyxXQUFXQyxhQUFhLEdBQUdoQywrQ0FB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dHMvZnJvbnRlbmQvc3JjL2hvb2tzL3VzZVN5bmNNYW5hZ2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuLyoqXG4gKiB1c2VTeW5jTWFuYWdlciAtIFRoZSBIZWFydCBvZiBPZmZsaW5lLUZpcnN0IFN5bmMuXG4gKiAtIExpc3RlbnMgdG8gbmF2aWdhdG9yLm9uTGluZTsgb24gcmVjb25uZWN0aW9uIHJ1bnMgcHVsbCB0aGVuIHB1c2guXG4gKiAtIFB1bGw6IEdFVCAvc3luYy9wdWxsP3RlbmFudF9pZD0mbWF4X3ZlcnNpb25faWQ9IOKGkiBhcHBseSBkZWx0YSB0byBEZXhpZSAoc2VydmVyIHdpbnMgZm9yIHByb2R1Y3RzKS5cbiAqIC0gUHVzaDogUE9TVCAvc3luYyB3aXRoIFN5bmNRdWV1ZSBpdGVtcyDihpIgc2VydmVyIHByb2Nlc3NlcyBpbiB0cmFuc2FjdGlvbiwgcmV0dXJucyB2ZXJzaW9uX2lkLlxuICovXG5cbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZGIsIHR5cGUgU3luY1F1ZXVlUmVjb3JkIH0gZnJvbSAnQC9saWIvZGInO1xuaW1wb3J0IHsgZ2V0QXV0aFRva2VuIH0gZnJvbSAnQC9jb250ZXh0cy9BdXRoQ29udGV4dCc7XG5cbmNvbnN0IFNZTkNfTUVUQV9LRVlfTUFYX1ZFUlNJT04gPSAnbG9jYWxfbWF4X3ZlcnNpb25faWQnO1xuY29uc3QgU0lNVUxBVEVfT0ZGTElORV9LRVkgPSAnYmx1ZWNvdW50c19zaW11bGF0ZV9vZmZsaW5lJztcbmNvbnN0IEFQSV9CQVNFID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAxJztcblxuZnVuY3Rpb24gZ2V0U2ltdWxhdGVPZmZsaW5lKCk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNJTVVMQVRFX09GRkxJTkVfS0VZKSA9PT0gJzEnO1xufVxuXG5mdW5jdGlvbiBhdXRoSGVhZGVycygpOiBIZWFkZXJzSW5pdCB7XG4gIGNvbnN0IHRva2VuID0gZ2V0QXV0aFRva2VuKCk7XG4gIGNvbnN0IGg6IEhlYWRlcnNJbml0ID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH07XG4gIGlmICh0b2tlbikgKGggYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPilbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICByZXR1cm4gaDtcbn1cblxudHlwZSBTeW5jU3RhdGUgPSAnaWRsZScgfCAncHVsbGluZycgfCAncHVzaGluZycgfCAnZXJyb3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVN5bmNNYW5hZ2VyT3B0aW9ucyB7XG4gIHRlbmFudElkOiBzdHJpbmc7XG4gIG91dGxldElkOiBzdHJpbmc7XG4gIGRldmljZUlkOiBzdHJpbmc7XG4gIGVuYWJsZWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3luY01hbmFnZXIoeyB0ZW5hbnRJZCwgb3V0bGV0SWQsIGRldmljZUlkLCBlbmFibGVkID0gdHJ1ZSB9OiBVc2VTeW5jTWFuYWdlck9wdGlvbnMpIHtcbiAgY29uc3QgW3NpbXVsYXRlT2ZmbGluZSwgc2V0U2ltdWxhdGVPZmZsaW5lU3RhdGVdID0gdXNlU3RhdGUoXG4gICAgKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0U2ltdWxhdGVPZmZsaW5lKClcbiAgKTtcbiAgY29uc3QgYWN0dWFsbHlPbmxpbmUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lIDogdHJ1ZTtcbiAgY29uc3QgaXNPbmxpbmUgPSBhY3R1YWxseU9ubGluZSAmJiAhc2ltdWxhdGVPZmZsaW5lO1xuXG4gIGNvbnN0IHNldFNpbXVsYXRlT2ZmbGluZSA9IHVzZUNhbGxiYWNrKCh2YWx1ZTogYm9vbGVhbikgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSkgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU0lNVUxBVEVfT0ZGTElORV9LRVksICcxJyk7XG4gICAgZWxzZSBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShTSU1VTEFURV9PRkZMSU5FX0tFWSk7XG4gICAgc2V0U2ltdWxhdGVPZmZsaW5lU3RhdGUodmFsdWUpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgW3N5bmNTdGF0ZSwgc2V0U3luY1N0YXRlXSA9IHVzZVN0YXRlPFN5bmNTdGF0ZT4oJ2lkbGUnKTtcbiAgY29uc3QgW2xhc3RFcnJvciwgc2V0TGFzdEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbcGVuZGluZ0NvdW50LCBzZXRQZW5kaW5nQ291bnRdID0gdXNlU3RhdGUoMCk7XG5cbiAgY29uc3QgZ2V0TWF4VmVyc2lvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpOiBQcm9taXNlPG51bWJlcj4gPT4ge1xuICAgIGNvbnN0IHJvdyA9IGF3YWl0IGRiLnN5bmNfbWV0YS5nZXQoU1lOQ19NRVRBX0tFWV9NQVhfVkVSU0lPTik7XG4gICAgY29uc3QgdiA9IHJvdz8udmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykgcmV0dXJuIHY7XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykgcmV0dXJuIHBhcnNlSW50KHYsIDEwKSB8fCAwO1xuICAgIHJldHVybiAwO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgc2V0TWF4VmVyc2lvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICh2ZXJzaW9uOiBudW1iZXIpID0+IHtcbiAgICBhd2FpdCBkYi5zeW5jX21ldGEucHV0KHsga2V5OiBTWU5DX01FVEFfS0VZX01BWF9WRVJTSU9OLCB2YWx1ZTogdmVyc2lvbiB9KTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHB1bGwgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoZm9yY2VGdWxsU3luYyA9IGZhbHNlKSA9PiB7XG4gICAgICBpZiAoIXRlbmFudElkKSByZXR1cm47XG4gICAgICBzZXRTeW5jU3RhdGUoJ3B1bGxpbmcnKTtcbiAgICAgIHNldExhc3RFcnJvcihudWxsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBtYXhWZXIgPSBhd2FpdCBnZXRNYXhWZXJzaW9uKCk7XG4gICAgICAgIGlmIChmb3JjZUZ1bGxTeW5jKSB7XG4gICAgICAgICAgbWF4VmVyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBoYXNMb2NhbERhdGEgPSBhd2FpdCBkYi5wcm9kdWN0cy53aGVyZSgndGVuYW50X2lkJykuZXF1YWxzKHRlbmFudElkKS5jb3VudCgpO1xuICAgICAgICAgIGlmIChoYXNMb2NhbERhdGEgPT09IDApIHtcbiAgICAgICAgICAgIG1heFZlciA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IGAke0FQSV9CQVNFfS9zeW5jL3B1bGw/dGVuYW50X2lkPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRlbmFudElkKX0mbWF4X3ZlcnNpb25faWQ9JHttYXhWZXJ9YDtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgeyBoZWFkZXJzOiBhdXRoSGVhZGVycygpIH0pO1xuICAgICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcihgUHVsbCBmYWlsZWQ6ICR7cmVzLnN0YXR1c31gKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgY29uc3QgeyB0YWJsZXMsIHNlcnZlcl9tYXhfdmVyc2lvbl9pZCB9ID0gZGF0YTtcblxuICAgICAgaWYgKHRhYmxlcy5wcm9kdWN0cz8ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlcy5wcm9kdWN0cykge1xuICAgICAgICAgIGlmIChyb3cuZGVsZXRlZF9hdCkge1xuICAgICAgICAgICAgYXdhaXQgZGIucHJvZHVjdHMudXBkYXRlKHJvdy5pZCwgeyBkZWxldGVkX2F0OiByb3cuZGVsZXRlZF9hdCwgdmVyc2lvbl9pZDogcm93LnZlcnNpb25faWQgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGRiLnByb2R1Y3RzLnB1dCh7XG4gICAgICAgICAgICAgIGlkOiByb3cuaWQsXG4gICAgICAgICAgICAgIHRlbmFudF9pZDogcm93LnRlbmFudF9pZCxcbiAgICAgICAgICAgICAgc2t1OiByb3cuc2t1LFxuICAgICAgICAgICAgICBuYW1lOiByb3cubmFtZSxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHJvdy5kZXNjcmlwdGlvbiA/PyBudWxsLFxuICAgICAgICAgICAgICBwcmljZTogTnVtYmVyKHJvdy5wcmljZSksXG4gICAgICAgICAgICAgIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkLFxuICAgICAgICAgICAgICBjcmVhdGVkX2F0OiByb3cuY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgdXBkYXRlZF9hdDogcm93LnVwZGF0ZWRfYXQsXG4gICAgICAgICAgICAgIGRlbGV0ZWRfYXQ6IHJvdy5kZWxldGVkX2F0ID8/IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZXMuaW52ZW50b3J5Py5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGVzLmludmVudG9yeSkge1xuICAgICAgICAgIGNvbnN0IHByb2R1Y3RLZXkgPSBbcm93LnRlbmFudF9pZCwgcm93Lm91dGxldF9pZCwgcm93LnByb2R1Y3RfaWRdIGFzIFtzdHJpbmcsIHN0cmluZywgc3RyaW5nXTtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGF3YWl0IGRiLmludmVudG9yeS53aGVyZSgnW3RlbmFudF9pZCtvdXRsZXRfaWQrcHJvZHVjdF9pZF0nKS5lcXVhbHMocHJvZHVjdEtleSkudG9BcnJheSgpO1xuICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBleGlzdGluZykge1xuICAgICAgICAgICAgaWYgKGUuaWQgIT09IHJvdy5pZCkgYXdhaXQgZGIuaW52ZW50b3J5LmRlbGV0ZShlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvdy5kZWxldGVkX2F0KSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5pbnZlbnRvcnkudXBkYXRlKHJvdy5pZCwgeyBkZWxldGVkX2F0OiByb3cuZGVsZXRlZF9hdCwgdmVyc2lvbl9pZDogcm93LnZlcnNpb25faWQgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGRiLmludmVudG9yeS5wdXQoe1xuICAgICAgICAgICAgICBpZDogcm93LmlkLFxuICAgICAgICAgICAgICB0ZW5hbnRfaWQ6IHJvdy50ZW5hbnRfaWQsXG4gICAgICAgICAgICAgIG91dGxldF9pZDogcm93Lm91dGxldF9pZCxcbiAgICAgICAgICAgICAgcHJvZHVjdF9pZDogcm93LnByb2R1Y3RfaWQsXG4gICAgICAgICAgICAgIHF1YW50aXR5OiBOdW1iZXIocm93LnF1YW50aXR5KSxcbiAgICAgICAgICAgICAgdmVyc2lvbl9pZDogcm93LnZlcnNpb25faWQsXG4gICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IHJvdy5jcmVhdGVkX2F0LFxuICAgICAgICAgICAgICB1cGRhdGVkX2F0OiByb3cudXBkYXRlZF9hdCxcbiAgICAgICAgICAgICAgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQgPz8gbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRhYmxlcy5zYWxlcz8ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlcy5zYWxlcykge1xuICAgICAgICAgIGlmIChyb3cuZGVsZXRlZF9hdCkge1xuICAgICAgICAgICAgYXdhaXQgZGIuc2FsZXMudXBkYXRlKHJvdy5pZCwgeyBkZWxldGVkX2F0OiByb3cuZGVsZXRlZF9hdCwgdmVyc2lvbl9pZDogcm93LnZlcnNpb25faWQgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGRiLnNhbGVzLnB1dCh7XG4gICAgICAgICAgICAgIGlkOiByb3cuaWQsXG4gICAgICAgICAgICAgIHRlbmFudF9pZDogcm93LnRlbmFudF9pZCxcbiAgICAgICAgICAgICAgb3V0bGV0X2lkOiByb3cub3V0bGV0X2lkLFxuICAgICAgICAgICAgICBkZXZpY2VfaWQ6IHJvdy5kZXZpY2VfaWQsXG4gICAgICAgICAgICAgIHNlc3Npb25faWQ6IHJvdy5zZXNzaW9uX2lkID8/IG51bGwsXG4gICAgICAgICAgICAgIGRldmljZV90cmFuc2FjdGlvbl9pZDogcm93LmRldmljZV90cmFuc2FjdGlvbl9pZCxcbiAgICAgICAgICAgICAgdG90YWxfYW1vdW50OiBOdW1iZXIocm93LnRvdGFsX2Ftb3VudCksXG4gICAgICAgICAgICAgIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkLFxuICAgICAgICAgICAgICBjcmVhdGVkX2F0OiByb3cuY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgdXBkYXRlZF9hdDogcm93LnVwZGF0ZWRfYXQsXG4gICAgICAgICAgICAgIGRlbGV0ZWRfYXQ6IHJvdy5kZWxldGVkX2F0ID8/IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZXMuc2FsZV9pdGVtcz8ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlcy5zYWxlX2l0ZW1zKSB7XG4gICAgICAgICAgaWYgKHJvdy5kZWxldGVkX2F0KSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5zYWxlX2l0ZW1zLnVwZGF0ZShyb3cuaWQsIHsgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQsIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5zYWxlX2l0ZW1zLnB1dCh7XG4gICAgICAgICAgICAgIGlkOiByb3cuaWQsXG4gICAgICAgICAgICAgIHRlbmFudF9pZDogcm93LnRlbmFudF9pZCxcbiAgICAgICAgICAgICAgb3V0bGV0X2lkOiByb3cub3V0bGV0X2lkLFxuICAgICAgICAgICAgICBzYWxlX2lkOiByb3cuc2FsZV9pZCxcbiAgICAgICAgICAgICAgcHJvZHVjdF9pZDogcm93LnByb2R1Y3RfaWQsXG4gICAgICAgICAgICAgIHF1YW50aXR5OiByb3cucXVhbnRpdHksXG4gICAgICAgICAgICAgIHVuaXRfcHJpY2U6IE51bWJlcihyb3cudW5pdF9wcmljZSksXG4gICAgICAgICAgICAgIGxpbmVfdG90YWw6IE51bWJlcihyb3cubGluZV90b3RhbCksXG4gICAgICAgICAgICAgIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkLFxuICAgICAgICAgICAgICBjcmVhdGVkX2F0OiByb3cuY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQgPz8gbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRhYmxlcy5wb3Nfc2Vzc2lvbnM/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZXMucG9zX3Nlc3Npb25zKSB7XG4gICAgICAgICAgaWYgKHJvdy5kZWxldGVkX2F0KSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5wb3Nfc2Vzc2lvbnMudXBkYXRlKHJvdy5pZCwgeyBkZWxldGVkX2F0OiByb3cuZGVsZXRlZF9hdCwgdmVyc2lvbl9pZDogcm93LnZlcnNpb25faWQgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGRiLnBvc19zZXNzaW9ucy5wdXQoe1xuICAgICAgICAgICAgICBpZDogcm93LmlkLFxuICAgICAgICAgICAgICB0ZW5hbnRfaWQ6IHJvdy50ZW5hbnRfaWQsXG4gICAgICAgICAgICAgIG91dGxldF9pZDogcm93Lm91dGxldF9pZCxcbiAgICAgICAgICAgICAgdXNlcl9pZDogcm93LnVzZXJfaWQsXG4gICAgICAgICAgICAgIGRldmljZV9pZDogcm93LmRldmljZV9pZCA/PyBudWxsLFxuICAgICAgICAgICAgICBvcGVuaW5nX2JhbGFuY2U6IE51bWJlcihyb3cub3BlbmluZ19iYWxhbmNlKSxcbiAgICAgICAgICAgICAgY2xvc2luZ19iYWxhbmNlOiByb3cuY2xvc2luZ19iYWxhbmNlICE9IG51bGwgPyBOdW1iZXIocm93LmNsb3NpbmdfYmFsYW5jZSkgOiBudWxsLFxuICAgICAgICAgICAgICBleHBlY3RlZF9iYWxhbmNlOiByb3cuZXhwZWN0ZWRfYmFsYW5jZSAhPSBudWxsID8gTnVtYmVyKHJvdy5leHBlY3RlZF9iYWxhbmNlKSA6IG51bGwsXG4gICAgICAgICAgICAgIHN0YXR1czogcm93LnN0YXR1cyA9PT0gJ2Nsb3NlZCcgPyAnY2xvc2VkJyA6ICdvcGVuJyxcbiAgICAgICAgICAgICAgb3BlbmVkX2F0OiByb3cub3BlbmVkX2F0LFxuICAgICAgICAgICAgICBjbG9zZWRfYXQ6IHJvdy5jbG9zZWRfYXQgPz8gbnVsbCxcbiAgICAgICAgICAgICAgdmVyc2lvbl9pZDogcm93LnZlcnNpb25faWQsXG4gICAgICAgICAgICAgIGRlbGV0ZWRfYXQ6IHJvdy5kZWxldGVkX2F0ID8/IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzZXJ2ZXJfbWF4X3ZlcnNpb25faWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGF3YWl0IHNldE1heFZlcnNpb24oc2VydmVyX21heF92ZXJzaW9uX2lkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBtc2cgPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiAnUHVsbCBmYWlsZWQnO1xuICAgICAgc2V0TGFzdEVycm9yKG1zZyk7XG4gICAgICBzZXRTeW5jU3RhdGUoJ2Vycm9yJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldFN5bmNTdGF0ZSgnaWRsZScpO1xuICB9LFxuICAgIFt0ZW5hbnRJZCwgb3V0bGV0SWQsIGdldE1heFZlcnNpb24sIHNldE1heFZlcnNpb25dXG4gICk7XG5cbiAgY29uc3QgcHVzaCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXRlbmFudElkIHx8ICFvdXRsZXRJZCB8fCAhZGV2aWNlSWQpIHJldHVybjtcbiAgICBjb25zdCBwZW5kaW5nID0gYXdhaXQgZGIuc3luY19xdWV1ZS53aGVyZSgnc3RhdHVzJykuZXF1YWxzKCdwZW5kaW5nJykudG9BcnJheSgpO1xuICAgIGlmIChwZW5kaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2V0UGVuZGluZ0NvdW50KDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRTeW5jU3RhdGUoJ3B1c2hpbmcnKTtcbiAgICBzZXRMYXN0RXJyb3IobnVsbCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gcGVuZGluZy5tYXAoKHE6IFN5bmNRdWV1ZVJlY29yZCkgPT4gKHtcbiAgICAgICAgaWQ6IHEuaWQsXG4gICAgICAgIGFjdGlvbl90eXBlOiBxLmFjdGlvbl90eXBlLFxuICAgICAgICBwYXlsb2FkOiBxLnBheWxvYWQsXG4gICAgICB9KSk7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRX0vc3luY2AsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzKCksXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB0ZW5hbnRfaWQ6IHRlbmFudElkLFxuICAgICAgICAgIG91dGxldF9pZDogb3V0bGV0SWQsXG4gICAgICAgICAgZGV2aWNlX2lkOiBkZXZpY2VJZCxcbiAgICAgICAgICBpdGVtcyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIGNvbnN0IGVyckJvZHkgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyQm9keSB8fCBgUHVzaCBmYWlsZWQ6ICR7cmVzLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgaWYgKGRhdGEudmVyc2lvbl9pZCAhPSBudWxsKSBhd2FpdCBzZXRNYXhWZXJzaW9uKGRhdGEudmVyc2lvbl9pZCk7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgZGF0YS5yZXN1bHRzIHx8IFtdKSB7XG4gICAgICAgIGlmIChyLnN0YXR1cyA9PT0gJ2FjY2VwdGVkJyB8fCByLnN0YXR1cyA9PT0gJ3N5bmNlZCcpIHtcbiAgICAgICAgICBhd2FpdCBkYi5zeW5jX3F1ZXVlLnVwZGF0ZShyLnF1ZXVlX2lkLCB7IHN0YXR1czogJ3N5bmNlZCcgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoci5zdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgYXdhaXQgZGIuc3luY19xdWV1ZS51cGRhdGUoci5xdWV1ZV9pZCwgeyBzdGF0dXM6ICdmYWlsZWQnLCBlcnJvcl9tZXNzYWdlOiByLmVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzdGlsbFBlbmRpbmcgPSBhd2FpdCBkYi5zeW5jX3F1ZXVlLndoZXJlKCdzdGF0dXMnKS5lcXVhbHMoJ3BlbmRpbmcnKS5jb3VudCgpO1xuICAgICAgc2V0UGVuZGluZ0NvdW50KHN0aWxsUGVuZGluZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgbXNnID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogJ1B1c2ggZmFpbGVkJztcbiAgICAgIHNldExhc3RFcnJvcihtc2cpO1xuICAgICAgc2V0U3luY1N0YXRlKCdlcnJvcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRTeW5jU3RhdGUoJ2lkbGUnKTtcbiAgICBjb25zdCBzdGlsbFBlbmRpbmcgPSBhd2FpdCBkYi5zeW5jX3F1ZXVlLndoZXJlKCdzdGF0dXMnKS5lcXVhbHMoJ3BlbmRpbmcnKS5jb3VudCgpO1xuICAgIHNldFBlbmRpbmdDb3VudChzdGlsbFBlbmRpbmcpO1xuICB9LCBbdGVuYW50SWQsIG91dGxldElkLCBkZXZpY2VJZCwgc2V0TWF4VmVyc2lvbl0pO1xuXG4gIGNvbnN0IHN5bmMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgYXdhaXQgcHVsbCh0cnVlKTtcbiAgICBhd2FpdCBwdXNoKCk7XG4gICAgYXdhaXQgcHVsbCh0cnVlKTtcbiAgfSwgW2VuYWJsZWQsIHB1bGwsIHB1c2hdKTtcblxuICAvLyBXaGVuIG9ubGluZSAoYW5kIG5vdCBzaW11bGF0aW5nIG9mZmxpbmUpLCBkbyBhIGZ1bGwgcHVsbCBvbiBwYWdlIGxvYWQuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFlbmFibGVkIHx8ICF0ZW5hbnRJZCB8fCAhaXNPbmxpbmUpIHJldHVybjtcbiAgICBwdWxsKHRydWUpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW3RlbmFudElkLCBlbmFibGVkLCBpc09ubGluZV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgY29uc3QgaGFuZGxlT25saW5lID0gKCkgPT4ge1xuICAgICAgc2V0SXNPbmxpbmUodHJ1ZSk7XG4gICAgICBpZiAoZW5hYmxlZCAmJiB0ZW5hbnRJZCkgc3luYygpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlT2ZmbGluZSA9ICgpID0+IHNldElzT25saW5lKGZhbHNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgaGFuZGxlT25saW5lKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGhhbmRsZU9mZmxpbmUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb25saW5lJywgaGFuZGxlT25saW5lKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgaGFuZGxlT2ZmbGluZSk7XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHRlbmFudElkLCBzeW5jXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgZGIuc3luY19xdWV1ZS53aGVyZSgnc3RhdHVzJykuZXF1YWxzKCdwZW5kaW5nJykuY291bnQoKS50aGVuKChjKSA9PiB7XG4gICAgICBpZiAoIWNhbmNlbGxlZCkgc2V0UGVuZGluZ0NvdW50KGMpO1xuICAgIH0pO1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgZGIuc3luY19xdWV1ZS53aGVyZSgnc3RhdHVzJykuZXF1YWxzKCdwZW5kaW5nJykuY291bnQoKS50aGVuKChjKSA9PiB7XG4gICAgICAgIGlmICghY2FuY2VsbGVkKSBzZXRQZW5kaW5nQ291bnQoYyk7XG4gICAgICB9KTtcbiAgICB9LCAyMDAwKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICByZXR1cm4ge1xuICAgIGlzT25saW5lLFxuICAgIHN5bmNTdGF0ZSxcbiAgICBsYXN0RXJyb3IsXG4gICAgcGVuZGluZ0NvdW50LFxuICAgIHN5bmMsXG4gICAgcHVsbCxcbiAgICBwdXNoLFxuICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJkYiIsImdldEF1dGhUb2tlbiIsIlNZTkNfTUVUQV9LRVlfTUFYX1ZFUlNJT04iLCJTSU1VTEFURV9PRkZMSU5FX0tFWSIsIkFQSV9CQVNFIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJnZXRTaW11bGF0ZU9mZmxpbmUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiYXV0aEhlYWRlcnMiLCJ0b2tlbiIsImgiLCJ1c2VTeW5jTWFuYWdlciIsInRlbmFudElkIiwib3V0bGV0SWQiLCJkZXZpY2VJZCIsImVuYWJsZWQiLCJzaW11bGF0ZU9mZmxpbmUiLCJzZXRTaW11bGF0ZU9mZmxpbmVTdGF0ZSIsImFjdHVhbGx5T25saW5lIiwid2luZG93IiwibmF2aWdhdG9yIiwib25MaW5lIiwiaXNPbmxpbmUiLCJzZXRTaW11bGF0ZU9mZmxpbmUiLCJ2YWx1ZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwic3luY1N0YXRlIiwic2V0U3luY1N0YXRlIiwibGFzdEVycm9yIiwic2V0TGFzdEVycm9yIiwicGVuZGluZ0NvdW50Iiwic2V0UGVuZGluZ0NvdW50IiwiZ2V0TWF4VmVyc2lvbiIsInJvdyIsInN5bmNfbWV0YSIsImdldCIsInYiLCJwYXJzZUludCIsInNldE1heFZlcnNpb24iLCJ2ZXJzaW9uIiwicHV0Iiwia2V5IiwicHVsbCIsImZvcmNlRnVsbFN5bmMiLCJ0YWJsZXMiLCJtYXhWZXIiLCJoYXNMb2NhbERhdGEiLCJwcm9kdWN0cyIsIndoZXJlIiwiZXF1YWxzIiwiY291bnQiLCJ1cmwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXMiLCJmZXRjaCIsImhlYWRlcnMiLCJvayIsIkVycm9yIiwic3RhdHVzIiwiZGF0YSIsImpzb24iLCJzZXJ2ZXJfbWF4X3ZlcnNpb25faWQiLCJsZW5ndGgiLCJkZWxldGVkX2F0IiwidXBkYXRlIiwiaWQiLCJ2ZXJzaW9uX2lkIiwidGVuYW50X2lkIiwic2t1IiwibmFtZSIsImRlc2NyaXB0aW9uIiwicHJpY2UiLCJOdW1iZXIiLCJjcmVhdGVkX2F0IiwidXBkYXRlZF9hdCIsImludmVudG9yeSIsInByb2R1Y3RLZXkiLCJvdXRsZXRfaWQiLCJwcm9kdWN0X2lkIiwiZXhpc3RpbmciLCJ0b0FycmF5IiwiZSIsImRlbGV0ZSIsInF1YW50aXR5Iiwic2FsZXMiLCJkZXZpY2VfaWQiLCJzZXNzaW9uX2lkIiwiZGV2aWNlX3RyYW5zYWN0aW9uX2lkIiwidG90YWxfYW1vdW50Iiwic2FsZV9pdGVtcyIsInNhbGVfaWQiLCJ1bml0X3ByaWNlIiwibGluZV90b3RhbCIsInBvc19zZXNzaW9ucyIsInVzZXJfaWQiLCJvcGVuaW5nX2JhbGFuY2UiLCJjbG9zaW5nX2JhbGFuY2UiLCJleHBlY3RlZF9iYWxhbmNlIiwib3BlbmVkX2F0IiwiY2xvc2VkX2F0IiwibXNnIiwibWVzc2FnZSIsInB1c2giLCJwZW5kaW5nIiwic3luY19xdWV1ZSIsIml0ZW1zIiwibWFwIiwicSIsImFjdGlvbl90eXBlIiwicGF5bG9hZCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyQm9keSIsInRleHQiLCJyIiwicmVzdWx0cyIsInF1ZXVlX2lkIiwiZXJyb3JfbWVzc2FnZSIsImVycm9yIiwic3RpbGxQZW5kaW5nIiwic3luYyIsImhhbmRsZU9ubGluZSIsInNldElzT25saW5lIiwiaGFuZGxlT2ZmbGluZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsbGVkIiwidGhlbiIsImMiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSyncManager.ts\n"));

/***/ })

});