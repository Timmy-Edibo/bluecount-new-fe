"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useSyncManager.ts":
/*!*************************************!*\
  !*** ./src/hooks/useSyncManager.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSyncManager: () => (/* binding */ useSyncManager)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/db */ \"(app-pages-browser)/./src/lib/db.ts\");\n/* harmony import */ var _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/contexts/AuthContext */ \"(app-pages-browser)/./src/contexts/AuthContext.tsx\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ useSyncManager auto */ /**\n * useSyncManager - The Heart of Offline-First Sync.\n * - Listens to navigator.onLine; on reconnection runs pull then push.\n * - Pull: GET /sync/pull?tenant_id=&max_version_id= → apply delta to Dexie (server wins for products).\n * - Push: POST /sync with SyncQueue items → server processes in transaction, returns version_id.\n */ \n\n\nconst SYNC_META_KEY_MAX_VERSION = 'local_max_version_id';\nconst SIMULATE_OFFLINE_KEY = 'bluecounts_simulate_offline';\nconst API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';\nfunction getSimulateOffline() {\n    if (false) {}\n    return localStorage.getItem(SIMULATE_OFFLINE_KEY) === '1';\n}\nfunction authHeaders() {\n    const token = (0,_contexts_AuthContext__WEBPACK_IMPORTED_MODULE_2__.getAuthToken)();\n    const h = {\n        'Content-Type': 'application/json'\n    };\n    if (token) h['Authorization'] = \"Bearer \".concat(token);\n    return h;\n}\nfunction useSyncManager(param) {\n    let { tenantId, outletId, deviceId, enabled = true } = param;\n    const [simulateOffline, setSimulateOfflineState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useSyncManager.useState\": ()=> true && getSimulateOffline()\n    }[\"useSyncManager.useState\"]);\n    const actuallyOnline =  true ? window.navigator.onLine : 0;\n    const isOnline = actuallyOnline && !simulateOffline;\n    const setSimulateOffline = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[setSimulateOffline]\": (value)=>{\n            if (false) {}\n            if (value) localStorage.setItem(SIMULATE_OFFLINE_KEY, '1');\n            else localStorage.removeItem(SIMULATE_OFFLINE_KEY);\n            setSimulateOfflineState(value);\n        }\n    }[\"useSyncManager.useCallback[setSimulateOffline]\"], []);\n    const [syncState, setSyncState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('idle');\n    const [lastError, setLastError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [pendingCount, setPendingCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const getMaxVersion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[getMaxVersion]\": async ()=>{\n            const row = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_meta.get(SYNC_META_KEY_MAX_VERSION);\n            const v = row === null || row === void 0 ? void 0 : row.value;\n            if (typeof v === 'number') return v;\n            if (typeof v === 'string') return parseInt(v, 10) || 0;\n            return 0;\n        }\n    }[\"useSyncManager.useCallback[getMaxVersion]\"], []);\n    const setMaxVersion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[setMaxVersion]\": async (version)=>{\n            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_meta.put({\n                key: SYNC_META_KEY_MAX_VERSION,\n                value: version\n            });\n        }\n    }[\"useSyncManager.useCallback[setMaxVersion]\"], []);\n    const pull = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[pull]\": async function() {\n            let forceFullSync = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n            if (!tenantId) return;\n            setSyncState('pulling');\n            setLastError(null);\n            try {\n                var _tables_products, _tables_inventory, _tables_sales, _tables_sale_items, _tables_pos_sessions;\n                let maxVer = await getMaxVersion();\n                if (forceFullSync) {\n                    maxVer = 0;\n                } else {\n                    const hasLocalData = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.products.where('tenant_id').equals(tenantId).count();\n                    if (hasLocalData === 0) {\n                        maxVer = 0;\n                    }\n                }\n                const url = \"\".concat(API_BASE, \"/sync/pull?tenant_id=\").concat(encodeURIComponent(tenantId), \"&max_version_id=\").concat(maxVer);\n                const res = await fetch(url, {\n                    headers: authHeaders()\n                });\n                if (!res.ok) throw new Error(\"Pull failed: \".concat(res.status));\n                const data = await res.json();\n                const { tables, server_max_version_id } = data;\n                if ((_tables_products = tables.products) === null || _tables_products === void 0 ? void 0 : _tables_products.length) {\n                    for (const row of tables.products){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.products.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_description, _row_deleted_at;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.products.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                sku: row.sku,\n                                name: row.name,\n                                description: (_row_description = row.description) !== null && _row_description !== void 0 ? _row_description : null,\n                                price: Number(row.price),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                updated_at: row.updated_at,\n                                deleted_at: (_row_deleted_at = row.deleted_at) !== null && _row_deleted_at !== void 0 ? _row_deleted_at : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_inventory = tables.inventory) === null || _tables_inventory === void 0 ? void 0 : _tables_inventory.length) {\n                    for (const row of tables.inventory){\n                        const productKey = [\n                            row.tenant_id,\n                            row.outlet_id,\n                            row.product_id\n                        ];\n                        const existing = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.where('[tenant_id+outlet_id+product_id]').equals(productKey).toArray();\n                        for (const e of existing){\n                            if (e.id !== row.id) await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.delete(e.id);\n                        }\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_deleted_at1;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                product_id: row.product_id,\n                                quantity: Number(row.quantity),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                updated_at: row.updated_at,\n                                deleted_at: (_row_deleted_at1 = row.deleted_at) !== null && _row_deleted_at1 !== void 0 ? _row_deleted_at1 : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_sales = tables.sales) === null || _tables_sales === void 0 ? void 0 : _tables_sales.length) {\n                    for (const row of tables.sales){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sales.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_session_id, _row_deleted_at2;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sales.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                device_id: row.device_id,\n                                session_id: (_row_session_id = row.session_id) !== null && _row_session_id !== void 0 ? _row_session_id : null,\n                                device_transaction_id: row.device_transaction_id,\n                                total_amount: Number(row.total_amount),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                updated_at: row.updated_at,\n                                deleted_at: (_row_deleted_at2 = row.deleted_at) !== null && _row_deleted_at2 !== void 0 ? _row_deleted_at2 : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_sale_items = tables.sale_items) === null || _tables_sale_items === void 0 ? void 0 : _tables_sale_items.length) {\n                    for (const row of tables.sale_items){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sale_items.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_deleted_at3;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sale_items.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                sale_id: row.sale_id,\n                                product_id: row.product_id,\n                                quantity: row.quantity,\n                                unit_price: Number(row.unit_price),\n                                line_total: Number(row.line_total),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                deleted_at: (_row_deleted_at3 = row.deleted_at) !== null && _row_deleted_at3 !== void 0 ? _row_deleted_at3 : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_pos_sessions = tables.pos_sessions) === null || _tables_pos_sessions === void 0 ? void 0 : _tables_pos_sessions.length) {\n                    for (const row of tables.pos_sessions){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.pos_sessions.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_device_id, _row_closed_at, _row_deleted_at4;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.pos_sessions.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                user_id: row.user_id,\n                                device_id: (_row_device_id = row.device_id) !== null && _row_device_id !== void 0 ? _row_device_id : null,\n                                opening_balance: Number(row.opening_balance),\n                                closing_balance: row.closing_balance != null ? Number(row.closing_balance) : null,\n                                expected_balance: row.expected_balance != null ? Number(row.expected_balance) : null,\n                                status: row.status === 'closed' ? 'closed' : 'open',\n                                opened_at: row.opened_at,\n                                closed_at: (_row_closed_at = row.closed_at) !== null && _row_closed_at !== void 0 ? _row_closed_at : null,\n                                version_id: row.version_id,\n                                deleted_at: (_row_deleted_at4 = row.deleted_at) !== null && _row_deleted_at4 !== void 0 ? _row_deleted_at4 : null\n                            });\n                        }\n                    }\n                }\n                if (typeof server_max_version_id === 'number') {\n                    await setMaxVersion(server_max_version_id);\n                }\n            } catch (e) {\n                const msg = e instanceof Error ? e.message : 'Pull failed';\n                setLastError(msg);\n                setSyncState('error');\n                return;\n            }\n            setSyncState('idle');\n        }\n    }[\"useSyncManager.useCallback[pull]\"], [\n        tenantId,\n        outletId,\n        getMaxVersion,\n        setMaxVersion\n    ]);\n    const push = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[push]\": async ()=>{\n            if (!tenantId || !outletId || !deviceId) return;\n            const pending = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').toArray();\n            if (pending.length === 0) {\n                setPendingCount(0);\n                return;\n            }\n            setSyncState('pushing');\n            setLastError(null);\n            try {\n                const items = pending.map({\n                    \"useSyncManager.useCallback[push].items\": (q)=>({\n                            id: q.id,\n                            action_type: q.action_type,\n                            payload: q.payload\n                        })\n                }[\"useSyncManager.useCallback[push].items\"]);\n                const res = await fetch(\"\".concat(API_BASE, \"/sync\"), {\n                    method: 'POST',\n                    headers: authHeaders(),\n                    body: JSON.stringify({\n                        tenant_id: tenantId,\n                        outlet_id: outletId,\n                        device_id: deviceId,\n                        items\n                    })\n                });\n                if (!res.ok) {\n                    const errBody = await res.text();\n                    throw new Error(errBody || \"Push failed: \".concat(res.status));\n                }\n                const data = await res.json();\n                if (data.version_id != null) await setMaxVersion(data.version_id);\n                for (const r of data.results || []){\n                    if (r.status === 'accepted' || r.status === 'synced') {\n                        await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.update(r.queue_id, {\n                            status: 'synced'\n                        });\n                    } else if (r.status === 'failed') {\n                        await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.update(r.queue_id, {\n                            status: 'failed',\n                            error_message: r.error\n                        });\n                    }\n                }\n                const stillPending = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count();\n                setPendingCount(stillPending);\n            } catch (e) {\n                const msg = e instanceof Error ? e.message : 'Push failed';\n                setLastError(msg);\n                setSyncState('error');\n                return;\n            }\n            setSyncState('idle');\n            const stillPending = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count();\n            setPendingCount(stillPending);\n        }\n    }[\"useSyncManager.useCallback[push]\"], [\n        tenantId,\n        outletId,\n        deviceId,\n        setMaxVersion\n    ]);\n    const sync = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[sync]\": async ()=>{\n            if (!enabled) return;\n            await pull(true);\n            await push();\n            await pull(true);\n        }\n    }[\"useSyncManager.useCallback[sync]\"], [\n        enabled,\n        pull,\n        push\n    ]);\n    // When online, do a full pull on page load so we get all DB rows (products with low version_id are never sent on incremental pull).\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncManager.useEffect\": ()=>{\n            if ( false || !enabled || !tenantId) return;\n            if (window.navigator.onLine) {\n                pull(true);\n            }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useSyncManager.useEffect\"], [\n        tenantId,\n        enabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncManager.useEffect\": ()=>{\n            if (false) {}\n            const handleOnline = {\n                \"useSyncManager.useEffect.handleOnline\": ()=>{\n                    setIsOnline(true);\n                    if (enabled && tenantId) sync();\n                }\n            }[\"useSyncManager.useEffect.handleOnline\"];\n            const handleOffline = {\n                \"useSyncManager.useEffect.handleOffline\": ()=>setIsOnline(false)\n            }[\"useSyncManager.useEffect.handleOffline\"];\n            window.addEventListener('online', handleOnline);\n            window.addEventListener('offline', handleOffline);\n            return ({\n                \"useSyncManager.useEffect\": ()=>{\n                    window.removeEventListener('online', handleOnline);\n                    window.removeEventListener('offline', handleOffline);\n                }\n            })[\"useSyncManager.useEffect\"];\n        }\n    }[\"useSyncManager.useEffect\"], [\n        enabled,\n        tenantId,\n        sync\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncManager.useEffect\": ()=>{\n            let cancelled = false;\n            _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count().then({\n                \"useSyncManager.useEffect\": (c)=>{\n                    if (!cancelled) setPendingCount(c);\n                }\n            }[\"useSyncManager.useEffect\"]);\n            const interval = setInterval({\n                \"useSyncManager.useEffect.interval\": ()=>{\n                    _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count().then({\n                        \"useSyncManager.useEffect.interval\": (c)=>{\n                            if (!cancelled) setPendingCount(c);\n                        }\n                    }[\"useSyncManager.useEffect.interval\"]);\n                }\n            }[\"useSyncManager.useEffect.interval\"], 2000);\n            return ({\n                \"useSyncManager.useEffect\": ()=>{\n                    cancelled = true;\n                    clearInterval(interval);\n                }\n            })[\"useSyncManager.useEffect\"];\n        }\n    }[\"useSyncManager.useEffect\"], []);\n    return {\n        isOnline,\n        syncState,\n        lastError,\n        pendingCount,\n        sync,\n        pull,\n        push\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTeW5jTWFuYWdlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7b0VBRUE7Ozs7O0NBS0MsR0FFd0Q7QUFDTDtBQUNFO0FBRXRELE1BQU1LLDRCQUE0QjtBQUNsQyxNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTUMsV0FBV0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSTtBQUVwRCxTQUFTQztJQUNQLElBQUksS0FBNkIsRUFBRSxFQUFhO0lBQ2hELE9BQU9DLGFBQWFDLE9BQU8sQ0FBQ1AsMEJBQTBCO0FBQ3hEO0FBRUEsU0FBU1E7SUFDUCxNQUFNQyxRQUFRWCxtRUFBWUE7SUFDMUIsTUFBTVksSUFBaUI7UUFBRSxnQkFBZ0I7SUFBbUI7SUFDNUQsSUFBSUQsT0FBTyxDQUE2QixDQUFDLGdCQUFnQixHQUFHLFVBQWdCLE9BQU5BO0lBQ3RFLE9BQU9DO0FBQ1Q7QUFXTyxTQUFTQyxlQUFlLEtBQXVFO1FBQXZFLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsSUFBSSxFQUF5QixHQUF2RTtJQUM3QixNQUFNLENBQUNDLGlCQUFpQkMsd0JBQXdCLEdBQUdyQiwrQ0FBUUE7bUNBQ3pELElBQU0sS0FBNkIsSUFBSVM7O0lBRXpDLE1BQU1hLGlCQUFpQixLQUE2QixHQUFHQyxPQUFPQyxTQUFTLENBQUNDLE1BQU0sR0FBRyxDQUFJO0lBQ3JGLE1BQU1DLFdBQVdKLGtCQUFrQixDQUFDRjtJQUVwQyxNQUFNTyxxQkFBcUI3QixrREFBV0E7MERBQUMsQ0FBQzhCO1lBQ3RDLElBQUksS0FBNkIsRUFBRSxFQUFPO1lBQzFDLElBQUlBLE9BQU9sQixhQUFhbUIsT0FBTyxDQUFDekIsc0JBQXNCO2lCQUNqRE0sYUFBYW9CLFVBQVUsQ0FBQzFCO1lBQzdCaUIsd0JBQXdCTztRQUMxQjt5REFBRyxFQUFFO0lBRUwsTUFBTSxDQUFDRyxXQUFXQyxhQUFhLEdBQUdoQywrQ0FBUUEsQ0FBWTtJQUN0RCxNQUFNLENBQUNpQyxXQUFXQyxhQUFhLEdBQUdsQywrQ0FBUUEsQ0FBZ0I7SUFDMUQsTUFBTSxDQUFDbUMsY0FBY0MsZ0JBQWdCLEdBQUdwQywrQ0FBUUEsQ0FBQztJQUVqRCxNQUFNcUMsZ0JBQWdCdkMsa0RBQVdBO3FEQUFDO1lBQ2hDLE1BQU13QyxNQUFNLE1BQU1yQyx1Q0FBRUEsQ0FBQ3NDLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDckM7WUFDbkMsTUFBTXNDLElBQUlILGdCQUFBQSwwQkFBQUEsSUFBS1YsS0FBSztZQUNwQixJQUFJLE9BQU9hLE1BQU0sVUFBVSxPQUFPQTtZQUNsQyxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPQyxTQUFTRCxHQUFHLE9BQU87WUFDckQsT0FBTztRQUNUO29EQUFHLEVBQUU7SUFFTCxNQUFNRSxnQkFBZ0I3QyxrREFBV0E7cURBQUMsT0FBTzhDO1lBQ3ZDLE1BQU0zQyx1Q0FBRUEsQ0FBQ3NDLFNBQVMsQ0FBQ00sR0FBRyxDQUFDO2dCQUFFQyxLQUFLM0M7Z0JBQTJCeUIsT0FBT2dCO1lBQVE7UUFDMUU7b0RBQUcsRUFBRTtJQUVMLE1BQU1HLE9BQU9qRCxrREFBV0E7NENBQ3RCO2dCQUFPa0QsaUZBQWdCO1lBQ3JCLElBQUksQ0FBQ2hDLFVBQVU7WUFDZmdCLGFBQWE7WUFDYkUsYUFBYTtZQUNiLElBQUk7b0JBZ0JBZSxrQkFvQkFBLG1CQXdCQUEsZUFxQkFBLG9CQXFCQUE7Z0JBckdGLElBQUlDLFNBQVMsTUFBTWI7Z0JBQ25CLElBQUlXLGVBQWU7b0JBQ2pCRSxTQUFTO2dCQUNYLE9BQU87b0JBQ0wsTUFBTUMsZUFBZSxNQUFNbEQsdUNBQUVBLENBQUNtRCxRQUFRLENBQUNDLEtBQUssQ0FBQyxhQUFhQyxNQUFNLENBQUN0QyxVQUFVdUMsS0FBSztvQkFDaEYsSUFBSUosaUJBQWlCLEdBQUc7d0JBQ3RCRCxTQUFTO29CQUNYO2dCQUNGO2dCQUNBLE1BQU1NLE1BQU0sR0FBbUNDLE9BQWhDcEQsVUFBUyx5QkFBc0U2QyxPQUEvQ08sbUJBQW1CekMsV0FBVSxvQkFBeUIsT0FBUGtDO2dCQUNoRyxNQUFNUSxNQUFNLE1BQU1DLE1BQU1ILEtBQUs7b0JBQUVJLFNBQVNoRDtnQkFBYztnQkFDdEQsSUFBSSxDQUFDOEMsSUFBSUcsRUFBRSxFQUFFLE1BQU0sSUFBSUMsTUFBTSxnQkFBMkIsT0FBWEosSUFBSUssTUFBTTtnQkFDdkQsTUFBTUMsT0FBTyxNQUFNTixJQUFJTyxJQUFJO2dCQUMzQixNQUFNLEVBQUVoQixNQUFNLEVBQUVpQixxQkFBcUIsRUFBRSxHQUFHRjtnQkFFMUMsS0FBSWYsbUJBQUFBLE9BQU9HLFFBQVEsY0FBZkgsdUNBQUFBLGlCQUFpQmtCLE1BQU0sRUFBRTtvQkFDM0IsS0FBSyxNQUFNN0IsT0FBT1csT0FBT0csUUFBUSxDQUFFO3dCQUNqQyxJQUFJZCxJQUFJOEIsVUFBVSxFQUFFOzRCQUNsQixNQUFNbkUsdUNBQUVBLENBQUNtRCxRQUFRLENBQUNpQixNQUFNLENBQUMvQixJQUFJZ0MsRUFBRSxFQUFFO2dDQUFFRixZQUFZOUIsSUFBSThCLFVBQVU7Z0NBQUVHLFlBQVlqQyxJQUFJaUMsVUFBVTs0QkFBQzt3QkFDNUYsT0FBTztnQ0FNVWpDLGtCQUtEQTs0QkFWZCxNQUFNckMsdUNBQUVBLENBQUNtRCxRQUFRLENBQUNQLEdBQUcsQ0FBQztnQ0FDcEJ5QixJQUFJaEMsSUFBSWdDLEVBQUU7Z0NBQ1ZFLFdBQVdsQyxJQUFJa0MsU0FBUztnQ0FDeEJDLEtBQUtuQyxJQUFJbUMsR0FBRztnQ0FDWkMsTUFBTXBDLElBQUlvQyxJQUFJO2dDQUNkQyxhQUFhckMsQ0FBQUEsbUJBQUFBLElBQUlxQyxXQUFXLGNBQWZyQyw4QkFBQUEsbUJBQW1CO2dDQUNoQ3NDLE9BQU9DLE9BQU92QyxJQUFJc0MsS0FBSztnQ0FDdkJMLFlBQVlqQyxJQUFJaUMsVUFBVTtnQ0FDMUJPLFlBQVl4QyxJQUFJd0MsVUFBVTtnQ0FDMUJDLFlBQVl6QyxJQUFJeUMsVUFBVTtnQ0FDMUJYLFlBQVk5QixDQUFBQSxrQkFBQUEsSUFBSThCLFVBQVUsY0FBZDlCLDZCQUFBQSxrQkFBa0I7NEJBQ2hDO3dCQUNGO29CQUNGO2dCQUNGO2dCQUNBLEtBQUlXLG9CQUFBQSxPQUFPK0IsU0FBUyxjQUFoQi9CLHdDQUFBQSxrQkFBa0JrQixNQUFNLEVBQUU7b0JBQzVCLEtBQUssTUFBTTdCLE9BQU9XLE9BQU8rQixTQUFTLENBQUU7d0JBQ2xDLE1BQU1DLGFBQWE7NEJBQUMzQyxJQUFJa0MsU0FBUzs0QkFBRWxDLElBQUk0QyxTQUFTOzRCQUFFNUMsSUFBSTZDLFVBQVU7eUJBQUM7d0JBQ2pFLE1BQU1DLFdBQVcsTUFBTW5GLHVDQUFFQSxDQUFDK0UsU0FBUyxDQUFDM0IsS0FBSyxDQUFDLG9DQUFvQ0MsTUFBTSxDQUFDMkIsWUFBWUksT0FBTzt3QkFDeEcsS0FBSyxNQUFNQyxLQUFLRixTQUFVOzRCQUN4QixJQUFJRSxFQUFFaEIsRUFBRSxLQUFLaEMsSUFBSWdDLEVBQUUsRUFBRSxNQUFNckUsdUNBQUVBLENBQUMrRSxTQUFTLENBQUNPLE1BQU0sQ0FBQ0QsRUFBRWhCLEVBQUU7d0JBQ3JEO3dCQUNBLElBQUloQyxJQUFJOEIsVUFBVSxFQUFFOzRCQUNsQixNQUFNbkUsdUNBQUVBLENBQUMrRSxTQUFTLENBQUNYLE1BQU0sQ0FBQy9CLElBQUlnQyxFQUFFLEVBQUU7Z0NBQUVGLFlBQVk5QixJQUFJOEIsVUFBVTtnQ0FBRUcsWUFBWWpDLElBQUlpQyxVQUFVOzRCQUFDO3dCQUM3RixPQUFPO2dDQVVTakM7NEJBVGQsTUFBTXJDLHVDQUFFQSxDQUFDK0UsU0FBUyxDQUFDbkMsR0FBRyxDQUFDO2dDQUNyQnlCLElBQUloQyxJQUFJZ0MsRUFBRTtnQ0FDVkUsV0FBV2xDLElBQUlrQyxTQUFTO2dDQUN4QlUsV0FBVzVDLElBQUk0QyxTQUFTO2dDQUN4QkMsWUFBWTdDLElBQUk2QyxVQUFVO2dDQUMxQkssVUFBVVgsT0FBT3ZDLElBQUlrRCxRQUFRO2dDQUM3QmpCLFlBQVlqQyxJQUFJaUMsVUFBVTtnQ0FDMUJPLFlBQVl4QyxJQUFJd0MsVUFBVTtnQ0FDMUJDLFlBQVl6QyxJQUFJeUMsVUFBVTtnQ0FDMUJYLFlBQVk5QixDQUFBQSxtQkFBQUEsSUFBSThCLFVBQVUsY0FBZDlCLDhCQUFBQSxtQkFBa0I7NEJBQ2hDO3dCQUNGO29CQUNGO2dCQUNGO2dCQUNBLEtBQUlXLGdCQUFBQSxPQUFPd0MsS0FBSyxjQUFaeEMsb0NBQUFBLGNBQWNrQixNQUFNLEVBQUU7b0JBQ3hCLEtBQUssTUFBTTdCLE9BQU9XLE9BQU93QyxLQUFLLENBQUU7d0JBQzlCLElBQUluRCxJQUFJOEIsVUFBVSxFQUFFOzRCQUNsQixNQUFNbkUsdUNBQUVBLENBQUN3RixLQUFLLENBQUNwQixNQUFNLENBQUMvQixJQUFJZ0MsRUFBRSxFQUFFO2dDQUFFRixZQUFZOUIsSUFBSThCLFVBQVU7Z0NBQUVHLFlBQVlqQyxJQUFJaUMsVUFBVTs0QkFBQzt3QkFDekYsT0FBTztnQ0FNU2pDLGlCQU1BQTs0QkFYZCxNQUFNckMsdUNBQUVBLENBQUN3RixLQUFLLENBQUM1QyxHQUFHLENBQUM7Z0NBQ2pCeUIsSUFBSWhDLElBQUlnQyxFQUFFO2dDQUNWRSxXQUFXbEMsSUFBSWtDLFNBQVM7Z0NBQ3hCVSxXQUFXNUMsSUFBSTRDLFNBQVM7Z0NBQ3hCUSxXQUFXcEQsSUFBSW9ELFNBQVM7Z0NBQ3hCQyxZQUFZckQsQ0FBQUEsa0JBQUFBLElBQUlxRCxVQUFVLGNBQWRyRCw2QkFBQUEsa0JBQWtCO2dDQUM5QnNELHVCQUF1QnRELElBQUlzRCxxQkFBcUI7Z0NBQ2hEQyxjQUFjaEIsT0FBT3ZDLElBQUl1RCxZQUFZO2dDQUNyQ3RCLFlBQVlqQyxJQUFJaUMsVUFBVTtnQ0FDMUJPLFlBQVl4QyxJQUFJd0MsVUFBVTtnQ0FDMUJDLFlBQVl6QyxJQUFJeUMsVUFBVTtnQ0FDMUJYLFlBQVk5QixDQUFBQSxtQkFBQUEsSUFBSThCLFVBQVUsY0FBZDlCLDhCQUFBQSxtQkFBa0I7NEJBQ2hDO3dCQUNGO29CQUNGO2dCQUNGO2dCQUNBLEtBQUlXLHFCQUFBQSxPQUFPNkMsVUFBVSxjQUFqQjdDLHlDQUFBQSxtQkFBbUJrQixNQUFNLEVBQUU7b0JBQzdCLEtBQUssTUFBTTdCLE9BQU9XLE9BQU82QyxVQUFVLENBQUU7d0JBQ25DLElBQUl4RCxJQUFJOEIsVUFBVSxFQUFFOzRCQUNsQixNQUFNbkUsdUNBQUVBLENBQUM2RixVQUFVLENBQUN6QixNQUFNLENBQUMvQixJQUFJZ0MsRUFBRSxFQUFFO2dDQUFFRixZQUFZOUIsSUFBSThCLFVBQVU7Z0NBQUVHLFlBQVlqQyxJQUFJaUMsVUFBVTs0QkFBQzt3QkFDOUYsT0FBTztnQ0FZU2pDOzRCQVhkLE1BQU1yQyx1Q0FBRUEsQ0FBQzZGLFVBQVUsQ0FBQ2pELEdBQUcsQ0FBQztnQ0FDdEJ5QixJQUFJaEMsSUFBSWdDLEVBQUU7Z0NBQ1ZFLFdBQVdsQyxJQUFJa0MsU0FBUztnQ0FDeEJVLFdBQVc1QyxJQUFJNEMsU0FBUztnQ0FDeEJhLFNBQVN6RCxJQUFJeUQsT0FBTztnQ0FDcEJaLFlBQVk3QyxJQUFJNkMsVUFBVTtnQ0FDMUJLLFVBQVVsRCxJQUFJa0QsUUFBUTtnQ0FDdEJRLFlBQVluQixPQUFPdkMsSUFBSTBELFVBQVU7Z0NBQ2pDQyxZQUFZcEIsT0FBT3ZDLElBQUkyRCxVQUFVO2dDQUNqQzFCLFlBQVlqQyxJQUFJaUMsVUFBVTtnQ0FDMUJPLFlBQVl4QyxJQUFJd0MsVUFBVTtnQ0FDMUJWLFlBQVk5QixDQUFBQSxtQkFBQUEsSUFBSThCLFVBQVUsY0FBZDlCLDhCQUFBQSxtQkFBa0I7NEJBQ2hDO3dCQUNGO29CQUNGO2dCQUNGO2dCQUNBLEtBQUlXLHVCQUFBQSxPQUFPaUQsWUFBWSxjQUFuQmpELDJDQUFBQSxxQkFBcUJrQixNQUFNLEVBQUU7b0JBQy9CLEtBQUssTUFBTTdCLE9BQU9XLE9BQU9pRCxZQUFZLENBQUU7d0JBQ3JDLElBQUk1RCxJQUFJOEIsVUFBVSxFQUFFOzRCQUNsQixNQUFNbkUsdUNBQUVBLENBQUNpRyxZQUFZLENBQUM3QixNQUFNLENBQUMvQixJQUFJZ0MsRUFBRSxFQUFFO2dDQUFFRixZQUFZOUIsSUFBSThCLFVBQVU7Z0NBQUVHLFlBQVlqQyxJQUFJaUMsVUFBVTs0QkFBQzt3QkFDaEcsT0FBTztnQ0FNUWpDLGdCQU1BQSxnQkFFQ0E7NEJBYmQsTUFBTXJDLHVDQUFFQSxDQUFDaUcsWUFBWSxDQUFDckQsR0FBRyxDQUFDO2dDQUN4QnlCLElBQUloQyxJQUFJZ0MsRUFBRTtnQ0FDVkUsV0FBV2xDLElBQUlrQyxTQUFTO2dDQUN4QlUsV0FBVzVDLElBQUk0QyxTQUFTO2dDQUN4QmlCLFNBQVM3RCxJQUFJNkQsT0FBTztnQ0FDcEJULFdBQVdwRCxDQUFBQSxpQkFBQUEsSUFBSW9ELFNBQVMsY0FBYnBELDRCQUFBQSxpQkFBaUI7Z0NBQzVCOEQsaUJBQWlCdkIsT0FBT3ZDLElBQUk4RCxlQUFlO2dDQUMzQ0MsaUJBQWlCL0QsSUFBSStELGVBQWUsSUFBSSxPQUFPeEIsT0FBT3ZDLElBQUkrRCxlQUFlLElBQUk7Z0NBQzdFQyxrQkFBa0JoRSxJQUFJZ0UsZ0JBQWdCLElBQUksT0FBT3pCLE9BQU92QyxJQUFJZ0UsZ0JBQWdCLElBQUk7Z0NBQ2hGdkMsUUFBUXpCLElBQUl5QixNQUFNLEtBQUssV0FBVyxXQUFXO2dDQUM3Q3dDLFdBQVdqRSxJQUFJaUUsU0FBUztnQ0FDeEJDLFdBQVdsRSxDQUFBQSxpQkFBQUEsSUFBSWtFLFNBQVMsY0FBYmxFLDRCQUFBQSxpQkFBaUI7Z0NBQzVCaUMsWUFBWWpDLElBQUlpQyxVQUFVO2dDQUMxQkgsWUFBWTlCLENBQUFBLG1CQUFBQSxJQUFJOEIsVUFBVSxjQUFkOUIsOEJBQUFBLG1CQUFrQjs0QkFDaEM7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7Z0JBRUEsSUFBSSxPQUFPNEIsMEJBQTBCLFVBQVU7b0JBQzdDLE1BQU12QixjQUFjdUI7Z0JBQ3RCO1lBQ0YsRUFBRSxPQUFPb0IsR0FBRztnQkFDVixNQUFNbUIsTUFBTW5CLGFBQWF4QixRQUFRd0IsRUFBRW9CLE9BQU8sR0FBRztnQkFDN0N4RSxhQUFhdUU7Z0JBQ2J6RSxhQUFhO2dCQUNiO1lBQ0Y7WUFDQUEsYUFBYTtRQUNmOzJDQUNFO1FBQUNoQjtRQUFVQztRQUFVb0I7UUFBZU07S0FBYztJQUdwRCxNQUFNZ0UsT0FBTzdHLGtEQUFXQTs0Q0FBQztZQUN2QixJQUFJLENBQUNrQixZQUFZLENBQUNDLFlBQVksQ0FBQ0MsVUFBVTtZQUN6QyxNQUFNMEYsVUFBVSxNQUFNM0csdUNBQUVBLENBQUM0RyxVQUFVLENBQUN4RCxLQUFLLENBQUMsVUFBVUMsTUFBTSxDQUFDLFdBQVcrQixPQUFPO1lBQzdFLElBQUl1QixRQUFRekMsTUFBTSxLQUFLLEdBQUc7Z0JBQ3hCL0IsZ0JBQWdCO2dCQUNoQjtZQUNGO1lBQ0FKLGFBQWE7WUFDYkUsYUFBYTtZQUNiLElBQUk7Z0JBQ0YsTUFBTTRFLFFBQVFGLFFBQVFHLEdBQUc7OERBQUMsQ0FBQ0MsSUFBd0I7NEJBQ2pEMUMsSUFBSTBDLEVBQUUxQyxFQUFFOzRCQUNSMkMsYUFBYUQsRUFBRUMsV0FBVzs0QkFDMUJDLFNBQVNGLEVBQUVFLE9BQU87d0JBQ3BCOztnQkFDQSxNQUFNeEQsTUFBTSxNQUFNQyxNQUFNLEdBQVksT0FBVHRELFVBQVMsVUFBUTtvQkFDMUM4RyxRQUFRO29CQUNSdkQsU0FBU2hEO29CQUNUd0csTUFBTUMsS0FBS0MsU0FBUyxDQUFDO3dCQUNuQjlDLFdBQVd4RDt3QkFDWGtFLFdBQVdqRTt3QkFDWHlFLFdBQVd4RTt3QkFDWDRGO29CQUNGO2dCQUNGO2dCQUNBLElBQUksQ0FBQ3BELElBQUlHLEVBQUUsRUFBRTtvQkFDWCxNQUFNMEQsVUFBVSxNQUFNN0QsSUFBSThELElBQUk7b0JBQzlCLE1BQU0sSUFBSTFELE1BQU15RCxXQUFXLGdCQUEyQixPQUFYN0QsSUFBSUssTUFBTTtnQkFDdkQ7Z0JBQ0EsTUFBTUMsT0FBTyxNQUFNTixJQUFJTyxJQUFJO2dCQUMzQixJQUFJRCxLQUFLTyxVQUFVLElBQUksTUFBTSxNQUFNNUIsY0FBY3FCLEtBQUtPLFVBQVU7Z0JBQ2hFLEtBQUssTUFBTWtELEtBQUt6RCxLQUFLMEQsT0FBTyxJQUFJLEVBQUUsQ0FBRTtvQkFDbEMsSUFBSUQsRUFBRTFELE1BQU0sS0FBSyxjQUFjMEQsRUFBRTFELE1BQU0sS0FBSyxVQUFVO3dCQUNwRCxNQUFNOUQsdUNBQUVBLENBQUM0RyxVQUFVLENBQUN4QyxNQUFNLENBQUNvRCxFQUFFRSxRQUFRLEVBQUU7NEJBQUU1RCxRQUFRO3dCQUFTO29CQUM1RCxPQUFPLElBQUkwRCxFQUFFMUQsTUFBTSxLQUFLLFVBQVU7d0JBQ2hDLE1BQU05RCx1Q0FBRUEsQ0FBQzRHLFVBQVUsQ0FBQ3hDLE1BQU0sQ0FBQ29ELEVBQUVFLFFBQVEsRUFBRTs0QkFBRTVELFFBQVE7NEJBQVU2RCxlQUFlSCxFQUFFSSxLQUFLO3dCQUFDO29CQUNwRjtnQkFDRjtnQkFDQSxNQUFNQyxlQUFlLE1BQU03SCx1Q0FBRUEsQ0FBQzRHLFVBQVUsQ0FBQ3hELEtBQUssQ0FBQyxVQUFVQyxNQUFNLENBQUMsV0FBV0MsS0FBSztnQkFDaEZuQixnQkFBZ0IwRjtZQUNsQixFQUFFLE9BQU94QyxHQUFHO2dCQUNWLE1BQU1tQixNQUFNbkIsYUFBYXhCLFFBQVF3QixFQUFFb0IsT0FBTyxHQUFHO2dCQUM3Q3hFLGFBQWF1RTtnQkFDYnpFLGFBQWE7Z0JBQ2I7WUFDRjtZQUNBQSxhQUFhO1lBQ2IsTUFBTThGLGVBQWUsTUFBTTdILHVDQUFFQSxDQUFDNEcsVUFBVSxDQUFDeEQsS0FBSyxDQUFDLFVBQVVDLE1BQU0sQ0FBQyxXQUFXQyxLQUFLO1lBQ2hGbkIsZ0JBQWdCMEY7UUFDbEI7MkNBQUc7UUFBQzlHO1FBQVVDO1FBQVVDO1FBQVV5QjtLQUFjO0lBRWhELE1BQU1vRixPQUFPakksa0RBQVdBOzRDQUFDO1lBQ3ZCLElBQUksQ0FBQ3FCLFNBQVM7WUFDZCxNQUFNNEIsS0FBSztZQUNYLE1BQU00RDtZQUNOLE1BQU01RCxLQUFLO1FBQ2I7MkNBQUc7UUFBQzVCO1FBQVM0QjtRQUFNNEQ7S0FBSztJQUV4QixvSUFBb0k7SUFDcEk1RyxnREFBU0E7b0NBQUM7WUFDUixJQUFJLE1BQTZCLElBQUksQ0FBQ29CLFdBQVcsQ0FBQ0gsVUFBVTtZQUM1RCxJQUFJTyxPQUFPQyxTQUFTLENBQUNDLE1BQU0sRUFBRTtnQkFDM0JzQixLQUFLO1lBQ1A7UUFDQSx1REFBdUQ7UUFDekQ7bUNBQUc7UUFBQy9CO1FBQVVHO0tBQVE7SUFFdEJwQixnREFBU0E7b0NBQUM7WUFDUixJQUFJLEtBQTZCLEVBQUUsRUFBTztZQUMxQyxNQUFNaUk7eURBQWU7b0JBQ25CQyxZQUFZO29CQUNaLElBQUk5RyxXQUFXSCxVQUFVK0c7Z0JBQzNCOztZQUNBLE1BQU1HOzBEQUFnQixJQUFNRCxZQUFZOztZQUN4QzFHLE9BQU80RyxnQkFBZ0IsQ0FBQyxVQUFVSDtZQUNsQ3pHLE9BQU80RyxnQkFBZ0IsQ0FBQyxXQUFXRDtZQUNuQzs0Q0FBTztvQkFDTDNHLE9BQU82RyxtQkFBbUIsQ0FBQyxVQUFVSjtvQkFDckN6RyxPQUFPNkcsbUJBQW1CLENBQUMsV0FBV0Y7Z0JBQ3hDOztRQUNGO21DQUFHO1FBQUMvRztRQUFTSDtRQUFVK0c7S0FBSztJQUU1QmhJLGdEQUFTQTtvQ0FBQztZQUNSLElBQUlzSSxZQUFZO1lBQ2hCcEksdUNBQUVBLENBQUM0RyxVQUFVLENBQUN4RCxLQUFLLENBQUMsVUFBVUMsTUFBTSxDQUFDLFdBQVdDLEtBQUssR0FBRytFLElBQUk7NENBQUMsQ0FBQ0M7b0JBQzVELElBQUksQ0FBQ0YsV0FBV2pHLGdCQUFnQm1HO2dCQUNsQzs7WUFDQSxNQUFNQyxXQUFXQztxREFBWTtvQkFDM0J4SSx1Q0FBRUEsQ0FBQzRHLFVBQVUsQ0FBQ3hELEtBQUssQ0FBQyxVQUFVQyxNQUFNLENBQUMsV0FBV0MsS0FBSyxHQUFHK0UsSUFBSTs2REFBQyxDQUFDQzs0QkFDNUQsSUFBSSxDQUFDRixXQUFXakcsZ0JBQWdCbUc7d0JBQ2xDOztnQkFDRjtvREFBRztZQUNIOzRDQUFPO29CQUNMRixZQUFZO29CQUNaSyxjQUFjRjtnQkFDaEI7O1FBQ0Y7bUNBQUcsRUFBRTtJQUVMLE9BQU87UUFDTDlHO1FBQ0FLO1FBQ0FFO1FBQ0FFO1FBQ0E0RjtRQUNBaEY7UUFDQTREO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RpbW90aHllZGliby9wcm9qZWN0cy9wZXJzb25hbC9ibHVlY291bnRzL2Zyb250ZW5kL3NyYy9ob29rcy91c2VTeW5jTWFuYWdlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbi8qKlxuICogdXNlU3luY01hbmFnZXIgLSBUaGUgSGVhcnQgb2YgT2ZmbGluZS1GaXJzdCBTeW5jLlxuICogLSBMaXN0ZW5zIHRvIG5hdmlnYXRvci5vbkxpbmU7IG9uIHJlY29ubmVjdGlvbiBydW5zIHB1bGwgdGhlbiBwdXNoLlxuICogLSBQdWxsOiBHRVQgL3N5bmMvcHVsbD90ZW5hbnRfaWQ9Jm1heF92ZXJzaW9uX2lkPSDihpIgYXBwbHkgZGVsdGEgdG8gRGV4aWUgKHNlcnZlciB3aW5zIGZvciBwcm9kdWN0cykuXG4gKiAtIFB1c2g6IFBPU1QgL3N5bmMgd2l0aCBTeW5jUXVldWUgaXRlbXMg4oaSIHNlcnZlciBwcm9jZXNzZXMgaW4gdHJhbnNhY3Rpb24sIHJldHVybnMgdmVyc2lvbl9pZC5cbiAqL1xuXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGRiLCB0eXBlIFN5bmNRdWV1ZVJlY29yZCB9IGZyb20gJ0AvbGliL2RiJztcbmltcG9ydCB7IGdldEF1dGhUb2tlbiB9IGZyb20gJ0AvY29udGV4dHMvQXV0aENvbnRleHQnO1xuXG5jb25zdCBTWU5DX01FVEFfS0VZX01BWF9WRVJTSU9OID0gJ2xvY2FsX21heF92ZXJzaW9uX2lkJztcbmNvbnN0IFNJTVVMQVRFX09GRkxJTkVfS0VZID0gJ2JsdWVjb3VudHNfc2ltdWxhdGVfb2ZmbGluZSc7XG5jb25zdCBBUElfQkFTRSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7XG5cbmZ1bmN0aW9uIGdldFNpbXVsYXRlT2ZmbGluZSgpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTSU1VTEFURV9PRkZMSU5FX0tFWSkgPT09ICcxJztcbn1cblxuZnVuY3Rpb24gYXV0aEhlYWRlcnMoKTogSGVhZGVyc0luaXQge1xuICBjb25zdCB0b2tlbiA9IGdldEF1dGhUb2tlbigpO1xuICBjb25zdCBoOiBIZWFkZXJzSW5pdCA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9O1xuICBpZiAodG9rZW4pIChoIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz4pWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgcmV0dXJuIGg7XG59XG5cbnR5cGUgU3luY1N0YXRlID0gJ2lkbGUnIHwgJ3B1bGxpbmcnIHwgJ3B1c2hpbmcnIHwgJ2Vycm9yJztcblxuZXhwb3J0IGludGVyZmFjZSBVc2VTeW5jTWFuYWdlck9wdGlvbnMge1xuICB0ZW5hbnRJZDogc3RyaW5nO1xuICBvdXRsZXRJZDogc3RyaW5nO1xuICBkZXZpY2VJZDogc3RyaW5nO1xuICBlbmFibGVkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN5bmNNYW5hZ2VyKHsgdGVuYW50SWQsIG91dGxldElkLCBkZXZpY2VJZCwgZW5hYmxlZCA9IHRydWUgfTogVXNlU3luY01hbmFnZXJPcHRpb25zKSB7XG4gIGNvbnN0IFtzaW11bGF0ZU9mZmxpbmUsIHNldFNpbXVsYXRlT2ZmbGluZVN0YXRlXSA9IHVzZVN0YXRlKFxuICAgICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIGdldFNpbXVsYXRlT2ZmbGluZSgpXG4gICk7XG4gIGNvbnN0IGFjdHVhbGx5T25saW5lID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubmF2aWdhdG9yLm9uTGluZSA6IHRydWU7XG4gIGNvbnN0IGlzT25saW5lID0gYWN0dWFsbHlPbmxpbmUgJiYgIXNpbXVsYXRlT2ZmbGluZTtcblxuICBjb25zdCBzZXRTaW11bGF0ZU9mZmxpbmUgPSB1c2VDYWxsYmFjaygodmFsdWU6IGJvb2xlYW4pID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBpZiAodmFsdWUpIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNJTVVMQVRFX09GRkxJTkVfS0VZLCAnMScpO1xuICAgIGVsc2UgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oU0lNVUxBVEVfT0ZGTElORV9LRVkpO1xuICAgIHNldFNpbXVsYXRlT2ZmbGluZVN0YXRlKHZhbHVlKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IFtzeW5jU3RhdGUsIHNldFN5bmNTdGF0ZV0gPSB1c2VTdGF0ZTxTeW5jU3RhdGU+KCdpZGxlJyk7XG4gIGNvbnN0IFtsYXN0RXJyb3IsIHNldExhc3RFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3BlbmRpbmdDb3VudCwgc2V0UGVuZGluZ0NvdW50XSA9IHVzZVN0YXRlKDApO1xuXG4gIGNvbnN0IGdldE1heFZlcnNpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoKTogUHJvbWlzZTxudW1iZXI+ID0+IHtcbiAgICBjb25zdCByb3cgPSBhd2FpdCBkYi5zeW5jX21ldGEuZ2V0KFNZTkNfTUVUQV9LRVlfTUFYX1ZFUlNJT04pO1xuICAgIGNvbnN0IHYgPSByb3c/LnZhbHVlO1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHJldHVybiB2O1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHJldHVybiBwYXJzZUludCh2LCAxMCkgfHwgMDtcbiAgICByZXR1cm4gMDtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNldE1heFZlcnNpb24gPSB1c2VDYWxsYmFjayhhc3luYyAodmVyc2lvbjogbnVtYmVyKSA9PiB7XG4gICAgYXdhaXQgZGIuc3luY19tZXRhLnB1dCh7IGtleTogU1lOQ19NRVRBX0tFWV9NQVhfVkVSU0lPTiwgdmFsdWU6IHZlcnNpb24gfSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBwdWxsID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGZvcmNlRnVsbFN5bmMgPSBmYWxzZSkgPT4ge1xuICAgICAgaWYgKCF0ZW5hbnRJZCkgcmV0dXJuO1xuICAgICAgc2V0U3luY1N0YXRlKCdwdWxsaW5nJyk7XG4gICAgICBzZXRMYXN0RXJyb3IobnVsbCk7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgbWF4VmVyID0gYXdhaXQgZ2V0TWF4VmVyc2lvbigpO1xuICAgICAgICBpZiAoZm9yY2VGdWxsU3luYykge1xuICAgICAgICAgIG1heFZlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaGFzTG9jYWxEYXRhID0gYXdhaXQgZGIucHJvZHVjdHMud2hlcmUoJ3RlbmFudF9pZCcpLmVxdWFscyh0ZW5hbnRJZCkuY291bnQoKTtcbiAgICAgICAgICBpZiAoaGFzTG9jYWxEYXRhID09PSAwKSB7XG4gICAgICAgICAgICBtYXhWZXIgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBgJHtBUElfQkFTRX0vc3luYy9wdWxsP3RlbmFudF9pZD0ke2VuY29kZVVSSUNvbXBvbmVudCh0ZW5hbnRJZCl9Jm1heF92ZXJzaW9uX2lkPSR7bWF4VmVyfWA7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHsgaGVhZGVyczogYXV0aEhlYWRlcnMoKSB9KTtcbiAgICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoYFB1bGwgZmFpbGVkOiAke3Jlcy5zdGF0dXN9YCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgIGNvbnN0IHsgdGFibGVzLCBzZXJ2ZXJfbWF4X3ZlcnNpb25faWQgfSA9IGRhdGE7XG5cbiAgICAgIGlmICh0YWJsZXMucHJvZHVjdHM/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZXMucHJvZHVjdHMpIHtcbiAgICAgICAgICBpZiAocm93LmRlbGV0ZWRfYXQpIHtcbiAgICAgICAgICAgIGF3YWl0IGRiLnByb2R1Y3RzLnVwZGF0ZShyb3cuaWQsIHsgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQsIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5wcm9kdWN0cy5wdXQoe1xuICAgICAgICAgICAgICBpZDogcm93LmlkLFxuICAgICAgICAgICAgICB0ZW5hbnRfaWQ6IHJvdy50ZW5hbnRfaWQsXG4gICAgICAgICAgICAgIHNrdTogcm93LnNrdSxcbiAgICAgICAgICAgICAgbmFtZTogcm93Lm5hbWUsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiByb3cuZGVzY3JpcHRpb24gPz8gbnVsbCxcbiAgICAgICAgICAgICAgcHJpY2U6IE51bWJlcihyb3cucHJpY2UpLFxuICAgICAgICAgICAgICB2ZXJzaW9uX2lkOiByb3cudmVyc2lvbl9pZCxcbiAgICAgICAgICAgICAgY3JlYXRlZF9hdDogcm93LmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IHJvdy51cGRhdGVkX2F0LFxuICAgICAgICAgICAgICBkZWxldGVkX2F0OiByb3cuZGVsZXRlZF9hdCA/PyBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGFibGVzLmludmVudG9yeT8ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlcy5pbnZlbnRvcnkpIHtcbiAgICAgICAgICBjb25zdCBwcm9kdWN0S2V5ID0gW3Jvdy50ZW5hbnRfaWQsIHJvdy5vdXRsZXRfaWQsIHJvdy5wcm9kdWN0X2lkXSBhcyBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ107XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCBkYi5pbnZlbnRvcnkud2hlcmUoJ1t0ZW5hbnRfaWQrb3V0bGV0X2lkK3Byb2R1Y3RfaWRdJykuZXF1YWxzKHByb2R1Y3RLZXkpLnRvQXJyYXkoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGlmIChlLmlkICE9PSByb3cuaWQpIGF3YWl0IGRiLmludmVudG9yeS5kZWxldGUoZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb3cuZGVsZXRlZF9hdCkge1xuICAgICAgICAgICAgYXdhaXQgZGIuaW52ZW50b3J5LnVwZGF0ZShyb3cuaWQsIHsgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQsIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5pbnZlbnRvcnkucHV0KHtcbiAgICAgICAgICAgICAgaWQ6IHJvdy5pZCxcbiAgICAgICAgICAgICAgdGVuYW50X2lkOiByb3cudGVuYW50X2lkLFxuICAgICAgICAgICAgICBvdXRsZXRfaWQ6IHJvdy5vdXRsZXRfaWQsXG4gICAgICAgICAgICAgIHByb2R1Y3RfaWQ6IHJvdy5wcm9kdWN0X2lkLFxuICAgICAgICAgICAgICBxdWFudGl0eTogTnVtYmVyKHJvdy5xdWFudGl0eSksXG4gICAgICAgICAgICAgIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkLFxuICAgICAgICAgICAgICBjcmVhdGVkX2F0OiByb3cuY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgdXBkYXRlZF9hdDogcm93LnVwZGF0ZWRfYXQsXG4gICAgICAgICAgICAgIGRlbGV0ZWRfYXQ6IHJvdy5kZWxldGVkX2F0ID8/IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZXMuc2FsZXM/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZXMuc2FsZXMpIHtcbiAgICAgICAgICBpZiAocm93LmRlbGV0ZWRfYXQpIHtcbiAgICAgICAgICAgIGF3YWl0IGRiLnNhbGVzLnVwZGF0ZShyb3cuaWQsIHsgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQsIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5zYWxlcy5wdXQoe1xuICAgICAgICAgICAgICBpZDogcm93LmlkLFxuICAgICAgICAgICAgICB0ZW5hbnRfaWQ6IHJvdy50ZW5hbnRfaWQsXG4gICAgICAgICAgICAgIG91dGxldF9pZDogcm93Lm91dGxldF9pZCxcbiAgICAgICAgICAgICAgZGV2aWNlX2lkOiByb3cuZGV2aWNlX2lkLFxuICAgICAgICAgICAgICBzZXNzaW9uX2lkOiByb3cuc2Vzc2lvbl9pZCA/PyBudWxsLFxuICAgICAgICAgICAgICBkZXZpY2VfdHJhbnNhY3Rpb25faWQ6IHJvdy5kZXZpY2VfdHJhbnNhY3Rpb25faWQsXG4gICAgICAgICAgICAgIHRvdGFsX2Ftb3VudDogTnVtYmVyKHJvdy50b3RhbF9hbW91bnQpLFxuICAgICAgICAgICAgICB2ZXJzaW9uX2lkOiByb3cudmVyc2lvbl9pZCxcbiAgICAgICAgICAgICAgY3JlYXRlZF9hdDogcm93LmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IHJvdy51cGRhdGVkX2F0LFxuICAgICAgICAgICAgICBkZWxldGVkX2F0OiByb3cuZGVsZXRlZF9hdCA/PyBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGFibGVzLnNhbGVfaXRlbXM/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZXMuc2FsZV9pdGVtcykge1xuICAgICAgICAgIGlmIChyb3cuZGVsZXRlZF9hdCkge1xuICAgICAgICAgICAgYXdhaXQgZGIuc2FsZV9pdGVtcy51cGRhdGUocm93LmlkLCB7IGRlbGV0ZWRfYXQ6IHJvdy5kZWxldGVkX2F0LCB2ZXJzaW9uX2lkOiByb3cudmVyc2lvbl9pZCB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgZGIuc2FsZV9pdGVtcy5wdXQoe1xuICAgICAgICAgICAgICBpZDogcm93LmlkLFxuICAgICAgICAgICAgICB0ZW5hbnRfaWQ6IHJvdy50ZW5hbnRfaWQsXG4gICAgICAgICAgICAgIG91dGxldF9pZDogcm93Lm91dGxldF9pZCxcbiAgICAgICAgICAgICAgc2FsZV9pZDogcm93LnNhbGVfaWQsXG4gICAgICAgICAgICAgIHByb2R1Y3RfaWQ6IHJvdy5wcm9kdWN0X2lkLFxuICAgICAgICAgICAgICBxdWFudGl0eTogcm93LnF1YW50aXR5LFxuICAgICAgICAgICAgICB1bml0X3ByaWNlOiBOdW1iZXIocm93LnVuaXRfcHJpY2UpLFxuICAgICAgICAgICAgICBsaW5lX3RvdGFsOiBOdW1iZXIocm93LmxpbmVfdG90YWwpLFxuICAgICAgICAgICAgICB2ZXJzaW9uX2lkOiByb3cudmVyc2lvbl9pZCxcbiAgICAgICAgICAgICAgY3JlYXRlZF9hdDogcm93LmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgIGRlbGV0ZWRfYXQ6IHJvdy5kZWxldGVkX2F0ID8/IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZXMucG9zX3Nlc3Npb25zPy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGVzLnBvc19zZXNzaW9ucykge1xuICAgICAgICAgIGlmIChyb3cuZGVsZXRlZF9hdCkge1xuICAgICAgICAgICAgYXdhaXQgZGIucG9zX3Nlc3Npb25zLnVwZGF0ZShyb3cuaWQsIHsgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQsIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5wb3Nfc2Vzc2lvbnMucHV0KHtcbiAgICAgICAgICAgICAgaWQ6IHJvdy5pZCxcbiAgICAgICAgICAgICAgdGVuYW50X2lkOiByb3cudGVuYW50X2lkLFxuICAgICAgICAgICAgICBvdXRsZXRfaWQ6IHJvdy5vdXRsZXRfaWQsXG4gICAgICAgICAgICAgIHVzZXJfaWQ6IHJvdy51c2VyX2lkLFxuICAgICAgICAgICAgICBkZXZpY2VfaWQ6IHJvdy5kZXZpY2VfaWQgPz8gbnVsbCxcbiAgICAgICAgICAgICAgb3BlbmluZ19iYWxhbmNlOiBOdW1iZXIocm93Lm9wZW5pbmdfYmFsYW5jZSksXG4gICAgICAgICAgICAgIGNsb3NpbmdfYmFsYW5jZTogcm93LmNsb3NpbmdfYmFsYW5jZSAhPSBudWxsID8gTnVtYmVyKHJvdy5jbG9zaW5nX2JhbGFuY2UpIDogbnVsbCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWRfYmFsYW5jZTogcm93LmV4cGVjdGVkX2JhbGFuY2UgIT0gbnVsbCA/IE51bWJlcihyb3cuZXhwZWN0ZWRfYmFsYW5jZSkgOiBudWxsLFxuICAgICAgICAgICAgICBzdGF0dXM6IHJvdy5zdGF0dXMgPT09ICdjbG9zZWQnID8gJ2Nsb3NlZCcgOiAnb3BlbicsXG4gICAgICAgICAgICAgIG9wZW5lZF9hdDogcm93Lm9wZW5lZF9hdCxcbiAgICAgICAgICAgICAgY2xvc2VkX2F0OiByb3cuY2xvc2VkX2F0ID8/IG51bGwsXG4gICAgICAgICAgICAgIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkLFxuICAgICAgICAgICAgICBkZWxldGVkX2F0OiByb3cuZGVsZXRlZF9hdCA/PyBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VydmVyX21heF92ZXJzaW9uX2lkID09PSAnbnVtYmVyJykge1xuICAgICAgICBhd2FpdCBzZXRNYXhWZXJzaW9uKHNlcnZlcl9tYXhfdmVyc2lvbl9pZCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgbXNnID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogJ1B1bGwgZmFpbGVkJztcbiAgICAgIHNldExhc3RFcnJvcihtc2cpO1xuICAgICAgc2V0U3luY1N0YXRlKCdlcnJvcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRTeW5jU3RhdGUoJ2lkbGUnKTtcbiAgfSxcbiAgICBbdGVuYW50SWQsIG91dGxldElkLCBnZXRNYXhWZXJzaW9uLCBzZXRNYXhWZXJzaW9uXVxuICApO1xuXG4gIGNvbnN0IHB1c2ggPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF0ZW5hbnRJZCB8fCAhb3V0bGV0SWQgfHwgIWRldmljZUlkKSByZXR1cm47XG4gICAgY29uc3QgcGVuZGluZyA9IGF3YWl0IGRiLnN5bmNfcXVldWUud2hlcmUoJ3N0YXR1cycpLmVxdWFscygncGVuZGluZycpLnRvQXJyYXkoKTtcbiAgICBpZiAocGVuZGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHNldFBlbmRpbmdDb3VudCgwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0U3luY1N0YXRlKCdwdXNoaW5nJyk7XG4gICAgc2V0TGFzdEVycm9yKG51bGwpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpdGVtcyA9IHBlbmRpbmcubWFwKChxOiBTeW5jUXVldWVSZWNvcmQpID0+ICh7XG4gICAgICAgIGlkOiBxLmlkLFxuICAgICAgICBhY3Rpb25fdHlwZTogcS5hY3Rpb25fdHlwZSxcbiAgICAgICAgcGF5bG9hZDogcS5wYXlsb2FkLFxuICAgICAgfSkpO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0V9L3N5bmNgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycygpLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdGVuYW50X2lkOiB0ZW5hbnRJZCxcbiAgICAgICAgICBvdXRsZXRfaWQ6IG91dGxldElkLFxuICAgICAgICAgIGRldmljZV9pZDogZGV2aWNlSWQsXG4gICAgICAgICAgaXRlbXMsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICBjb25zdCBlcnJCb2R5ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyckJvZHkgfHwgYFB1c2ggZmFpbGVkOiAke3Jlcy5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgIGlmIChkYXRhLnZlcnNpb25faWQgIT0gbnVsbCkgYXdhaXQgc2V0TWF4VmVyc2lvbihkYXRhLnZlcnNpb25faWQpO1xuICAgICAgZm9yIChjb25zdCByIG9mIGRhdGEucmVzdWx0cyB8fCBbXSkge1xuICAgICAgICBpZiAoci5zdGF0dXMgPT09ICdhY2NlcHRlZCcgfHwgci5zdGF0dXMgPT09ICdzeW5jZWQnKSB7XG4gICAgICAgICAgYXdhaXQgZGIuc3luY19xdWV1ZS51cGRhdGUoci5xdWV1ZV9pZCwgeyBzdGF0dXM6ICdzeW5jZWQnIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHIuc3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgICAgIGF3YWl0IGRiLnN5bmNfcXVldWUudXBkYXRlKHIucXVldWVfaWQsIHsgc3RhdHVzOiAnZmFpbGVkJywgZXJyb3JfbWVzc2FnZTogci5lcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc3RpbGxQZW5kaW5nID0gYXdhaXQgZGIuc3luY19xdWV1ZS53aGVyZSgnc3RhdHVzJykuZXF1YWxzKCdwZW5kaW5nJykuY291bnQoKTtcbiAgICAgIHNldFBlbmRpbmdDb3VudChzdGlsbFBlbmRpbmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6ICdQdXNoIGZhaWxlZCc7XG4gICAgICBzZXRMYXN0RXJyb3IobXNnKTtcbiAgICAgIHNldFN5bmNTdGF0ZSgnZXJyb3InKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0U3luY1N0YXRlKCdpZGxlJyk7XG4gICAgY29uc3Qgc3RpbGxQZW5kaW5nID0gYXdhaXQgZGIuc3luY19xdWV1ZS53aGVyZSgnc3RhdHVzJykuZXF1YWxzKCdwZW5kaW5nJykuY291bnQoKTtcbiAgICBzZXRQZW5kaW5nQ291bnQoc3RpbGxQZW5kaW5nKTtcbiAgfSwgW3RlbmFudElkLCBvdXRsZXRJZCwgZGV2aWNlSWQsIHNldE1heFZlcnNpb25dKTtcblxuICBjb25zdCBzeW5jID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGF3YWl0IHB1bGwodHJ1ZSk7XG4gICAgYXdhaXQgcHVzaCgpO1xuICAgIGF3YWl0IHB1bGwodHJ1ZSk7XG4gIH0sIFtlbmFibGVkLCBwdWxsLCBwdXNoXSk7XG5cbiAgLy8gV2hlbiBvbmxpbmUsIGRvIGEgZnVsbCBwdWxsIG9uIHBhZ2UgbG9hZCBzbyB3ZSBnZXQgYWxsIERCIHJvd3MgKHByb2R1Y3RzIHdpdGggbG93IHZlcnNpb25faWQgYXJlIG5ldmVyIHNlbnQgb24gaW5jcmVtZW50YWwgcHVsbCkuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFlbmFibGVkIHx8ICF0ZW5hbnRJZCkgcmV0dXJuO1xuICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm9uTGluZSkge1xuICAgICAgcHVsbCh0cnVlKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbdGVuYW50SWQsIGVuYWJsZWRdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIGNvbnN0IGhhbmRsZU9ubGluZSA9ICgpID0+IHtcbiAgICAgIHNldElzT25saW5lKHRydWUpO1xuICAgICAgaWYgKGVuYWJsZWQgJiYgdGVuYW50SWQpIHN5bmMoKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZU9mZmxpbmUgPSAoKSA9PiBzZXRJc09ubGluZShmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGhhbmRsZU9ubGluZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBoYW5kbGVPZmZsaW5lKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGhhbmRsZU9ubGluZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGhhbmRsZU9mZmxpbmUpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCB0ZW5hbnRJZCwgc3luY10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGRiLnN5bmNfcXVldWUud2hlcmUoJ3N0YXR1cycpLmVxdWFscygncGVuZGluZycpLmNvdW50KCkudGhlbigoYykgPT4ge1xuICAgICAgaWYgKCFjYW5jZWxsZWQpIHNldFBlbmRpbmdDb3VudChjKTtcbiAgICB9KTtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGRiLnN5bmNfcXVldWUud2hlcmUoJ3N0YXR1cycpLmVxdWFscygncGVuZGluZycpLmNvdW50KCkudGhlbigoYykgPT4ge1xuICAgICAgICBpZiAoIWNhbmNlbGxlZCkgc2V0UGVuZGluZ0NvdW50KGMpO1xuICAgICAgfSk7XG4gICAgfSwgMjAwMCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpc09ubGluZSxcbiAgICBzeW5jU3RhdGUsXG4gICAgbGFzdEVycm9yLFxuICAgIHBlbmRpbmdDb3VudCxcbiAgICBzeW5jLFxuICAgIHB1bGwsXG4gICAgcHVzaCxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiZGIiLCJnZXRBdXRoVG9rZW4iLCJTWU5DX01FVEFfS0VZX01BWF9WRVJTSU9OIiwiU0lNVUxBVEVfT0ZGTElORV9LRVkiLCJBUElfQkFTRSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiZ2V0U2ltdWxhdGVPZmZsaW5lIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImF1dGhIZWFkZXJzIiwidG9rZW4iLCJoIiwidXNlU3luY01hbmFnZXIiLCJ0ZW5hbnRJZCIsIm91dGxldElkIiwiZGV2aWNlSWQiLCJlbmFibGVkIiwic2ltdWxhdGVPZmZsaW5lIiwic2V0U2ltdWxhdGVPZmZsaW5lU3RhdGUiLCJhY3R1YWxseU9ubGluZSIsIndpbmRvdyIsIm5hdmlnYXRvciIsIm9uTGluZSIsImlzT25saW5lIiwic2V0U2ltdWxhdGVPZmZsaW5lIiwidmFsdWUiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsInN5bmNTdGF0ZSIsInNldFN5bmNTdGF0ZSIsImxhc3RFcnJvciIsInNldExhc3RFcnJvciIsInBlbmRpbmdDb3VudCIsInNldFBlbmRpbmdDb3VudCIsImdldE1heFZlcnNpb24iLCJyb3ciLCJzeW5jX21ldGEiLCJnZXQiLCJ2IiwicGFyc2VJbnQiLCJzZXRNYXhWZXJzaW9uIiwidmVyc2lvbiIsInB1dCIsImtleSIsInB1bGwiLCJmb3JjZUZ1bGxTeW5jIiwidGFibGVzIiwibWF4VmVyIiwiaGFzTG9jYWxEYXRhIiwicHJvZHVjdHMiLCJ3aGVyZSIsImVxdWFscyIsImNvdW50IiwidXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVzIiwiZmV0Y2giLCJoZWFkZXJzIiwib2siLCJFcnJvciIsInN0YXR1cyIsImRhdGEiLCJqc29uIiwic2VydmVyX21heF92ZXJzaW9uX2lkIiwibGVuZ3RoIiwiZGVsZXRlZF9hdCIsInVwZGF0ZSIsImlkIiwidmVyc2lvbl9pZCIsInRlbmFudF9pZCIsInNrdSIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInByaWNlIiwiTnVtYmVyIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJpbnZlbnRvcnkiLCJwcm9kdWN0S2V5Iiwib3V0bGV0X2lkIiwicHJvZHVjdF9pZCIsImV4aXN0aW5nIiwidG9BcnJheSIsImUiLCJkZWxldGUiLCJxdWFudGl0eSIsInNhbGVzIiwiZGV2aWNlX2lkIiwic2Vzc2lvbl9pZCIsImRldmljZV90cmFuc2FjdGlvbl9pZCIsInRvdGFsX2Ftb3VudCIsInNhbGVfaXRlbXMiLCJzYWxlX2lkIiwidW5pdF9wcmljZSIsImxpbmVfdG90YWwiLCJwb3Nfc2Vzc2lvbnMiLCJ1c2VyX2lkIiwib3BlbmluZ19iYWxhbmNlIiwiY2xvc2luZ19iYWxhbmNlIiwiZXhwZWN0ZWRfYmFsYW5jZSIsIm9wZW5lZF9hdCIsImNsb3NlZF9hdCIsIm1zZyIsIm1lc3NhZ2UiLCJwdXNoIiwicGVuZGluZyIsInN5bmNfcXVldWUiLCJpdGVtcyIsIm1hcCIsInEiLCJhY3Rpb25fdHlwZSIsInBheWxvYWQiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImVyckJvZHkiLCJ0ZXh0IiwiciIsInJlc3VsdHMiLCJxdWV1ZV9pZCIsImVycm9yX21lc3NhZ2UiLCJlcnJvciIsInN0aWxsUGVuZGluZyIsInN5bmMiLCJoYW5kbGVPbmxpbmUiLCJzZXRJc09ubGluZSIsImhhbmRsZU9mZmxpbmUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbGxlZCIsInRoZW4iLCJjIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSyncManager.ts\n"));

/***/ })

});