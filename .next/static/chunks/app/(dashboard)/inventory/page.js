/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/(dashboard)/inventory/page"],{

/***/ "(app-pages-browser)/./node_modules/dexie-react-hooks/dist/dexie-react-hooks.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/dexie-react-hooks/dist/dexie-react-hooks.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLiveQuery: () => (/* binding */ useLiveQuery),\n/* harmony export */   useObservable: () => (/* binding */ useObservable),\n/* harmony export */   usePermissions: () => (/* binding */ usePermissions)\n/* harmony export */ });\n/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dexie */ \"(app-pages-browser)/./node_modules/dexie/import-wrapper.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n\nfunction useObservable(observableFactory, arg2, arg3) {\n    // Resolve vars from overloading variants of this function:\n    var deps;\n    var defaultResult;\n    if (typeof observableFactory === 'function') {\n        deps = arg2 || [];\n        defaultResult = arg3;\n    }\n    else {\n        deps = [];\n        defaultResult = arg2;\n    }\n    // Create a ref that keeps the state we need\n    var monitor = react__WEBPACK_IMPORTED_MODULE_1__.useRef({\n        hasResult: false,\n        result: defaultResult,\n        error: null,\n    });\n    // We control when component should rerender. Make triggerUpdate\n    // as examplified on React's docs at:\n    // https://reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate\n    var _a = react__WEBPACK_IMPORTED_MODULE_1__.useReducer(function (x) { return x + 1; }, 0); _a[0]; var triggerUpdate = _a[1];\n    // Memoize the observable based on deps\n    var observable = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(function () {\n        // Make it remember previous subscription's default value when\n        // resubscribing.\n        var observable = typeof observableFactory === 'function'\n            ? observableFactory()\n            : observableFactory;\n        if (!observable || typeof observable.subscribe !== 'function') {\n            if (observableFactory === observable) {\n                throw new TypeError(\"Given argument to useObservable() was neither a valid observable nor a function.\");\n            }\n            else {\n                throw new TypeError(\"Observable factory given to useObservable() did not return a valid observable.\");\n            }\n        }\n        if (!monitor.current.hasResult &&\n            typeof window !== 'undefined' // Don't do this in SSR\n        ) {\n            // Optimize for BehaviorSubject and other observables implementing getValue():\n            if (typeof observable.hasValue !== 'function' || observable.hasValue()) {\n                if (typeof observable.getValue === 'function') {\n                    monitor.current.result = observable.getValue();\n                    monitor.current.hasResult = true;\n                }\n                else {\n                    // Find out if the observable has a current value: try get it by subscribing and\n                    // unsubscribing synchronously\n                    var subscription = observable.subscribe(function (val) {\n                        monitor.current.result = val;\n                        monitor.current.hasResult = true;\n                    });\n                    // Unsubscribe directly. We only needed any synchronous value if it was possible.\n                    if (typeof subscription === 'function') {\n                        subscription();\n                    }\n                    else {\n                        subscription.unsubscribe();\n                    }\n                }\n            }\n        }\n        return observable;\n    }, deps);\n    // Integrate with react devtools:\n    react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue(monitor.current.result);\n    // Subscribe to the observable\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(function () {\n        var subscription = observable.subscribe(function (val) {\n            var current = monitor.current;\n            if (current.error !== null || current.result !== val) {\n                current.error = null;\n                current.result = val;\n                current.hasResult = true;\n                triggerUpdate();\n            }\n        }, function (err) {\n            var current = monitor.current;\n            if (current.error !== err) {\n                current.error = err;\n                triggerUpdate();\n            }\n        });\n        return typeof subscription === 'function'\n            ? subscription // Support observables that return unsubscribe directly\n            : subscription.unsubscribe.bind(subscription);\n    }, deps);\n    // Throw if observable has emitted error so that\n    // an ErrorBoundrary can catch it\n    if (monitor.current.error)\n        throw monitor.current.error;\n    // Return the current result\n    return monitor.current.result;\n}\n\nfunction useLiveQuery(querier, deps, defaultResult) {\n    return useObservable(function () { return (0,dexie__WEBPACK_IMPORTED_MODULE_0__.liveQuery)(querier); }, deps || [], defaultResult);\n}\n\nfunction usePermissions(firstArg, table, obj) {\n    if (!firstArg)\n        throw new TypeError(\"Invalid arguments to usePermissions(): undefined or null\");\n    var db;\n    if (arguments.length >= 3) {\n        if (!('transaction' in firstArg)) {\n            // Using ducktyping instead of instanceof in case there are multiple Dexie modules in app.\n            // First arg is  ensures first arg is a Dexie instance\n            throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 1st arg must be a Dexie instance\");\n        }\n        if (typeof table !== 'string')\n            throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 2nd arg must be string\");\n        if (!obj || typeof obj !== 'object')\n            throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 3rd arg must be an object\");\n        db = firstArg;\n    }\n    else {\n        if (firstArg instanceof dexie__WEBPACK_IMPORTED_MODULE_0__.Dexie)\n            throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): Missing table and obj arguments.\");\n        if (typeof firstArg.table === 'function' &&\n            typeof firstArg.db === 'object') {\n            db = firstArg.db;\n            obj = firstArg;\n            table = firstArg.table();\n        }\n        else {\n            throw new TypeError(\"Invalid arguments to usePermissions(). \" +\n                \"Expected usePermissions(entity: DexieCloudEntity) or \" +\n                \"usePermissions(db: Dexie, table: string, obj: DexieCloudObject)\");\n        }\n    }\n    if (!('cloud' in db))\n        throw new Error(\"usePermissions() is only for Dexie Cloud but there's no dexie-cloud-addon active in given db.\");\n    if (!('permissions' in db.cloud))\n        throw new Error(\"usePermissions() requires a newer version of dexie-cloud-addon. Please upgrade it.\");\n    return useObservable(\n    // @ts-ignore\n    function () { return db.cloud.permissions(obj, table); }, [obj.realmId, obj.owner, table]);\n}\n\n\n//# sourceMappingURL=dexie-react-hooks.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZXhpZS1yZWFjdC1ob29rcy9kaXN0L2RleGllLXJlYWN0LWhvb2tzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5QztBQUNmOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5Q0FBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2Q0FBZ0IsZ0JBQWdCLGVBQWUsTUFBTSxPQUFPO0FBQ3pFO0FBQ0EscUJBQXFCLDBDQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGdEQUFtQjtBQUN2QjtBQUNBLElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxPQUFPLGdEQUFTLFlBQVk7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3Q0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQ0FBMEM7QUFDNUQ7O0FBRXVEO0FBQ3ZEIiwic291cmNlcyI6WyIvVXNlcnMvdGltb3RoeWVkaWJvL3Byb2plY3RzL3BlcnNvbmFsL2JsdWVjb3VudHMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2RleGllLXJlYWN0LWhvb2tzL2Rpc3QvZGV4aWUtcmVhY3QtaG9va3MubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxpdmVRdWVyeSwgRGV4aWUgfSBmcm9tICdkZXhpZSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiB1c2VPYnNlcnZhYmxlKG9ic2VydmFibGVGYWN0b3J5LCBhcmcyLCBhcmczKSB7XG4gICAgLy8gUmVzb2x2ZSB2YXJzIGZyb20gb3ZlcmxvYWRpbmcgdmFyaWFudHMgb2YgdGhpcyBmdW5jdGlvbjpcbiAgICB2YXIgZGVwcztcbiAgICB2YXIgZGVmYXVsdFJlc3VsdDtcbiAgICBpZiAodHlwZW9mIG9ic2VydmFibGVGYWN0b3J5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRlcHMgPSBhcmcyIHx8IFtdO1xuICAgICAgICBkZWZhdWx0UmVzdWx0ID0gYXJnMztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlcHMgPSBbXTtcbiAgICAgICAgZGVmYXVsdFJlc3VsdCA9IGFyZzI7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIHJlZiB0aGF0IGtlZXBzIHRoZSBzdGF0ZSB3ZSBuZWVkXG4gICAgdmFyIG1vbml0b3IgPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBoYXNSZXN1bHQ6IGZhbHNlLFxuICAgICAgICByZXN1bHQ6IGRlZmF1bHRSZXN1bHQsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgIH0pO1xuICAgIC8vIFdlIGNvbnRyb2wgd2hlbiBjb21wb25lbnQgc2hvdWxkIHJlcmVuZGVyLiBNYWtlIHRyaWdnZXJVcGRhdGVcbiAgICAvLyBhcyBleGFtcGxpZmllZCBvbiBSZWFjdCdzIGRvY3MgYXQ6XG4gICAgLy8gaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLWZhcS5odG1sI2lzLXRoZXJlLXNvbWV0aGluZy1saWtlLWZvcmNldXBkYXRlXG4gICAgdmFyIF9hID0gUmVhY3QudXNlUmVkdWNlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCArIDE7IH0sIDApOyBfYVswXTsgdmFyIHRyaWdnZXJVcGRhdGUgPSBfYVsxXTtcbiAgICAvLyBNZW1vaXplIHRoZSBvYnNlcnZhYmxlIGJhc2VkIG9uIGRlcHNcbiAgICB2YXIgb2JzZXJ2YWJsZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBNYWtlIGl0IHJlbWVtYmVyIHByZXZpb3VzIHN1YnNjcmlwdGlvbidzIGRlZmF1bHQgdmFsdWUgd2hlblxuICAgICAgICAvLyByZXN1YnNjcmliaW5nLlxuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IHR5cGVvZiBvYnNlcnZhYmxlRmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBvYnNlcnZhYmxlRmFjdG9yeSgpXG4gICAgICAgICAgICA6IG9ic2VydmFibGVGYWN0b3J5O1xuICAgICAgICBpZiAoIW9ic2VydmFibGUgfHwgdHlwZW9mIG9ic2VydmFibGUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2YWJsZUZhY3RvcnkgPT09IG9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2l2ZW4gYXJndW1lbnQgdG8gdXNlT2JzZXJ2YWJsZSgpIHdhcyBuZWl0aGVyIGEgdmFsaWQgb2JzZXJ2YWJsZSBub3IgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JzZXJ2YWJsZSBmYWN0b3J5IGdpdmVuIHRvIHVzZU9ic2VydmFibGUoKSBkaWQgbm90IHJldHVybiBhIHZhbGlkIG9ic2VydmFibGUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbW9uaXRvci5jdXJyZW50Lmhhc1Jlc3VsdCAmJlxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgLy8gRG9uJ3QgZG8gdGhpcyBpbiBTU1JcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgQmVoYXZpb3JTdWJqZWN0IGFuZCBvdGhlciBvYnNlcnZhYmxlcyBpbXBsZW1lbnRpbmcgZ2V0VmFsdWUoKTpcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2YWJsZS5oYXNWYWx1ZSAhPT0gJ2Z1bmN0aW9uJyB8fCBvYnNlcnZhYmxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ic2VydmFibGUuZ2V0VmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9uaXRvci5jdXJyZW50LnJlc3VsdCA9IG9ic2VydmFibGUuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgbW9uaXRvci5jdXJyZW50Lmhhc1Jlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIG91dCBpZiB0aGUgb2JzZXJ2YWJsZSBoYXMgYSBjdXJyZW50IHZhbHVlOiB0cnkgZ2V0IGl0IGJ5IHN1YnNjcmliaW5nIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB1bnN1YnNjcmliaW5nIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbml0b3IuY3VycmVudC5yZXN1bHQgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmN1cnJlbnQuaGFzUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuc3Vic2NyaWJlIGRpcmVjdGx5LiBXZSBvbmx5IG5lZWRlZCBhbnkgc3luY2hyb25vdXMgdmFsdWUgaWYgaXQgd2FzIHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9LCBkZXBzKTtcbiAgICAvLyBJbnRlZ3JhdGUgd2l0aCByZWFjdCBkZXZ0b29sczpcbiAgICBSZWFjdC51c2VEZWJ1Z1ZhbHVlKG1vbml0b3IuY3VycmVudC5yZXN1bHQpO1xuICAgIC8vIFN1YnNjcmliZSB0byB0aGUgb2JzZXJ2YWJsZVxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnN1YnNjcmliZShmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IG1vbml0b3IuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmVycm9yICE9PSBudWxsIHx8IGN1cnJlbnQucmVzdWx0ICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnJlc3VsdCA9IHZhbDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Lmhhc1Jlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJpZ2dlclVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IG1vbml0b3IuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmVycm9yICE9PSBlcnIpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJVcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc3Vic2NyaXB0aW9uID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHN1YnNjcmlwdGlvbiAvLyBTdXBwb3J0IG9ic2VydmFibGVzIHRoYXQgcmV0dXJuIHVuc3Vic2NyaWJlIGRpcmVjdGx5XG4gICAgICAgICAgICA6IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZS5iaW5kKHN1YnNjcmlwdGlvbik7XG4gICAgfSwgZGVwcyk7XG4gICAgLy8gVGhyb3cgaWYgb2JzZXJ2YWJsZSBoYXMgZW1pdHRlZCBlcnJvciBzbyB0aGF0XG4gICAgLy8gYW4gRXJyb3JCb3VuZHJhcnkgY2FuIGNhdGNoIGl0XG4gICAgaWYgKG1vbml0b3IuY3VycmVudC5lcnJvcilcbiAgICAgICAgdGhyb3cgbW9uaXRvci5jdXJyZW50LmVycm9yO1xuICAgIC8vIFJldHVybiB0aGUgY3VycmVudCByZXN1bHRcbiAgICByZXR1cm4gbW9uaXRvci5jdXJyZW50LnJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdXNlTGl2ZVF1ZXJ5KHF1ZXJpZXIsIGRlcHMsIGRlZmF1bHRSZXN1bHQpIHtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZShmdW5jdGlvbiAoKSB7IHJldHVybiBsaXZlUXVlcnkocXVlcmllcik7IH0sIGRlcHMgfHwgW10sIGRlZmF1bHRSZXN1bHQpO1xufVxuXG5mdW5jdGlvbiB1c2VQZXJtaXNzaW9ucyhmaXJzdEFyZywgdGFibGUsIG9iaikge1xuICAgIGlmICghZmlyc3RBcmcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyB0byB1c2VQZXJtaXNzaW9ucygpOiB1bmRlZmluZWQgb3IgbnVsbFwiKTtcbiAgICB2YXIgZGI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xuICAgICAgICBpZiAoISgndHJhbnNhY3Rpb24nIGluIGZpcnN0QXJnKSkge1xuICAgICAgICAgICAgLy8gVXNpbmcgZHVja3R5cGluZyBpbnN0ZWFkIG9mIGluc3RhbmNlb2YgaW4gY2FzZSB0aGVyZSBhcmUgbXVsdGlwbGUgRGV4aWUgbW9kdWxlcyBpbiBhcHAuXG4gICAgICAgICAgICAvLyBGaXJzdCBhcmcgaXMgIGVuc3VyZXMgZmlyc3QgYXJnIGlzIGEgRGV4aWUgaW5zdGFuY2VcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyB0byB1c2VQZXJtaXNzaW9uKGRiLCB0YWJsZSwgb2JqKTogMXN0IGFyZyBtdXN0IGJlIGEgRGV4aWUgaW5zdGFuY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YWJsZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgdG8gdXNlUGVybWlzc2lvbihkYiwgdGFibGUsIG9iaik6IDJuZCBhcmcgbXVzdCBiZSBzdHJpbmdcIik7XG4gICAgICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIHRvIHVzZVBlcm1pc3Npb24oZGIsIHRhYmxlLCBvYmopOiAzcmQgYXJnIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgICAgICBkYiA9IGZpcnN0QXJnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGZpcnN0QXJnIGluc3RhbmNlb2YgRGV4aWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgdG8gdXNlUGVybWlzc2lvbihkYiwgdGFibGUsIG9iaik6IE1pc3NpbmcgdGFibGUgYW5kIG9iaiBhcmd1bWVudHMuXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGZpcnN0QXJnLnRhYmxlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICB0eXBlb2YgZmlyc3RBcmcuZGIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkYiA9IGZpcnN0QXJnLmRiO1xuICAgICAgICAgICAgb2JqID0gZmlyc3RBcmc7XG4gICAgICAgICAgICB0YWJsZSA9IGZpcnN0QXJnLnRhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgdG8gdXNlUGVybWlzc2lvbnMoKS4gXCIgK1xuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdXNlUGVybWlzc2lvbnMoZW50aXR5OiBEZXhpZUNsb3VkRW50aXR5KSBvciBcIiArXG4gICAgICAgICAgICAgICAgXCJ1c2VQZXJtaXNzaW9ucyhkYjogRGV4aWUsIHRhYmxlOiBzdHJpbmcsIG9iajogRGV4aWVDbG91ZE9iamVjdClcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEoJ2Nsb3VkJyBpbiBkYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVzZVBlcm1pc3Npb25zKCkgaXMgb25seSBmb3IgRGV4aWUgQ2xvdWQgYnV0IHRoZXJlJ3Mgbm8gZGV4aWUtY2xvdWQtYWRkb24gYWN0aXZlIGluIGdpdmVuIGRiLlwiKTtcbiAgICBpZiAoISgncGVybWlzc2lvbnMnIGluIGRiLmNsb3VkKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXNlUGVybWlzc2lvbnMoKSByZXF1aXJlcyBhIG5ld2VyIHZlcnNpb24gb2YgZGV4aWUtY2xvdWQtYWRkb24uIFBsZWFzZSB1cGdyYWRlIGl0LlwiKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZShcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGIuY2xvdWQucGVybWlzc2lvbnMob2JqLCB0YWJsZSk7IH0sIFtvYmoucmVhbG1JZCwgb2JqLm93bmVyLCB0YWJsZV0pO1xufVxuXG5leHBvcnQgeyB1c2VMaXZlUXVlcnksIHVzZU9ic2VydmFibGUsIHVzZVBlcm1pc3Npb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXhpZS1yZWFjdC1ob29rcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/dexie-react-hooks/dist/dexie-react-hooks.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/dexie/dist/dexie.js":
/*!******************************************!*\
  !*** ./node_modules/dexie/dist/dexie.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 4.3.0, Sat Dec 20 2025\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n    return extendStatics(d, b);\n  };\n  function __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  }\n  var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n  };\n  function __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n  }\n  typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n  };\n\n  var _global = typeof globalThis !== 'undefined' ? globalThis :\n      typeof self !== 'undefined' ? self :\n          typeof window !== 'undefined' ? window :\n              __webpack_require__.g;\n\n  var keys = Object.keys;\n  var isArray = Array.isArray;\n  if (typeof Promise !== 'undefined' && !_global.Promise) {\n      _global.Promise = Promise;\n  }\n  function extend(obj, extension) {\n      if (typeof extension !== 'object')\n          return obj;\n      keys(extension).forEach(function (key) {\n          obj[key] = extension[key];\n      });\n      return obj;\n  }\n  var getProto = Object.getPrototypeOf;\n  var _hasOwn = {}.hasOwnProperty;\n  function hasOwn(obj, prop) {\n      return _hasOwn.call(obj, prop);\n  }\n  function props(proto, extension) {\n      if (typeof extension === 'function')\n          extension = extension(getProto(proto));\n      (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {\n          setProp(proto, key, extension[key]);\n      });\n  }\n  var defineProperty = Object.defineProperty;\n  function setProp(obj, prop, functionOrGetSet, options) {\n      defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n          { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n          { value: functionOrGetSet, configurable: true, writable: true }, options));\n  }\n  function derive(Child) {\n      return {\n          from: function (Parent) {\n              Child.prototype = Object.create(Parent.prototype);\n              setProp(Child.prototype, \"constructor\", Child);\n              return {\n                  extend: props.bind(null, Child.prototype)\n              };\n          }\n      };\n  }\n  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  function getPropertyDescriptor(obj, prop) {\n      var pd = getOwnPropertyDescriptor(obj, prop);\n      var proto;\n      return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n  }\n  var _slice = [].slice;\n  function slice(args, start, end) {\n      return _slice.call(args, start, end);\n  }\n  function override(origFunc, overridedFactory) {\n      return overridedFactory(origFunc);\n  }\n  function assert(b) {\n      if (!b)\n          throw new Error(\"Assertion Failed\");\n  }\n  function asap$1(fn) {\n      if (_global.setImmediate)\n          setImmediate(fn);\n      else\n          setTimeout(fn, 0);\n  }\n  function arrayToObject(array, extractor) {\n      return array.reduce(function (result, item, i) {\n          var nameAndValue = extractor(item, i);\n          if (nameAndValue)\n              result[nameAndValue[0]] = nameAndValue[1];\n          return result;\n      }, {});\n  }\n  function getByKeyPath(obj, keyPath) {\n      if (typeof keyPath === 'string' && hasOwn(obj, keyPath))\n          return obj[keyPath];\n      if (!keyPath)\n          return obj;\n      if (typeof keyPath !== 'string') {\n          var rv = [];\n          for (var i = 0, l = keyPath.length; i < l; ++i) {\n              var val = getByKeyPath(obj, keyPath[i]);\n              rv.push(val);\n          }\n          return rv;\n      }\n      var period = keyPath.indexOf('.');\n      if (period !== -1) {\n          var innerObj = obj[keyPath.substr(0, period)];\n          return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n      }\n      return undefined;\n  }\n  function setByKeyPath(obj, keyPath, value) {\n      if (!obj || keyPath === undefined)\n          return;\n      if ('isFrozen' in Object && Object.isFrozen(obj))\n          return;\n      if (typeof keyPath !== 'string' && 'length' in keyPath) {\n          assert(typeof value !== 'string' && 'length' in value);\n          for (var i = 0, l = keyPath.length; i < l; ++i) {\n              setByKeyPath(obj, keyPath[i], value[i]);\n          }\n      }\n      else {\n          var period = keyPath.indexOf('.');\n          if (period !== -1) {\n              var currentKeyPath = keyPath.substr(0, period);\n              var remainingKeyPath = keyPath.substr(period + 1);\n              if (remainingKeyPath === \"\")\n                  if (value === undefined) {\n                      if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                          obj.splice(currentKeyPath, 1);\n                      else\n                          delete obj[currentKeyPath];\n                  }\n                  else\n                      obj[currentKeyPath] = value;\n              else {\n                  var innerObj = obj[currentKeyPath];\n                  if (!innerObj || !hasOwn(obj, currentKeyPath))\n                      innerObj = (obj[currentKeyPath] = {});\n                  setByKeyPath(innerObj, remainingKeyPath, value);\n              }\n          }\n          else {\n              if (value === undefined) {\n                  if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                      obj.splice(keyPath, 1);\n                  else\n                      delete obj[keyPath];\n              }\n              else\n                  obj[keyPath] = value;\n          }\n      }\n  }\n  function delByKeyPath(obj, keyPath) {\n      if (typeof keyPath === 'string')\n          setByKeyPath(obj, keyPath, undefined);\n      else if ('length' in keyPath)\n          [].map.call(keyPath, function (kp) {\n              setByKeyPath(obj, kp, undefined);\n          });\n  }\n  function shallowClone(obj) {\n      var rv = {};\n      for (var m in obj) {\n          if (hasOwn(obj, m))\n              rv[m] = obj[m];\n      }\n      return rv;\n  }\n  var concat = [].concat;\n  function flatten(a) {\n      return concat.apply([], a);\n  }\n  var intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n      .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return [\"Int\", \"Uint\", \"Float\"].map(function (t) { return t + num + \"Array\"; }); }))).filter(function (t) { return _global[t]; });\n  var intrinsicTypes = new Set(intrinsicTypeNames.map(function (t) { return _global[t]; }));\n  function cloneSimpleObjectTree(o) {\n      var rv = {};\n      for (var k in o)\n          if (hasOwn(o, k)) {\n              var v = o[k];\n              rv[k] = !v || typeof v !== 'object' || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);\n          }\n      return rv;\n  }\n  function objectIsEmpty(o) {\n      for (var k in o)\n          if (hasOwn(o, k))\n              return false;\n      return true;\n  }\n  var circularRefs = null;\n  function deepClone(any) {\n      circularRefs = new WeakMap();\n      var rv = innerDeepClone(any);\n      circularRefs = null;\n      return rv;\n  }\n  function innerDeepClone(x) {\n      if (!x || typeof x !== 'object')\n          return x;\n      var rv = circularRefs.get(x);\n      if (rv)\n          return rv;\n      if (isArray(x)) {\n          rv = [];\n          circularRefs.set(x, rv);\n          for (var i = 0, l = x.length; i < l; ++i) {\n              rv.push(innerDeepClone(x[i]));\n          }\n      }\n      else if (intrinsicTypes.has(x.constructor)) {\n          rv = x;\n      }\n      else {\n          var proto = getProto(x);\n          rv = proto === Object.prototype ? {} : Object.create(proto);\n          circularRefs.set(x, rv);\n          for (var prop in x) {\n              if (hasOwn(x, prop)) {\n                  rv[prop] = innerDeepClone(x[prop]);\n              }\n          }\n      }\n      return rv;\n  }\n  var toString = {}.toString;\n  function toStringTag(o) {\n      return toString.call(o).slice(8, -1);\n  }\n  var iteratorSymbol = typeof Symbol !== 'undefined' ?\n      Symbol.iterator :\n      '@@iterator';\n  var getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n      var i;\n      return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n  } : function () { return null; };\n  function delArrayItem(a, x) {\n      var i = a.indexOf(x);\n      if (i >= 0)\n          a.splice(i, 1);\n      return i >= 0;\n  }\n  var NO_CHAR_ARRAY = {};\n  function getArrayOf(arrayLike) {\n      var i, a, x, it;\n      if (arguments.length === 1) {\n          if (isArray(arrayLike))\n              return arrayLike.slice();\n          if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n              return [arrayLike];\n          if ((it = getIteratorOf(arrayLike))) {\n              a = [];\n              while ((x = it.next()), !x.done)\n                  a.push(x.value);\n              return a;\n          }\n          if (arrayLike == null)\n              return [arrayLike];\n          i = arrayLike.length;\n          if (typeof i === 'number') {\n              a = new Array(i);\n              while (i--)\n                  a[i] = arrayLike[i];\n              return a;\n          }\n          return [arrayLike];\n      }\n      i = arguments.length;\n      a = new Array(i);\n      while (i--)\n          a[i] = arguments[i];\n      return a;\n  }\n  var isAsyncFunction = typeof Symbol !== 'undefined'\n      ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }\n      : function () { return false; };\n\n  var dexieErrorNames = [\n      'Modify',\n      'Bulk',\n      'OpenFailed',\n      'VersionChange',\n      'Schema',\n      'Upgrade',\n      'InvalidTable',\n      'MissingAPI',\n      'NoSuchDatabase',\n      'InvalidArgument',\n      'SubTransaction',\n      'Unsupported',\n      'Internal',\n      'DatabaseClosed',\n      'PrematureCommit',\n      'ForeignAwait'\n  ];\n  var idbDomErrorNames = [\n      'Unknown',\n      'Constraint',\n      'Data',\n      'TransactionInactive',\n      'ReadOnly',\n      'Version',\n      'NotFound',\n      'InvalidState',\n      'InvalidAccess',\n      'Abort',\n      'Timeout',\n      'QuotaExceeded',\n      'Syntax',\n      'DataClone'\n  ];\n  var errorList = dexieErrorNames.concat(idbDomErrorNames);\n  var defaultTexts = {\n      VersionChanged: \"Database version changed by other database connection\",\n      DatabaseClosed: \"Database has been closed\",\n      Abort: \"Transaction aborted\",\n      TransactionInactive: \"Transaction has already completed or failed\",\n      MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n  };\n  function DexieError(name, msg) {\n      this.name = name;\n      this.message = msg;\n  }\n  derive(DexieError).from(Error).extend({\n      toString: function () { return this.name + \": \" + this.message; }\n  });\n  function getMultiErrorMessage(msg, failures) {\n      return msg + \". Errors: \" + Object.keys(failures)\n          .map(function (key) { return failures[key].toString(); })\n          .filter(function (v, i, s) { return s.indexOf(v) === i; })\n          .join('\\n');\n  }\n  function ModifyError(msg, failures, successCount, failedKeys) {\n      this.failures = failures;\n      this.failedKeys = failedKeys;\n      this.successCount = successCount;\n      this.message = getMultiErrorMessage(msg, failures);\n  }\n  derive(ModifyError).from(DexieError);\n  function BulkError(msg, failures) {\n      this.name = \"BulkError\";\n      this.failures = Object.keys(failures).map(function (pos) { return failures[pos]; });\n      this.failuresByPos = failures;\n      this.message = getMultiErrorMessage(msg, this.failures);\n  }\n  derive(BulkError).from(DexieError);\n  var errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + \"Error\", obj); }, {});\n  var BaseException = DexieError;\n  var exceptions = errorList.reduce(function (obj, name) {\n      var fullName = name + \"Error\";\n      function DexieError(msgOrInner, inner) {\n          this.name = fullName;\n          if (!msgOrInner) {\n              this.message = defaultTexts[name] || fullName;\n              this.inner = null;\n          }\n          else if (typeof msgOrInner === 'string') {\n              this.message = \"\".concat(msgOrInner).concat(!inner ? '' : '\\n ' + inner);\n              this.inner = inner || null;\n          }\n          else if (typeof msgOrInner === 'object') {\n              this.message = \"\".concat(msgOrInner.name, \" \").concat(msgOrInner.message);\n              this.inner = msgOrInner;\n          }\n      }\n      derive(DexieError).from(BaseException);\n      obj[name] = DexieError;\n      return obj;\n  }, {});\n  exceptions.Syntax = SyntaxError;\n  exceptions.Type = TypeError;\n  exceptions.Range = RangeError;\n  var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\n      obj[name + \"Error\"] = exceptions[name];\n      return obj;\n  }, {});\n  function mapError(domError, message) {\n      if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n          return domError;\n      var rv = new exceptionMap[domError.name](message || domError.message, domError);\n      if (\"stack\" in domError) {\n          setProp(rv, \"stack\", { get: function () {\n                  return this.inner.stack;\n              } });\n      }\n      return rv;\n  }\n  var fullNameExceptions = errorList.reduce(function (obj, name) {\n      if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n          obj[name + \"Error\"] = exceptions[name];\n      return obj;\n  }, {});\n  fullNameExceptions.ModifyError = ModifyError;\n  fullNameExceptions.DexieError = DexieError;\n  fullNameExceptions.BulkError = BulkError;\n\n  function nop() { }\n  function mirror(val) { return val; }\n  function pureFunctionChain(f1, f2) {\n      if (f1 == null || f1 === mirror)\n          return f2;\n      return function (val) {\n          return f2(f1(val));\n      };\n  }\n  function callBoth(on1, on2) {\n      return function () {\n          on1.apply(this, arguments);\n          on2.apply(this, arguments);\n      };\n  }\n  function hookCreatingChain(f1, f2) {\n      if (f1 === nop)\n          return f2;\n      return function () {\n          var res = f1.apply(this, arguments);\n          if (res !== undefined)\n              arguments[0] = res;\n          var onsuccess = this.onsuccess,\n          onerror = this.onerror;\n          this.onsuccess = null;\n          this.onerror = null;\n          var res2 = f2.apply(this, arguments);\n          if (onsuccess)\n              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n          if (onerror)\n              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n          return res2 !== undefined ? res2 : res;\n      };\n  }\n  function hookDeletingChain(f1, f2) {\n      if (f1 === nop)\n          return f2;\n      return function () {\n          f1.apply(this, arguments);\n          var onsuccess = this.onsuccess,\n          onerror = this.onerror;\n          this.onsuccess = this.onerror = null;\n          f2.apply(this, arguments);\n          if (onsuccess)\n              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n          if (onerror)\n              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n      };\n  }\n  function hookUpdatingChain(f1, f2) {\n      if (f1 === nop)\n          return f2;\n      return function (modifications) {\n          var res = f1.apply(this, arguments);\n          extend(modifications, res);\n          var onsuccess = this.onsuccess,\n          onerror = this.onerror;\n          this.onsuccess = null;\n          this.onerror = null;\n          var res2 = f2.apply(this, arguments);\n          if (onsuccess)\n              this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n          if (onerror)\n              this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n          return res === undefined ?\n              (res2 === undefined ? undefined : res2) :\n              (extend(res, res2));\n      };\n  }\n  function reverseStoppableEventChain(f1, f2) {\n      if (f1 === nop)\n          return f2;\n      return function () {\n          if (f2.apply(this, arguments) === false)\n              return false;\n          return f1.apply(this, arguments);\n      };\n  }\n  function promisableChain(f1, f2) {\n      if (f1 === nop)\n          return f2;\n      return function () {\n          var res = f1.apply(this, arguments);\n          if (res && typeof res.then === 'function') {\n              var thiz = this, i = arguments.length, args = new Array(i);\n              while (i--)\n                  args[i] = arguments[i];\n              return res.then(function () {\n                  return f2.apply(thiz, args);\n              });\n          }\n          return f2.apply(this, arguments);\n      };\n  }\n\n  var debug = typeof location !== 'undefined' &&\n      /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n  function setDebug(value, filter) {\n      debug = value;\n  }\n\n  var INTERNAL = {};\n  var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ?\n      [] :\n      (function () {\n          var globalP = Promise.resolve();\n          if (typeof crypto === 'undefined' || !crypto.subtle)\n              return [globalP, getProto(globalP), globalP];\n          var nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n          return [\n              nativeP,\n              getProto(nativeP),\n              globalP\n          ];\n      })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\n  var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\n  var patchGlobalPromise = !!resolvedGlobalPromise;\n  function schedulePhysicalTick() {\n      queueMicrotask(physicalTick);\n  }\n  var asap = function (callback, args) {\n      microtickQueue.push([callback, args]);\n      if (needsNewPhysicalTick) {\n          schedulePhysicalTick();\n          needsNewPhysicalTick = false;\n      }\n  };\n  var isOutsideMicroTick = true,\n  needsNewPhysicalTick = true,\n  unhandledErrors = [],\n  rejectingErrors = [],\n  rejectionMapper = mirror;\n  var globalPSD = {\n      id: 'global',\n      global: true,\n      ref: 0,\n      unhandleds: [],\n      onunhandled: nop,\n      pgp: false,\n      env: {},\n      finalize: nop\n  };\n  var PSD = globalPSD;\n  var microtickQueue = [];\n  var numScheduledCalls = 0;\n  var tickFinalizers = [];\n  function DexiePromise(fn) {\n      if (typeof this !== 'object')\n          throw new TypeError('Promises must be constructed via new');\n      this._listeners = [];\n      this._lib = false;\n      var psd = (this._PSD = PSD);\n      if (typeof fn !== 'function') {\n          if (fn !== INTERNAL)\n              throw new TypeError('Not a function');\n          this._state = arguments[1];\n          this._value = arguments[2];\n          if (this._state === false)\n              handleRejection(this, this._value);\n          return;\n      }\n      this._state = null;\n      this._value = null;\n      ++psd.ref;\n      executePromiseTask(this, fn);\n  }\n  var thenProp = {\n      get: function () {\n          var psd = PSD, microTaskId = totalEchoes;\n          function then(onFulfilled, onRejected) {\n              var _this = this;\n              var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n              var cleanup = possibleAwait && !decrementExpectedAwaits();\n              var rv = new DexiePromise(function (resolve, reject) {\n                  propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n              });\n              if (this._consoleTask)\n                  rv._consoleTask = this._consoleTask;\n              return rv;\n          }\n          then.prototype = INTERNAL;\n          return then;\n      },\n      set: function (value) {\n          setProp(this, 'then', value && value.prototype === INTERNAL ?\n              thenProp :\n              {\n                  get: function () {\n                      return value;\n                  },\n                  set: thenProp.set\n              });\n      }\n  };\n  props(DexiePromise.prototype, {\n      then: thenProp,\n      _then: function (onFulfilled, onRejected) {\n          propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n      },\n      catch: function (onRejected) {\n          if (arguments.length === 1)\n              return this.then(null, onRejected);\n          var type = arguments[0], handler = arguments[1];\n          return typeof type === 'function' ? this.then(null, function (err) {\n              return err instanceof type ? handler(err) : PromiseReject(err);\n          })\n              : this.then(null, function (err) {\n                  return err && err.name === type ? handler(err) : PromiseReject(err);\n              });\n      },\n      finally: function (onFinally) {\n          return this.then(function (value) {\n              return DexiePromise.resolve(onFinally()).then(function () { return value; });\n          }, function (err) {\n              return DexiePromise.resolve(onFinally()).then(function () { return PromiseReject(err); });\n          });\n      },\n      timeout: function (ms, msg) {\n          var _this = this;\n          return ms < Infinity ?\n              new DexiePromise(function (resolve, reject) {\n                  var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);\n                  _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n              }) : this;\n      }\n  });\n  if (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n      setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\n  globalPSD.env = snapShot();\n  function Listener(onFulfilled, onRejected, resolve, reject, zone) {\n      this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n      this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n      this.resolve = resolve;\n      this.reject = reject;\n      this.psd = zone;\n  }\n  props(DexiePromise, {\n      all: function () {\n          var values = getArrayOf.apply(null, arguments)\n              .map(onPossibleParallellAsync);\n          return new DexiePromise(function (resolve, reject) {\n              if (values.length === 0)\n                  resolve([]);\n              var remaining = values.length;\n              values.forEach(function (a, i) { return DexiePromise.resolve(a).then(function (x) {\n                  values[i] = x;\n                  if (!--remaining)\n                      resolve(values);\n              }, reject); });\n          });\n      },\n      resolve: function (value) {\n          if (value instanceof DexiePromise)\n              return value;\n          if (value && typeof value.then === 'function')\n              return new DexiePromise(function (resolve, reject) {\n                  value.then(resolve, reject);\n              });\n          var rv = new DexiePromise(INTERNAL, true, value);\n          return rv;\n      },\n      reject: PromiseReject,\n      race: function () {\n          var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n          return new DexiePromise(function (resolve, reject) {\n              values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });\n          });\n      },\n      PSD: {\n          get: function () { return PSD; },\n          set: function (value) { return PSD = value; }\n      },\n      totalEchoes: { get: function () { return totalEchoes; } },\n      newPSD: newScope,\n      usePSD: usePSD,\n      scheduler: {\n          get: function () { return asap; },\n          set: function (value) { asap = value; }\n      },\n      rejectionMapper: {\n          get: function () { return rejectionMapper; },\n          set: function (value) { rejectionMapper = value; }\n      },\n      follow: function (fn, zoneProps) {\n          return new DexiePromise(function (resolve, reject) {\n              return newScope(function (resolve, reject) {\n                  var psd = PSD;\n                  psd.unhandleds = [];\n                  psd.onunhandled = reject;\n                  psd.finalize = callBoth(function () {\n                      var _this = this;\n                      run_at_end_of_this_or_next_physical_tick(function () {\n                          _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);\n                      });\n                  }, psd.finalize);\n                  fn();\n              }, zoneProps, resolve, reject);\n          });\n      }\n  });\n  if (NativePromise) {\n      if (NativePromise.allSettled)\n          setProp(DexiePromise, \"allSettled\", function () {\n              var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n              return new DexiePromise(function (resolve) {\n                  if (possiblePromises.length === 0)\n                      resolve([]);\n                  var remaining = possiblePromises.length;\n                  var results = new Array(remaining);\n                  possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: \"fulfilled\", value: value }; }, function (reason) { return results[i] = { status: \"rejected\", reason: reason }; })\n                      .then(function () { return --remaining || resolve(results); }); });\n              });\n          });\n      if (NativePromise.any && typeof AggregateError !== 'undefined')\n          setProp(DexiePromise, \"any\", function () {\n              var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n              return new DexiePromise(function (resolve, reject) {\n                  if (possiblePromises.length === 0)\n                      reject(new AggregateError([]));\n                  var remaining = possiblePromises.length;\n                  var failures = new Array(remaining);\n                  possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {\n                      failures[i] = failure;\n                      if (!--remaining)\n                          reject(new AggregateError(failures));\n                  }); });\n              });\n          });\n      if (NativePromise.withResolvers)\n          DexiePromise.withResolvers = NativePromise.withResolvers;\n  }\n  function executePromiseTask(promise, fn) {\n      try {\n          fn(function (value) {\n              if (promise._state !== null)\n                  return;\n              if (value === promise)\n                  throw new TypeError('A promise cannot be resolved with itself.');\n              var shouldExecuteTick = promise._lib && beginMicroTickScope();\n              if (value && typeof value.then === 'function') {\n                  executePromiseTask(promise, function (resolve, reject) {\n                      value instanceof DexiePromise ?\n                          value._then(resolve, reject) :\n                          value.then(resolve, reject);\n                  });\n              }\n              else {\n                  promise._state = true;\n                  promise._value = value;\n                  propagateAllListeners(promise);\n              }\n              if (shouldExecuteTick)\n                  endMicroTickScope();\n          }, handleRejection.bind(null, promise));\n      }\n      catch (ex) {\n          handleRejection(promise, ex);\n      }\n  }\n  function handleRejection(promise, reason) {\n      rejectingErrors.push(reason);\n      if (promise._state !== null)\n          return;\n      var shouldExecuteTick = promise._lib && beginMicroTickScope();\n      reason = rejectionMapper(reason);\n      promise._state = false;\n      promise._value = reason;\n      addPossiblyUnhandledError(promise);\n      propagateAllListeners(promise);\n      if (shouldExecuteTick)\n          endMicroTickScope();\n  }\n  function propagateAllListeners(promise) {\n      var listeners = promise._listeners;\n      promise._listeners = [];\n      for (var i = 0, len = listeners.length; i < len; ++i) {\n          propagateToListener(promise, listeners[i]);\n      }\n      var psd = promise._PSD;\n      --psd.ref || psd.finalize();\n      if (numScheduledCalls === 0) {\n          ++numScheduledCalls;\n          asap(function () {\n              if (--numScheduledCalls === 0)\n                  finalizePhysicalTick();\n          }, []);\n      }\n  }\n  function propagateToListener(promise, listener) {\n      if (promise._state === null) {\n          promise._listeners.push(listener);\n          return;\n      }\n      var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n      if (cb === null) {\n          return (promise._state ? listener.resolve : listener.reject)(promise._value);\n      }\n      ++listener.psd.ref;\n      ++numScheduledCalls;\n      asap(callListener, [cb, promise, listener]);\n  }\n  function callListener(cb, promise, listener) {\n      try {\n          var ret, value = promise._value;\n          if (!promise._state && rejectingErrors.length)\n              rejectingErrors = [];\n          ret = debug && promise._consoleTask ? promise._consoleTask.run(function () { return cb(value); }) : cb(value);\n          if (!promise._state && rejectingErrors.indexOf(value) === -1) {\n              markErrorAsHandled(promise);\n          }\n          listener.resolve(ret);\n      }\n      catch (e) {\n          listener.reject(e);\n      }\n      finally {\n          if (--numScheduledCalls === 0)\n              finalizePhysicalTick();\n          --listener.psd.ref || listener.psd.finalize();\n      }\n  }\n  function physicalTick() {\n      usePSD(globalPSD, function () {\n          beginMicroTickScope() && endMicroTickScope();\n      });\n  }\n  function beginMicroTickScope() {\n      var wasRootExec = isOutsideMicroTick;\n      isOutsideMicroTick = false;\n      needsNewPhysicalTick = false;\n      return wasRootExec;\n  }\n  function endMicroTickScope() {\n      var callbacks, i, l;\n      do {\n          while (microtickQueue.length > 0) {\n              callbacks = microtickQueue;\n              microtickQueue = [];\n              l = callbacks.length;\n              for (i = 0; i < l; ++i) {\n                  var item = callbacks[i];\n                  item[0].apply(null, item[1]);\n              }\n          }\n      } while (microtickQueue.length > 0);\n      isOutsideMicroTick = true;\n      needsNewPhysicalTick = true;\n  }\n  function finalizePhysicalTick() {\n      var unhandledErrs = unhandledErrors;\n      unhandledErrors = [];\n      unhandledErrs.forEach(function (p) {\n          p._PSD.onunhandled.call(null, p._value, p);\n      });\n      var finalizers = tickFinalizers.slice(0);\n      var i = finalizers.length;\n      while (i)\n          finalizers[--i]();\n  }\n  function run_at_end_of_this_or_next_physical_tick(fn) {\n      function finalizer() {\n          fn();\n          tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n      }\n      tickFinalizers.push(finalizer);\n      ++numScheduledCalls;\n      asap(function () {\n          if (--numScheduledCalls === 0)\n              finalizePhysicalTick();\n      }, []);\n  }\n  function addPossiblyUnhandledError(promise) {\n      if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))\n          unhandledErrors.push(promise);\n  }\n  function markErrorAsHandled(promise) {\n      var i = unhandledErrors.length;\n      while (i)\n          if (unhandledErrors[--i]._value === promise._value) {\n              unhandledErrors.splice(i, 1);\n              return;\n          }\n  }\n  function PromiseReject(reason) {\n      return new DexiePromise(INTERNAL, false, reason);\n  }\n  function wrap(fn, errorCatcher) {\n      var psd = PSD;\n      return function () {\n          var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n          try {\n              switchToZone(psd, true);\n              return fn.apply(this, arguments);\n          }\n          catch (e) {\n              errorCatcher && errorCatcher(e);\n          }\n          finally {\n              switchToZone(outerScope, false);\n              if (wasRootExec)\n                  endMicroTickScope();\n          }\n      };\n  }\n  var task = { awaits: 0, echoes: 0, id: 0 };\n  var taskCounter = 0;\n  var zoneStack = [];\n  var zoneEchoes = 0;\n  var totalEchoes = 0;\n  var zone_id_counter = 0;\n  function newScope(fn, props, a1, a2) {\n      var parent = PSD, psd = Object.create(parent);\n      psd.parent = parent;\n      psd.ref = 0;\n      psd.global = false;\n      psd.id = ++zone_id_counter;\n      globalPSD.env;\n      psd.env = patchGlobalPromise ? {\n          Promise: DexiePromise,\n          PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n          all: DexiePromise.all,\n          race: DexiePromise.race,\n          allSettled: DexiePromise.allSettled,\n          any: DexiePromise.any,\n          resolve: DexiePromise.resolve,\n          reject: DexiePromise.reject,\n      } : {};\n      if (props)\n          extend(psd, props);\n      ++parent.ref;\n      psd.finalize = function () {\n          --this.parent.ref || this.parent.finalize();\n      };\n      var rv = usePSD(psd, fn, a1, a2);\n      if (psd.ref === 0)\n          psd.finalize();\n      return rv;\n  }\n  function incrementExpectedAwaits() {\n      if (!task.id)\n          task.id = ++taskCounter;\n      ++task.awaits;\n      task.echoes += ZONE_ECHO_LIMIT;\n      return task.id;\n  }\n  function decrementExpectedAwaits() {\n      if (!task.awaits)\n          return false;\n      if (--task.awaits === 0)\n          task.id = 0;\n      task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n      return true;\n  }\n  if (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n      incrementExpectedAwaits = decrementExpectedAwaits = nop;\n  }\n  function onPossibleParallellAsync(possiblePromise) {\n      if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n          incrementExpectedAwaits();\n          return possiblePromise.then(function (x) {\n              decrementExpectedAwaits();\n              return x;\n          }, function (e) {\n              decrementExpectedAwaits();\n              return rejection(e);\n          });\n      }\n      return possiblePromise;\n  }\n  function zoneEnterEcho(targetZone) {\n      ++totalEchoes;\n      if (!task.echoes || --task.echoes === 0) {\n          task.echoes = task.awaits = task.id = 0;\n      }\n      zoneStack.push(PSD);\n      switchToZone(targetZone, true);\n  }\n  function zoneLeaveEcho() {\n      var zone = zoneStack[zoneStack.length - 1];\n      zoneStack.pop();\n      switchToZone(zone, false);\n  }\n  function switchToZone(targetZone, bEnteringZone) {\n      var currentZone = PSD;\n      if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n          queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n      }\n      if (targetZone === PSD)\n          return;\n      PSD = targetZone;\n      if (currentZone === globalPSD)\n          globalPSD.env = snapShot();\n      if (patchGlobalPromise) {\n          var GlobalPromise = globalPSD.env.Promise;\n          var targetEnv = targetZone.env;\n          if (currentZone.global || targetZone.global) {\n              Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n              GlobalPromise.all = targetEnv.all;\n              GlobalPromise.race = targetEnv.race;\n              GlobalPromise.resolve = targetEnv.resolve;\n              GlobalPromise.reject = targetEnv.reject;\n              if (targetEnv.allSettled)\n                  GlobalPromise.allSettled = targetEnv.allSettled;\n              if (targetEnv.any)\n                  GlobalPromise.any = targetEnv.any;\n          }\n      }\n  }\n  function snapShot() {\n      var GlobalPromise = _global.Promise;\n      return patchGlobalPromise ? {\n          Promise: GlobalPromise,\n          PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n          all: GlobalPromise.all,\n          race: GlobalPromise.race,\n          allSettled: GlobalPromise.allSettled,\n          any: GlobalPromise.any,\n          resolve: GlobalPromise.resolve,\n          reject: GlobalPromise.reject,\n      } : {};\n  }\n  function usePSD(psd, fn, a1, a2, a3) {\n      var outerScope = PSD;\n      try {\n          switchToZone(psd, true);\n          return fn(a1, a2, a3);\n      }\n      finally {\n          switchToZone(outerScope, false);\n      }\n  }\n  function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n      return typeof fn !== 'function' ? fn : function () {\n          var outerZone = PSD;\n          if (possibleAwait)\n              incrementExpectedAwaits();\n          switchToZone(zone, true);\n          try {\n              return fn.apply(this, arguments);\n          }\n          finally {\n              switchToZone(outerZone, false);\n              if (cleanup)\n                  queueMicrotask(decrementExpectedAwaits);\n          }\n      };\n  }\n  function execInGlobalContext(cb) {\n      if (Promise === NativePromise && task.echoes === 0) {\n          if (zoneEchoes === 0) {\n              cb();\n          }\n          else {\n              enqueueNativeMicroTask(cb);\n          }\n      }\n      else {\n          setTimeout(cb, 0);\n      }\n  }\n  var rejection = DexiePromise.reject;\n\n  function tempTransaction(db, mode, storeNames, fn) {\n      if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n          if (db._state.openComplete) {\n              return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n          }\n          if (!db._state.isBeingOpened) {\n              if (!db._state.autoOpen)\n                  return rejection(new exceptions.DatabaseClosed());\n              db.open().catch(nop);\n          }\n          return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });\n      }\n      else {\n          var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n          try {\n              trans.create();\n              db._state.PR1398_maxLoop = 3;\n          }\n          catch (ex) {\n              if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                  console.warn('Dexie: Need to reopen db');\n                  db.close({ disableAutoOpen: false });\n                  return db.open().then(function () { return tempTransaction(db, mode, storeNames, fn); });\n              }\n              return rejection(ex);\n          }\n          return trans._promise(mode, function (resolve, reject) {\n              return newScope(function () {\n                  PSD.trans = trans;\n                  return fn(resolve, reject, trans);\n              });\n          }).then(function (result) {\n              if (mode === 'readwrite')\n                  try {\n                      trans.idbtrans.commit();\n                  }\n                  catch (_a) { }\n              return mode === 'readonly' ? result : trans._completion.then(function () { return result; });\n          });\n      }\n  }\n\n  var DEXIE_VERSION = '4.3.0';\n  var maxString = String.fromCharCode(65535);\n  var minKey = -Infinity;\n  var INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\n  var STRING_EXPECTED = \"String expected.\";\n  var connections = [];\n  var DBNAMES_DB = '__dbnames';\n  var READONLY = 'readonly';\n  var READWRITE = 'readwrite';\n\n  function combine(filter1, filter2) {\n      return filter1 ?\n          filter2 ?\n              function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n              filter1 :\n          filter2;\n  }\n\n  var AnyRange = {\n      type: 3 ,\n      lower: -Infinity,\n      lowerOpen: false,\n      upper: [[]],\n      upperOpen: false\n  };\n\n  function workaroundForUndefinedPrimKey(keyPath) {\n      return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n          ? function (obj) {\n              if (obj[keyPath] === undefined && (keyPath in obj)) {\n                  obj = deepClone(obj);\n                  delete obj[keyPath];\n              }\n              return obj;\n          }\n          : function (obj) { return obj; };\n  }\n\n  function Entity() {\n      throw exceptions.Type(\"Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.\");\n  }\n\n  function cmp(a, b) {\n      try {\n          var ta = type(a);\n          var tb = type(b);\n          if (ta !== tb) {\n              if (ta === 'Array')\n                  return 1;\n              if (tb === 'Array')\n                  return -1;\n              if (ta === 'binary')\n                  return 1;\n              if (tb === 'binary')\n                  return -1;\n              if (ta === 'string')\n                  return 1;\n              if (tb === 'string')\n                  return -1;\n              if (ta === 'Date')\n                  return 1;\n              if (tb !== 'Date')\n                  return NaN;\n              return -1;\n          }\n          switch (ta) {\n              case 'number':\n              case 'Date':\n              case 'string':\n                  return a > b ? 1 : a < b ? -1 : 0;\n              case 'binary': {\n                  return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n              }\n              case 'Array':\n                  return compareArrays(a, b);\n          }\n      }\n      catch (_a) { }\n      return NaN;\n  }\n  function compareArrays(a, b) {\n      var al = a.length;\n      var bl = b.length;\n      var l = al < bl ? al : bl;\n      for (var i = 0; i < l; ++i) {\n          var res = cmp(a[i], b[i]);\n          if (res !== 0)\n              return res;\n      }\n      return al === bl ? 0 : al < bl ? -1 : 1;\n  }\n  function compareUint8Arrays(a, b) {\n      var al = a.length;\n      var bl = b.length;\n      var l = al < bl ? al : bl;\n      for (var i = 0; i < l; ++i) {\n          if (a[i] !== b[i])\n              return a[i] < b[i] ? -1 : 1;\n      }\n      return al === bl ? 0 : al < bl ? -1 : 1;\n  }\n  function type(x) {\n      var t = typeof x;\n      if (t !== 'object')\n          return t;\n      if (ArrayBuffer.isView(x))\n          return 'binary';\n      var tsTag = toStringTag(x);\n      return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n  }\n  function getUint8Array(a) {\n      if (a instanceof Uint8Array)\n          return a;\n      if (ArrayBuffer.isView(a))\n          return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n      return new Uint8Array(a);\n  }\n\n  function builtInDeletionTrigger(table, keys, res) {\n      var yProps = table.schema.yProps;\n      if (!yProps)\n          return res;\n      if (keys && res.numFailures > 0)\n          keys = keys.filter(function (_, i) { return !res.failures[i]; });\n      return Promise.all(yProps.map(function (_a) {\n          var updatesTable = _a.updatesTable;\n          return keys\n              ? table.db.table(updatesTable).where('k').anyOf(keys).delete()\n              : table.db.table(updatesTable).clear();\n      })).then(function () { return res; });\n  }\n\n  var PropModification =  (function () {\n      function PropModification(spec) {\n          this[\"@@propmod\"] = spec;\n      }\n      PropModification.prototype.execute = function (value) {\n          var _a;\n          var spec = this[\"@@propmod\"];\n          if (spec.add !== undefined) {\n              var term = spec.add;\n              if (isArray(term)) {\n                  return __spreadArray(__spreadArray([], (isArray(value) ? value : []), true), term, true).sort();\n              }\n              if (typeof term === 'number')\n                  return (Number(value) || 0) + term;\n              if (typeof term === 'bigint') {\n                  try {\n                      return BigInt(value) + term;\n                  }\n                  catch (_b) {\n                      return BigInt(0) + term;\n                  }\n              }\n              throw new TypeError(\"Invalid term \".concat(term));\n          }\n          if (spec.remove !== undefined) {\n              var subtrahend_1 = spec.remove;\n              if (isArray(subtrahend_1)) {\n                  return isArray(value) ? value.filter(function (item) { return !subtrahend_1.includes(item); }).sort() : [];\n              }\n              if (typeof subtrahend_1 === 'number')\n                  return Number(value) - subtrahend_1;\n              if (typeof subtrahend_1 === 'bigint') {\n                  try {\n                      return BigInt(value) - subtrahend_1;\n                  }\n                  catch (_c) {\n                      return BigInt(0) - subtrahend_1;\n                  }\n              }\n              throw new TypeError(\"Invalid subtrahend \".concat(subtrahend_1));\n          }\n          var prefixToReplace = (_a = spec.replacePrefix) === null || _a === void 0 ? void 0 : _a[0];\n          if (prefixToReplace && typeof value === 'string' && value.startsWith(prefixToReplace)) {\n              return spec.replacePrefix[1] + value.substring(prefixToReplace.length);\n          }\n          return value;\n      };\n      return PropModification;\n  }());\n\n  function applyUpdateSpec(obj, changes) {\n      var keyPaths = keys(changes);\n      var numKeys = keyPaths.length;\n      var anythingModified = false;\n      for (var i = 0; i < numKeys; ++i) {\n          var keyPath = keyPaths[i];\n          var value = changes[keyPath];\n          var origValue = getByKeyPath(obj, keyPath);\n          if (value instanceof PropModification) {\n              setByKeyPath(obj, keyPath, value.execute(origValue));\n              anythingModified = true;\n          }\n          else if (origValue !== value) {\n              setByKeyPath(obj, keyPath, value);\n              anythingModified = true;\n          }\n      }\n      return anythingModified;\n  }\n\n  var Table =  (function () {\n      function Table() {\n      }\n      Table.prototype._trans = function (mode, fn, writeLocked) {\n          var trans = this._tx || PSD.trans;\n          var tableName = this.name;\n          var task = debug && typeof console !== 'undefined' && console.createTask && console.createTask(\"Dexie: \".concat(mode === 'readonly' ? 'read' : 'write', \" \").concat(this.name));\n          function checkTableInTransaction(resolve, reject, trans) {\n              if (!trans.schema[tableName])\n                  throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n              return fn(trans.idbtrans, trans);\n          }\n          var wasRootExec = beginMicroTickScope();\n          try {\n              var p = trans && trans.db._novip === this.db._novip ?\n                  trans === PSD.trans ?\n                      trans._promise(mode, checkTableInTransaction, writeLocked) :\n                      newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :\n                  tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n              if (task) {\n                  p._consoleTask = task;\n                  p = p.catch(function (err) {\n                      console.trace(err);\n                      return rejection(err);\n                  });\n              }\n              return p;\n          }\n          finally {\n              if (wasRootExec)\n                  endMicroTickScope();\n          }\n      };\n      Table.prototype.get = function (keyOrCrit, cb) {\n          var _this = this;\n          if (keyOrCrit && keyOrCrit.constructor === Object)\n              return this.where(keyOrCrit).first(cb);\n          if (keyOrCrit == null)\n              return rejection(new exceptions.Type(\"Invalid argument to Table.get()\"));\n          return this._trans('readonly', function (trans) {\n              return _this.core.get({ trans: trans, key: keyOrCrit })\n                  .then(function (res) { return _this.hook.reading.fire(res); });\n          }).then(cb);\n      };\n      Table.prototype.where = function (indexOrCrit) {\n          if (typeof indexOrCrit === 'string')\n              return new this.db.WhereClause(this, indexOrCrit);\n          if (isArray(indexOrCrit))\n              return new this.db.WhereClause(this, \"[\".concat(indexOrCrit.join('+'), \"]\"));\n          var keyPaths = keys(indexOrCrit);\n          if (keyPaths.length === 1)\n              return this\n                  .where(keyPaths[0])\n                  .equals(indexOrCrit[keyPaths[0]]);\n          var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {\n              if (ix.compound &&\n                  keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; })) {\n                  for (var i = 0; i < keyPaths.length; ++i) {\n                      if (keyPaths.indexOf(ix.keyPath[i]) === -1)\n                          return false;\n                  }\n                  return true;\n              }\n              return false;\n          }).sort(function (a, b) { return a.keyPath.length - b.keyPath.length; })[0];\n          if (compoundIndex && this.db._maxKey !== maxString) {\n              var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n              return this\n                  .where(keyPathsInValidOrder)\n                  .equals(keyPathsInValidOrder.map(function (kp) { return indexOrCrit[kp]; }));\n          }\n          if (!compoundIndex && debug)\n              console.warn(\"The query \".concat(JSON.stringify(indexOrCrit), \" on \").concat(this.name, \" would benefit from a \") +\n                  \"compound index [\".concat(keyPaths.join('+'), \"]\"));\n          var idxByName = this.schema.idxByName;\n          function equals(a, b) {\n              return cmp(a, b) === 0;\n          }\n          var _a = keyPaths.reduce(function (_a, keyPath) {\n              var prevIndex = _a[0], prevFilterFn = _a[1];\n              var index = idxByName[keyPath];\n              var value = indexOrCrit[keyPath];\n              return [\n                  prevIndex || index,\n                  prevIndex || !index ?\n                      combine(prevFilterFn, index && index.multi ?\n                          function (x) {\n                              var prop = getByKeyPath(x, keyPath);\n                              return isArray(prop) && prop.some(function (item) { return equals(value, item); });\n                          } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })\n                      : prevFilterFn\n              ];\n          }, [null, null]), idx = _a[0], filterFunction = _a[1];\n          return idx ?\n              this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                  .filter(filterFunction) :\n              compoundIndex ?\n                  this.filter(filterFunction) :\n                  this.where(keyPaths).equals('');\n      };\n      Table.prototype.filter = function (filterFunction) {\n          return this.toCollection().and(filterFunction);\n      };\n      Table.prototype.count = function (thenShortcut) {\n          return this.toCollection().count(thenShortcut);\n      };\n      Table.prototype.offset = function (offset) {\n          return this.toCollection().offset(offset);\n      };\n      Table.prototype.limit = function (numRows) {\n          return this.toCollection().limit(numRows);\n      };\n      Table.prototype.each = function (callback) {\n          return this.toCollection().each(callback);\n      };\n      Table.prototype.toArray = function (thenShortcut) {\n          return this.toCollection().toArray(thenShortcut);\n      };\n      Table.prototype.toCollection = function () {\n          return new this.db.Collection(new this.db.WhereClause(this));\n      };\n      Table.prototype.orderBy = function (index) {\n          return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n              \"[\".concat(index.join('+'), \"]\") :\n              index));\n      };\n      Table.prototype.reverse = function () {\n          return this.toCollection().reverse();\n      };\n      Table.prototype.mapToClass = function (constructor) {\n          var _a = this, db = _a.db, tableName = _a.name;\n          this.schema.mappedClass = constructor;\n          if (constructor.prototype instanceof Entity) {\n              constructor =  (function (_super) {\n                  __extends(class_1, _super);\n                  function class_1() {\n                      return _super !== null && _super.apply(this, arguments) || this;\n                  }\n                  Object.defineProperty(class_1.prototype, \"db\", {\n                      get: function () { return db; },\n                      enumerable: false,\n                      configurable: true\n                  });\n                  class_1.prototype.table = function () { return tableName; };\n                  return class_1;\n              }(constructor));\n          }\n          var inheritedProps = new Set();\n          for (var proto = constructor.prototype; proto; proto = getProto(proto)) {\n              Object.getOwnPropertyNames(proto).forEach(function (propName) { return inheritedProps.add(propName); });\n          }\n          var readHook = function (obj) {\n              if (!obj)\n                  return obj;\n              var res = Object.create(constructor.prototype);\n              for (var m in obj)\n                  if (!inheritedProps.has(m))\n                      try {\n                          res[m] = obj[m];\n                      }\n                      catch (_) { }\n              return res;\n          };\n          if (this.schema.readHook) {\n              this.hook.reading.unsubscribe(this.schema.readHook);\n          }\n          this.schema.readHook = readHook;\n          this.hook(\"reading\", readHook);\n          return constructor;\n      };\n      Table.prototype.defineClass = function () {\n          function Class(content) {\n              extend(this, content);\n          }\n          return this.mapToClass(Class);\n      };\n      Table.prototype.add = function (obj, key) {\n          var _this = this;\n          var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n          var objToAdd = obj;\n          if (keyPath && auto) {\n              objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n          }\n          return this._trans('readwrite', function (trans) {\n              return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n          }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n              .then(function (lastResult) {\n              if (keyPath) {\n                  try {\n                      setByKeyPath(obj, keyPath, lastResult);\n                  }\n                  catch (_) { }\n              }\n              return lastResult;\n          });\n      };\n      Table.prototype.upsert = function (key, modifications) {\n          var _this = this;\n          var keyPath = this.schema.primKey.keyPath;\n          return this._trans('readwrite', function (trans) {\n              return _this.core.get({ trans: trans, key: key }).then(function (existing) {\n                  var obj = existing !== null && existing !== void 0 ? existing : {};\n                  applyUpdateSpec(obj, modifications);\n                  if (keyPath)\n                      setByKeyPath(obj, keyPath, key);\n                  return _this.core.mutate({\n                      trans: trans,\n                      type: 'put',\n                      values: [obj],\n                      keys: [key],\n                      upsert: true,\n                      updates: { keys: [key], changeSpecs: [modifications] }\n                  }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : !!existing; });\n              });\n          });\n      };\n      Table.prototype.update = function (keyOrObject, modifications) {\n          if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n              var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n              if (key === undefined)\n                  return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n              return this.where(\":id\").equals(key).modify(modifications);\n          }\n          else {\n              return this.where(\":id\").equals(keyOrObject).modify(modifications);\n          }\n      };\n      Table.prototype.put = function (obj, key) {\n          var _this = this;\n          var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n          var objToAdd = obj;\n          if (keyPath && auto) {\n              objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n          }\n          return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })\n              .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n              .then(function (lastResult) {\n              if (keyPath) {\n                  try {\n                      setByKeyPath(obj, keyPath, lastResult);\n                  }\n                  catch (_) { }\n              }\n              return lastResult;\n          });\n      };\n      Table.prototype.delete = function (key) {\n          var _this = this;\n          return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] })\n              .then(function (res) { return builtInDeletionTrigger(_this, [key], res); })\n              .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; }); });\n      };\n      Table.prototype.clear = function () {\n          var _this = this;\n          return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange })\n              .then(function (res) { return builtInDeletionTrigger(_this, null, res); }); })\n              .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n      };\n      Table.prototype.bulkGet = function (keys) {\n          var _this = this;\n          return this._trans('readonly', function (trans) {\n              return _this.core.getMany({\n                  keys: keys,\n                  trans: trans\n              }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });\n          });\n      };\n      Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {\n          var _this = this;\n          var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n          options = options || (keys ? undefined : keysOrOptions);\n          var wantResults = options ? options.allKeys : undefined;\n          return this._trans('readwrite', function (trans) {\n              var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n              if (keyPath && keys)\n                  throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n              if (keys && keys.length !== objects.length)\n                  throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n              var numObjects = objects.length;\n              var objectsToAdd = keyPath && auto ?\n                  objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                  objects;\n              return _this.core.mutate({ trans: trans, type: 'add', keys: keys, values: objectsToAdd, wantResults: wantResults })\n                  .then(function (_a) {\n                  var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n                  var result = wantResults ? results : lastResult;\n                  if (numFailures === 0)\n                      return result;\n                  throw new BulkError(\"\".concat(_this.name, \".bulkAdd(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n              });\n          });\n      };\n      Table.prototype.bulkPut = function (objects, keysOrOptions, options) {\n          var _this = this;\n          var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n          options = options || (keys ? undefined : keysOrOptions);\n          var wantResults = options ? options.allKeys : undefined;\n          return this._trans('readwrite', function (trans) {\n              var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n              if (keyPath && keys)\n                  throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n              if (keys && keys.length !== objects.length)\n                  throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n              var numObjects = objects.length;\n              var objectsToPut = keyPath && auto ?\n                  objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                  objects;\n              return _this.core.mutate({ trans: trans, type: 'put', keys: keys, values: objectsToPut, wantResults: wantResults })\n                  .then(function (_a) {\n                  var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n                  var result = wantResults ? results : lastResult;\n                  if (numFailures === 0)\n                      return result;\n                  throw new BulkError(\"\".concat(_this.name, \".bulkPut(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n              });\n          });\n      };\n      Table.prototype.bulkUpdate = function (keysAndChanges) {\n          var _this = this;\n          var coreTable = this.core;\n          var keys = keysAndChanges.map(function (entry) { return entry.key; });\n          var changeSpecs = keysAndChanges.map(function (entry) { return entry.changes; });\n          var offsetMap = [];\n          return this._trans('readwrite', function (trans) {\n              return coreTable.getMany({ trans: trans, keys: keys, cache: 'clone' }).then(function (objs) {\n                  var resultKeys = [];\n                  var resultObjs = [];\n                  keysAndChanges.forEach(function (_a, idx) {\n                      var key = _a.key, changes = _a.changes;\n                      var obj = objs[idx];\n                      if (obj) {\n                          for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {\n                              var keyPath = _b[_i];\n                              var value = changes[keyPath];\n                              if (keyPath === _this.schema.primKey.keyPath) {\n                                  if (cmp(value, key) !== 0) {\n                                      throw new exceptions.Constraint(\"Cannot update primary key in bulkUpdate()\");\n                                  }\n                              }\n                              else {\n                                  setByKeyPath(obj, keyPath, value);\n                              }\n                          }\n                          offsetMap.push(idx);\n                          resultKeys.push(key);\n                          resultObjs.push(obj);\n                      }\n                  });\n                  var numEntries = resultKeys.length;\n                  return coreTable\n                      .mutate({\n                      trans: trans,\n                      type: 'put',\n                      keys: resultKeys,\n                      values: resultObjs,\n                      updates: {\n                          keys: keys,\n                          changeSpecs: changeSpecs\n                      }\n                  })\n                      .then(function (_a) {\n                      var numFailures = _a.numFailures, failures = _a.failures;\n                      if (numFailures === 0)\n                          return numEntries;\n                      for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {\n                          var offset = _b[_i];\n                          var mappedOffset = offsetMap[Number(offset)];\n                          if (mappedOffset != null) {\n                              var failure = failures[offset];\n                              delete failures[offset];\n                              failures[mappedOffset] = failure;\n                          }\n                      }\n                      throw new BulkError(\"\".concat(_this.name, \".bulkUpdate(): \").concat(numFailures, \" of \").concat(numEntries, \" operations failed\"), failures);\n                  });\n              });\n          });\n      };\n      Table.prototype.bulkDelete = function (keys) {\n          var _this = this;\n          var numKeys = keys.length;\n          return this._trans('readwrite', function (trans) {\n              return _this.core.mutate({ trans: trans, type: 'delete', keys: keys })\n                  .then(function (res) { return builtInDeletionTrigger(_this, keys, res); });\n          }).then(function (_a) {\n              var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;\n              if (numFailures === 0)\n                  return lastResult;\n              throw new BulkError(\"\".concat(_this.name, \".bulkDelete(): \").concat(numFailures, \" of \").concat(numKeys, \" operations failed\"), failures);\n          });\n      };\n      return Table;\n  }());\n\n  function Events(ctx) {\n      var evs = {};\n      var rv = function (eventName, subscriber) {\n          if (subscriber) {\n              var i = arguments.length, args = new Array(i - 1);\n              while (--i)\n                  args[i - 1] = arguments[i];\n              evs[eventName].subscribe.apply(null, args);\n              return ctx;\n          }\n          else if (typeof (eventName) === 'string') {\n              return evs[eventName];\n          }\n      };\n      rv.addEventType = add;\n      for (var i = 1, l = arguments.length; i < l; ++i) {\n          add(arguments[i]);\n      }\n      return rv;\n      function add(eventName, chainFunction, defaultFunction) {\n          if (typeof eventName === 'object')\n              return addConfiguredEvents(eventName);\n          if (!chainFunction)\n              chainFunction = reverseStoppableEventChain;\n          if (!defaultFunction)\n              defaultFunction = nop;\n          var context = {\n              subscribers: [],\n              fire: defaultFunction,\n              subscribe: function (cb) {\n                  if (context.subscribers.indexOf(cb) === -1) {\n                      context.subscribers.push(cb);\n                      context.fire = chainFunction(context.fire, cb);\n                  }\n              },\n              unsubscribe: function (cb) {\n                  context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                  context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n              }\n          };\n          evs[eventName] = rv[eventName] = context;\n          return context;\n      }\n      function addConfiguredEvents(cfg) {\n          keys(cfg).forEach(function (eventName) {\n              var args = cfg[eventName];\n              if (isArray(args)) {\n                  add(eventName, cfg[eventName][0], cfg[eventName][1]);\n              }\n              else if (args === 'asap') {\n                  var context = add(eventName, mirror, function fire() {\n                      var i = arguments.length, args = new Array(i);\n                      while (i--)\n                          args[i] = arguments[i];\n                      context.subscribers.forEach(function (fn) {\n                          asap$1(function fireEvent() {\n                              fn.apply(null, args);\n                          });\n                      });\n                  });\n              }\n              else\n                  throw new exceptions.InvalidArgument(\"Invalid event config\");\n          });\n      }\n  }\n\n  function makeClassConstructor(prototype, constructor) {\n      derive(constructor).from({ prototype: prototype });\n      return constructor;\n  }\n\n  function createTableConstructor(db) {\n      return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n          this.db = db;\n          this._tx = trans;\n          this.name = name;\n          this.schema = tableSchema;\n          this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n              \"creating\": [hookCreatingChain, nop],\n              \"reading\": [pureFunctionChain, mirror],\n              \"updating\": [hookUpdatingChain, nop],\n              \"deleting\": [hookDeletingChain, nop]\n          });\n      });\n  }\n\n  function isPlainKeyRange(ctx, ignoreLimitFilter) {\n      return !(ctx.filter || ctx.algorithm || ctx.or) &&\n          (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n  }\n  function addFilter(ctx, fn) {\n      ctx.filter = combine(ctx.filter, fn);\n  }\n  function addReplayFilter(ctx, factory, isLimitFilter) {\n      var curr = ctx.replayFilter;\n      ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;\n      ctx.justLimit = isLimitFilter && !curr;\n  }\n  function addMatchFilter(ctx, fn) {\n      ctx.isMatch = combine(ctx.isMatch, fn);\n  }\n  function getIndexOrStore(ctx, coreSchema) {\n      if (ctx.isPrimKey)\n          return coreSchema.primaryKey;\n      var index = coreSchema.getIndexByKeyPath(ctx.index);\n      if (!index)\n          throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n      return index;\n  }\n  function openCursor(ctx, coreTable, trans) {\n      var index = getIndexOrStore(ctx, coreTable.schema);\n      return coreTable.openCursor({\n          trans: trans,\n          values: !ctx.keysOnly,\n          reverse: ctx.dir === 'prev',\n          unique: !!ctx.unique,\n          query: {\n              index: index,\n              range: ctx.range\n          }\n      });\n  }\n  function iter(ctx, fn, coreTrans, coreTable) {\n      var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n      if (!ctx.or) {\n          return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n      }\n      else {\n          var set_1 = {};\n          var union = function (item, cursor, advance) {\n              if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {\n                  var primaryKey = cursor.primaryKey;\n                  var key = '' + primaryKey;\n                  if (key === '[object ArrayBuffer]')\n                      key = '' + new Uint8Array(primaryKey);\n                  if (!hasOwn(set_1, key)) {\n                      set_1[key] = true;\n                      fn(item, cursor, advance);\n                  }\n              }\n          };\n          return Promise.all([\n              ctx.or._iterate(union, coreTrans),\n              iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n          ]);\n      }\n  }\n  function iterate(cursorPromise, filter, fn, valueMapper) {\n      var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;\n      var wrappedFn = wrap(mappedFn);\n      return cursorPromise.then(function (cursor) {\n          if (cursor) {\n              return cursor.start(function () {\n                  var c = function () { return cursor.continue(); };\n                  if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))\n                      wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });\n                  c();\n              });\n          }\n      });\n  }\n\n  var Collection =  (function () {\n      function Collection() {\n      }\n      Collection.prototype._read = function (fn, cb) {\n          var ctx = this._ctx;\n          return ctx.error ?\n              ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n              ctx.table._trans('readonly', fn).then(cb);\n      };\n      Collection.prototype._write = function (fn) {\n          var ctx = this._ctx;\n          return ctx.error ?\n              ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n              ctx.table._trans('readwrite', fn, \"locked\");\n      };\n      Collection.prototype._addAlgorithm = function (fn) {\n          var ctx = this._ctx;\n          ctx.algorithm = combine(ctx.algorithm, fn);\n      };\n      Collection.prototype._iterate = function (fn, coreTrans) {\n          return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n      };\n      Collection.prototype.clone = function (props) {\n          var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n          if (props)\n              extend(ctx, props);\n          rv._ctx = ctx;\n          return rv;\n      };\n      Collection.prototype.raw = function () {\n          this._ctx.valueMapper = null;\n          return this;\n      };\n      Collection.prototype.each = function (fn) {\n          var ctx = this._ctx;\n          return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });\n      };\n      Collection.prototype.count = function (cb) {\n          var _this = this;\n          return this._read(function (trans) {\n              var ctx = _this._ctx;\n              var coreTable = ctx.table.core;\n              if (isPlainKeyRange(ctx, true)) {\n                  return coreTable.count({\n                      trans: trans,\n                      query: {\n                          index: getIndexOrStore(ctx, coreTable.schema),\n                          range: ctx.range\n                      }\n                  }).then(function (count) { return Math.min(count, ctx.limit); });\n              }\n              else {\n                  var count = 0;\n                  return iter(ctx, function () { ++count; return false; }, trans, coreTable)\n                      .then(function () { return count; });\n              }\n          }).then(cb);\n      };\n      Collection.prototype.sortBy = function (keyPath, cb) {\n          var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n          function getval(obj, i) {\n              if (i)\n                  return getval(obj[parts[i]], i - 1);\n              return obj[lastPart];\n          }\n          var order = this._ctx.dir === \"next\" ? 1 : -1;\n          function sorter(a, b) {\n              var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n              return cmp(aVal, bVal) * order;\n          }\n          return this.toArray(function (a) {\n              return a.sort(sorter);\n          }).then(cb);\n      };\n      Collection.prototype.toArray = function (cb) {\n          var _this = this;\n          return this._read(function (trans) {\n              var ctx = _this._ctx;\n              if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                  var valueMapper_1 = ctx.valueMapper;\n                  var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                  return ctx.table.core.query({\n                      trans: trans,\n                      limit: ctx.limit,\n                      values: true,\n                      query: {\n                          index: index,\n                          range: ctx.range\n                      }\n                  }).then(function (_a) {\n                      var result = _a.result;\n                      return valueMapper_1 ? result.map(valueMapper_1) : result;\n                  });\n              }\n              else {\n                  var a_1 = [];\n                  return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });\n              }\n          }, cb);\n      };\n      Collection.prototype.offset = function (offset) {\n          var ctx = this._ctx;\n          if (offset <= 0)\n              return this;\n          ctx.offset += offset;\n          if (isPlainKeyRange(ctx)) {\n              addReplayFilter(ctx, function () {\n                  var offsetLeft = offset;\n                  return function (cursor, advance) {\n                      if (offsetLeft === 0)\n                          return true;\n                      if (offsetLeft === 1) {\n                          --offsetLeft;\n                          return false;\n                      }\n                      advance(function () {\n                          cursor.advance(offsetLeft);\n                          offsetLeft = 0;\n                      });\n                      return false;\n                  };\n              });\n          }\n          else {\n              addReplayFilter(ctx, function () {\n                  var offsetLeft = offset;\n                  return function () { return (--offsetLeft < 0); };\n              });\n          }\n          return this;\n      };\n      Collection.prototype.limit = function (numRows) {\n          this._ctx.limit = Math.min(this._ctx.limit, numRows);\n          addReplayFilter(this._ctx, function () {\n              var rowsLeft = numRows;\n              return function (cursor, advance, resolve) {\n                  if (--rowsLeft <= 0)\n                      advance(resolve);\n                  return rowsLeft >= 0;\n              };\n          }, true);\n          return this;\n      };\n      Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {\n          addFilter(this._ctx, function (cursor, advance, resolve) {\n              if (filterFunction(cursor.value)) {\n                  advance(resolve);\n                  return bIncludeStopEntry;\n              }\n              else {\n                  return true;\n              }\n          });\n          return this;\n      };\n      Collection.prototype.first = function (cb) {\n          return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n      };\n      Collection.prototype.last = function (cb) {\n          return this.reverse().first(cb);\n      };\n      Collection.prototype.filter = function (filterFunction) {\n          addFilter(this._ctx, function (cursor) {\n              return filterFunction(cursor.value);\n          });\n          addMatchFilter(this._ctx, filterFunction);\n          return this;\n      };\n      Collection.prototype.and = function (filter) {\n          return this.filter(filter);\n      };\n      Collection.prototype.or = function (indexName) {\n          return new this.db.WhereClause(this._ctx.table, indexName, this);\n      };\n      Collection.prototype.reverse = function () {\n          this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n          if (this._ondirectionchange)\n              this._ondirectionchange(this._ctx.dir);\n          return this;\n      };\n      Collection.prototype.desc = function () {\n          return this.reverse();\n      };\n      Collection.prototype.eachKey = function (cb) {\n          var ctx = this._ctx;\n          ctx.keysOnly = !ctx.isMatch;\n          return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n      };\n      Collection.prototype.eachUniqueKey = function (cb) {\n          this._ctx.unique = \"unique\";\n          return this.eachKey(cb);\n      };\n      Collection.prototype.eachPrimaryKey = function (cb) {\n          var ctx = this._ctx;\n          ctx.keysOnly = !ctx.isMatch;\n          return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n      };\n      Collection.prototype.keys = function (cb) {\n          var ctx = this._ctx;\n          ctx.keysOnly = !ctx.isMatch;\n          var a = [];\n          return this.each(function (item, cursor) {\n              a.push(cursor.key);\n          }).then(function () {\n              return a;\n          }).then(cb);\n      };\n      Collection.prototype.primaryKeys = function (cb) {\n          var ctx = this._ctx;\n          if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n              return this._read(function (trans) {\n                  var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                  return ctx.table.core.query({\n                      trans: trans,\n                      values: false,\n                      limit: ctx.limit,\n                      query: {\n                          index: index,\n                          range: ctx.range\n                      }\n                  });\n              }).then(function (_a) {\n                  var result = _a.result;\n                  return result;\n              }).then(cb);\n          }\n          ctx.keysOnly = !ctx.isMatch;\n          var a = [];\n          return this.each(function (item, cursor) {\n              a.push(cursor.primaryKey);\n          }).then(function () {\n              return a;\n          }).then(cb);\n      };\n      Collection.prototype.uniqueKeys = function (cb) {\n          this._ctx.unique = \"unique\";\n          return this.keys(cb);\n      };\n      Collection.prototype.firstKey = function (cb) {\n          return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n      };\n      Collection.prototype.lastKey = function (cb) {\n          return this.reverse().firstKey(cb);\n      };\n      Collection.prototype.distinct = function () {\n          var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n          if (!idx || !idx.multi)\n              return this;\n          var set = {};\n          addFilter(this._ctx, function (cursor) {\n              var strKey = cursor.primaryKey.toString();\n              var found = hasOwn(set, strKey);\n              set[strKey] = true;\n              return !found;\n          });\n          return this;\n      };\n      Collection.prototype.modify = function (changes) {\n          var _this = this;\n          var ctx = this._ctx;\n          return this._write(function (trans) {\n              var modifyer;\n              if (typeof changes === 'function') {\n                  modifyer = changes;\n              }\n              else {\n                  modifyer = function (item) { return applyUpdateSpec(item, changes); };\n              }\n              var coreTable = ctx.table.core;\n              var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;\n              var limit = 200;\n              var modifyChunkSize = _this.db._options.modifyChunkSize;\n              if (modifyChunkSize) {\n                  if (typeof modifyChunkSize == 'object') {\n                      limit = modifyChunkSize[coreTable.name] || modifyChunkSize['*'] || 200;\n                  }\n                  else {\n                      limit = modifyChunkSize;\n                  }\n              }\n              var totalFailures = [];\n              var successCount = 0;\n              var failedKeys = [];\n              var applyMutateResult = function (expectedCount, res) {\n                  var failures = res.failures, numFailures = res.numFailures;\n                  successCount += expectedCount - numFailures;\n                  for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {\n                      var pos = _a[_i];\n                      totalFailures.push(failures[pos]);\n                  }\n              };\n              var isUnconditionalDelete = changes === deleteCallback;\n              return _this.clone().primaryKeys().then(function (keys) {\n                  var criteria = isPlainKeyRange(ctx) &&\n                      ctx.limit === Infinity &&\n                      (typeof changes !== 'function' || isUnconditionalDelete) && {\n                      index: ctx.index,\n                      range: ctx.range\n                  };\n                  var nextChunk = function (offset) {\n                      var count = Math.min(limit, keys.length - offset);\n                      var keysInChunk = keys.slice(offset, offset + count);\n                      return (isUnconditionalDelete ? Promise.resolve([]) : coreTable.getMany({\n                          trans: trans,\n                          keys: keysInChunk,\n                          cache: \"immutable\"\n                      })).then(function (values) {\n                          var addValues = [];\n                          var putValues = [];\n                          var putKeys = outbound ? [] : null;\n                          var deleteKeys = isUnconditionalDelete ? keysInChunk : [];\n                          if (!isUnconditionalDelete)\n                              for (var i = 0; i < count; ++i) {\n                                  var origValue = values[i];\n                                  var ctx_1 = {\n                                      value: deepClone(origValue),\n                                      primKey: keys[offset + i]\n                                  };\n                                  if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {\n                                      if (ctx_1.value == null) {\n                                          deleteKeys.push(keys[offset + i]);\n                                      }\n                                      else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {\n                                          deleteKeys.push(keys[offset + i]);\n                                          addValues.push(ctx_1.value);\n                                      }\n                                      else {\n                                          putValues.push(ctx_1.value);\n                                          if (outbound)\n                                              putKeys.push(keys[offset + i]);\n                                      }\n                                  }\n                              }\n                          return Promise.resolve(addValues.length > 0 &&\n                              coreTable.mutate({ trans: trans, type: 'add', values: addValues })\n                                  .then(function (res) {\n                                  for (var pos in res.failures) {\n                                      deleteKeys.splice(parseInt(pos), 1);\n                                  }\n                                  applyMutateResult(addValues.length, res);\n                              })).then(function () { return (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                              coreTable.mutate({\n                                  trans: trans,\n                                  type: 'put',\n                                  keys: putKeys,\n                                  values: putValues,\n                                  criteria: criteria,\n                                  changeSpec: typeof changes !== 'function'\n                                      && changes,\n                                  isAdditionalChunk: offset > 0\n                              }).then(function (res) { return applyMutateResult(putValues.length, res); }); }).then(function () { return (deleteKeys.length > 0 || (criteria && isUnconditionalDelete)) &&\n                              coreTable.mutate({\n                                  trans: trans,\n                                  type: 'delete',\n                                  keys: deleteKeys,\n                                  criteria: criteria,\n                                  isAdditionalChunk: offset > 0\n                              }).then(function (res) { return builtInDeletionTrigger(ctx.table, deleteKeys, res); })\n                                  .then(function (res) { return applyMutateResult(deleteKeys.length, res); }); }).then(function () {\n                              return keys.length > offset + count && nextChunk(offset + limit);\n                          });\n                      });\n                  };\n                  return nextChunk(0).then(function () {\n                      if (totalFailures.length > 0)\n                          throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                      return keys.length;\n                  });\n              });\n          });\n      };\n      Collection.prototype.delete = function () {\n          var ctx = this._ctx, range = ctx.range;\n          if (isPlainKeyRange(ctx) &&\n              !ctx.table.schema.yProps &&\n              (ctx.isPrimKey || range.type === 3 ))\n           {\n              return this._write(function (trans) {\n                  var primaryKey = ctx.table.core.schema.primaryKey;\n                  var coreRange = range;\n                  return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {\n                      return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })\n                          .then(function (_a) {\n                          var failures = _a.failures, numFailures = _a.numFailures;\n                          if (numFailures)\n                              throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);\n                          return count - numFailures;\n                      });\n                  });\n              });\n          }\n          return this.modify(deleteCallback);\n      };\n      return Collection;\n  }());\n  var deleteCallback = function (value, ctx) { return ctx.value = null; };\n\n  function createCollectionConstructor(db) {\n      return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n          this.db = db;\n          var keyRange = AnyRange, error = null;\n          if (keyRangeGenerator)\n              try {\n                  keyRange = keyRangeGenerator();\n              }\n              catch (ex) {\n                  error = ex;\n              }\n          var whereCtx = whereClause._ctx;\n          var table = whereCtx.table;\n          var readingHook = table.hook.reading.fire;\n          this._ctx = {\n              table: table,\n              index: whereCtx.index,\n              isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n              range: keyRange,\n              keysOnly: false,\n              dir: \"next\",\n              unique: \"\",\n              algorithm: null,\n              filter: null,\n              replayFilter: null,\n              justLimit: true,\n              isMatch: null,\n              offset: 0,\n              limit: Infinity,\n              error: error,\n              or: whereCtx.or,\n              valueMapper: readingHook !== mirror ? readingHook : null\n          };\n      });\n  }\n\n  function simpleCompare(a, b) {\n      return a < b ? -1 : a === b ? 0 : 1;\n  }\n  function simpleCompareReverse(a, b) {\n      return a > b ? -1 : a === b ? 0 : 1;\n  }\n\n  function fail(collectionOrWhereClause, err, T) {\n      var collection = collectionOrWhereClause instanceof WhereClause ?\n          new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n          collectionOrWhereClause;\n      collection._ctx.error = T ? new T(err) : new TypeError(err);\n      return collection;\n  }\n  function emptyCollection(whereClause) {\n      return new whereClause.Collection(whereClause, function () { return rangeEqual(\"\"); }).limit(0);\n  }\n  function upperFactory(dir) {\n      return dir === \"next\" ?\n          function (s) { return s.toUpperCase(); } :\n          function (s) { return s.toLowerCase(); };\n  }\n  function lowerFactory(dir) {\n      return dir === \"next\" ?\n          function (s) { return s.toLowerCase(); } :\n          function (s) { return s.toUpperCase(); };\n  }\n  function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n      var length = Math.min(key.length, lowerNeedle.length);\n      var llp = -1;\n      for (var i = 0; i < length; ++i) {\n          var lwrKeyChar = lowerKey[i];\n          if (lwrKeyChar !== lowerNeedle[i]) {\n              if (cmp(key[i], upperNeedle[i]) < 0)\n                  return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n              if (cmp(key[i], lowerNeedle[i]) < 0)\n                  return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n              if (llp >= 0)\n                  return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n              return null;\n          }\n          if (cmp(key[i], lwrKeyChar) < 0)\n              llp = i;\n      }\n      if (length < lowerNeedle.length && dir === \"next\")\n          return key + upperNeedle.substr(key.length);\n      if (length < key.length && dir === \"prev\")\n          return key.substr(0, upperNeedle.length);\n      return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n  }\n  function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n      var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n      if (!needles.every(function (s) { return typeof s === 'string'; })) {\n          return fail(whereClause, STRING_EXPECTED);\n      }\n      function initDirection(dir) {\n          upper = upperFactory(dir);\n          lower = lowerFactory(dir);\n          compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n          var needleBounds = needles.map(function (needle) {\n              return { lower: lower(needle), upper: upper(needle) };\n          }).sort(function (a, b) {\n              return compare(a.lower, b.lower);\n          });\n          upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n          lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n          direction = dir;\n          nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n      }\n      initDirection(\"next\");\n      var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });\n      c._ondirectionchange = function (direction) {\n          initDirection(direction);\n      };\n      var firstPossibleNeedle = 0;\n      c._addAlgorithm(function (cursor, advance, resolve) {\n          var key = cursor.key;\n          if (typeof key !== 'string')\n              return false;\n          var lowerKey = lower(key);\n          if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n              return true;\n          }\n          else {\n              var lowestPossibleCasing = null;\n              for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                  var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                  if (casing === null && lowestPossibleCasing === null)\n                      firstPossibleNeedle = i + 1;\n                  else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                      lowestPossibleCasing = casing;\n                  }\n              }\n              if (lowestPossibleCasing !== null) {\n                  advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n              }\n              else {\n                  advance(resolve);\n              }\n              return false;\n          }\n      });\n      return c;\n  }\n  function createRange(lower, upper, lowerOpen, upperOpen) {\n      return {\n          type: 2 ,\n          lower: lower,\n          upper: upper,\n          lowerOpen: lowerOpen,\n          upperOpen: upperOpen\n      };\n  }\n  function rangeEqual(value) {\n      return {\n          type: 1 ,\n          lower: value,\n          upper: value\n      };\n  }\n\n  var WhereClause =  (function () {\n      function WhereClause() {\n      }\n      Object.defineProperty(WhereClause.prototype, \"Collection\", {\n          get: function () {\n              return this._ctx.table.db.Collection;\n          },\n          enumerable: false,\n          configurable: true\n      });\n      WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {\n          includeLower = includeLower !== false;\n          includeUpper = includeUpper === true;\n          try {\n              if ((this._cmp(lower, upper) > 0) ||\n                  (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                  return emptyCollection(this);\n              return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });\n          }\n          catch (e) {\n              return fail(this, INVALID_KEY_ARGUMENT);\n          }\n      };\n      WhereClause.prototype.equals = function (value) {\n          if (value == null)\n              return fail(this, INVALID_KEY_ARGUMENT);\n          return new this.Collection(this, function () { return rangeEqual(value); });\n      };\n      WhereClause.prototype.above = function (value) {\n          if (value == null)\n              return fail(this, INVALID_KEY_ARGUMENT);\n          return new this.Collection(this, function () { return createRange(value, undefined, true); });\n      };\n      WhereClause.prototype.aboveOrEqual = function (value) {\n          if (value == null)\n              return fail(this, INVALID_KEY_ARGUMENT);\n          return new this.Collection(this, function () { return createRange(value, undefined, false); });\n      };\n      WhereClause.prototype.below = function (value) {\n          if (value == null)\n              return fail(this, INVALID_KEY_ARGUMENT);\n          return new this.Collection(this, function () { return createRange(undefined, value, false, true); });\n      };\n      WhereClause.prototype.belowOrEqual = function (value) {\n          if (value == null)\n              return fail(this, INVALID_KEY_ARGUMENT);\n          return new this.Collection(this, function () { return createRange(undefined, value); });\n      };\n      WhereClause.prototype.startsWith = function (str) {\n          if (typeof str !== 'string')\n              return fail(this, STRING_EXPECTED);\n          return this.between(str, str + maxString, true, true);\n      };\n      WhereClause.prototype.startsWithIgnoreCase = function (str) {\n          if (str === \"\")\n              return this.startsWith(str);\n          return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);\n      };\n      WhereClause.prototype.equalsIgnoreCase = function (str) {\n          return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], \"\");\n      };\n      WhereClause.prototype.anyOfIgnoreCase = function () {\n          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n          if (set.length === 0)\n              return emptyCollection(this);\n          return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, \"\");\n      };\n      WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {\n          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n          if (set.length === 0)\n              return emptyCollection(this);\n          return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);\n      };\n      WhereClause.prototype.anyOf = function () {\n          var _this = this;\n          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n          var compare = this._cmp;\n          try {\n              set.sort(compare);\n          }\n          catch (e) {\n              return fail(this, INVALID_KEY_ARGUMENT);\n          }\n          if (set.length === 0)\n              return emptyCollection(this);\n          var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });\n          c._ondirectionchange = function (direction) {\n              compare = (direction === \"next\" ?\n                  _this._ascending :\n                  _this._descending);\n              set.sort(compare);\n          };\n          var i = 0;\n          c._addAlgorithm(function (cursor, advance, resolve) {\n              var key = cursor.key;\n              while (compare(key, set[i]) > 0) {\n                  ++i;\n                  if (i === set.length) {\n                      advance(resolve);\n                      return false;\n                  }\n              }\n              if (compare(key, set[i]) === 0) {\n                  return true;\n              }\n              else {\n                  advance(function () { cursor.continue(set[i]); });\n                  return false;\n              }\n          });\n          return c;\n      };\n      WhereClause.prototype.notEqual = function (value) {\n          return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n      };\n      WhereClause.prototype.noneOf = function () {\n          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n          if (set.length === 0)\n              return new this.Collection(this);\n          try {\n              set.sort(this._ascending);\n          }\n          catch (e) {\n              return fail(this, INVALID_KEY_ARGUMENT);\n          }\n          var ranges = set.reduce(function (res, val) { return res ?\n              res.concat([[res[res.length - 1][1], val]]) :\n              [[minKey, val]]; }, null);\n          ranges.push([set[set.length - 1], this.db._maxKey]);\n          return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n      };\n      WhereClause.prototype.inAnyRange = function (ranges, options) {\n          var _this = this;\n          var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n          if (ranges.length === 0)\n              return emptyCollection(this);\n          if (!ranges.every(function (range) {\n              return range[0] !== undefined &&\n                  range[1] !== undefined &&\n                  ascending(range[0], range[1]) <= 0;\n          })) {\n              return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n          }\n          var includeLowers = !options || options.includeLowers !== false;\n          var includeUppers = options && options.includeUppers === true;\n          function addRange(ranges, newRange) {\n              var i = 0, l = ranges.length;\n              for (; i < l; ++i) {\n                  var range = ranges[i];\n                  if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                      range[0] = min(range[0], newRange[0]);\n                      range[1] = max(range[1], newRange[1]);\n                      break;\n                  }\n              }\n              if (i === l)\n                  ranges.push(newRange);\n              return ranges;\n          }\n          var sortDirection = ascending;\n          function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n          var set;\n          try {\n              set = ranges.reduce(addRange, []);\n              set.sort(rangeSorter);\n          }\n          catch (ex) {\n              return fail(this, INVALID_KEY_ARGUMENT);\n          }\n          var rangePos = 0;\n          var keyIsBeyondCurrentEntry = includeUppers ?\n              function (key) { return ascending(key, set[rangePos][1]) > 0; } :\n              function (key) { return ascending(key, set[rangePos][1]) >= 0; };\n          var keyIsBeforeCurrentEntry = includeLowers ?\n              function (key) { return descending(key, set[rangePos][0]) > 0; } :\n              function (key) { return descending(key, set[rangePos][0]) >= 0; };\n          function keyWithinCurrentRange(key) {\n              return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n          }\n          var checkKey = keyIsBeyondCurrentEntry;\n          var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });\n          c._ondirectionchange = function (direction) {\n              if (direction === \"next\") {\n                  checkKey = keyIsBeyondCurrentEntry;\n                  sortDirection = ascending;\n              }\n              else {\n                  checkKey = keyIsBeforeCurrentEntry;\n                  sortDirection = descending;\n              }\n              set.sort(rangeSorter);\n          };\n          c._addAlgorithm(function (cursor, advance, resolve) {\n              var key = cursor.key;\n              while (checkKey(key)) {\n                  ++rangePos;\n                  if (rangePos === set.length) {\n                      advance(resolve);\n                      return false;\n                  }\n              }\n              if (keyWithinCurrentRange(key)) {\n                  return true;\n              }\n              else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {\n                  return false;\n              }\n              else {\n                  advance(function () {\n                      if (sortDirection === ascending)\n                          cursor.continue(set[rangePos][0]);\n                      else\n                          cursor.continue(set[rangePos][1]);\n                  });\n                  return false;\n              }\n          });\n          return c;\n      };\n      WhereClause.prototype.startsWithAnyOf = function () {\n          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n          if (!set.every(function (s) { return typeof s === 'string'; })) {\n              return fail(this, \"startsWithAnyOf() only works with strings\");\n          }\n          if (set.length === 0)\n              return emptyCollection(this);\n          return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));\n      };\n      return WhereClause;\n  }());\n\n  function createWhereClauseConstructor(db) {\n      return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n          this.db = db;\n          this._ctx = {\n              table: table,\n              index: index === \":id\" ? null : index,\n              or: orCollection\n          };\n          this._cmp = this._ascending = cmp;\n          this._descending = function (a, b) { return cmp(b, a); };\n          this._max = function (a, b) { return cmp(a, b) > 0 ? a : b; };\n          this._min = function (a, b) { return cmp(a, b) < 0 ? a : b; };\n          this._IDBKeyRange = db._deps.IDBKeyRange;\n          if (!this._IDBKeyRange)\n              throw new exceptions.MissingAPI();\n      });\n  }\n\n  function eventRejectHandler(reject) {\n      return wrap(function (event) {\n          preventDefault(event);\n          reject(event.target.error);\n          return false;\n      });\n  }\n  function preventDefault(event) {\n      if (event.stopPropagation)\n          event.stopPropagation();\n      if (event.preventDefault)\n          event.preventDefault();\n  }\n\n  var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\n  var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\n  var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\n  var Transaction =  (function () {\n      function Transaction() {\n      }\n      Transaction.prototype._lock = function () {\n          assert(!PSD.global);\n          ++this._reculock;\n          if (this._reculock === 1 && !PSD.global)\n              PSD.lockOwnerFor = this;\n          return this;\n      };\n      Transaction.prototype._unlock = function () {\n          assert(!PSD.global);\n          if (--this._reculock === 0) {\n              if (!PSD.global)\n                  PSD.lockOwnerFor = null;\n              while (this._blockedFuncs.length > 0 && !this._locked()) {\n                  var fnAndPSD = this._blockedFuncs.shift();\n                  try {\n                      usePSD(fnAndPSD[1], fnAndPSD[0]);\n                  }\n                  catch (e) { }\n              }\n          }\n          return this;\n      };\n      Transaction.prototype._locked = function () {\n          return this._reculock && PSD.lockOwnerFor !== this;\n      };\n      Transaction.prototype.create = function (idbtrans) {\n          var _this = this;\n          if (!this.mode)\n              return this;\n          var idbdb = this.db.idbdb;\n          var dbOpenError = this.db._state.dbOpenError;\n          assert(!this.idbtrans);\n          if (!idbtrans && !idbdb) {\n              switch (dbOpenError && dbOpenError.name) {\n                  case \"DatabaseClosedError\":\n                      throw new exceptions.DatabaseClosed(dbOpenError);\n                  case \"MissingAPIError\":\n                      throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                  default:\n                      throw new exceptions.OpenFailed(dbOpenError);\n              }\n          }\n          if (!this.active)\n              throw new exceptions.TransactionInactive();\n          assert(this._completion._state === null);\n          idbtrans = this.idbtrans = idbtrans ||\n              (this.db.core\n                  ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                  : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n          idbtrans.onerror = wrap(function (ev) {\n              preventDefault(ev);\n              _this._reject(idbtrans.error);\n          });\n          idbtrans.onabort = wrap(function (ev) {\n              preventDefault(ev);\n              _this.active && _this._reject(new exceptions.Abort(idbtrans.error));\n              _this.active = false;\n              _this.on(\"abort\").fire(ev);\n          });\n          idbtrans.oncomplete = wrap(function () {\n              _this.active = false;\n              _this._resolve();\n              if ('mutatedParts' in idbtrans) {\n                  globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n              }\n          });\n          return this;\n      };\n      Transaction.prototype._promise = function (mode, fn, bWriteLock) {\n          var _this = this;\n          if (mode === 'readwrite' && this.mode !== 'readwrite')\n              return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n          if (!this.active)\n              return rejection(new exceptions.TransactionInactive());\n          if (this._locked()) {\n              return new DexiePromise(function (resolve, reject) {\n                  _this._blockedFuncs.push([function () {\n                          _this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                      }, PSD]);\n              });\n          }\n          else if (bWriteLock) {\n              return newScope(function () {\n                  var p = new DexiePromise(function (resolve, reject) {\n                      _this._lock();\n                      var rv = fn(resolve, reject, _this);\n                      if (rv && rv.then)\n                          rv.then(resolve, reject);\n                  });\n                  p.finally(function () { return _this._unlock(); });\n                  p._lib = true;\n                  return p;\n              });\n          }\n          else {\n              var p = new DexiePromise(function (resolve, reject) {\n                  var rv = fn(resolve, reject, _this);\n                  if (rv && rv.then)\n                      rv.then(resolve, reject);\n              });\n              p._lib = true;\n              return p;\n          }\n      };\n      Transaction.prototype._root = function () {\n          return this.parent ? this.parent._root() : this;\n      };\n      Transaction.prototype.waitFor = function (promiseLike) {\n          var root = this._root();\n          var promise = DexiePromise.resolve(promiseLike);\n          if (root._waitingFor) {\n              root._waitingFor = root._waitingFor.then(function () { return promise; });\n          }\n          else {\n              root._waitingFor = promise;\n              root._waitingQueue = [];\n              var store = root.idbtrans.objectStore(root.storeNames[0]);\n              (function spin() {\n                  ++root._spinCount;\n                  while (root._waitingQueue.length)\n                      (root._waitingQueue.shift())();\n                  if (root._waitingFor)\n                      store.get(-Infinity).onsuccess = spin;\n              }());\n          }\n          var currentWaitPromise = root._waitingFor;\n          return new DexiePromise(function (resolve, reject) {\n              promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {\n                  if (root._waitingFor === currentWaitPromise) {\n                      root._waitingFor = null;\n                  }\n              });\n          });\n      };\n      Transaction.prototype.abort = function () {\n          if (this.active) {\n              this.active = false;\n              if (this.idbtrans)\n                  this.idbtrans.abort();\n              this._reject(new exceptions.Abort());\n          }\n      };\n      Transaction.prototype.table = function (tableName) {\n          var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n          if (hasOwn(memoizedTables, tableName))\n              return memoizedTables[tableName];\n          var tableSchema = this.schema[tableName];\n          if (!tableSchema) {\n              throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n          }\n          var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n          transactionBoundTable.core = this.db.core.table(tableName);\n          memoizedTables[tableName] = transactionBoundTable;\n          return transactionBoundTable;\n      };\n      return Transaction;\n  }());\n\n  function createTransactionConstructor(db) {\n      return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n          var _this = this;\n          if (mode !== 'readonly')\n              storeNames.forEach(function (storeName) {\n                  var _a;\n                  var yProps = (_a = dbschema[storeName]) === null || _a === void 0 ? void 0 : _a.yProps;\n                  if (yProps)\n                      storeNames = storeNames.concat(yProps.map(function (p) { return p.updatesTable; }));\n              });\n          this.db = db;\n          this.mode = mode;\n          this.storeNames = storeNames;\n          this.schema = dbschema;\n          this.chromeTransactionDurability = chromeTransactionDurability;\n          this.idbtrans = null;\n          this.on = Events(this, \"complete\", \"error\", \"abort\");\n          this.parent = parent || null;\n          this.active = true;\n          this._reculock = 0;\n          this._blockedFuncs = [];\n          this._resolve = null;\n          this._reject = null;\n          this._waitingFor = null;\n          this._waitingQueue = null;\n          this._spinCount = 0;\n          this._completion = new DexiePromise(function (resolve, reject) {\n              _this._resolve = resolve;\n              _this._reject = reject;\n          });\n          this._completion.then(function () {\n              _this.active = false;\n              _this.on.complete.fire();\n          }, function (e) {\n              var wasActive = _this.active;\n              _this.active = false;\n              _this.on.error.fire(e);\n              _this.parent ?\n                  _this.parent._reject(e) :\n                  wasActive && _this.idbtrans && _this.idbtrans.abort();\n              return rejection(e);\n          });\n      });\n  }\n\n  function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey, type) {\n      return {\n          name: name,\n          keyPath: keyPath,\n          unique: unique,\n          multi: multi,\n          auto: auto,\n          compound: compound,\n          src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath),\n          type: type\n      };\n  }\n  function nameFromKeyPath(keyPath) {\n      return typeof keyPath === 'string' ?\n          keyPath :\n          keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n  }\n\n  function createTableSchema(name, primKey, indexes) {\n      return {\n          name: name,\n          primKey: primKey,\n          indexes: indexes,\n          mappedClass: null,\n          idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; }),\n      };\n  }\n\n  function safariMultiStoreFix(storeNames) {\n      return storeNames.length === 1 ? storeNames[0] : storeNames;\n  }\n  var getMaxKey = function (IdbKeyRange) {\n      try {\n          IdbKeyRange.only([[]]);\n          getMaxKey = function () { return [[]]; };\n          return [[]];\n      }\n      catch (e) {\n          getMaxKey = function () { return maxString; };\n          return maxString;\n      }\n  };\n\n  function getKeyExtractor(keyPath) {\n      if (keyPath == null) {\n          return function () { return undefined; };\n      }\n      else if (typeof keyPath === 'string') {\n          return getSinglePathKeyExtractor(keyPath);\n      }\n      else {\n          return function (obj) { return getByKeyPath(obj, keyPath); };\n      }\n  }\n  function getSinglePathKeyExtractor(keyPath) {\n      var split = keyPath.split('.');\n      if (split.length === 1) {\n          return function (obj) { return obj[keyPath]; };\n      }\n      else {\n          return function (obj) { return getByKeyPath(obj, keyPath); };\n      }\n  }\n\n  function arrayify(arrayLike) {\n      return [].slice.call(arrayLike);\n  }\n  var _id_counter = 0;\n  function getKeyPathAlias(keyPath) {\n      return keyPath == null ?\n          \":id\" :\n          typeof keyPath === 'string' ?\n              keyPath :\n              \"[\".concat(keyPath.join('+'), \"]\");\n  }\n  function createDBCore(db, IdbKeyRange, tmpTrans) {\n      function extractSchema(db, trans) {\n          var tables = arrayify(db.objectStoreNames);\n          return {\n              schema: {\n                  name: db.name,\n                  tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {\n                      var keyPath = store.keyPath, autoIncrement = store.autoIncrement;\n                      var compound = isArray(keyPath);\n                      var outbound = keyPath == null;\n                      var indexByKeyPath = {};\n                      var result = {\n                          name: store.name,\n                          primaryKey: {\n                              name: null,\n                              isPrimaryKey: true,\n                              outbound: outbound,\n                              compound: compound,\n                              keyPath: keyPath,\n                              autoIncrement: autoIncrement,\n                              unique: true,\n                              extractKey: getKeyExtractor(keyPath)\n                          },\n                          indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })\n                              .map(function (index) {\n                              var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;\n                              var compound = isArray(keyPath);\n                              var result = {\n                                  name: name,\n                                  compound: compound,\n                                  keyPath: keyPath,\n                                  unique: unique,\n                                  multiEntry: multiEntry,\n                                  extractKey: getKeyExtractor(keyPath)\n                              };\n                              indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                              return result;\n                          }),\n                          getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }\n                      };\n                      indexByKeyPath[\":id\"] = result.primaryKey;\n                      if (keyPath != null) {\n                          indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                      }\n                      return result;\n                  })\n              },\n              hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                  !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                      !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                      [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n          };\n      }\n      function makeIDBKeyRange(range) {\n          if (range.type === 3 )\n              return null;\n          if (range.type === 4 )\n              throw new Error(\"Cannot convert never type to IDBKeyRange\");\n          var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;\n          var idbRange = lower === undefined ?\n              upper === undefined ?\n                  null :\n                  IdbKeyRange.upperBound(upper, !!upperOpen) :\n              upper === undefined ?\n                  IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                  IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n          return idbRange;\n      }\n      function createDbCoreTable(tableSchema) {\n          var tableName = tableSchema.name;\n          function mutate(_a) {\n              var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;\n              return new Promise(function (resolve, reject) {\n                  resolve = wrap(resolve);\n                  var store = trans.objectStore(tableName);\n                  var outbound = store.keyPath == null;\n                  var isAddOrPut = type === \"put\" || type === \"add\";\n                  if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                      throw new Error(\"Invalid operation type: \" + type);\n                  var length = (keys || values || { length: 1 }).length;\n                  if (keys && values && keys.length !== values.length) {\n                      throw new Error(\"Given keys array must have same length as given values array.\");\n                  }\n                  if (length === 0)\n                      return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                  var req;\n                  var reqs = [];\n                  var failures = [];\n                  var numFailures = 0;\n                  var errorHandler = function (event) {\n                      ++numFailures;\n                      preventDefault(event);\n                  };\n                  if (type === 'deleteRange') {\n                      if (range.type === 4 )\n                          return resolve({ numFailures: numFailures, failures: failures, results: [], lastResult: undefined });\n                      if (range.type === 3 )\n                          reqs.push(req = store.clear());\n                      else\n                          reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                  }\n                  else {\n                      var _a = isAddOrPut ?\n                          outbound ?\n                              [values, keys] :\n                              [values, null] :\n                          [keys, null], args1 = _a[0], args2 = _a[1];\n                      if (isAddOrPut) {\n                          for (var i = 0; i < length; ++i) {\n                              reqs.push(req = (args2 && args2[i] !== undefined ?\n                                  store[type](args1[i], args2[i]) :\n                                  store[type](args1[i])));\n                              req.onerror = errorHandler;\n                          }\n                      }\n                      else {\n                          for (var i = 0; i < length; ++i) {\n                              reqs.push(req = store[type](args1[i]));\n                              req.onerror = errorHandler;\n                          }\n                      }\n                  }\n                  var done = function (event) {\n                      var lastResult = event.target.result;\n                      reqs.forEach(function (req, i) { return req.error != null && (failures[i] = req.error); });\n                      resolve({\n                          numFailures: numFailures,\n                          failures: failures,\n                          results: type === \"delete\" ? keys : reqs.map(function (req) { return req.result; }),\n                          lastResult: lastResult\n                      });\n                  };\n                  req.onerror = function (event) {\n                      errorHandler(event);\n                      done(event);\n                  };\n                  req.onsuccess = done;\n              });\n          }\n          function openCursor(_a) {\n              var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;\n              return new Promise(function (resolve, reject) {\n                  resolve = wrap(resolve);\n                  var index = query.index, range = query.range;\n                  var store = trans.objectStore(tableName);\n                  var source = index.isPrimaryKey ?\n                      store :\n                      store.index(index.name);\n                  var direction = reverse ?\n                      unique ?\n                          \"prevunique\" :\n                          \"prev\" :\n                      unique ?\n                          \"nextunique\" :\n                          \"next\";\n                  var req = values || !('openKeyCursor' in source) ?\n                      source.openCursor(makeIDBKeyRange(range), direction) :\n                      source.openKeyCursor(makeIDBKeyRange(range), direction);\n                  req.onerror = eventRejectHandler(reject);\n                  req.onsuccess = wrap(function (ev) {\n                      var cursor = req.result;\n                      if (!cursor) {\n                          resolve(null);\n                          return;\n                      }\n                      cursor.___id = ++_id_counter;\n                      cursor.done = false;\n                      var _cursorContinue = cursor.continue.bind(cursor);\n                      var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                      if (_cursorContinuePrimaryKey)\n                          _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                      var _cursorAdvance = cursor.advance.bind(cursor);\n                      var doThrowCursorIsNotStarted = function () { throw new Error(\"Cursor not started\"); };\n                      var doThrowCursorIsStopped = function () { throw new Error(\"Cursor not stopped\"); };\n                      cursor.trans = trans;\n                      cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                      cursor.fail = wrap(reject);\n                      cursor.next = function () {\n                          var _this = this;\n                          var gotOne = 1;\n                          return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });\n                      };\n                      cursor.start = function (callback) {\n                          var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {\n                              resolveIteration = wrap(resolveIteration);\n                              req.onerror = eventRejectHandler(rejectIteration);\n                              cursor.fail = rejectIteration;\n                              cursor.stop = function (value) {\n                                  cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                  resolveIteration(value);\n                              };\n                          });\n                          var guardedCallback = function () {\n                              if (req.result) {\n                                  try {\n                                      callback();\n                                  }\n                                  catch (err) {\n                                      cursor.fail(err);\n                                  }\n                              }\n                              else {\n                                  cursor.done = true;\n                                  cursor.start = function () { throw new Error(\"Cursor behind last entry\"); };\n                                  cursor.stop();\n                              }\n                          };\n                          req.onsuccess = wrap(function (ev) {\n                              req.onsuccess = guardedCallback;\n                              guardedCallback();\n                          });\n                          cursor.continue = _cursorContinue;\n                          cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                          cursor.advance = _cursorAdvance;\n                          guardedCallback();\n                          return iterationPromise;\n                      };\n                      resolve(cursor);\n                  }, reject);\n              });\n          }\n          function query(hasGetAll) {\n              return function (request) {\n                  return new Promise(function (resolve, reject) {\n                      resolve = wrap(resolve);\n                      var trans = request.trans, values = request.values, limit = request.limit, query = request.query;\n                      var nonInfinitLimit = limit === Infinity ? undefined : limit;\n                      var index = query.index, range = query.range;\n                      var store = trans.objectStore(tableName);\n                      var source = index.isPrimaryKey ? store : store.index(index.name);\n                      var idbKeyRange = makeIDBKeyRange(range);\n                      if (limit === 0)\n                          return resolve({ result: [] });\n                      if (hasGetAll) {\n                          var req = values ?\n                              source.getAll(idbKeyRange, nonInfinitLimit) :\n                              source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                          req.onsuccess = function (event) { return resolve({ result: event.target.result }); };\n                          req.onerror = eventRejectHandler(reject);\n                      }\n                      else {\n                          var count_1 = 0;\n                          var req_1 = values || !('openKeyCursor' in source) ?\n                              source.openCursor(idbKeyRange) :\n                              source.openKeyCursor(idbKeyRange);\n                          var result_1 = [];\n                          req_1.onsuccess = function (event) {\n                              var cursor = req_1.result;\n                              if (!cursor)\n                                  return resolve({ result: result_1 });\n                              result_1.push(values ? cursor.value : cursor.primaryKey);\n                              if (++count_1 === limit)\n                                  return resolve({ result: result_1 });\n                              cursor.continue();\n                          };\n                          req_1.onerror = eventRejectHandler(reject);\n                      }\n                  });\n              };\n          }\n          return {\n              name: tableName,\n              schema: tableSchema,\n              mutate: mutate,\n              getMany: function (_a) {\n                  var trans = _a.trans, keys = _a.keys;\n                  return new Promise(function (resolve, reject) {\n                      resolve = wrap(resolve);\n                      var store = trans.objectStore(tableName);\n                      var length = keys.length;\n                      var result = new Array(length);\n                      var keyCount = 0;\n                      var callbackCount = 0;\n                      var req;\n                      var successHandler = function (event) {\n                          var req = event.target;\n                          if ((result[req._pos] = req.result) != null)\n                              ;\n                          if (++callbackCount === keyCount)\n                              resolve(result);\n                      };\n                      var errorHandler = eventRejectHandler(reject);\n                      for (var i = 0; i < length; ++i) {\n                          var key = keys[i];\n                          if (key != null) {\n                              req = store.get(keys[i]);\n                              req._pos = i;\n                              req.onsuccess = successHandler;\n                              req.onerror = errorHandler;\n                              ++keyCount;\n                          }\n                      }\n                      if (keyCount === 0)\n                          resolve(result);\n                  });\n              },\n              get: function (_a) {\n                  var trans = _a.trans, key = _a.key;\n                  return new Promise(function (resolve, reject) {\n                      resolve = wrap(resolve);\n                      var store = trans.objectStore(tableName);\n                      var req = store.get(key);\n                      req.onsuccess = function (event) { return resolve(event.target.result); };\n                      req.onerror = eventRejectHandler(reject);\n                  });\n              },\n              query: query(hasGetAll),\n              openCursor: openCursor,\n              count: function (_a) {\n                  var query = _a.query, trans = _a.trans;\n                  var index = query.index, range = query.range;\n                  return new Promise(function (resolve, reject) {\n                      var store = trans.objectStore(tableName);\n                      var source = index.isPrimaryKey ? store : store.index(index.name);\n                      var idbKeyRange = makeIDBKeyRange(range);\n                      var req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                      req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });\n                      req.onerror = eventRejectHandler(reject);\n                  });\n              }\n          };\n      }\n      var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;\n      var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });\n      var tableMap = {};\n      tables.forEach(function (table) { return tableMap[table.name] = table; });\n      return {\n          stack: \"dbcore\",\n          transaction: db.transaction.bind(db),\n          table: function (name) {\n              var result = tableMap[name];\n              if (!result)\n                  throw new Error(\"Table '\".concat(name, \"' not found\"));\n              return tableMap[name];\n          },\n          MIN_KEY: -Infinity,\n          MAX_KEY: getMaxKey(IdbKeyRange),\n          schema: schema\n      };\n  }\n\n  function createMiddlewareStack(stackImpl, middlewares) {\n      return middlewares.reduce(function (down, _a) {\n          var create = _a.create;\n          return (__assign(__assign({}, down), create(down)));\n      }, stackImpl);\n  }\n  function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {\n      var IDBKeyRange = _a.IDBKeyRange; _a.indexedDB;\n      var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n      return {\n          dbcore: dbcore\n      };\n  }\n  function generateMiddlewareStacks(db, tmpTrans) {\n      var idbdb = tmpTrans.db;\n      var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n      db.core = stacks.dbcore;\n      db.tables.forEach(function (table) {\n          var tableName = table.name;\n          if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {\n              table.core = db.core.table(tableName);\n              if (db[tableName] instanceof db.Table) {\n                  db[tableName].core = table.core;\n              }\n          }\n      });\n  }\n\n  function setApiOnPlace(db, objs, tableNames, dbschema) {\n      tableNames.forEach(function (tableName) {\n          var schema = dbschema[tableName];\n          objs.forEach(function (obj) {\n              var propDesc = getPropertyDescriptor(obj, tableName);\n              if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                  if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                      setProp(obj, tableName, {\n                          get: function () { return this.table(tableName); },\n                          set: function (value) {\n                              defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });\n                          }\n                      });\n                  }\n                  else {\n                      obj[tableName] = new db.Table(tableName, schema);\n                  }\n              }\n          });\n      });\n  }\n  function removeTablesApi(db, objs) {\n      objs.forEach(function (obj) {\n          for (var key in obj) {\n              if (obj[key] instanceof db.Table)\n                  delete obj[key];\n          }\n      });\n  }\n  function lowerVersionFirst(a, b) {\n      return a._cfg.version - b._cfg.version;\n  }\n  function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n      var globalSchema = db._dbSchema;\n      if (idbUpgradeTrans.objectStoreNames.contains('$meta') && !globalSchema.$meta) {\n          globalSchema.$meta = createTableSchema(\"$meta\", parseIndexSyntax(\"\")[0], []);\n          db._storeNames.push('$meta');\n      }\n      var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n      trans.create(idbUpgradeTrans);\n      trans._completion.catch(reject);\n      var rejectTransaction = trans._reject.bind(trans);\n      var transless = PSD.transless || PSD;\n      newScope(function () {\n          PSD.trans = trans;\n          PSD.transless = transless;\n          if (oldVersion === 0) {\n              keys(globalSchema).forEach(function (tableName) {\n                  createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n              });\n              generateMiddlewareStacks(db, idbUpgradeTrans);\n              DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);\n          }\n          else {\n              generateMiddlewareStacks(db, idbUpgradeTrans);\n              return getExistingVersion(db, trans, oldVersion)\n                  .then(function (oldVersion) { return updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans); })\n                  .catch(rejectTransaction);\n          }\n      });\n  }\n  function patchCurrentVersion(db, idbUpgradeTrans) {\n      createMissingTables(db._dbSchema, idbUpgradeTrans);\n      if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains('$meta')) {\n          idbUpgradeTrans.db.createObjectStore('$meta').add(Math.ceil((idbUpgradeTrans.db.version / 10) - 1), 'version');\n      }\n      var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n      adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);\n      var diff = getSchemaDiff(globalSchema, db._dbSchema);\n      var _loop_1 = function (tableChange) {\n          if (tableChange.change.length || tableChange.recreate) {\n              console.warn(\"Unable to patch indexes of table \".concat(tableChange.name, \" because it has changes on the type of index or primary key.\"));\n              return { value: void 0 };\n          }\n          var store = idbUpgradeTrans.objectStore(tableChange.name);\n          tableChange.add.forEach(function (idx) {\n              if (debug)\n                  console.debug(\"Dexie upgrade patch: Creating missing index \".concat(tableChange.name, \".\").concat(idx.src));\n              addIndex(store, idx);\n          });\n      };\n      for (var _i = 0, _a = diff.change; _i < _a.length; _i++) {\n          var tableChange = _a[_i];\n          var state_1 = _loop_1(tableChange);\n          if (typeof state_1 === \"object\")\n              return state_1.value;\n      }\n  }\n  function getExistingVersion(db, trans, oldVersion) {\n      if (trans.storeNames.includes('$meta')) {\n          return trans.table('$meta').get('version').then(function (metaVersion) {\n              return metaVersion != null ? metaVersion : oldVersion;\n          });\n      }\n      else {\n          return DexiePromise.resolve(oldVersion);\n      }\n  }\n  function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {\n      var queue = [];\n      var versions = db._versions;\n      var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n      var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });\n      if (versToRun.length === 0) {\n          return DexiePromise.resolve();\n      }\n      versToRun.forEach(function (version) {\n          queue.push(function () {\n              var oldSchema = globalSchema;\n              var newSchema = version._cfg.dbschema;\n              adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n              adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n              globalSchema = db._dbSchema = newSchema;\n              var diff = getSchemaDiff(oldSchema, newSchema);\n              diff.add.forEach(function (tuple) {\n                  createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n              });\n              diff.change.forEach(function (change) {\n                  if (change.recreate) {\n                      throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                  }\n                  else {\n                      var store_1 = idbUpgradeTrans.objectStore(change.name);\n                      change.add.forEach(function (idx) { return addIndex(store_1, idx); });\n                      change.change.forEach(function (idx) {\n                          store_1.deleteIndex(idx.name);\n                          addIndex(store_1, idx);\n                      });\n                      change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });\n                  }\n              });\n              var contentUpgrade = version._cfg.contentUpgrade;\n              if (contentUpgrade && version._cfg.version > oldVersion) {\n                  generateMiddlewareStacks(db, idbUpgradeTrans);\n                  trans._memoizedTables = {};\n                  var upgradeSchema_1 = shallowClone(newSchema);\n                  diff.del.forEach(function (table) {\n                      upgradeSchema_1[table] = oldSchema[table];\n                  });\n                  removeTablesApi(db, [db.Transaction.prototype]);\n                  setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);\n                  trans.schema = upgradeSchema_1;\n                  var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);\n                  if (contentUpgradeIsAsync_1) {\n                      incrementExpectedAwaits();\n                  }\n                  var returnValue_1;\n                  var promiseFollowed = DexiePromise.follow(function () {\n                      returnValue_1 = contentUpgrade(trans);\n                      if (returnValue_1) {\n                          if (contentUpgradeIsAsync_1) {\n                              var decrementor = decrementExpectedAwaits.bind(null, null);\n                              returnValue_1.then(decrementor, decrementor);\n                          }\n                      }\n                  });\n                  return (returnValue_1 && typeof returnValue_1.then === 'function' ?\n                      DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));\n              }\n          });\n          queue.push(function (idbtrans) {\n              var newSchema = version._cfg.dbschema;\n              deleteRemovedTables(newSchema, idbtrans);\n              removeTablesApi(db, [db.Transaction.prototype]);\n              setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n              trans.schema = db._dbSchema;\n          });\n          queue.push(function (idbtrans) {\n              if (db.idbdb.objectStoreNames.contains('$meta')) {\n                  if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {\n                      db.idbdb.deleteObjectStore('$meta');\n                      delete db._dbSchema.$meta;\n                      db._storeNames = db._storeNames.filter(function (name) { return name !== '$meta'; });\n                  }\n                  else {\n                      idbtrans.objectStore('$meta').put(version._cfg.version, 'version');\n                  }\n              }\n          });\n      });\n      function runQueue() {\n          return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n              DexiePromise.resolve();\n      }\n      return runQueue().then(function () {\n          createMissingTables(globalSchema, idbUpgradeTrans);\n      });\n  }\n  function getSchemaDiff(oldSchema, newSchema) {\n      var diff = {\n          del: [],\n          add: [],\n          change: []\n      };\n      var table;\n      for (table in oldSchema) {\n          if (!newSchema[table])\n              diff.del.push(table);\n      }\n      for (table in newSchema) {\n          var oldDef = oldSchema[table], newDef = newSchema[table];\n          if (!oldDef) {\n              diff.add.push([table, newDef]);\n          }\n          else {\n              var change = {\n                  name: table,\n                  def: newDef,\n                  recreate: false,\n                  del: [],\n                  add: [],\n                  change: []\n              };\n              if ((\n              '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                  (oldDef.primKey.auto !== newDef.primKey.auto)) {\n                  change.recreate = true;\n                  diff.change.push(change);\n              }\n              else {\n                  var oldIndexes = oldDef.idxByName;\n                  var newIndexes = newDef.idxByName;\n                  var idxName = void 0;\n                  for (idxName in oldIndexes) {\n                      if (!newIndexes[idxName])\n                          change.del.push(idxName);\n                  }\n                  for (idxName in newIndexes) {\n                      var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                      if (!oldIdx)\n                          change.add.push(newIdx);\n                      else if (oldIdx.src !== newIdx.src)\n                          change.change.push(newIdx);\n                  }\n                  if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                      diff.change.push(change);\n                  }\n              }\n          }\n      }\n      return diff;\n  }\n  function createTable(idbtrans, tableName, primKey, indexes) {\n      var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n          { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n          { autoIncrement: primKey.auto });\n      indexes.forEach(function (idx) { return addIndex(store, idx); });\n      return store;\n  }\n  function createMissingTables(newSchema, idbtrans) {\n      keys(newSchema).forEach(function (tableName) {\n          if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n              if (debug)\n                  console.debug('Dexie: Creating missing table', tableName);\n              createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n          }\n      });\n  }\n  function deleteRemovedTables(newSchema, idbtrans) {\n      [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {\n          return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);\n      });\n  }\n  function addIndex(store, idx) {\n      store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n  }\n  function buildGlobalSchema(db, idbdb, tmpTrans) {\n      var globalSchema = {};\n      var dbStoreNames = slice(idbdb.objectStoreNames, 0);\n      dbStoreNames.forEach(function (storeName) {\n          var store = tmpTrans.objectStore(storeName);\n          var keyPath = store.keyPath;\n          var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n          var indexes = [];\n          for (var j = 0; j < store.indexNames.length; ++j) {\n              var idbindex = store.index(store.indexNames[j]);\n              keyPath = idbindex.keyPath;\n              var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n              indexes.push(index);\n          }\n          globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n      });\n      return globalSchema;\n  }\n  function readGlobalSchema(db, idbdb, tmpTrans) {\n      db.verno = idbdb.version / 10;\n      var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n      db._storeNames = slice(idbdb.objectStoreNames, 0);\n      setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n  }\n  function verifyInstalledSchema(db, tmpTrans) {\n      var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n      var diff = getSchemaDiff(installedSchema, db._dbSchema);\n      return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));\n  }\n  function adjustToExistingIndexNames(db, schema, idbtrans) {\n      var storeNames = idbtrans.db.objectStoreNames;\n      for (var i = 0; i < storeNames.length; ++i) {\n          var storeName = storeNames[i];\n          var store = idbtrans.objectStore(storeName);\n          db._hasGetAll = 'getAll' in store;\n          for (var j = 0; j < store.indexNames.length; ++j) {\n              var indexName = store.indexNames[j];\n              var keyPath = store.index(indexName).keyPath;\n              var dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n              if (schema[storeName]) {\n                  var indexSpec = schema[storeName].idxByName[dexieName];\n                  if (indexSpec) {\n                      indexSpec.name = indexName;\n                      delete schema[storeName].idxByName[dexieName];\n                      schema[storeName].idxByName[indexName] = indexSpec;\n                  }\n              }\n          }\n      }\n      if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n          !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n          _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n          [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n          db._hasGetAll = false;\n      }\n  }\n  function parseIndexSyntax(primKeyAndIndexes) {\n      return primKeyAndIndexes.split(',').map(function (index, indexNum) {\n          var _a;\n          var typeSplit = index.split(':');\n          var type = (_a = typeSplit[1]) === null || _a === void 0 ? void 0 : _a.trim();\n          index = typeSplit[0].trim();\n          var name = index.replace(/([&*]|\\+\\+)/g, \"\");\n          var keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n          return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0, type);\n      });\n  }\n\n  var Version =  (function () {\n      function Version() {\n      }\n      Version.prototype._createTableSchema = function (name, primKey, indexes) {\n          return createTableSchema(name, primKey, indexes);\n      };\n      Version.prototype._parseIndexSyntax = function (primKeyAndIndexes) {\n          return parseIndexSyntax(primKeyAndIndexes);\n      };\n      Version.prototype._parseStoresSpec = function (stores, outSchema) {\n          var _this = this;\n          keys(stores).forEach(function (tableName) {\n              if (stores[tableName] !== null) {\n                  var indexes = _this._parseIndexSyntax(stores[tableName]);\n                  var primKey = indexes.shift();\n                  if (!primKey) {\n                      throw new exceptions.Schema('Invalid schema for table ' + tableName + ': ' + stores[tableName]);\n                  }\n                  primKey.unique = true;\n                  if (primKey.multi)\n                      throw new exceptions.Schema('Primary key cannot be multiEntry*');\n                  indexes.forEach(function (idx) {\n                      if (idx.auto)\n                          throw new exceptions.Schema('Only primary key can be marked as autoIncrement (++)');\n                      if (!idx.keyPath)\n                          throw new exceptions.Schema('Index must have a name and cannot be an empty string');\n                  });\n                  var tblSchema = _this._createTableSchema(tableName, primKey, indexes);\n                  outSchema[tableName] = tblSchema;\n              }\n          });\n      };\n      Version.prototype.stores = function (stores) {\n          var db = this.db;\n          this._cfg.storesSource = this._cfg.storesSource\n              ? extend(this._cfg.storesSource, stores)\n              : stores;\n          var versions = db._versions;\n          var storesSpec = {};\n          var dbschema = {};\n          versions.forEach(function (version) {\n              extend(storesSpec, version._cfg.storesSource);\n              dbschema = version._cfg.dbschema = {};\n              version._parseStoresSpec(storesSpec, dbschema);\n          });\n          db._dbSchema = dbschema;\n          removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n          setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n          db._storeNames = keys(dbschema);\n          return this;\n      };\n      Version.prototype.upgrade = function (upgradeFunction) {\n          this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n          return this;\n      };\n      return Version;\n  }());\n\n  function createVersionConstructor(db) {\n      return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n          this.db = db;\n          this._cfg = {\n              version: versionNumber,\n              storesSource: null,\n              dbschema: {},\n              tables: {},\n              contentUpgrade: null\n          };\n      });\n  }\n\n  function getDbNamesTable(indexedDB, IDBKeyRange) {\n      var dbNamesDB = indexedDB[\"_dbNamesDB\"];\n      if (!dbNamesDB) {\n          dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n              addons: [],\n              indexedDB: indexedDB,\n              IDBKeyRange: IDBKeyRange,\n          });\n          dbNamesDB.version(1).stores({ dbnames: \"name\" });\n      }\n      return dbNamesDB.table(\"dbnames\");\n  }\n  function hasDatabasesNative(indexedDB) {\n      return indexedDB && typeof indexedDB.databases === \"function\";\n  }\n  function getDatabaseNames(_a) {\n      var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n      return hasDatabasesNative(indexedDB)\n          ? Promise.resolve(indexedDB.databases()).then(function (infos) {\n              return infos\n                  .map(function (info) { return info.name; })\n                  .filter(function (name) { return name !== DBNAMES_DB; });\n          })\n          : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n  }\n  function _onDatabaseCreated(_a, name) {\n      var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n      !hasDatabasesNative(indexedDB) &&\n          name !== DBNAMES_DB &&\n          getDbNamesTable(indexedDB, IDBKeyRange).put({ name: name }).catch(nop);\n  }\n  function _onDatabaseDeleted(_a, name) {\n      var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n      !hasDatabasesNative(indexedDB) &&\n          name !== DBNAMES_DB &&\n          getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n  }\n\n  function vip(fn) {\n      return newScope(function () {\n          PSD.letThrough = true;\n          return fn();\n      });\n  }\n\n  function idbReady() {\n      var isSafari = !navigator.userAgentData &&\n          /Safari\\//.test(navigator.userAgent) &&\n          !/Chrom(e|ium)\\//.test(navigator.userAgent);\n      if (!isSafari || !indexedDB.databases)\n          return Promise.resolve();\n      var intervalId;\n      return new Promise(function (resolve) {\n          var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n          intervalId = setInterval(tryIdb, 100);\n          tryIdb();\n      }).finally(function () { return clearInterval(intervalId); });\n  }\n\n  var _a;\n  function isEmptyRange(node) {\n      return !(\"from\" in node);\n  }\n  var RangeSet = function (fromOrTree, to) {\n      if (this) {\n          extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n      }\n      else {\n          var rv = new RangeSet();\n          if (fromOrTree && (\"d\" in fromOrTree)) {\n              extend(rv, fromOrTree);\n          }\n          return rv;\n      }\n  };\n  props(RangeSet.prototype, (_a = {\n          add: function (rangeSet) {\n              mergeRanges(this, rangeSet);\n              return this;\n          },\n          addKey: function (key) {\n              addRange(this, key, key);\n              return this;\n          },\n          addKeys: function (keys) {\n              var _this = this;\n              keys.forEach(function (key) { return addRange(_this, key, key); });\n              return this;\n          },\n          hasKey: function (key) {\n              var node = getRangeSetIterator(this).next(key).value;\n              return node && cmp(node.from, key) <= 0 && cmp(node.to, key) >= 0;\n          }\n      },\n      _a[iteratorSymbol] = function () {\n          return getRangeSetIterator(this);\n      },\n      _a));\n  function addRange(target, from, to) {\n      var diff = cmp(from, to);\n      if (isNaN(diff))\n          return;\n      if (diff > 0)\n          throw RangeError();\n      if (isEmptyRange(target))\n          return extend(target, { from: from, to: to, d: 1 });\n      var left = target.l;\n      var right = target.r;\n      if (cmp(to, target.from) < 0) {\n          left\n              ? addRange(left, from, to)\n              : (target.l = { from: from, to: to, d: 1, l: null, r: null });\n          return rebalance(target);\n      }\n      if (cmp(from, target.to) > 0) {\n          right\n              ? addRange(right, from, to)\n              : (target.r = { from: from, to: to, d: 1, l: null, r: null });\n          return rebalance(target);\n      }\n      if (cmp(from, target.from) < 0) {\n          target.from = from;\n          target.l = null;\n          target.d = right ? right.d + 1 : 1;\n      }\n      if (cmp(to, target.to) > 0) {\n          target.to = to;\n          target.r = null;\n          target.d = target.l ? target.l.d + 1 : 1;\n      }\n      var rightWasCutOff = !target.r;\n      if (left && !target.l) {\n          mergeRanges(target, left);\n      }\n      if (right && rightWasCutOff) {\n          mergeRanges(target, right);\n      }\n  }\n  function mergeRanges(target, newSet) {\n      function _addRangeSet(target, _a) {\n          var from = _a.from, to = _a.to, l = _a.l, r = _a.r;\n          addRange(target, from, to);\n          if (l)\n              _addRangeSet(target, l);\n          if (r)\n              _addRangeSet(target, r);\n      }\n      if (!isEmptyRange(newSet))\n          _addRangeSet(target, newSet);\n  }\n  function rangesOverlap(rangeSet1, rangeSet2) {\n      var i1 = getRangeSetIterator(rangeSet2);\n      var nextResult1 = i1.next();\n      if (nextResult1.done)\n          return false;\n      var a = nextResult1.value;\n      var i2 = getRangeSetIterator(rangeSet1);\n      var nextResult2 = i2.next(a.from);\n      var b = nextResult2.value;\n      while (!nextResult1.done && !nextResult2.done) {\n          if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n              return true;\n          cmp(a.from, b.from) < 0\n              ? (a = (nextResult1 = i1.next(b.from)).value)\n              : (b = (nextResult2 = i2.next(a.from)).value);\n      }\n      return false;\n  }\n  function getRangeSetIterator(node) {\n      var state = isEmptyRange(node) ? null : { s: 0, n: node };\n      return {\n          next: function (key) {\n              var keyProvided = arguments.length > 0;\n              while (state) {\n                  switch (state.s) {\n                      case 0:\n                          state.s = 1;\n                          if (keyProvided) {\n                              while (state.n.l && cmp(key, state.n.from) < 0)\n                                  state = { up: state, n: state.n.l, s: 1 };\n                          }\n                          else {\n                              while (state.n.l)\n                                  state = { up: state, n: state.n.l, s: 1 };\n                          }\n                      case 1:\n                          state.s = 2;\n                          if (!keyProvided || cmp(key, state.n.to) <= 0)\n                              return { value: state.n, done: false };\n                      case 2:\n                          if (state.n.r) {\n                              state.s = 3;\n                              state = { up: state, n: state.n.r, s: 0 };\n                              continue;\n                          }\n                      case 3:\n                          state = state.up;\n                  }\n              }\n              return { done: true };\n          },\n      };\n  }\n  function rebalance(target) {\n      var _a, _b;\n      var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n      var r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n      if (r) {\n          var l = r === \"r\" ? \"l\" : \"r\";\n          var rootClone = __assign({}, target);\n          var oldRootRight = target[r];\n          target.from = oldRootRight.from;\n          target.to = oldRootRight.to;\n          target[r] = oldRootRight[r];\n          rootClone[r] = oldRootRight[l];\n          target[l] = rootClone;\n          rootClone.d = computeDepth(rootClone);\n      }\n      target.d = computeDepth(target);\n  }\n  function computeDepth(_a) {\n      var r = _a.r, l = _a.l;\n      return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n  }\n\n  function extendObservabilitySet(target, newSet) {\n      keys(newSet).forEach(function (part) {\n          if (target[part])\n              mergeRanges(target[part], newSet[part]);\n          else\n              target[part] = cloneSimpleObjectTree(newSet[part]);\n      });\n      return target;\n  }\n\n  function obsSetsOverlap(os1, os2) {\n      return os1.all || os2.all || Object.keys(os1).some(function (key) { return os2[key] && rangesOverlap(os2[key], os1[key]); });\n  }\n\n  var cache = {};\n\n  var unsignaledParts = {};\n  var isTaskEnqueued = false;\n  function signalSubscribersLazily(part, optimistic) {\n      extendObservabilitySet(unsignaledParts, part);\n      if (!isTaskEnqueued) {\n          isTaskEnqueued = true;\n          setTimeout(function () {\n              isTaskEnqueued = false;\n              var parts = unsignaledParts;\n              unsignaledParts = {};\n              signalSubscribersNow(parts, false);\n          }, 0);\n      }\n  }\n  function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {\n      if (deleteAffectedCacheEntries === void 0) { deleteAffectedCacheEntries = false; }\n      var queriesToSignal = new Set();\n      if (updatedParts.all) {\n          for (var _i = 0, _a = Object.values(cache); _i < _a.length; _i++) {\n              var tblCache = _a[_i];\n              collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n          }\n      }\n      else {\n          for (var key in updatedParts) {\n              var parts = /^idb\\:\\/\\/(.*)\\/(.*)\\//.exec(key);\n              if (parts) {\n                  var dbName = parts[1], tableName = parts[2];\n                  var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n                  if (tblCache)\n                      collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n              }\n          }\n      }\n      queriesToSignal.forEach(function (requery) { return requery(); });\n  }\n  function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {\n      var updatedEntryLists = [];\n      for (var _i = 0, _a = Object.entries(tblCache.queries.query); _i < _a.length; _i++) {\n          var _b = _a[_i], indexName = _b[0], entries = _b[1];\n          var filteredEntries = [];\n          for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {\n              var entry = entries_1[_c];\n              if (obsSetsOverlap(updatedParts, entry.obsSet)) {\n                  entry.subscribers.forEach(function (requery) { return outQueriesToSignal.add(requery); });\n              }\n              else if (deleteAffectedCacheEntries) {\n                  filteredEntries.push(entry);\n              }\n          }\n          if (deleteAffectedCacheEntries)\n              updatedEntryLists.push([indexName, filteredEntries]);\n      }\n      if (deleteAffectedCacheEntries) {\n          for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {\n              var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];\n              tblCache.queries.query[indexName] = filteredEntries;\n          }\n      }\n  }\n\n  function dexieOpen(db) {\n      var state = db._state;\n      var indexedDB = db._deps.indexedDB;\n      if (state.isBeingOpened || db.idbdb)\n          return state.dbReadyPromise.then(function () { return state.dbOpenError ?\n              rejection(state.dbOpenError) :\n              db; });\n      state.isBeingOpened = true;\n      state.dbOpenError = null;\n      state.openComplete = false;\n      var openCanceller = state.openCanceller;\n      var nativeVerToOpen = Math.round(db.verno * 10);\n      var schemaPatchMode = false;\n      function throwIfCancelled() {\n          if (state.openCanceller !== openCanceller)\n              throw new exceptions.DatabaseClosed('db.open() was cancelled');\n      }\n      var resolveDbReady = state.dbReadyResolve,\n      upgradeTransaction = null, wasCreated = false;\n      var tryOpenDB = function () { return new DexiePromise(function (resolve, reject) {\n          throwIfCancelled();\n          if (!indexedDB)\n              throw new exceptions.MissingAPI();\n          var dbName = db.name;\n          var req = state.autoSchema || !nativeVerToOpen ?\n              indexedDB.open(dbName) :\n              indexedDB.open(dbName, nativeVerToOpen);\n          if (!req)\n              throw new exceptions.MissingAPI();\n          req.onerror = eventRejectHandler(reject);\n          req.onblocked = wrap(db._fireOnBlocked);\n          req.onupgradeneeded = wrap(function (e) {\n              upgradeTransaction = req.transaction;\n              if (state.autoSchema && !db._options.allowEmptyDB) {\n                  req.onerror = preventDefault;\n                  upgradeTransaction.abort();\n                  req.result.close();\n                  var delreq = indexedDB.deleteDatabase(dbName);\n                  delreq.onsuccess = delreq.onerror = wrap(function () {\n                      reject(new exceptions.NoSuchDatabase(\"Database \".concat(dbName, \" doesnt exist\")));\n                  });\n              }\n              else {\n                  upgradeTransaction.onerror = eventRejectHandler(reject);\n                  var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                  wasCreated = oldVer < 1;\n                  db.idbdb = req.result;\n                  if (schemaPatchMode) {\n                      patchCurrentVersion(db, upgradeTransaction);\n                  }\n                  runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n              }\n          }, reject);\n          req.onsuccess = wrap(function () {\n              upgradeTransaction = null;\n              var idbdb = db.idbdb = req.result;\n              var objectStoreNames = slice(idbdb.objectStoreNames);\n              if (objectStoreNames.length > 0)\n                  try {\n                      var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                      if (state.autoSchema)\n                          readGlobalSchema(db, idbdb, tmpTrans);\n                      else {\n                          adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                          if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {\n                              console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.\");\n                              idbdb.close();\n                              nativeVerToOpen = idbdb.version + 1;\n                              schemaPatchMode = true;\n                              return resolve(tryOpenDB());\n                          }\n                      }\n                      generateMiddlewareStacks(db, tmpTrans);\n                  }\n                  catch (e) {\n                  }\n              connections.push(db);\n              idbdb.onversionchange = wrap(function (ev) {\n                  state.vcFired = true;\n                  db.on(\"versionchange\").fire(ev);\n              });\n              idbdb.onclose = wrap(function () {\n                  db.close({ disableAutoOpen: false });\n              });\n              if (wasCreated)\n                  _onDatabaseCreated(db._deps, dbName);\n              resolve();\n          }, reject);\n      }).catch(function (err) {\n          switch (err === null || err === void 0 ? void 0 : err.name) {\n              case \"UnknownError\":\n                  if (state.PR1398_maxLoop > 0) {\n                      state.PR1398_maxLoop--;\n                      console.warn('Dexie: Workaround for Chrome UnknownError on open()');\n                      return tryOpenDB();\n                  }\n                  break;\n              case \"VersionError\":\n                  if (nativeVerToOpen > 0) {\n                      nativeVerToOpen = 0;\n                      return tryOpenDB();\n                  }\n                  break;\n          }\n          return DexiePromise.reject(err);\n      }); };\n      return DexiePromise.race([\n          openCanceller,\n          (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n      ]).then(function () {\n          throwIfCancelled();\n          state.onReadyBeingFired = [];\n          return DexiePromise.resolve(vip(function () { return db.on.ready.fire(db.vip); })).then(function fireRemainders() {\n              if (state.onReadyBeingFired.length > 0) {\n                  var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);\n                  state.onReadyBeingFired = [];\n                  return DexiePromise.resolve(vip(function () { return remainders_1(db.vip); })).then(fireRemainders);\n              }\n          });\n      }).finally(function () {\n          if (state.openCanceller === openCanceller) {\n              state.onReadyBeingFired = null;\n              state.isBeingOpened = false;\n          }\n      }).catch(function (err) {\n          state.dbOpenError = err;\n          try {\n              upgradeTransaction && upgradeTransaction.abort();\n          }\n          catch (_a) { }\n          if (openCanceller === state.openCanceller) {\n              db._close();\n          }\n          return rejection(err);\n      }).finally(function () {\n          state.openComplete = true;\n          resolveDbReady();\n      }).then(function () {\n          if (wasCreated) {\n              var everything_1 = {};\n              db.tables.forEach(function (table) {\n                  table.schema.indexes.forEach(function (idx) {\n                      if (idx.name)\n                          everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\").concat(idx.name)] = new RangeSet(-Infinity, [[[]]]);\n                  });\n                  everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\")] = everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/:dels\")] = new RangeSet(-Infinity, [[[]]]);\n              });\n              globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);\n              signalSubscribersNow(everything_1, true);\n          }\n          return db;\n      });\n  }\n\n  function awaitIterator(iterator) {\n      var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);\n      function step(getNext) {\n          return function (val) {\n              var next = getNext(val), value = next.value;\n              return next.done ? value :\n                  (!value || typeof value.then !== 'function' ?\n                      isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                      value.then(onSuccess, onError));\n          };\n      }\n      return step(callNext)();\n  }\n\n  function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n      var i = arguments.length;\n      if (i < 2)\n          throw new exceptions.InvalidArgument(\"Too few arguments\");\n      var args = new Array(i - 1);\n      while (--i)\n          args[i - 1] = arguments[i];\n      scopeFunc = args.pop();\n      var tables = flatten(args);\n      return [mode, tables, scopeFunc];\n  }\n  function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n      return DexiePromise.resolve().then(function () {\n          var transless = PSD.transless || PSD;\n          var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n          trans.explicit = true;\n          var zoneProps = {\n              trans: trans,\n              transless: transless\n          };\n          if (parentTransaction) {\n              trans.idbtrans = parentTransaction.idbtrans;\n          }\n          else {\n              try {\n                  trans.create();\n                  trans.idbtrans._explicit = true;\n                  db._state.PR1398_maxLoop = 3;\n              }\n              catch (ex) {\n                  if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                      console.warn('Dexie: Need to reopen db');\n                      db.close({ disableAutoOpen: false });\n                      return db.open().then(function () { return enterTransactionScope(db, mode, storeNames, null, scopeFunc); });\n                  }\n                  return rejection(ex);\n              }\n          }\n          var scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n          if (scopeFuncIsAsync) {\n              incrementExpectedAwaits();\n          }\n          var returnValue;\n          var promiseFollowed = DexiePromise.follow(function () {\n              returnValue = scopeFunc.call(trans, trans);\n              if (returnValue) {\n                  if (scopeFuncIsAsync) {\n                      var decrementor = decrementExpectedAwaits.bind(null, null);\n                      returnValue.then(decrementor, decrementor);\n                  }\n                  else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                      returnValue = awaitIterator(returnValue);\n                  }\n              }\n          }, zoneProps);\n          return (returnValue && typeof returnValue.then === 'function' ?\n              DexiePromise.resolve(returnValue).then(function (x) { return trans.active ?\n                  x\n                  : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")); })\n              : promiseFollowed.then(function () { return returnValue; })).then(function (x) {\n              if (parentTransaction)\n                  trans._resolve();\n              return trans._completion.then(function () { return x; });\n          }).catch(function (e) {\n              trans._reject(e);\n              return rejection(e);\n          });\n      });\n  }\n\n  function pad(a, value, count) {\n      var result = isArray(a) ? a.slice() : [a];\n      for (var i = 0; i < count; ++i)\n          result.push(value);\n      return result;\n  }\n  function createVirtualIndexMiddleware(down) {\n      return __assign(__assign({}, down), { table: function (tableName) {\n              var table = down.table(tableName);\n              var schema = table.schema;\n              var indexLookup = {};\n              var allVirtualIndexes = [];\n              function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                  var keyPathAlias = getKeyPathAlias(keyPath);\n                  var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                  var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                  var isVirtual = keyTail > 0;\n                  var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual\n                          ? \"\".concat(keyPathAlias, \"(virtual-from:\").concat(lowLevelIndex.name, \")\")\n                          : lowLevelIndex.name, lowLevelIndex: lowLevelIndex, isVirtual: isVirtual, keyTail: keyTail, keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });\n                  indexList.push(virtualIndex);\n                  if (!virtualIndex.isPrimaryKey) {\n                      allVirtualIndexes.push(virtualIndex);\n                  }\n                  if (keyLength > 1) {\n                      var virtualKeyPath = keyLength === 2 ?\n                          keyPath[0] :\n                          keyPath.slice(0, keyLength - 1);\n                      addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                  }\n                  indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });\n                  return virtualIndex;\n              }\n              var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n              indexLookup[\":id\"] = [primaryKey];\n              for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {\n                  var index = _a[_i];\n                  addVirtualIndexes(index.keyPath, 0, index);\n              }\n              function findBestIndex(keyPath) {\n                  var result = indexLookup[getKeyPathAlias(keyPath)];\n                  return result && result[0];\n              }\n              function translateRange(range, keyTail) {\n                  return {\n                      type: range.type === 1  ?\n                          2  :\n                          range.type,\n                      lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                      lowerOpen: true,\n                      upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                      upperOpen: true\n                  };\n              }\n              function translateRequest(req) {\n                  var index = req.query.index;\n                  return index.isVirtual ? __assign(__assign({}, req), { query: {\n                          index: index.lowLevelIndex,\n                          range: translateRange(req.query.range, index.keyTail)\n                      } }) : req;\n              }\n              var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {\n                      return table.count(translateRequest(req));\n                  }, query: function (req) {\n                      return table.query(translateRequest(req));\n                  }, openCursor: function (req) {\n                      var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;\n                      if (!isVirtual)\n                          return table.openCursor(req);\n                      function createVirtualCursor(cursor) {\n                          function _continue(key) {\n                              key != null ?\n                                  cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                  req.unique ?\n                                      cursor.continue(cursor.key.slice(0, keyLength)\n                                          .concat(req.reverse\n                                          ? down.MIN_KEY\n                                          : down.MAX_KEY, keyTail)) :\n                                      cursor.continue();\n                          }\n                          var virtualCursor = Object.create(cursor, {\n                              continue: { value: _continue },\n                              continuePrimaryKey: {\n                                  value: function (key, primaryKey) {\n                                      cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                  }\n                              },\n                              primaryKey: {\n                                  get: function () {\n                                      return cursor.primaryKey;\n                                  }\n                              },\n                              key: {\n                                  get: function () {\n                                      var key = cursor.key;\n                                      return keyLength === 1 ?\n                                          key[0] :\n                                          key.slice(0, keyLength);\n                                  }\n                              },\n                              value: {\n                                  get: function () {\n                                      return cursor.value;\n                                  }\n                              }\n                          });\n                          return virtualCursor;\n                      }\n                      return table.openCursor(translateRequest(req))\n                          .then(function (cursor) { return cursor && createVirtualCursor(cursor); });\n                  } });\n              return result;\n          } });\n  }\n  var virtualIndexMiddleware = {\n      stack: \"dbcore\",\n      name: \"VirtualIndexMiddleware\",\n      level: 1,\n      create: createVirtualIndexMiddleware\n  };\n\n  function getObjectDiff(a, b, rv, prfx) {\n      rv = rv || {};\n      prfx = prfx || '';\n      keys(a).forEach(function (prop) {\n          if (!hasOwn(b, prop)) {\n              rv[prfx + prop] = undefined;\n          }\n          else {\n              var ap = a[prop], bp = b[prop];\n              if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                  var apTypeName = toStringTag(ap);\n                  var bpTypeName = toStringTag(bp);\n                  if (apTypeName !== bpTypeName) {\n                      rv[prfx + prop] = b[prop];\n                  }\n                  else if (apTypeName === 'Object') {\n                      getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                  }\n                  else if (ap !== bp) {\n                      rv[prfx + prop] = b[prop];\n                  }\n              }\n              else if (ap !== bp)\n                  rv[prfx + prop] = b[prop];\n          }\n      });\n      keys(b).forEach(function (prop) {\n          if (!hasOwn(a, prop)) {\n              rv[prfx + prop] = b[prop];\n          }\n      });\n      return rv;\n  }\n\n  function getEffectiveKeys(primaryKey, req) {\n      if (req.type === 'delete')\n          return req.keys;\n      return req.keys || req.values.map(primaryKey.extractKey);\n  }\n\n  var hooksMiddleware = {\n      stack: \"dbcore\",\n      name: \"HooksMiddleware\",\n      level: 2,\n      create: function (downCore) { return (__assign(__assign({}, downCore), { table: function (tableName) {\n              var downTable = downCore.table(tableName);\n              var primaryKey = downTable.schema.primaryKey;\n              var tableMiddleware = __assign(__assign({}, downTable), { mutate: function (req) {\n                      var dxTrans = PSD.trans;\n                      var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;\n                      switch (req.type) {\n                          case 'add':\n                              if (creating.fire === nop)\n                                  break;\n                              return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                          case 'put':\n                              if (creating.fire === nop && updating.fire === nop)\n                                  break;\n                              return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                          case 'delete':\n                              if (deleting.fire === nop)\n                                  break;\n                              return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                          case 'deleteRange':\n                              if (deleting.fire === nop)\n                                  break;\n                              return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);\n                      }\n                      return downTable.mutate(req);\n                      function addPutOrDelete(req) {\n                          var dxTrans = PSD.trans;\n                          var keys = req.keys || getEffectiveKeys(primaryKey, req);\n                          if (!keys)\n                              throw new Error(\"Keys missing\");\n                          req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys }) : __assign({}, req);\n                          if (req.type !== 'delete')\n                              req.values = __spreadArray([], req.values, true);\n                          if (req.keys)\n                              req.keys = __spreadArray([], req.keys, true);\n                          return getExistingValues(downTable, req, keys).then(function (existingValues) {\n                              var contexts = keys.map(function (key, i) {\n                                  var existingValue = existingValues[i];\n                                  var ctx = { onerror: null, onsuccess: null };\n                                  if (req.type === 'delete') {\n                                      deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                  }\n                                  else if (req.type === 'add' || existingValue === undefined) {\n                                      var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                      if (key == null && generatedPrimaryKey != null) {\n                                          key = generatedPrimaryKey;\n                                          req.keys[i] = key;\n                                          if (!primaryKey.outbound) {\n                                              setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                          }\n                                      }\n                                  }\n                                  else {\n                                      var objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                      var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                      if (additionalChanges_1) {\n                                          var requestedValue_1 = req.values[i];\n                                          Object.keys(additionalChanges_1).forEach(function (keyPath) {\n                                              if (hasOwn(requestedValue_1, keyPath)) {\n                                                  requestedValue_1[keyPath] = additionalChanges_1[keyPath];\n                                              }\n                                              else {\n                                                  setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);\n                                              }\n                                          });\n                                      }\n                                  }\n                                  return ctx;\n                              });\n                              return downTable.mutate(req).then(function (_a) {\n                                  var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;\n                                  for (var i = 0; i < keys.length; ++i) {\n                                      var primKey = results ? results[i] : keys[i];\n                                      var ctx = contexts[i];\n                                      if (primKey == null) {\n                                          ctx.onerror && ctx.onerror(failures[i]);\n                                      }\n                                      else {\n                                          ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                              req.values[i] :\n                                              primKey\n                                          );\n                                      }\n                                  }\n                                  return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };\n                              }).catch(function (error) {\n                                  contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });\n                                  return Promise.reject(error);\n                              });\n                          });\n                      }\n                      function deleteRange(req) {\n                          return deleteNextChunk(req.trans, req.range, 10000);\n                      }\n                      function deleteNextChunk(trans, range, limit) {\n                          return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })\n                              .then(function (_a) {\n                              var result = _a.result;\n                              return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {\n                                  if (res.numFailures > 0)\n                                      return Promise.reject(res.failures[0]);\n                                  if (result.length < limit) {\n                                      return { failures: [], numFailures: 0, lastResult: undefined };\n                                  }\n                                  else {\n                                      return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);\n                                  }\n                              });\n                          });\n                      }\n                  } });\n              return tableMiddleware;\n          } })); }\n  };\n  function getExistingValues(table, req, effectiveKeys) {\n      return req.type === \"add\"\n          ? Promise.resolve([])\n          : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n  }\n\n  function getFromTransactionCache(keys, cache, clone) {\n      try {\n          if (!cache)\n              return null;\n          if (cache.keys.length < keys.length)\n              return null;\n          var result = [];\n          for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n              if (cmp(cache.keys[i], keys[j]) !== 0)\n                  continue;\n              result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n              ++j;\n          }\n          return result.length === keys.length ? result : null;\n      }\n      catch (_a) {\n          return null;\n      }\n  }\n  var cacheExistingValuesMiddleware = {\n      stack: \"dbcore\",\n      level: -1,\n      create: function (core) {\n          return {\n              table: function (tableName) {\n                  var table = core.table(tableName);\n                  return __assign(__assign({}, table), { getMany: function (req) {\n                          if (!req.cache) {\n                              return table.getMany(req);\n                          }\n                          var cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                          if (cachedResult) {\n                              return DexiePromise.resolve(cachedResult);\n                          }\n                          return table.getMany(req).then(function (res) {\n                              req.trans[\"_cache\"] = {\n                                  keys: req.keys,\n                                  values: req.cache === \"clone\" ? deepClone(res) : res,\n                              };\n                              return res;\n                          });\n                      }, mutate: function (req) {\n                          if (req.type !== \"add\")\n                              req.trans[\"_cache\"] = null;\n                          return table.mutate(req);\n                      } });\n              },\n          };\n      },\n  };\n\n  function isCachableContext(ctx, table) {\n      return (ctx.trans.mode === 'readonly' &&\n          !!ctx.subscr &&\n          !ctx.trans.explicit &&\n          ctx.trans.db._options.cache !== 'disabled' &&\n          !table.schema.primaryKey.outbound);\n  }\n\n  function isCachableRequest(type, req) {\n      switch (type) {\n          case 'query':\n              return req.values && !req.unique;\n          case 'get':\n              return false;\n          case 'getMany':\n              return false;\n          case 'count':\n              return false;\n          case 'openCursor':\n              return false;\n      }\n  }\n\n  var observabilityMiddleware = {\n      stack: \"dbcore\",\n      level: 0,\n      name: \"Observability\",\n      create: function (core) {\n          var dbName = core.schema.name;\n          var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n          return __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n                  if (PSD.subscr && mode !== 'readonly') {\n                      throw new exceptions.ReadOnly(\"Readwrite transaction in liveQuery context. Querier source: \".concat(PSD.querier));\n                  }\n                  return core.transaction(stores, mode, options);\n              }, table: function (tableName) {\n                  var table = core.table(tableName);\n                  var schema = table.schema;\n                  var primaryKey = schema.primaryKey, indexes = schema.indexes;\n                  var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;\n                  var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function (index) { return index.compound && index.keyPath.includes(primaryKey.keyPath); });\n                  var tableClone = __assign(__assign({}, table), { mutate: function (req) {\n                          var _a, _b;\n                          var trans = req.trans;\n                          var mutatedParts = req.mutatedParts || (req.mutatedParts = {});\n                          var getRangeSet = function (indexName) {\n                              var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n                              return (mutatedParts[part] ||\n                                  (mutatedParts[part] = new RangeSet()));\n                          };\n                          var pkRangeSet = getRangeSet(\"\");\n                          var delsRangeSet = getRangeSet(\":dels\");\n                          var type = req.type;\n                          var _c = req.type === \"deleteRange\"\n                              ? [req.range]\n                              : req.type === \"delete\"\n                                  ? [req.keys]\n                                  : req.values.length < 50\n                                      ? [getEffectiveKeys(primaryKey, req).filter(function (id) { return id; }), req.values]\n                                      : [], keys = _c[0], newObjs = _c[1];\n                          var oldCache = req.trans[\"_cache\"];\n                          if (isArray(keys)) {\n                              pkRangeSet.addKeys(keys);\n                              var oldObjs = type === 'delete' || keys.length === newObjs.length ? getFromTransactionCache(keys, oldCache) : null;\n                              if (!oldObjs) {\n                                  delsRangeSet.addKeys(keys);\n                              }\n                              if (oldObjs || newObjs) {\n                                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                              }\n                          }\n                          else if (keys) {\n                              var range = {\n                                  from: (_a = keys.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY,\n                                  to: (_b = keys.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY\n                              };\n                              delsRangeSet.add(range);\n                              pkRangeSet.add(range);\n                          }\n                          else {\n                              pkRangeSet.add(FULL_RANGE);\n                              delsRangeSet.add(FULL_RANGE);\n                              schema.indexes.forEach(function (idx) { return getRangeSet(idx.name).add(FULL_RANGE); });\n                          }\n                          return table.mutate(req).then(function (res) {\n                              if (keys && (req.type === 'add' || req.type === 'put')) {\n                                  pkRangeSet.addKeys(res.results);\n                                  if (indexesWithAutoIncPK) {\n                                      indexesWithAutoIncPK.forEach(function (idx) {\n                                          var idxVals = req.values.map(function (v) { return idx.extractKey(v); });\n                                          var pkPos = idx.keyPath.findIndex(function (prop) { return prop === primaryKey.keyPath; });\n                                          for (var i = 0, len = res.results.length; i < len; ++i) {\n                                              idxVals[i][pkPos] = res.results[i];\n                                          }\n                                          getRangeSet(idx.name).addKeys(idxVals);\n                                      });\n                                  }\n                              }\n                              trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);\n                              return res;\n                          });\n                      } });\n                  var getRange = function (_a) {\n                      var _b, _c;\n                      var _d = _a.query, index = _d.index, range = _d.range;\n                      return [\n                          index,\n                          new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY),\n                      ];\n                  };\n                  var readSubscribers = {\n                      get: function (req) { return [primaryKey, new RangeSet(req.key)]; },\n                      getMany: function (req) { return [primaryKey, new RangeSet().addKeys(req.keys)]; },\n                      count: getRange,\n                      query: getRange,\n                      openCursor: getRange,\n                  };\n                  keys(readSubscribers).forEach(function (method) {\n                      tableClone[method] = function (req) {\n                          var subscr = PSD.subscr;\n                          var isLiveQuery = !!subscr;\n                          var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);\n                          var obsSet = cachable\n                              ? req.obsSet = {}\n                              : subscr;\n                          if (isLiveQuery) {\n                              var getRangeSet = function (indexName) {\n                                  var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n                                  return (obsSet[part] ||\n                                      (obsSet[part] = new RangeSet()));\n                              };\n                              var pkRangeSet_1 = getRangeSet(\"\");\n                              var delsRangeSet_1 = getRangeSet(\":dels\");\n                              var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];\n                              if (method === 'query' && queriedIndex.isPrimaryKey && !req.values) {\n                                  delsRangeSet_1.add(queriedRanges);\n                              }\n                              else {\n                                  getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                              }\n                              if (!queriedIndex.isPrimaryKey) {\n                                  if (method === \"count\") {\n                                      delsRangeSet_1.add(FULL_RANGE);\n                                  }\n                                  else {\n                                      var keysPromise_1 = method === \"query\" &&\n                                          outbound &&\n                                          req.values &&\n                                          table.query(__assign(__assign({}, req), { values: false }));\n                                      return table[method].apply(this, arguments).then(function (res) {\n                                          if (method === \"query\") {\n                                              if (outbound && req.values) {\n                                                  return keysPromise_1.then(function (_a) {\n                                                      var resultingKeys = _a.result;\n                                                      pkRangeSet_1.addKeys(resultingKeys);\n                                                      return res;\n                                                  });\n                                              }\n                                              var pKeys = req.values\n                                                  ? res.result.map(extractKey)\n                                                  : res.result;\n                                              if (req.values) {\n                                                  pkRangeSet_1.addKeys(pKeys);\n                                              }\n                                              else {\n                                                  delsRangeSet_1.addKeys(pKeys);\n                                              }\n                                          }\n                                          else if (method === \"openCursor\") {\n                                              var cursor_1 = res;\n                                              var wantValues_1 = req.values;\n                                              return (cursor_1 &&\n                                                  Object.create(cursor_1, {\n                                                      key: {\n                                                          get: function () {\n                                                              delsRangeSet_1.addKey(cursor_1.primaryKey);\n                                                              return cursor_1.key;\n                                                          },\n                                                      },\n                                                      primaryKey: {\n                                                          get: function () {\n                                                              var pkey = cursor_1.primaryKey;\n                                                              delsRangeSet_1.addKey(pkey);\n                                                              return pkey;\n                                                          },\n                                                      },\n                                                      value: {\n                                                          get: function () {\n                                                              wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);\n                                                              return cursor_1.value;\n                                                          },\n                                                      },\n                                                  }));\n                                          }\n                                          return res;\n                                      });\n                                  }\n                              }\n                          }\n                          return table[method].apply(this, arguments);\n                      };\n                  });\n                  return tableClone;\n              } });\n      },\n  };\n  function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n      function addAffectedIndex(ix) {\n          var rangeSet = getRangeSet(ix.name || \"\");\n          function extractKey(obj) {\n              return obj != null ? ix.extractKey(obj) : null;\n          }\n          var addKeyOrKeys = function (key) { return ix.multiEntry && isArray(key)\n              ? key.forEach(function (key) { return rangeSet.addKey(key); })\n              : rangeSet.addKey(key); };\n          (oldObjs || newObjs).forEach(function (_, i) {\n              var oldKey = oldObjs && extractKey(oldObjs[i]);\n              var newKey = newObjs && extractKey(newObjs[i]);\n              if (cmp(oldKey, newKey) !== 0) {\n                  if (oldKey != null)\n                      addKeyOrKeys(oldKey);\n                  if (newKey != null)\n                      addKeyOrKeys(newKey);\n              }\n          });\n      }\n      schema.indexes.forEach(addAffectedIndex);\n  }\n\n  function adjustOptimisticFromFailures(tblCache, req, res) {\n      if (res.numFailures === 0)\n          return req;\n      if (req.type === 'deleteRange') {\n          return null;\n      }\n      var numBulkOps = req.keys\n          ? req.keys.length\n          : 'values' in req && req.values\n              ? req.values.length\n              : 1;\n      if (res.numFailures === numBulkOps) {\n          return null;\n      }\n      var clone = __assign({}, req);\n      if (isArray(clone.keys)) {\n          clone.keys = clone.keys.filter(function (_, i) { return !(i in res.failures); });\n      }\n      if ('values' in clone && isArray(clone.values)) {\n          clone.values = clone.values.filter(function (_, i) { return !(i in res.failures); });\n      }\n      return clone;\n  }\n\n  function isAboveLower(key, range) {\n      return range.lower === undefined\n          ? true\n          : range.lowerOpen\n              ? cmp(key, range.lower) > 0\n              : cmp(key, range.lower) >= 0;\n  }\n  function isBelowUpper(key, range) {\n      return range.upper === undefined\n          ? true\n          : range.upperOpen\n              ? cmp(key, range.upper) < 0\n              : cmp(key, range.upper) <= 0;\n  }\n  function isWithinRange(key, range) {\n      return isAboveLower(key, range) && isBelowUpper(key, range);\n  }\n\n  function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {\n      if (!ops || ops.length === 0)\n          return result;\n      var index = req.query.index;\n      var multiEntry = index.multiEntry;\n      var queryRange = req.query.range;\n      var primaryKey = table.schema.primaryKey;\n      var extractPrimKey = primaryKey.extractKey;\n      var extractIndex = index.extractKey;\n      var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;\n      var finalResult = ops.reduce(function (result, op) {\n          var modifedResult = result;\n          var includedValues = [];\n          if (op.type === 'add' || op.type === 'put') {\n              var includedPKs = new RangeSet();\n              for (var i = op.values.length - 1; i >= 0; --i) {\n                  var value = op.values[i];\n                  var pk = extractPrimKey(value);\n                  if (includedPKs.hasKey(pk))\n                      continue;\n                  var key = extractIndex(value);\n                  if (multiEntry && isArray(key)\n                      ? key.some(function (k) { return isWithinRange(k, queryRange); })\n                      : isWithinRange(key, queryRange)) {\n                      includedPKs.addKey(pk);\n                      includedValues.push(value);\n                  }\n              }\n          }\n          switch (op.type) {\n              case 'add': {\n                  var existingKeys_1 = new RangeSet().addKeys(req.values ? result.map(function (v) { return extractPrimKey(v); }) : result);\n                  modifedResult = result.concat(req.values\n                      ? includedValues.filter(function (v) {\n                          var key = extractPrimKey(v);\n                          if (existingKeys_1.hasKey(key))\n                              return false;\n                          existingKeys_1.addKey(key);\n                          return true;\n                      })\n                      : includedValues\n                          .map(function (v) { return extractPrimKey(v); })\n                          .filter(function (k) {\n                          if (existingKeys_1.hasKey(k))\n                              return false;\n                          existingKeys_1.addKey(k);\n                          return true;\n                      }));\n                  break;\n              }\n              case 'put': {\n                  var keySet_1 = new RangeSet().addKeys(op.values.map(function (v) { return extractPrimKey(v); }));\n                  modifedResult = result\n                      .filter(\n                  function (item) { return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item); })\n                      .concat(\n                  req.values\n                      ? includedValues\n                      : includedValues.map(function (v) { return extractPrimKey(v); }));\n                  break;\n              }\n              case 'delete':\n                  var keysToDelete_1 = new RangeSet().addKeys(op.keys);\n                  modifedResult = result.filter(function (item) {\n                      return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);\n                  });\n                  break;\n              case 'deleteRange':\n                  var range_1 = op.range;\n                  modifedResult = result.filter(function (item) { return !isWithinRange(extractPrimKey(item), range_1); });\n                  break;\n          }\n          return modifedResult;\n      }, result);\n      if (finalResult === result)\n          return result;\n      finalResult.sort(function (a, b) {\n          return cmp(extractLowLevelIndex(a), extractLowLevelIndex(b)) ||\n              cmp(extractPrimKey(a), extractPrimKey(b));\n      });\n      if (req.limit && req.limit < Infinity) {\n          if (finalResult.length > req.limit) {\n              finalResult.length = req.limit;\n          }\n          else if (result.length === req.limit && finalResult.length < req.limit) {\n              cacheEntry.dirty = true;\n          }\n      }\n      return immutable ? Object.freeze(finalResult) : finalResult;\n  }\n\n  function areRangesEqual(r1, r2) {\n      return (cmp(r1.lower, r2.lower) === 0 &&\n          cmp(r1.upper, r2.upper) === 0 &&\n          !!r1.lowerOpen === !!r2.lowerOpen &&\n          !!r1.upperOpen === !!r2.upperOpen);\n  }\n\n  function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {\n      if (lower1 === undefined)\n          return lower2 !== undefined ? -1 : 0;\n      if (lower2 === undefined)\n          return 1;\n      var c = cmp(lower1, lower2);\n      if (c === 0) {\n          if (lowerOpen1 && lowerOpen2)\n              return 0;\n          if (lowerOpen1)\n              return 1;\n          if (lowerOpen2)\n              return -1;\n      }\n      return c;\n  }\n  function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {\n      if (upper1 === undefined)\n          return upper2 !== undefined ? 1 : 0;\n      if (upper2 === undefined)\n          return -1;\n      var c = cmp(upper1, upper2);\n      if (c === 0) {\n          if (upperOpen1 && upperOpen2)\n              return 0;\n          if (upperOpen1)\n              return -1;\n          if (upperOpen2)\n              return 1;\n      }\n      return c;\n  }\n  function isSuperRange(r1, r2) {\n      return (compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 &&\n          compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0);\n  }\n\n  function findCompatibleQuery(dbName, tableName, type, req) {\n      var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n      if (!tblCache)\n          return [];\n      var queries = tblCache.queries[type];\n      if (!queries)\n          return [null, false, tblCache, null];\n      var indexName = req.query ? req.query.index.name : null;\n      var entries = queries[indexName || ''];\n      if (!entries)\n          return [null, false, tblCache, null];\n      switch (type) {\n          case 'query':\n              var equalEntry = entries.find(function (entry) {\n                  return entry.req.limit === req.limit &&\n                      entry.req.values === req.values &&\n                      areRangesEqual(entry.req.query.range, req.query.range);\n              });\n              if (equalEntry)\n                  return [\n                      equalEntry,\n                      true,\n                      tblCache,\n                      entries,\n                  ];\n              var superEntry = entries.find(function (entry) {\n                  var limit = 'limit' in entry.req ? entry.req.limit : Infinity;\n                  return (limit >= req.limit &&\n                      (req.values ? entry.req.values : true) &&\n                      isSuperRange(entry.req.query.range, req.query.range));\n              });\n              return [superEntry, false, tblCache, entries];\n          case 'count':\n              var countQuery = entries.find(function (entry) {\n                  return areRangesEqual(entry.req.query.range, req.query.range);\n              });\n              return [countQuery, !!countQuery, tblCache, entries];\n      }\n  }\n\n  function subscribeToCacheEntry(cacheEntry, container, requery, signal) {\n      cacheEntry.subscribers.add(requery);\n      signal.addEventListener(\"abort\", function () {\n          cacheEntry.subscribers.delete(requery);\n          if (cacheEntry.subscribers.size === 0) {\n              enqueForDeletion(cacheEntry, container);\n          }\n      });\n  }\n  function enqueForDeletion(cacheEntry, container) {\n      setTimeout(function () {\n          if (cacheEntry.subscribers.size === 0) {\n              delArrayItem(container, cacheEntry);\n          }\n      }, 3000);\n  }\n\n  var cacheMiddleware = {\n      stack: 'dbcore',\n      level: 0,\n      name: 'Cache',\n      create: function (core) {\n          var dbName = core.schema.name;\n          var coreMW = __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n                  var idbtrans = core.transaction(stores, mode, options);\n                  if (mode === 'readwrite') {\n                      var ac_1 = new AbortController();\n                      var signal = ac_1.signal;\n                      var endTransaction = function (wasCommitted) { return function () {\n                          ac_1.abort();\n                          if (mode === 'readwrite') {\n                              var affectedSubscribers_1 = new Set();\n                              for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {\n                                  var storeName = stores_1[_i];\n                                  var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(storeName)];\n                                  if (tblCache) {\n                                      var table = core.table(storeName);\n                                      var ops = tblCache.optimisticOps.filter(function (op) { return op.trans === idbtrans; });\n                                      if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {\n                                          for (var _a = 0, _b = Object.values(tblCache.queries.query); _a < _b.length; _a++) {\n                                              var entries = _b[_a];\n                                              for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {\n                                                  var entry = _d[_c];\n                                                  if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {\n                                                      delArrayItem(entries, entry);\n                                                      entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                  }\n                                              }\n                                          }\n                                      }\n                                      else if (ops.length > 0) {\n                                          tblCache.optimisticOps = tblCache.optimisticOps.filter(function (op) { return op.trans !== idbtrans; });\n                                          for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {\n                                              var entries = _f[_e];\n                                              for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {\n                                                  var entry = _h[_g];\n                                                  if (entry.res != null &&\n                                                      idbtrans.mutatedParts\n  ) {\n                                                      if (wasCommitted && !entry.dirty) {\n                                                          var freezeResults = Object.isFrozen(entry.res);\n                                                          var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);\n                                                          if (entry.dirty) {\n                                                              delArrayItem(entries, entry);\n                                                              entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                          }\n                                                          else if (modRes !== entry.res) {\n                                                              entry.res = modRes;\n                                                              entry.promise = DexiePromise.resolve({ result: modRes });\n                                                          }\n                                                      }\n                                                      else {\n                                                          if (entry.dirty) {\n                                                              delArrayItem(entries, entry);\n                                                          }\n                                                          entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                      }\n                                                  }\n                                              }\n                                          }\n                                      }\n                                  }\n                              }\n                              affectedSubscribers_1.forEach(function (requery) { return requery(); });\n                          }\n                      }; };\n                      idbtrans.addEventListener('abort', endTransaction(false), {\n                          signal: signal,\n                      });\n                      idbtrans.addEventListener('error', endTransaction(false), {\n                          signal: signal,\n                      });\n                      idbtrans.addEventListener('complete', endTransaction(true), {\n                          signal: signal,\n                      });\n                  }\n                  return idbtrans;\n              }, table: function (tableName) {\n                  var downTable = core.table(tableName);\n                  var primKey = downTable.schema.primaryKey;\n                  var tableMW = __assign(__assign({}, downTable), { mutate: function (req) {\n                          var trans = PSD.trans;\n                          if (primKey.outbound ||\n                              trans.db._options.cache === 'disabled' ||\n                              trans.explicit ||\n                              trans.idbtrans.mode !== 'readwrite'\n                          ) {\n                              return downTable.mutate(req);\n                          }\n                          var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n                          if (!tblCache)\n                              return downTable.mutate(req);\n                          var promise = downTable.mutate(req);\n                          if ((req.type === 'add' || req.type === 'put') && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function (key) { return key == null; }))) {\n                              promise.then(function (res) {\n                                  var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function (value, i) {\n                                          var _a;\n                                          if (res.failures[i])\n                                              return value;\n                                          var valueWithKey = ((_a = primKey.keyPath) === null || _a === void 0 ? void 0 : _a.includes('.'))\n                                              ? deepClone(value)\n                                              : __assign({}, value);\n                                          setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);\n                                          return valueWithKey;\n                                      }) });\n                                  var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);\n                                  tblCache.optimisticOps.push(adjustedReq);\n                                  queueMicrotask(function () { return req.mutatedParts && signalSubscribersLazily(req.mutatedParts); });\n                              });\n                          }\n                          else {\n                              tblCache.optimisticOps.push(req);\n                              req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                              promise.then(function (res) {\n                                  if (res.numFailures > 0) {\n                                      delArrayItem(tblCache.optimisticOps, req);\n                                      var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);\n                                      if (adjustedReq) {\n                                          tblCache.optimisticOps.push(adjustedReq);\n                                      }\n                                      req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                                  }\n                              });\n                              promise.catch(function () {\n                                  delArrayItem(tblCache.optimisticOps, req);\n                                  req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                              });\n                          }\n                          return promise;\n                      }, query: function (req) {\n                          var _a;\n                          if (!isCachableContext(PSD, downTable) || !isCachableRequest(\"query\", req))\n                              return downTable.query(req);\n                          var freezeResults = ((_a = PSD.trans) === null || _a === void 0 ? void 0 : _a.db._options.cache) === 'immutable';\n                          var _b = PSD, requery = _b.requery, signal = _b.signal;\n                          var _c = findCompatibleQuery(dbName, tableName, 'query', req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];\n                          if (cacheEntry && exactMatch) {\n                              cacheEntry.obsSet = req.obsSet;\n                          }\n                          else {\n                              var promise = downTable.query(req).then(function (res) {\n                                  var result = res.result;\n                                  if (cacheEntry)\n                                      cacheEntry.res = result;\n                                  if (freezeResults) {\n                                      for (var i = 0, l = result.length; i < l; ++i) {\n                                          Object.freeze(result[i]);\n                                      }\n                                      Object.freeze(result);\n                                  }\n                                  else {\n                                      res.result = deepClone(result);\n                                  }\n                                  return res;\n                              }).catch(function (error) {\n                                  if (container && cacheEntry)\n                                      delArrayItem(container, cacheEntry);\n                                  return Promise.reject(error);\n                              });\n                              cacheEntry = {\n                                  obsSet: req.obsSet,\n                                  promise: promise,\n                                  subscribers: new Set(),\n                                  type: 'query',\n                                  req: req,\n                                  dirty: false,\n                              };\n                              if (container) {\n                                  container.push(cacheEntry);\n                              }\n                              else {\n                                  container = [cacheEntry];\n                                  if (!tblCache) {\n                                      tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)] = {\n                                          queries: {\n                                              query: {},\n                                              count: {},\n                                          },\n                                          objs: new Map(),\n                                          optimisticOps: [],\n                                          unsignaledParts: {}\n                                      };\n                                  }\n                                  tblCache.queries.query[req.query.index.name || ''] = container;\n                              }\n                          }\n                          subscribeToCacheEntry(cacheEntry, container, requery, signal);\n                          return cacheEntry.promise.then(function (res) {\n                              return {\n                                  result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults),\n                              };\n                          });\n                      } });\n                  return tableMW;\n              } });\n          return coreMW;\n      },\n  };\n\n  function vipify(target, vipDb) {\n      return new Proxy(target, {\n          get: function (target, prop, receiver) {\n              if (prop === 'db')\n                  return vipDb;\n              return Reflect.get(target, prop, receiver);\n          }\n      });\n  }\n\n  var Dexie$1 =  (function () {\n      function Dexie(name, options) {\n          var _this = this;\n          this._middlewares = {};\n          this.verno = 0;\n          var deps = Dexie.dependencies;\n          this._options = options = __assign({\n              addons: Dexie.addons, autoOpen: true,\n              indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange, cache: 'cloned' }, options);\n          this._deps = {\n              indexedDB: options.indexedDB,\n              IDBKeyRange: options.IDBKeyRange\n          };\n          var addons = options.addons;\n          this._dbSchema = {};\n          this._versions = [];\n          this._storeNames = [];\n          this._allTables = {};\n          this.idbdb = null;\n          this._novip = this;\n          var state = {\n              dbOpenError: null,\n              isBeingOpened: false,\n              onReadyBeingFired: null,\n              openComplete: false,\n              dbReadyResolve: nop,\n              dbReadyPromise: null,\n              cancelOpen: nop,\n              openCanceller: null,\n              autoSchema: true,\n              PR1398_maxLoop: 3,\n              autoOpen: options.autoOpen,\n          };\n          state.dbReadyPromise = new DexiePromise(function (resolve) {\n              state.dbReadyResolve = resolve;\n          });\n          state.openCanceller = new DexiePromise(function (_, reject) {\n              state.cancelOpen = reject;\n          });\n          this._state = state;\n          this.name = name;\n          this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n          this.once = function (event, callback) {\n              var fn = function () {\n                  var args = [];\n                  for (var _i = 0; _i < arguments.length; _i++) {\n                      args[_i] = arguments[_i];\n                  }\n                  _this.on(event).unsubscribe(fn);\n                  callback.apply(_this, args);\n              };\n              return _this.on(event, fn);\n          };\n          this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\n              return function (subscriber, bSticky) {\n                  Dexie.vip(function () {\n                      var state = _this._state;\n                      if (state.openComplete) {\n                          if (!state.dbOpenError)\n                              DexiePromise.resolve().then(subscriber);\n                          if (bSticky)\n                              subscribe(subscriber);\n                      }\n                      else if (state.onReadyBeingFired) {\n                          state.onReadyBeingFired.push(subscriber);\n                          if (bSticky)\n                              subscribe(subscriber);\n                      }\n                      else {\n                          subscribe(subscriber);\n                          var db_1 = _this;\n                          if (!bSticky)\n                              subscribe(function unsubscribe() {\n                                  db_1.on.ready.unsubscribe(subscriber);\n                                  db_1.on.ready.unsubscribe(unsubscribe);\n                              });\n                      }\n                  });\n              };\n          });\n          this.Collection = createCollectionConstructor(this);\n          this.Table = createTableConstructor(this);\n          this.Transaction = createTransactionConstructor(this);\n          this.Version = createVersionConstructor(this);\n          this.WhereClause = createWhereClauseConstructor(this);\n          this.on(\"versionchange\", function (ev) {\n              if (ev.newVersion > 0)\n                  console.warn(\"Another connection wants to upgrade database '\".concat(_this.name, \"'. Closing db now to resume the upgrade.\"));\n              else\n                  console.warn(\"Another connection wants to delete database '\".concat(_this.name, \"'. Closing db now to resume the delete request.\"));\n              _this.close({ disableAutoOpen: false });\n          });\n          this.on(\"blocked\", function (ev) {\n              if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                  console.warn(\"Dexie.delete('\".concat(_this.name, \"') was blocked\"));\n              else\n                  console.warn(\"Upgrade '\".concat(_this.name, \"' blocked by other connection holding version \").concat(ev.oldVersion / 10));\n          });\n          this._maxKey = getMaxKey(options.IDBKeyRange);\n          this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction); };\n          this._fireOnBlocked = function (ev) {\n              _this.on(\"blocked\").fire(ev);\n              connections\n                  .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })\n                  .map(function (c) { return c.on(\"versionchange\").fire(ev); });\n          };\n          this.use(cacheExistingValuesMiddleware);\n          this.use(cacheMiddleware);\n          this.use(observabilityMiddleware);\n          this.use(virtualIndexMiddleware);\n          this.use(hooksMiddleware);\n          var vipDB = new Proxy(this, {\n              get: function (_, prop, receiver) {\n                  if (prop === '_vip')\n                      return true;\n                  if (prop === 'table')\n                      return function (tableName) { return vipify(_this.table(tableName), vipDB); };\n                  var rv = Reflect.get(_, prop, receiver);\n                  if (rv instanceof Table)\n                      return vipify(rv, vipDB);\n                  if (prop === 'tables')\n                      return rv.map(function (t) { return vipify(t, vipDB); });\n                  if (prop === '_createTransaction')\n                      return function () {\n                          var tx = rv.apply(this, arguments);\n                          return vipify(tx, vipDB);\n                      };\n                  return rv;\n              }\n          });\n          this.vip = vipDB;\n          addons.forEach(function (addon) { return addon(_this); });\n      }\n      Dexie.prototype.version = function (versionNumber) {\n          if (isNaN(versionNumber) || versionNumber < 0.1)\n              throw new exceptions.Type(\"Given version is not a positive number\");\n          versionNumber = Math.round(versionNumber * 10) / 10;\n          if (this.idbdb || this._state.isBeingOpened)\n              throw new exceptions.Schema(\"Cannot add version when database is open\");\n          this.verno = Math.max(this.verno, versionNumber);\n          var versions = this._versions;\n          var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];\n          if (versionInstance)\n              return versionInstance;\n          versionInstance = new this.Version(versionNumber);\n          versions.push(versionInstance);\n          versions.sort(lowerVersionFirst);\n          versionInstance.stores({});\n          this._state.autoSchema = false;\n          return versionInstance;\n      };\n      Dexie.prototype._whenReady = function (fn) {\n          var _this = this;\n          return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise(function (resolve, reject) {\n              if (_this._state.openComplete) {\n                  return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));\n              }\n              if (!_this._state.isBeingOpened) {\n                  if (!_this._state.autoOpen) {\n                      reject(new exceptions.DatabaseClosed());\n                      return;\n                  }\n                  _this.open().catch(nop);\n              }\n              _this._state.dbReadyPromise.then(resolve, reject);\n          }).then(fn);\n      };\n      Dexie.prototype.use = function (_a) {\n          var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;\n          if (name)\n              this.unuse({ stack: stack, name: name });\n          var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n          middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });\n          middlewares.sort(function (a, b) { return a.level - b.level; });\n          return this;\n      };\n      Dexie.prototype.unuse = function (_a) {\n          var stack = _a.stack, name = _a.name, create = _a.create;\n          if (stack && this._middlewares[stack]) {\n              this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {\n                  return create ? mw.create !== create :\n                      name ? mw.name !== name :\n                          false;\n              });\n          }\n          return this;\n      };\n      Dexie.prototype.open = function () {\n          var _this = this;\n          return usePSD(globalPSD,\n          function () { return dexieOpen(_this); });\n      };\n      Dexie.prototype._close = function () {\n          this.on.close.fire(new CustomEvent('close'));\n          var state = this._state;\n          var idx = connections.indexOf(this);\n          if (idx >= 0)\n              connections.splice(idx, 1);\n          if (this.idbdb) {\n              try {\n                  this.idbdb.close();\n              }\n              catch (e) { }\n              this.idbdb = null;\n          }\n          if (!state.isBeingOpened) {\n              state.dbReadyPromise = new DexiePromise(function (resolve) {\n                  state.dbReadyResolve = resolve;\n              });\n              state.openCanceller = new DexiePromise(function (_, reject) {\n                  state.cancelOpen = reject;\n              });\n          }\n      };\n      Dexie.prototype.close = function (_a) {\n          var _b = _a === void 0 ? { disableAutoOpen: true } : _a, disableAutoOpen = _b.disableAutoOpen;\n          var state = this._state;\n          if (disableAutoOpen) {\n              if (state.isBeingOpened) {\n                  state.cancelOpen(new exceptions.DatabaseClosed());\n              }\n              this._close();\n              state.autoOpen = false;\n              state.dbOpenError = new exceptions.DatabaseClosed();\n          }\n          else {\n              this._close();\n              state.autoOpen = this._options.autoOpen ||\n                  state.isBeingOpened;\n              state.openComplete = false;\n              state.dbOpenError = null;\n          }\n      };\n      Dexie.prototype.delete = function (closeOptions) {\n          var _this = this;\n          if (closeOptions === void 0) { closeOptions = { disableAutoOpen: true }; }\n          var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== 'object';\n          var state = this._state;\n          return new DexiePromise(function (resolve, reject) {\n              var doDelete = function () {\n                  _this.close(closeOptions);\n                  var req = _this._deps.indexedDB.deleteDatabase(_this.name);\n                  req.onsuccess = wrap(function () {\n                      _onDatabaseDeleted(_this._deps, _this.name);\n                      resolve();\n                  });\n                  req.onerror = eventRejectHandler(reject);\n                  req.onblocked = _this._fireOnBlocked;\n              };\n              if (hasInvalidArguments)\n                  throw new exceptions.InvalidArgument(\"Invalid closeOptions argument to db.delete()\");\n              if (state.isBeingOpened) {\n                  state.dbReadyPromise.then(doDelete);\n              }\n              else {\n                  doDelete();\n              }\n          });\n      };\n      Dexie.prototype.backendDB = function () {\n          return this.idbdb;\n      };\n      Dexie.prototype.isOpen = function () {\n          return this.idbdb !== null;\n      };\n      Dexie.prototype.hasBeenClosed = function () {\n          var dbOpenError = this._state.dbOpenError;\n          return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n      };\n      Dexie.prototype.hasFailed = function () {\n          return this._state.dbOpenError !== null;\n      };\n      Dexie.prototype.dynamicallyOpened = function () {\n          return this._state.autoSchema;\n      };\n      Object.defineProperty(Dexie.prototype, \"tables\", {\n          get: function () {\n              var _this = this;\n              return keys(this._allTables).map(function (name) { return _this._allTables[name]; });\n          },\n          enumerable: false,\n          configurable: true\n      });\n      Dexie.prototype.transaction = function () {\n          var args = extractTransactionArgs.apply(this, arguments);\n          return this._transaction.apply(this, args);\n      };\n      Dexie.prototype._transaction = function (mode, tables, scopeFunc) {\n          var _this = this;\n          var parentTransaction = PSD.trans;\n          if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n              parentTransaction = null;\n          var onlyIfCompatible = mode.indexOf('?') !== -1;\n          mode = mode.replace('!', '').replace('?', '');\n          var idbMode, storeNames;\n          try {\n              storeNames = tables.map(function (table) {\n                  var storeName = table instanceof _this.Table ? table.name : table;\n                  if (typeof storeName !== 'string')\n                      throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                  return storeName;\n              });\n              if (mode == \"r\" || mode === READONLY)\n                  idbMode = READONLY;\n              else if (mode == \"rw\" || mode == READWRITE)\n                  idbMode = READWRITE;\n              else\n                  throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n              if (parentTransaction) {\n                  if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                      if (onlyIfCompatible) {\n                          parentTransaction = null;\n                      }\n                      else\n                          throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                  }\n                  if (parentTransaction) {\n                      storeNames.forEach(function (storeName) {\n                          if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                              if (onlyIfCompatible) {\n                                  parentTransaction = null;\n                              }\n                              else\n                                  throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                      \" not included in parent transaction.\");\n                          }\n                      });\n                  }\n                  if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                      parentTransaction = null;\n                  }\n              }\n          }\n          catch (e) {\n              return parentTransaction ?\n                  parentTransaction._promise(null, function (_, reject) { reject(e); }) :\n                  rejection(e);\n          }\n          var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n          return (parentTransaction ?\n              parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n              PSD.trans ?\n                  usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :\n                  this._whenReady(enterTransaction));\n      };\n      Dexie.prototype.table = function (tableName) {\n          if (!hasOwn(this._allTables, tableName)) {\n              throw new exceptions.InvalidTable(\"Table \".concat(tableName, \" does not exist\"));\n          }\n          return this._allTables[tableName];\n      };\n      return Dexie;\n  }());\n\n  var symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n      ? Symbol.observable\n      : \"@@observable\";\n  var Observable =  (function () {\n      function Observable(subscribe) {\n          this._subscribe = subscribe;\n      }\n      Observable.prototype.subscribe = function (x, error, complete) {\n          return this._subscribe(!x || typeof x === \"function\" ? { next: x, error: error, complete: complete } : x);\n      };\n      Observable.prototype[symbolObservable] = function () {\n          return this;\n      };\n      return Observable;\n  }());\n\n  var domDeps;\n  try {\n      domDeps = {\n          indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n          IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n      };\n  }\n  catch (e) {\n      domDeps = { indexedDB: null, IDBKeyRange: null };\n  }\n\n  function liveQuery(querier) {\n      var hasValue = false;\n      var currentValue;\n      var observable = new Observable(function (observer) {\n          var scopeFuncIsAsync = isAsyncFunction(querier);\n          function execute(ctx) {\n              var wasRootExec = beginMicroTickScope();\n              try {\n                  if (scopeFuncIsAsync) {\n                      incrementExpectedAwaits();\n                  }\n                  var rv = newScope(querier, ctx);\n                  if (scopeFuncIsAsync) {\n                      rv = rv.finally(decrementExpectedAwaits);\n                  }\n                  return rv;\n              }\n              finally {\n                  wasRootExec && endMicroTickScope();\n              }\n          }\n          var closed = false;\n          var abortController;\n          var accumMuts = {};\n          var currentObs = {};\n          var subscription = {\n              get closed() {\n                  return closed;\n              },\n              unsubscribe: function () {\n                  if (closed)\n                      return;\n                  closed = true;\n                  if (abortController)\n                      abortController.abort();\n                  if (startedListening)\n                      globalEvents.storagemutated.unsubscribe(mutationListener);\n              },\n          };\n          observer.start && observer.start(subscription);\n          var startedListening = false;\n          var doQuery = function () { return execInGlobalContext(_doQuery); };\n          function shouldNotify() {\n              return obsSetsOverlap(currentObs, accumMuts);\n          }\n          var mutationListener = function (parts) {\n              extendObservabilitySet(accumMuts, parts);\n              if (shouldNotify()) {\n                  doQuery();\n              }\n          };\n          var _doQuery = function () {\n              if (closed ||\n                  !domDeps.indexedDB)\n               {\n                  return;\n              }\n              accumMuts = {};\n              var subscr = {};\n              if (abortController)\n                  abortController.abort();\n              abortController = new AbortController();\n              var ctx = {\n                  subscr: subscr,\n                  signal: abortController.signal,\n                  requery: doQuery,\n                  querier: querier,\n                  trans: null\n              };\n              var ret = execute(ctx);\n              Promise.resolve(ret).then(function (result) {\n                  hasValue = true;\n                  currentValue = result;\n                  if (closed || ctx.signal.aborted) {\n                      return;\n                  }\n                  accumMuts = {};\n                  currentObs = subscr;\n                  if (!objectIsEmpty(currentObs) && !startedListening) {\n                      globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                      startedListening = true;\n                  }\n                  execInGlobalContext(function () { return !closed && observer.next && observer.next(result); });\n              }, function (err) {\n                  hasValue = false;\n                  if (!['DatabaseClosedError', 'AbortError'].includes(err === null || err === void 0 ? void 0 : err.name)) {\n                      if (!closed)\n                          execInGlobalContext(function () {\n                              if (closed)\n                                  return;\n                              observer.error && observer.error(err);\n                          });\n                  }\n              });\n          };\n          setTimeout(doQuery, 0);\n          return subscription;\n      });\n      observable.hasValue = function () { return hasValue; };\n      observable.getValue = function () { return currentValue; };\n      return observable;\n  }\n\n  var Dexie = Dexie$1;\n  props(Dexie, __assign(__assign({}, fullNameExceptions), {\n      delete: function (databaseName) {\n          var db = new Dexie(databaseName, { addons: [] });\n          return db.delete();\n      },\n      exists: function (name) {\n          return new Dexie(name, { addons: [] }).open().then(function (db) {\n              db.close();\n              return true;\n          }).catch('NoSuchDatabaseError', function () { return false; });\n      },\n      getDatabaseNames: function (cb) {\n          try {\n              return getDatabaseNames(Dexie.dependencies).then(cb);\n          }\n          catch (_a) {\n              return rejection(new exceptions.MissingAPI());\n          }\n      },\n      defineClass: function () {\n          function Class(content) {\n              extend(this, content);\n          }\n          return Class;\n      }, ignoreTransaction: function (scopeFunc) {\n          return PSD.trans ?\n              usePSD(PSD.transless, scopeFunc) :\n              scopeFunc();\n      }, vip: vip, async: function (generatorFn) {\n          return function () {\n              try {\n                  var rv = awaitIterator(generatorFn.apply(this, arguments));\n                  if (!rv || typeof rv.then !== 'function')\n                      return DexiePromise.resolve(rv);\n                  return rv;\n              }\n              catch (e) {\n                  return rejection(e);\n              }\n          };\n      }, spawn: function (generatorFn, args, thiz) {\n          try {\n              var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n              if (!rv || typeof rv.then !== 'function')\n                  return DexiePromise.resolve(rv);\n              return rv;\n          }\n          catch (e) {\n              return rejection(e);\n          }\n      },\n      currentTransaction: {\n          get: function () { return PSD.trans || null; }\n      }, waitFor: function (promiseOrFunction, optionalTimeout) {\n          var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n              Dexie.ignoreTransaction(promiseOrFunction) :\n              promiseOrFunction)\n              .timeout(optionalTimeout || 60000);\n          return PSD.trans ?\n              PSD.trans.waitFor(promise) :\n              promise;\n      },\n      Promise: DexiePromise,\n      debug: {\n          get: function () { return debug; },\n          set: function (value) {\n              setDebug(value);\n          }\n      },\n      derive: derive, extend: extend, props: props, override: override,\n      Events: Events, on: globalEvents, liveQuery: liveQuery, extendObservabilitySet: extendObservabilitySet,\n      getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, cmp: cmp, asap: asap$1,\n      minKey: minKey,\n      addons: [],\n      connections: connections,\n      errnames: errnames,\n      dependencies: domDeps, cache: cache,\n      semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')\n          .map(function (n) { return parseInt(n); })\n          .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }) }));\n  Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\n  if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n      globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {\n          if (!propagatingLocally) {\n              var event_1;\n              event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                  detail: updatedParts\n              });\n              propagatingLocally = true;\n              dispatchEvent(event_1);\n              propagatingLocally = false;\n          }\n      });\n      addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {\n          var detail = _a.detail;\n          if (!propagatingLocally) {\n              propagateLocally(detail);\n          }\n      });\n  }\n  function propagateLocally(updateParts) {\n      var wasMe = propagatingLocally;\n      try {\n          propagatingLocally = true;\n          globalEvents.storagemutated.fire(updateParts);\n          signalSubscribersNow(updateParts, true);\n      }\n      finally {\n          propagatingLocally = wasMe;\n      }\n  }\n  var propagatingLocally = false;\n\n  var bc;\n  var createBC = function () { };\n  if (typeof BroadcastChannel !== 'undefined') {\n      createBC = function () {\n          bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n          bc.onmessage = function (ev) { return ev.data && propagateLocally(ev.data); };\n      };\n      createBC();\n      if (typeof bc.unref === 'function') {\n          bc.unref();\n      }\n      globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n          if (!propagatingLocally) {\n              bc.postMessage(changedParts);\n          }\n      });\n  }\n\n  if (typeof addEventListener !== 'undefined') {\n      addEventListener('pagehide', function (event) {\n          if (!Dexie$1.disableBfCache && event.persisted) {\n              if (debug)\n                  console.debug('Dexie: handling persisted pagehide');\n              bc === null || bc === void 0 ? void 0 : bc.close();\n              for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {\n                  var db = connections_1[_i];\n                  db.close({ disableAutoOpen: false });\n              }\n          }\n      });\n      addEventListener('pageshow', function (event) {\n          if (!Dexie$1.disableBfCache && event.persisted) {\n              if (debug)\n                  console.debug('Dexie: handling persisted pageshow');\n              createBC();\n              propagateLocally({ all: new RangeSet(-Infinity, [[]]) });\n          }\n      });\n  }\n\n  function add(value) {\n      return new PropModification({ add: value });\n  }\n\n  function remove(value) {\n      return new PropModification({ remove: value });\n  }\n\n  function replacePrefix(a, b) {\n      return new PropModification({ replacePrefix: [a, b] });\n  }\n\n  DexiePromise.rejectionMapper = mapError;\n  setDebug(debug);\n\n  var namedExports = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Dexie: Dexie$1,\n    Entity: Entity,\n    PropModification: PropModification,\n    RangeSet: RangeSet,\n    add: add,\n    cmp: cmp,\n    default: Dexie$1,\n    liveQuery: liveQuery,\n    mergeRanges: mergeRanges,\n    rangesOverlap: rangesOverlap,\n    remove: remove,\n    replacePrefix: replacePrefix\n  });\n\n  __assign(Dexie$1, namedExports, { default: Dexie$1 });\n\n  return Dexie$1;\n\n}));\n//# sourceMappingURL=dexie.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZXhpZS9kaXN0L2RleGllLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDb0c7QUFDdEcsQ0FBQyx1QkFBdUI7O0FBRXhCO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFNOztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkVBQTJFO0FBQ3ZGLFlBQVksNkRBQTZEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLG1EQUFtRCwyQkFBMkIsSUFBSSwwQkFBMEIsb0JBQW9CO0FBQ3RNLHFFQUFxRSxvQkFBb0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBa0M7QUFDbEUsdUNBQXVDLDRCQUE0QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHVCQUF1QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwyQ0FBMkMsSUFBSTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDJCQUEyQjtBQUN2RjtBQUNBLDZCQUE2Qix3QkFBd0I7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9DQUFvQztBQUNyRTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEOztBQUVBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7O0FBRUE7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsb0NBQW9DLGtCQUFrQjs7QUFFdEQ7O0FBRUEsQ0FBQztBQUNEIiwic291cmNlcyI6WyIvVXNlcnMvdGltb3RoeWVkaWJvL3Byb2plY3RzL3BlcnNvbmFsL2JsdWVjb3VudHMvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2RleGllL2Rpc3QvZGV4aWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIERleGllLmpzIC0gYSBtaW5pbWFsaXN0aWMgd3JhcHBlciBmb3IgSW5kZXhlZERCXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEJ5IERhdmlkIEZhaGxhbmRlciwgZGF2aWQuZmFobGFuZGVyQGdtYWlsLmNvbVxuICpcbiAqIFZlcnNpb24gNC4zLjAsIFNhdCBEZWMgMjAgMjAyNVxuICpcbiAqIGh0dHBzOi8vZGV4aWUub3JnXG4gKlxuICogQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIEphbnVhcnkgMjAwNCwgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL1xuICovXG4gXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5EZXhpZSA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gIH07XG4gIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9XG4gIHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG4gIH1cbiAgdHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbiAgfTtcblxuICB2YXIgX2dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOlxuICAgICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6XG4gICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOlxuICAgICAgICAgICAgICBnbG9iYWw7XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cztcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmICFfZ2xvYmFsLlByb21pc2UpIHtcbiAgICAgIF9nbG9iYWwuUHJvbWlzZSA9IFByb21pc2U7XG4gIH1cbiAgZnVuY3Rpb24gZXh0ZW5kKG9iaiwgZXh0ZW5zaW9uKSB7XG4gICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIGtleXMoZXh0ZW5zaW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IGV4dGVuc2lvbltrZXldO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICB9XG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIF9oYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgZnVuY3Rpb24gaGFzT3duKG9iaiwgcHJvcCkge1xuICAgICAgcmV0dXJuIF9oYXNPd24uY2FsbChvYmosIHByb3ApO1xuICB9XG4gIGZ1bmN0aW9uIHByb3BzKHByb3RvLCBleHRlbnNpb24pIHtcbiAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbihnZXRQcm90byhwcm90bykpO1xuICAgICAgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiID8ga2V5cyA6IFJlZmxlY3Qub3duS2V5cykoZXh0ZW5zaW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBzZXRQcm9wKHByb3RvLCBrZXksIGV4dGVuc2lvbltrZXldKTtcbiAgICAgIH0pO1xuICB9XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgZnVuY3Rpb24gc2V0UHJvcChvYmosIHByb3AsIGZ1bmN0aW9uT3JHZXRTZXQsIG9wdGlvbnMpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZXh0ZW5kKGZ1bmN0aW9uT3JHZXRTZXQgJiYgaGFzT3duKGZ1bmN0aW9uT3JHZXRTZXQsIFwiZ2V0XCIpICYmIHR5cGVvZiBmdW5jdGlvbk9yR2V0U2V0LmdldCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgeyBnZXQ6IGZ1bmN0aW9uT3JHZXRTZXQuZ2V0LCBzZXQ6IGZ1bmN0aW9uT3JHZXRTZXQuc2V0LCBjb25maWd1cmFibGU6IHRydWUgfSA6XG4gICAgICAgICAgeyB2YWx1ZTogZnVuY3Rpb25PckdldFNldCwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVyaXZlKENoaWxkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIGZyb206IGZ1bmN0aW9uIChQYXJlbnQpIHtcbiAgICAgICAgICAgICAgQ2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgc2V0UHJvcChDaGlsZC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgQ2hpbGQpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgZXh0ZW5kOiBwcm9wcy5iaW5kKG51bGwsIENoaWxkLnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICB9XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICBmdW5jdGlvbiBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKSB7XG4gICAgICB2YXIgcGQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgIHZhciBwcm90bztcbiAgICAgIHJldHVybiBwZCB8fCAocHJvdG8gPSBnZXRQcm90byhvYmopKSAmJiBnZXRQcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIHByb3ApO1xuICB9XG4gIHZhciBfc2xpY2UgPSBbXS5zbGljZTtcbiAgZnVuY3Rpb24gc2xpY2UoYXJncywgc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIF9zbGljZS5jYWxsKGFyZ3MsIHN0YXJ0LCBlbmQpO1xuICB9XG4gIGZ1bmN0aW9uIG92ZXJyaWRlKG9yaWdGdW5jLCBvdmVycmlkZWRGYWN0b3J5KSB7XG4gICAgICByZXR1cm4gb3ZlcnJpZGVkRmFjdG9yeShvcmlnRnVuYyk7XG4gIH1cbiAgZnVuY3Rpb24gYXNzZXJ0KGIpIHtcbiAgICAgIGlmICghYilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gRmFpbGVkXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGFzYXAkMShmbikge1xuICAgICAgaWYgKF9nbG9iYWwuc2V0SW1tZWRpYXRlKVxuICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgICBlbHNlXG4gICAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gIH1cbiAgZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnJheSwgZXh0cmFjdG9yKSB7XG4gICAgICByZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGl0ZW0sIGkpIHtcbiAgICAgICAgICB2YXIgbmFtZUFuZFZhbHVlID0gZXh0cmFjdG9yKGl0ZW0sIGkpO1xuICAgICAgICAgIGlmIChuYW1lQW5kVmFsdWUpXG4gICAgICAgICAgICAgIHJlc3VsdFtuYW1lQW5kVmFsdWVbMF1dID0gbmFtZUFuZFZhbHVlWzFdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCB7fSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyAmJiBoYXNPd24ob2JqLCBrZXlQYXRoKSlcbiAgICAgICAgICByZXR1cm4gb2JqW2tleVBhdGhdO1xuICAgICAgaWYgKCFrZXlQYXRoKVxuICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICBpZiAodHlwZW9mIGtleVBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgdmFsID0gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSk7XG4gICAgICAgICAgICAgIHJ2LnB1c2godmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfVxuICAgICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgICAgaWYgKHBlcmlvZCAhPT0gLTEpIHtcbiAgICAgICAgICB2YXIgaW5uZXJPYmogPSBvYmpba2V5UGF0aC5zdWJzdHIoMCwgcGVyaW9kKV07XG4gICAgICAgICAgcmV0dXJuIGlubmVyT2JqID09IG51bGwgPyB1bmRlZmluZWQgOiBnZXRCeUtleVBhdGgoaW5uZXJPYmosIGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdmFsdWUpIHtcbiAgICAgIGlmICghb2JqIHx8IGtleVBhdGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICBpZiAoJ2lzRnJvemVuJyBpbiBPYmplY3QgJiYgT2JqZWN0LmlzRnJvemVuKG9iaikpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiBrZXlQYXRoKSB7XG4gICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgJ2xlbmd0aCcgaW4gdmFsdWUpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5UGF0aC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSwgdmFsdWVbaV0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBwZXJpb2QgPSBrZXlQYXRoLmluZGV4T2YoJy4nKTtcbiAgICAgICAgICBpZiAocGVyaW9kICE9PSAtMSkge1xuICAgICAgICAgICAgICB2YXIgY3VycmVudEtleVBhdGggPSBrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpO1xuICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nS2V5UGF0aCA9IGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpO1xuICAgICAgICAgICAgICBpZiAocmVtYWluaW5nS2V5UGF0aCA9PT0gXCJcIilcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSAmJiAhaXNOYU4ocGFyc2VJbnQoY3VycmVudEtleVBhdGgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnNwbGljZShjdXJyZW50S2V5UGF0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICBvYmpbY3VycmVudEtleVBhdGhdID0gdmFsdWU7XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGlubmVyT2JqID0gb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICAgIGlmICghaW5uZXJPYmogfHwgIWhhc093bihvYmosIGN1cnJlbnRLZXlQYXRoKSlcbiAgICAgICAgICAgICAgICAgICAgICBpbm5lck9iaiA9IChvYmpbY3VycmVudEtleVBhdGhdID0ge30pO1xuICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGlubmVyT2JqLCByZW1haW5pbmdLZXlQYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvYmopICYmICFpc05hTihwYXJzZUludChrZXlQYXRoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgb2JqLnNwbGljZShrZXlQYXRoLCAxKTtcbiAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleVBhdGhdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIG9ialtrZXlQYXRoXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkZWxCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnKVxuICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHVuZGVmaW5lZCk7XG4gICAgICBlbHNlIGlmICgnbGVuZ3RoJyBpbiBrZXlQYXRoKVxuICAgICAgICAgIFtdLm1hcC5jYWxsKGtleVBhdGgsIGZ1bmN0aW9uIChrcCkge1xuICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrcCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzaGFsbG93Q2xvbmUob2JqKSB7XG4gICAgICB2YXIgcnYgPSB7fTtcbiAgICAgIGZvciAodmFyIG0gaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKGhhc093bihvYmosIG0pKVxuICAgICAgICAgICAgICBydlttXSA9IG9ialttXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydjtcbiAgfVxuICB2YXIgY29uY2F0ID0gW10uY29uY2F0O1xuICBmdW5jdGlvbiBmbGF0dGVuKGEpIHtcbiAgICAgIHJldHVybiBjb25jYXQuYXBwbHkoW10sIGEpO1xuICB9XG4gIHZhciBpbnRyaW5zaWNUeXBlTmFtZXMgPSBcIkJpZ1VpbnQ2NEFycmF5LEJpZ0ludDY0QXJyYXksQXJyYXksQm9vbGVhbixTdHJpbmcsRGF0ZSxSZWdFeHAsQmxvYixGaWxlLEZpbGVMaXN0LEZpbGVTeXN0ZW1GaWxlSGFuZGxlLEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUsQXJyYXlCdWZmZXIsRGF0YVZpZXcsVWludDhDbGFtcGVkQXJyYXksSW1hZ2VCaXRtYXAsSW1hZ2VEYXRhLE1hcCxTZXQsQ3J5cHRvS2V5XCJcbiAgICAgIC5zcGxpdCgnLCcpLmNvbmNhdChmbGF0dGVuKFs4LCAxNiwgMzIsIDY0XS5tYXAoZnVuY3Rpb24gKG51bSkgeyByZXR1cm4gW1wiSW50XCIsIFwiVWludFwiLCBcIkZsb2F0XCJdLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdCArIG51bSArIFwiQXJyYXlcIjsgfSk7IH0pKSkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiBfZ2xvYmFsW3RdOyB9KTtcbiAgdmFyIGludHJpbnNpY1R5cGVzID0gbmV3IFNldChpbnRyaW5zaWNUeXBlTmFtZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBfZ2xvYmFsW3RdOyB9KSk7XG4gIGZ1bmN0aW9uIGNsb25lU2ltcGxlT2JqZWN0VHJlZShvKSB7XG4gICAgICB2YXIgcnYgPSB7fTtcbiAgICAgIGZvciAodmFyIGsgaW4gbylcbiAgICAgICAgICBpZiAoaGFzT3duKG8sIGspKSB7XG4gICAgICAgICAgICAgIHZhciB2ID0gb1trXTtcbiAgICAgICAgICAgICAgcnZba10gPSAhdiB8fCB0eXBlb2YgdiAhPT0gJ29iamVjdCcgfHwgaW50cmluc2ljVHlwZXMuaGFzKHYuY29uc3RydWN0b3IpID8gdiA6IGNsb25lU2ltcGxlT2JqZWN0VHJlZSh2KTtcbiAgICAgICAgICB9XG4gICAgICByZXR1cm4gcnY7XG4gIH1cbiAgZnVuY3Rpb24gb2JqZWN0SXNFbXB0eShvKSB7XG4gICAgICBmb3IgKHZhciBrIGluIG8pXG4gICAgICAgICAgaWYgKGhhc093bihvLCBrKSlcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGNpcmN1bGFyUmVmcyA9IG51bGw7XG4gIGZ1bmN0aW9uIGRlZXBDbG9uZShhbnkpIHtcbiAgICAgIGNpcmN1bGFyUmVmcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICB2YXIgcnYgPSBpbm5lckRlZXBDbG9uZShhbnkpO1xuICAgICAgY2lyY3VsYXJSZWZzID0gbnVsbDtcbiAgICAgIHJldHVybiBydjtcbiAgfVxuICBmdW5jdGlvbiBpbm5lckRlZXBDbG9uZSh4KSB7XG4gICAgICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKVxuICAgICAgICAgIHJldHVybiB4O1xuICAgICAgdmFyIHJ2ID0gY2lyY3VsYXJSZWZzLmdldCh4KTtcbiAgICAgIGlmIChydilcbiAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICBpZiAoaXNBcnJheSh4KSkge1xuICAgICAgICAgIHJ2ID0gW107XG4gICAgICAgICAgY2lyY3VsYXJSZWZzLnNldCh4LCBydik7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICBydi5wdXNoKGlubmVyRGVlcENsb25lKHhbaV0pKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpbnRyaW5zaWNUeXBlcy5oYXMoeC5jb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICBydiA9IHg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJvdG8gPSBnZXRQcm90byh4KTtcbiAgICAgICAgICBydiA9IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlID8ge30gOiBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICAgICAgICBjaXJjdWxhclJlZnMuc2V0KHgsIHJ2KTtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHgpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc093bih4LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgcnZbcHJvcF0gPSBpbm5lckRlZXBDbG9uZSh4W3Byb3BdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydjtcbiAgfVxuICB2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcbiAgZnVuY3Rpb24gdG9TdHJpbmdUYWcobykge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICB9XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID9cbiAgICAgIFN5bWJvbC5pdGVyYXRvciA6XG4gICAgICAnQEBpdGVyYXRvcic7XG4gIHZhciBnZXRJdGVyYXRvck9mID0gdHlwZW9mIGl0ZXJhdG9yU3ltYm9sID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBpO1xuICAgICAgcmV0dXJuIHggIT0gbnVsbCAmJiAoaSA9IHhbaXRlcmF0b3JTeW1ib2xdKSAmJiBpLmFwcGx5KHgpO1xuICB9IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgZnVuY3Rpb24gZGVsQXJyYXlJdGVtKGEsIHgpIHtcbiAgICAgIHZhciBpID0gYS5pbmRleE9mKHgpO1xuICAgICAgaWYgKGkgPj0gMClcbiAgICAgICAgICBhLnNwbGljZShpLCAxKTtcbiAgICAgIHJldHVybiBpID49IDA7XG4gIH1cbiAgdmFyIE5PX0NIQVJfQVJSQVkgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0QXJyYXlPZihhcnJheUxpa2UpIHtcbiAgICAgIHZhciBpLCBhLCB4LCBpdDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoYXJyYXlMaWtlKSlcbiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5TGlrZS5zbGljZSgpO1xuICAgICAgICAgIGlmICh0aGlzID09PSBOT19DSEFSX0FSUkFZICYmIHR5cGVvZiBhcnJheUxpa2UgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgICAgICAgaWYgKChpdCA9IGdldEl0ZXJhdG9yT2YoYXJyYXlMaWtlKSkpIHtcbiAgICAgICAgICAgICAgYSA9IFtdO1xuICAgICAgICAgICAgICB3aGlsZSAoKHggPSBpdC5uZXh0KCkpLCAheC5kb25lKVxuICAgICAgICAgICAgICAgICAgYS5wdXNoKHgudmFsdWUpO1xuICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFycmF5TGlrZSA9PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgICAgICAgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICBhID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgICAgYVtpXSA9IGFycmF5TGlrZVtpXTtcbiAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICAgIH1cbiAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgYSA9IG5ldyBBcnJheShpKTtcbiAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgYVtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiBhO1xuICB9XG4gIHZhciBpc0FzeW5jRnVuY3Rpb24gPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0Z1bmN0aW9uJzsgfVxuICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuICB2YXIgZGV4aWVFcnJvck5hbWVzID0gW1xuICAgICAgJ01vZGlmeScsXG4gICAgICAnQnVsaycsXG4gICAgICAnT3BlbkZhaWxlZCcsXG4gICAgICAnVmVyc2lvbkNoYW5nZScsXG4gICAgICAnU2NoZW1hJyxcbiAgICAgICdVcGdyYWRlJyxcbiAgICAgICdJbnZhbGlkVGFibGUnLFxuICAgICAgJ01pc3NpbmdBUEknLFxuICAgICAgJ05vU3VjaERhdGFiYXNlJyxcbiAgICAgICdJbnZhbGlkQXJndW1lbnQnLFxuICAgICAgJ1N1YlRyYW5zYWN0aW9uJyxcbiAgICAgICdVbnN1cHBvcnRlZCcsXG4gICAgICAnSW50ZXJuYWwnLFxuICAgICAgJ0RhdGFiYXNlQ2xvc2VkJyxcbiAgICAgICdQcmVtYXR1cmVDb21taXQnLFxuICAgICAgJ0ZvcmVpZ25Bd2FpdCdcbiAgXTtcbiAgdmFyIGlkYkRvbUVycm9yTmFtZXMgPSBbXG4gICAgICAnVW5rbm93bicsXG4gICAgICAnQ29uc3RyYWludCcsXG4gICAgICAnRGF0YScsXG4gICAgICAnVHJhbnNhY3Rpb25JbmFjdGl2ZScsXG4gICAgICAnUmVhZE9ubHknLFxuICAgICAgJ1ZlcnNpb24nLFxuICAgICAgJ05vdEZvdW5kJyxcbiAgICAgICdJbnZhbGlkU3RhdGUnLFxuICAgICAgJ0ludmFsaWRBY2Nlc3MnLFxuICAgICAgJ0Fib3J0JyxcbiAgICAgICdUaW1lb3V0JyxcbiAgICAgICdRdW90YUV4Y2VlZGVkJyxcbiAgICAgICdTeW50YXgnLFxuICAgICAgJ0RhdGFDbG9uZSdcbiAgXTtcbiAgdmFyIGVycm9yTGlzdCA9IGRleGllRXJyb3JOYW1lcy5jb25jYXQoaWRiRG9tRXJyb3JOYW1lcyk7XG4gIHZhciBkZWZhdWx0VGV4dHMgPSB7XG4gICAgICBWZXJzaW9uQ2hhbmdlZDogXCJEYXRhYmFzZSB2ZXJzaW9uIGNoYW5nZWQgYnkgb3RoZXIgZGF0YWJhc2UgY29ubmVjdGlvblwiLFxuICAgICAgRGF0YWJhc2VDbG9zZWQ6IFwiRGF0YWJhc2UgaGFzIGJlZW4gY2xvc2VkXCIsXG4gICAgICBBYm9ydDogXCJUcmFuc2FjdGlvbiBhYm9ydGVkXCIsXG4gICAgICBUcmFuc2FjdGlvbkluYWN0aXZlOiBcIlRyYW5zYWN0aW9uIGhhcyBhbHJlYWR5IGNvbXBsZXRlZCBvciBmYWlsZWRcIixcbiAgICAgIE1pc3NpbmdBUEk6IFwiSW5kZXhlZERCIEFQSSBtaXNzaW5nLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly90aW55dXJsLmNvbS95MnV1dnNrYlwiXG4gIH07XG4gIGZ1bmN0aW9uIERleGllRXJyb3IobmFtZSwgbXNnKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5tZXNzYWdlID0gbXNnO1xuICB9XG4gIGRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEVycm9yKS5leHRlbmQoe1xuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTsgfVxuICB9KTtcbiAgZnVuY3Rpb24gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCBmYWlsdXJlcykge1xuICAgICAgcmV0dXJuIG1zZyArIFwiLiBFcnJvcnM6IFwiICsgT2JqZWN0LmtleXMoZmFpbHVyZXMpXG4gICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmYWlsdXJlc1trZXldLnRvU3RyaW5nKCk7IH0pXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodiwgaSwgcykgeyByZXR1cm4gcy5pbmRleE9mKHYpID09PSBpOyB9KVxuICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgfVxuICBmdW5jdGlvbiBNb2RpZnlFcnJvcihtc2csIGZhaWx1cmVzLCBzdWNjZXNzQ291bnQsIGZhaWxlZEtleXMpIHtcbiAgICAgIHRoaXMuZmFpbHVyZXMgPSBmYWlsdXJlcztcbiAgICAgIHRoaXMuZmFpbGVkS2V5cyA9IGZhaWxlZEtleXM7XG4gICAgICB0aGlzLnN1Y2Nlc3NDb3VudCA9IHN1Y2Nlc3NDb3VudDtcbiAgICAgIHRoaXMubWVzc2FnZSA9IGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpO1xuICB9XG4gIGRlcml2ZShNb2RpZnlFcnJvcikuZnJvbShEZXhpZUVycm9yKTtcbiAgZnVuY3Rpb24gQnVsa0Vycm9yKG1zZywgZmFpbHVyZXMpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiQnVsa0Vycm9yXCI7XG4gICAgICB0aGlzLmZhaWx1cmVzID0gT2JqZWN0LmtleXMoZmFpbHVyZXMpLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBmYWlsdXJlc1twb3NdOyB9KTtcbiAgICAgIHRoaXMuZmFpbHVyZXNCeVBvcyA9IGZhaWx1cmVzO1xuICAgICAgdGhpcy5tZXNzYWdlID0gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCB0aGlzLmZhaWx1cmVzKTtcbiAgfVxuICBkZXJpdmUoQnVsa0Vycm9yKS5mcm9tKERleGllRXJyb3IpO1xuICB2YXIgZXJybmFtZXMgPSBlcnJvckxpc3QucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHsgcmV0dXJuIChvYmpbbmFtZV0gPSBuYW1lICsgXCJFcnJvclwiLCBvYmopOyB9LCB7fSk7XG4gIHZhciBCYXNlRXhjZXB0aW9uID0gRGV4aWVFcnJvcjtcbiAgdmFyIGV4Y2VwdGlvbnMgPSBlcnJvckxpc3QucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcbiAgICAgIHZhciBmdWxsTmFtZSA9IG5hbWUgKyBcIkVycm9yXCI7XG4gICAgICBmdW5jdGlvbiBEZXhpZUVycm9yKG1zZ09ySW5uZXIsIGlubmVyKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gZnVsbE5hbWU7XG4gICAgICAgICAgaWYgKCFtc2dPcklubmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGRlZmF1bHRUZXh0c1tuYW1lXSB8fCBmdWxsTmFtZTtcbiAgICAgICAgICAgICAgdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtc2dPcklubmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlwiLmNvbmNhdChtc2dPcklubmVyKS5jb25jYXQoIWlubmVyID8gJycgOiAnXFxuICcgKyBpbm5lcik7XG4gICAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lciB8fCBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJcIi5jb25jYXQobXNnT3JJbm5lci5uYW1lLCBcIiBcIikuY29uY2F0KG1zZ09ySW5uZXIubWVzc2FnZSk7XG4gICAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBtc2dPcklubmVyO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEJhc2VFeGNlcHRpb24pO1xuICAgICAgb2JqW25hbWVdID0gRGV4aWVFcnJvcjtcbiAgICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbiAgZXhjZXB0aW9ucy5TeW50YXggPSBTeW50YXhFcnJvcjtcbiAgZXhjZXB0aW9ucy5UeXBlID0gVHlwZUVycm9yO1xuICBleGNlcHRpb25zLlJhbmdlID0gUmFuZ2VFcnJvcjtcbiAgdmFyIGV4Y2VwdGlvbk1hcCA9IGlkYkRvbUVycm9yTmFtZXMucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcbiAgICAgIG9ialtuYW1lICsgXCJFcnJvclwiXSA9IGV4Y2VwdGlvbnNbbmFtZV07XG4gICAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG4gIGZ1bmN0aW9uIG1hcEVycm9yKGRvbUVycm9yLCBtZXNzYWdlKSB7XG4gICAgICBpZiAoIWRvbUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgRGV4aWVFcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIFN5bnRheEVycm9yIHx8ICFkb21FcnJvci5uYW1lIHx8ICFleGNlcHRpb25NYXBbZG9tRXJyb3IubmFtZV0pXG4gICAgICAgICAgcmV0dXJuIGRvbUVycm9yO1xuICAgICAgdmFyIHJ2ID0gbmV3IGV4Y2VwdGlvbk1hcFtkb21FcnJvci5uYW1lXShtZXNzYWdlIHx8IGRvbUVycm9yLm1lc3NhZ2UsIGRvbUVycm9yKTtcbiAgICAgIGlmIChcInN0YWNrXCIgaW4gZG9tRXJyb3IpIHtcbiAgICAgICAgICBzZXRQcm9wKHJ2LCBcInN0YWNrXCIsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbm5lci5zdGFjaztcbiAgICAgICAgICAgICAgfSB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydjtcbiAgfVxuICB2YXIgZnVsbE5hbWVFeGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gICAgICBpZiAoW1wiU3ludGF4XCIsIFwiVHlwZVwiLCBcIlJhbmdlXCJdLmluZGV4T2YobmFtZSkgPT09IC0xKVxuICAgICAgICAgIG9ialtuYW1lICsgXCJFcnJvclwiXSA9IGV4Y2VwdGlvbnNbbmFtZV07XG4gICAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG4gIGZ1bGxOYW1lRXhjZXB0aW9ucy5Nb2RpZnlFcnJvciA9IE1vZGlmeUVycm9yO1xuICBmdWxsTmFtZUV4Y2VwdGlvbnMuRGV4aWVFcnJvciA9IERleGllRXJyb3I7XG4gIGZ1bGxOYW1lRXhjZXB0aW9ucy5CdWxrRXJyb3IgPSBCdWxrRXJyb3I7XG5cbiAgZnVuY3Rpb24gbm9wKCkgeyB9XG4gIGZ1bmN0aW9uIG1pcnJvcih2YWwpIHsgcmV0dXJuIHZhbDsgfVxuICBmdW5jdGlvbiBwdXJlRnVuY3Rpb25DaGFpbihmMSwgZjIpIHtcbiAgICAgIGlmIChmMSA9PSBudWxsIHx8IGYxID09PSBtaXJyb3IpXG4gICAgICAgICAgcmV0dXJuIGYyO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gZjIoZjEodmFsKSk7XG4gICAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGNhbGxCb3RoKG9uMSwgb24yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9uMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIG9uMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfVxuICBmdW5jdGlvbiBob29rQ3JlYXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICAgIHJldHVybiBmMjtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICBhcmd1bWVudHNbMF0gPSByZXM7XG4gICAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSBudWxsO1xuICAgICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgdmFyIHJlczIgPSBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmIChvbnN1Y2Nlc3MpXG4gICAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgICBpZiAob25lcnJvcilcbiAgICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgICAgICAgcmV0dXJuIHJlczIgIT09IHVuZGVmaW5lZCA/IHJlczIgOiByZXM7XG4gICAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGhvb2tEZWxldGluZ0NoYWluKGYxLCBmMikge1xuICAgICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgICAgcmV0dXJuIGYyO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyxcbiAgICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmIChvbnN1Y2Nlc3MpXG4gICAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgICBpZiAob25lcnJvcilcbiAgICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGhvb2tVcGRhdGluZ0NoYWluKGYxLCBmMikge1xuICAgICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgICAgcmV0dXJuIGYyO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RpZmljYXRpb25zKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgZXh0ZW5kKG1vZGlmaWNhdGlvbnMsIHJlcyk7XG4gICAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSBudWxsO1xuICAgICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgdmFyIHJlczIgPSBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmIChvbnN1Y2Nlc3MpXG4gICAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgICBpZiAob25lcnJvcilcbiAgICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgICAgICAgcmV0dXJuIHJlcyA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgKHJlczIgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlczIpIDpcbiAgICAgICAgICAgICAgKGV4dGVuZChyZXMsIHJlczIpKTtcbiAgICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gcmV2ZXJzZVN0b3BwYWJsZUV2ZW50Q2hhaW4oZjEsIGYyKSB7XG4gICAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgICByZXR1cm4gZjI7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHJldHVybiBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfVxuICBmdW5jdGlvbiBwcm9taXNhYmxlQ2hhaW4oZjEsIGYyKSB7XG4gICAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgICByZXR1cm4gZjI7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhciB0aGl6ID0gdGhpcywgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXosIGFyZ3MpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIGRlYnVnID0gdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgL14oaHR0cHxodHRwcyk6XFwvXFwvKGxvY2FsaG9zdHwxMjdcXC4wXFwuMFxcLjEpLy50ZXN0KGxvY2F0aW9uLmhyZWYpO1xuICBmdW5jdGlvbiBzZXREZWJ1Zyh2YWx1ZSwgZmlsdGVyKSB7XG4gICAgICBkZWJ1ZyA9IHZhbHVlO1xuICB9XG5cbiAgdmFyIElOVEVSTkFMID0ge307XG4gIHZhciBaT05FX0VDSE9fTElNSVQgPSAxMDAsIF9hJDEgPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgW10gOlxuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZ2xvYmFsUCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJyB8fCAhY3J5cHRvLnN1YnRsZSlcbiAgICAgICAgICAgICAgcmV0dXJuIFtnbG9iYWxQLCBnZXRQcm90byhnbG9iYWxQKSwgZ2xvYmFsUF07XG4gICAgICAgICAgdmFyIG5hdGl2ZVAgPSBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS01MTJcIiwgbmV3IFVpbnQ4QXJyYXkoWzBdKSk7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgbmF0aXZlUCxcbiAgICAgICAgICAgICAgZ2V0UHJvdG8obmF0aXZlUCksXG4gICAgICAgICAgICAgIGdsb2JhbFBcbiAgICAgICAgICBdO1xuICAgICAgfSkoKSwgcmVzb2x2ZWROYXRpdmVQcm9taXNlID0gX2EkMVswXSwgbmF0aXZlUHJvbWlzZVByb3RvID0gX2EkMVsxXSwgcmVzb2x2ZWRHbG9iYWxQcm9taXNlID0gX2EkMVsyXSwgbmF0aXZlUHJvbWlzZVRoZW4gPSBuYXRpdmVQcm9taXNlUHJvdG8gJiYgbmF0aXZlUHJvbWlzZVByb3RvLnRoZW47XG4gIHZhciBOYXRpdmVQcm9taXNlID0gcmVzb2x2ZWROYXRpdmVQcm9taXNlICYmIHJlc29sdmVkTmF0aXZlUHJvbWlzZS5jb25zdHJ1Y3RvcjtcbiAgdmFyIHBhdGNoR2xvYmFsUHJvbWlzZSA9ICEhcmVzb2x2ZWRHbG9iYWxQcm9taXNlO1xuICBmdW5jdGlvbiBzY2hlZHVsZVBoeXNpY2FsVGljaygpIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKHBoeXNpY2FsVGljayk7XG4gIH1cbiAgdmFyIGFzYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICAgIG1pY3JvdGlja1F1ZXVlLnB1c2goW2NhbGxiYWNrLCBhcmdzXSk7XG4gICAgICBpZiAobmVlZHNOZXdQaHlzaWNhbFRpY2spIHtcbiAgICAgICAgICBzY2hlZHVsZVBoeXNpY2FsVGljaygpO1xuICAgICAgICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gZmFsc2U7XG4gICAgICB9XG4gIH07XG4gIHZhciBpc091dHNpZGVNaWNyb1RpY2sgPSB0cnVlLFxuICBuZWVkc05ld1BoeXNpY2FsVGljayA9IHRydWUsXG4gIHVuaGFuZGxlZEVycm9ycyA9IFtdLFxuICByZWplY3RpbmdFcnJvcnMgPSBbXSxcbiAgcmVqZWN0aW9uTWFwcGVyID0gbWlycm9yO1xuICB2YXIgZ2xvYmFsUFNEID0ge1xuICAgICAgaWQ6ICdnbG9iYWwnLFxuICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgcmVmOiAwLFxuICAgICAgdW5oYW5kbGVkczogW10sXG4gICAgICBvbnVuaGFuZGxlZDogbm9wLFxuICAgICAgcGdwOiBmYWxzZSxcbiAgICAgIGVudjoge30sXG4gICAgICBmaW5hbGl6ZTogbm9wXG4gIH07XG4gIHZhciBQU0QgPSBnbG9iYWxQU0Q7XG4gIHZhciBtaWNyb3RpY2tRdWV1ZSA9IFtdO1xuICB2YXIgbnVtU2NoZWR1bGVkQ2FsbHMgPSAwO1xuICB2YXIgdGlja0ZpbmFsaXplcnMgPSBbXTtcbiAgZnVuY3Rpb24gRGV4aWVQcm9taXNlKGZuKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgICB0aGlzLl9saWIgPSBmYWxzZTtcbiAgICAgIHZhciBwc2QgPSAodGhpcy5fUFNEID0gUFNEKTtcbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpZiAoZm4gIT09IElOVEVSTkFMKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgIHRoaXMuX3ZhbHVlID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgIGhhbmRsZVJlamVjdGlvbih0aGlzLCB0aGlzLl92YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgKytwc2QucmVmO1xuICAgICAgZXhlY3V0ZVByb21pc2VUYXNrKHRoaXMsIGZuKTtcbiAgfVxuICB2YXIgdGhlblByb3AgPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcHNkID0gUFNELCBtaWNyb1Rhc2tJZCA9IHRvdGFsRWNob2VzO1xuICAgICAgICAgIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlQXdhaXQgPSAhcHNkLmdsb2JhbCAmJiAocHNkICE9PSBQU0QgfHwgbWljcm9UYXNrSWQgIT09IHRvdGFsRWNob2VzKTtcbiAgICAgICAgICAgICAgdmFyIGNsZWFudXAgPSBwb3NzaWJsZUF3YWl0ICYmICFkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgICB2YXIgcnYgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIoX3RoaXMsIG5ldyBMaXN0ZW5lcihuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uRnVsZmlsbGVkLCBwc2QsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApLCBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uUmVqZWN0ZWQsIHBzZCwgcG9zc2libGVBd2FpdCwgY2xlYW51cCksIHJlc29sdmUsIHJlamVjdCwgcHNkKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fY29uc29sZVRhc2spXG4gICAgICAgICAgICAgICAgICBydi5fY29uc29sZVRhc2sgPSB0aGlzLl9jb25zb2xlVGFzaztcbiAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGVuLnByb3RvdHlwZSA9IElOVEVSTkFMO1xuICAgICAgICAgIHJldHVybiB0aGVuO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgc2V0UHJvcCh0aGlzLCAndGhlbicsIHZhbHVlICYmIHZhbHVlLnByb3RvdHlwZSA9PT0gSU5URVJOQUwgP1xuICAgICAgICAgICAgICB0aGVuUHJvcCA6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBzZXQ6IHRoZW5Qcm9wLnNldFxuICAgICAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgfTtcbiAgcHJvcHMoRGV4aWVQcm9taXNlLnByb3RvdHlwZSwge1xuICAgICAgdGhlbjogdGhlblByb3AsXG4gICAgICBfdGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcih0aGlzLCBuZXcgTGlzdGVuZXIobnVsbCwgbnVsbCwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIFBTRCkpO1xuICAgICAgfSxcbiAgICAgIGNhdGNoOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICAgICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdLCBoYW5kbGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlcnIgaW5zdGFuY2VvZiB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIDogdGhpcy50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlcnIgJiYgZXJyLm5hbWUgPT09IHR5cGUgPyBoYW5kbGVyKGVycikgOiBQcm9taXNlUmVqZWN0KGVycik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZpbmFsbHk6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUob25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2VSZWplY3QoZXJyKTsgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdGltZW91dDogZnVuY3Rpb24gKG1zLCBtc2cpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBtcyA8IEluZmluaXR5ID9cbiAgICAgICAgICAgICAgbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiByZWplY3QobmV3IGV4Y2VwdGlvbnMuVGltZW91dChtc2cpKTsgfSwgbXMpO1xuICAgICAgICAgICAgICAgICAgX3RoaXMudGhlbihyZXNvbHZlLCByZWplY3QpLmZpbmFsbHkoY2xlYXJUaW1lb3V0LmJpbmQobnVsbCwgaGFuZGxlKSk7XG4gICAgICAgICAgICAgIH0pIDogdGhpcztcbiAgICAgIH1cbiAgfSk7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpXG4gICAgICBzZXRQcm9wKERleGllUHJvbWlzZS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywgJ0RleGllLlByb21pc2UnKTtcbiAgZ2xvYmFsUFNELmVudiA9IHNuYXBTaG90KCk7XG4gIGZ1bmN0aW9uIExpc3RlbmVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3QsIHpvbmUpIHtcbiAgICAgIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG4gICAgICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgdGhpcy5wc2QgPSB6b25lO1xuICB9XG4gIHByb3BzKERleGllUHJvbWlzZSwge1xuICAgICAgYWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgICAubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKGEsIGkpIHsgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKGEpLnRoZW4oZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlc1tpXSA9IHg7XG4gICAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgICAgICAgfSwgcmVqZWN0KTsgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcmVzb2x2ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGV4aWVQcm9taXNlKVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBydiA9IG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIHRydWUsIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9LFxuICAgICAgcmVqZWN0OiBQcm9taXNlUmVqZWN0LFxuICAgICAgcmFjZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTsgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgUFNEOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQU0Q7IH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIFBTRCA9IHZhbHVlOyB9XG4gICAgICB9LFxuICAgICAgdG90YWxFY2hvZXM6IHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0b3RhbEVjaG9lczsgfSB9LFxuICAgICAgbmV3UFNEOiBuZXdTY29wZSxcbiAgICAgIHVzZVBTRDogdXNlUFNELFxuICAgICAgc2NoZWR1bGVyOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhc2FwOyB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IGFzYXAgPSB2YWx1ZTsgfVxuICAgICAgfSxcbiAgICAgIHJlamVjdGlvbk1hcHBlcjoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0aW9uTWFwcGVyOyB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHJlamVjdGlvbk1hcHBlciA9IHZhbHVlOyB9XG4gICAgICB9LFxuICAgICAgZm9sbG93OiBmdW5jdGlvbiAoZm4sIHpvbmVQcm9wcykge1xuICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwc2QgPSBQU0Q7XG4gICAgICAgICAgICAgICAgICBwc2QudW5oYW5kbGVkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgcHNkLm9udW5oYW5kbGVkID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgICAgcHNkLmZpbmFsaXplID0gY2FsbEJvdGgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgcnVuX2F0X2VuZF9vZl90aGlzX29yX25leHRfcGh5c2ljYWxfdGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVuaGFuZGxlZHMubGVuZ3RoID09PSAwID8gcmVzb2x2ZSgpIDogcmVqZWN0KF90aGlzLnVuaGFuZGxlZHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSwgcHNkLmZpbmFsaXplKTtcbiAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgIH0sIHpvbmVQcm9wcywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgfSk7XG4gIGlmIChOYXRpdmVQcm9taXNlKSB7XG4gICAgICBpZiAoTmF0aXZlUHJvbWlzZS5hbGxTZXR0bGVkKVxuICAgICAgICAgIHNldFByb3AoRGV4aWVQcm9taXNlLCBcImFsbFNldHRsZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgcG9zc2libGVQcm9taXNlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVByb21pc2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSBwb3NzaWJsZVByb21pc2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICBwb3NzaWJsZVByb21pc2VzLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHApLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiByZXN1bHRzW2ldID0geyBzdGF0dXM6IFwiZnVsZmlsbGVkXCIsIHZhbHVlOiB2YWx1ZSB9OyB9LCBmdW5jdGlvbiAocmVhc29uKSB7IHJldHVybiByZXN1bHRzW2ldID0geyBzdGF0dXM6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiByZWFzb24gfTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHJlc3VsdHMpOyB9KTsgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgaWYgKE5hdGl2ZVByb21pc2UuYW55ICYmIHR5cGVvZiBBZ2dyZWdhdGVFcnJvciAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgc2V0UHJvcChEZXhpZVByb21pc2UsIFwiYW55XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlUHJvbWlzZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVByb21pc2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKFtdKSk7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gcG9zc2libGVQcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZXMgPSBuZXcgQXJyYXkocmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgIHBvc3NpYmxlUHJvbWlzZXMuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkgeyByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUocCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHJlc29sdmUodmFsdWUpOyB9LCBmdW5jdGlvbiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzW2ldID0gZmFpbHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKGZhaWx1cmVzKSk7XG4gICAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgaWYgKE5hdGl2ZVByb21pc2Uud2l0aFJlc29sdmVycylcbiAgICAgICAgICBEZXhpZVByb21pc2Uud2l0aFJlc29sdmVycyA9IE5hdGl2ZVByb21pc2Uud2l0aFJlc29sdmVycztcbiAgfVxuICBmdW5jdGlvbiBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgZm4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgZm4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBwcm9taXNlKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgICAgICAgICAgdmFyIHNob3VsZEV4ZWN1dGVUaWNrID0gcHJvbWlzZS5fbGliICYmIGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgRGV4aWVQcm9taXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX3RoZW4ocmVzb2x2ZSwgcmVqZWN0KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2hvdWxkRXhlY3V0ZVRpY2spXG4gICAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICAgIH0sIGhhbmRsZVJlamVjdGlvbi5iaW5kKG51bGwsIHByb21pc2UpKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgIGhhbmRsZVJlamVjdGlvbihwcm9taXNlLCBleCk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUmVqZWN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICAgICAgcmVqZWN0aW5nRXJyb3JzLnB1c2gocmVhc29uKTtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICB2YXIgc2hvdWxkRXhlY3V0ZVRpY2sgPSBwcm9taXNlLl9saWIgJiYgYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgICAgcmVhc29uID0gcmVqZWN0aW9uTWFwcGVyKHJlYXNvbik7XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGZhbHNlO1xuICAgICAgcHJvbWlzZS5fdmFsdWUgPSByZWFzb247XG4gICAgICBhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yKHByb21pc2UpO1xuICAgICAgcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpO1xuICAgICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKVxuICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBwcm9taXNlLl9saXN0ZW5lcnM7XG4gICAgICBwcm9taXNlLl9saXN0ZW5lcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKHByb21pc2UsIGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgICB2YXIgcHNkID0gcHJvbWlzZS5fUFNEO1xuICAgICAgLS1wc2QucmVmIHx8IHBzZC5maW5hbGl6ZSgpO1xuICAgICAgaWYgKG51bVNjaGVkdWxlZENhbGxzID09PSAwKSB7XG4gICAgICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICAgICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApXG4gICAgICAgICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuICAgICAgICAgIH0sIFtdKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9wYWdhdGVUb0xpc3RlbmVyKHByb21pc2UsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICBwcm9taXNlLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNiID0gcHJvbWlzZS5fc3RhdGUgPyBsaXN0ZW5lci5vbkZ1bGZpbGxlZCA6IGxpc3RlbmVyLm9uUmVqZWN0ZWQ7XG4gICAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gKHByb21pc2UuX3N0YXRlID8gbGlzdGVuZXIucmVzb2x2ZSA6IGxpc3RlbmVyLnJlamVjdCkocHJvbWlzZS5fdmFsdWUpO1xuICAgICAgfVxuICAgICAgKytsaXN0ZW5lci5wc2QucmVmO1xuICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICAgIGFzYXAoY2FsbExpc3RlbmVyLCBbY2IsIHByb21pc2UsIGxpc3RlbmVyXSk7XG4gIH1cbiAgZnVuY3Rpb24gY2FsbExpc3RlbmVyKGNiLCBwcm9taXNlLCBsaXN0ZW5lcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmV0LCB2YWx1ZSA9IHByb21pc2UuX3ZhbHVlO1xuICAgICAgICAgIGlmICghcHJvbWlzZS5fc3RhdGUgJiYgcmVqZWN0aW5nRXJyb3JzLmxlbmd0aClcbiAgICAgICAgICAgICAgcmVqZWN0aW5nRXJyb3JzID0gW107XG4gICAgICAgICAgcmV0ID0gZGVidWcgJiYgcHJvbWlzZS5fY29uc29sZVRhc2sgPyBwcm9taXNlLl9jb25zb2xlVGFzay5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gY2IodmFsdWUpOyB9KSA6IGNiKHZhbHVlKTtcbiAgICAgICAgICBpZiAoIXByb21pc2UuX3N0YXRlICYmIHJlamVjdGluZ0Vycm9ycy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgbWFya0Vycm9yQXNIYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaXN0ZW5lci5yZXNvbHZlKHJldCk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIGxpc3RlbmVyLnJlamVjdChlKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsbHkge1xuICAgICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuICAgICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuICAgICAgICAgIC0tbGlzdGVuZXIucHNkLnJlZiB8fCBsaXN0ZW5lci5wc2QuZmluYWxpemUoKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwaHlzaWNhbFRpY2soKSB7XG4gICAgICB1c2VQU0QoZ2xvYmFsUFNELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYmVnaW5NaWNyb1RpY2tTY29wZSgpICYmIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBiZWdpbk1pY3JvVGlja1Njb3BlKCkge1xuICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gaXNPdXRzaWRlTWljcm9UaWNrO1xuICAgICAgaXNPdXRzaWRlTWljcm9UaWNrID0gZmFsc2U7XG4gICAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHdhc1Jvb3RFeGVjO1xuICB9XG4gIGZ1bmN0aW9uIGVuZE1pY3JvVGlja1Njb3BlKCkge1xuICAgICAgdmFyIGNhbGxiYWNrcywgaSwgbDtcbiAgICAgIGRvIHtcbiAgICAgICAgICB3aGlsZSAobWljcm90aWNrUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjYWxsYmFja3MgPSBtaWNyb3RpY2tRdWV1ZTtcbiAgICAgICAgICAgICAgbWljcm90aWNrUXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgbCA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgICAgICAgaXRlbVswXS5hcHBseShudWxsLCBpdGVtWzFdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApO1xuICAgICAgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZTtcbiAgICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBmaW5hbGl6ZVBoeXNpY2FsVGljaygpIHtcbiAgICAgIHZhciB1bmhhbmRsZWRFcnJzID0gdW5oYW5kbGVkRXJyb3JzO1xuICAgICAgdW5oYW5kbGVkRXJyb3JzID0gW107XG4gICAgICB1bmhhbmRsZWRFcnJzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICBwLl9QU0Qub251bmhhbmRsZWQuY2FsbChudWxsLCBwLl92YWx1ZSwgcCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBmaW5hbGl6ZXJzID0gdGlja0ZpbmFsaXplcnMuc2xpY2UoMCk7XG4gICAgICB2YXIgaSA9IGZpbmFsaXplcnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkpXG4gICAgICAgICAgZmluYWxpemVyc1stLWldKCk7XG4gIH1cbiAgZnVuY3Rpb24gcnVuX2F0X2VuZF9vZl90aGlzX29yX25leHRfcGh5c2ljYWxfdGljayhmbikge1xuICAgICAgZnVuY3Rpb24gZmluYWxpemVyKCkge1xuICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgdGlja0ZpbmFsaXplcnMuc3BsaWNlKHRpY2tGaW5hbGl6ZXJzLmluZGV4T2YoZmluYWxpemVyKSwgMSk7XG4gICAgICB9XG4gICAgICB0aWNrRmluYWxpemVycy5wdXNoKGZpbmFsaXplcik7XG4gICAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApXG4gICAgICAgICAgICAgIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7XG4gICAgICB9LCBbXSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcihwcm9taXNlKSB7XG4gICAgICBpZiAoIXVuaGFuZGxlZEVycm9ycy5zb21lKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLl92YWx1ZSA9PT0gcHJvbWlzZS5fdmFsdWU7IH0pKVxuICAgICAgICAgIHVuaGFuZGxlZEVycm9ycy5wdXNoKHByb21pc2UpO1xuICB9XG4gIGZ1bmN0aW9uIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKSB7XG4gICAgICB2YXIgaSA9IHVuaGFuZGxlZEVycm9ycy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaSlcbiAgICAgICAgICBpZiAodW5oYW5kbGVkRXJyb3JzWy0taV0uX3ZhbHVlID09PSBwcm9taXNlLl92YWx1ZSkge1xuICAgICAgICAgICAgICB1bmhhbmRsZWRFcnJvcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIFByb21pc2VSZWplY3QocmVhc29uKSB7XG4gICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShJTlRFUk5BTCwgZmFsc2UsIHJlYXNvbik7XG4gIH1cbiAgZnVuY3Rpb24gd3JhcChmbiwgZXJyb3JDYXRjaGVyKSB7XG4gICAgICB2YXIgcHNkID0gUFNEO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCksIG91dGVyU2NvcGUgPSBQU0Q7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3dpdGNoVG9ab25lKHBzZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBlcnJvckNhdGNoZXIgJiYgZXJyb3JDYXRjaGVyKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgaWYgKHdhc1Jvb3RFeGVjKVxuICAgICAgICAgICAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICB9XG4gIHZhciB0YXNrID0geyBhd2FpdHM6IDAsIGVjaG9lczogMCwgaWQ6IDAgfTtcbiAgdmFyIHRhc2tDb3VudGVyID0gMDtcbiAgdmFyIHpvbmVTdGFjayA9IFtdO1xuICB2YXIgem9uZUVjaG9lcyA9IDA7XG4gIHZhciB0b3RhbEVjaG9lcyA9IDA7XG4gIHZhciB6b25lX2lkX2NvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBuZXdTY29wZShmbiwgcHJvcHMsIGExLCBhMikge1xuICAgICAgdmFyIHBhcmVudCA9IFBTRCwgcHNkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgICAgcHNkLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHBzZC5yZWYgPSAwO1xuICAgICAgcHNkLmdsb2JhbCA9IGZhbHNlO1xuICAgICAgcHNkLmlkID0gKyt6b25lX2lkX2NvdW50ZXI7XG4gICAgICBnbG9iYWxQU0QuZW52O1xuICAgICAgcHNkLmVudiA9IHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcbiAgICAgICAgICBQcm9taXNlOiBEZXhpZVByb21pc2UsXG4gICAgICAgICAgUHJvbWlzZVByb3A6IHsgdmFsdWU6IERleGllUHJvbWlzZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgICAgICAgIGFsbDogRGV4aWVQcm9taXNlLmFsbCxcbiAgICAgICAgICByYWNlOiBEZXhpZVByb21pc2UucmFjZSxcbiAgICAgICAgICBhbGxTZXR0bGVkOiBEZXhpZVByb21pc2UuYWxsU2V0dGxlZCxcbiAgICAgICAgICBhbnk6IERleGllUHJvbWlzZS5hbnksXG4gICAgICAgICAgcmVzb2x2ZTogRGV4aWVQcm9taXNlLnJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0OiBEZXhpZVByb21pc2UucmVqZWN0LFxuICAgICAgfSA6IHt9O1xuICAgICAgaWYgKHByb3BzKVxuICAgICAgICAgIGV4dGVuZChwc2QsIHByb3BzKTtcbiAgICAgICsrcGFyZW50LnJlZjtcbiAgICAgIHBzZC5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAtLXRoaXMucGFyZW50LnJlZiB8fCB0aGlzLnBhcmVudC5maW5hbGl6ZSgpO1xuICAgICAgfTtcbiAgICAgIHZhciBydiA9IHVzZVBTRChwc2QsIGZuLCBhMSwgYTIpO1xuICAgICAgaWYgKHBzZC5yZWYgPT09IDApXG4gICAgICAgICAgcHNkLmZpbmFsaXplKCk7XG4gICAgICByZXR1cm4gcnY7XG4gIH1cbiAgZnVuY3Rpb24gaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG4gICAgICBpZiAoIXRhc2suaWQpXG4gICAgICAgICAgdGFzay5pZCA9ICsrdGFza0NvdW50ZXI7XG4gICAgICArK3Rhc2suYXdhaXRzO1xuICAgICAgdGFzay5lY2hvZXMgKz0gWk9ORV9FQ0hPX0xJTUlUO1xuICAgICAgcmV0dXJuIHRhc2suaWQ7XG4gIH1cbiAgZnVuY3Rpb24gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG4gICAgICBpZiAoIXRhc2suYXdhaXRzKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICgtLXRhc2suYXdhaXRzID09PSAwKVxuICAgICAgICAgIHRhc2suaWQgPSAwO1xuICAgICAgdGFzay5lY2hvZXMgPSB0YXNrLmF3YWl0cyAqIFpPTkVfRUNIT19MSU1JVDtcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgoJycgKyBuYXRpdmVQcm9taXNlVGhlbikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpID09PSAtMSkge1xuICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyA9IG5vcDtcbiAgfVxuICBmdW5jdGlvbiBvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMocG9zc2libGVQcm9taXNlKSB7XG4gICAgICBpZiAodGFzay5lY2hvZXMgJiYgcG9zc2libGVQcm9taXNlICYmIHBvc3NpYmxlUHJvbWlzZS5jb25zdHJ1Y3RvciA9PT0gTmF0aXZlUHJvbWlzZSkge1xuICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZS50aGVuKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zc2libGVQcm9taXNlO1xuICB9XG4gIGZ1bmN0aW9uIHpvbmVFbnRlckVjaG8odGFyZ2V0Wm9uZSkge1xuICAgICAgKyt0b3RhbEVjaG9lcztcbiAgICAgIGlmICghdGFzay5lY2hvZXMgfHwgLS10YXNrLmVjaG9lcyA9PT0gMCkge1xuICAgICAgICAgIHRhc2suZWNob2VzID0gdGFzay5hd2FpdHMgPSB0YXNrLmlkID0gMDtcbiAgICAgIH1cbiAgICAgIHpvbmVTdGFjay5wdXNoKFBTRCk7XG4gICAgICBzd2l0Y2hUb1pvbmUodGFyZ2V0Wm9uZSwgdHJ1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gem9uZUxlYXZlRWNobygpIHtcbiAgICAgIHZhciB6b25lID0gem9uZVN0YWNrW3pvbmVTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHpvbmVTdGFjay5wb3AoKTtcbiAgICAgIHN3aXRjaFRvWm9uZSh6b25lLCBmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gc3dpdGNoVG9ab25lKHRhcmdldFpvbmUsIGJFbnRlcmluZ1pvbmUpIHtcbiAgICAgIHZhciBjdXJyZW50Wm9uZSA9IFBTRDtcbiAgICAgIGlmIChiRW50ZXJpbmdab25lID8gdGFzay5lY2hvZXMgJiYgKCF6b25lRWNob2VzKysgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSA6IHpvbmVFY2hvZXMgJiYgKCEtLXpvbmVFY2hvZXMgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSkge1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKGJFbnRlcmluZ1pvbmUgPyB6b25lRW50ZXJFY2hvLmJpbmQobnVsbCwgdGFyZ2V0Wm9uZSkgOiB6b25lTGVhdmVFY2hvKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRab25lID09PSBQU0QpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgUFNEID0gdGFyZ2V0Wm9uZTtcbiAgICAgIGlmIChjdXJyZW50Wm9uZSA9PT0gZ2xvYmFsUFNEKVxuICAgICAgICAgIGdsb2JhbFBTRC5lbnYgPSBzbmFwU2hvdCgpO1xuICAgICAgaWYgKHBhdGNoR2xvYmFsUHJvbWlzZSkge1xuICAgICAgICAgIHZhciBHbG9iYWxQcm9taXNlID0gZ2xvYmFsUFNELmVudi5Qcm9taXNlO1xuICAgICAgICAgIHZhciB0YXJnZXRFbnYgPSB0YXJnZXRab25lLmVudjtcbiAgICAgICAgICBpZiAoY3VycmVudFpvbmUuZ2xvYmFsIHx8IHRhcmdldFpvbmUuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZ2xvYmFsLCAnUHJvbWlzZScsIHRhcmdldEVudi5Qcm9taXNlUHJvcCk7XG4gICAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYWxsID0gdGFyZ2V0RW52LmFsbDtcbiAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yYWNlID0gdGFyZ2V0RW52LnJhY2U7XG4gICAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmVzb2x2ZSA9IHRhcmdldEVudi5yZXNvbHZlO1xuICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJlamVjdCA9IHRhcmdldEVudi5yZWplY3Q7XG4gICAgICAgICAgICAgIGlmICh0YXJnZXRFbnYuYWxsU2V0dGxlZClcbiAgICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCA9IHRhcmdldEVudi5hbGxTZXR0bGVkO1xuICAgICAgICAgICAgICBpZiAodGFyZ2V0RW52LmFueSlcbiAgICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYW55ID0gdGFyZ2V0RW52LmFueTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc25hcFNob3QoKSB7XG4gICAgICB2YXIgR2xvYmFsUHJvbWlzZSA9IF9nbG9iYWwuUHJvbWlzZTtcbiAgICAgIHJldHVybiBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG4gICAgICAgICAgUHJvbWlzZTogR2xvYmFsUHJvbWlzZSxcbiAgICAgICAgICBQcm9taXNlUHJvcDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfZ2xvYmFsLCBcIlByb21pc2VcIiksXG4gICAgICAgICAgYWxsOiBHbG9iYWxQcm9taXNlLmFsbCxcbiAgICAgICAgICByYWNlOiBHbG9iYWxQcm9taXNlLnJhY2UsXG4gICAgICAgICAgYWxsU2V0dGxlZDogR2xvYmFsUHJvbWlzZS5hbGxTZXR0bGVkLFxuICAgICAgICAgIGFueTogR2xvYmFsUHJvbWlzZS5hbnksXG4gICAgICAgICAgcmVzb2x2ZTogR2xvYmFsUHJvbWlzZS5yZXNvbHZlLFxuICAgICAgICAgIHJlamVjdDogR2xvYmFsUHJvbWlzZS5yZWplY3QsXG4gICAgICB9IDoge307XG4gIH1cbiAgZnVuY3Rpb24gdXNlUFNEKHBzZCwgZm4sIGExLCBhMiwgYTMpIHtcbiAgICAgIHZhciBvdXRlclNjb3BlID0gUFNEO1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gZm4oYTEsIGEyLCBhMyk7XG4gICAgICB9XG4gICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBzd2l0Y2hUb1pvbmUob3V0ZXJTY29wZSwgZmFsc2UpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAoZm4sIHpvbmUsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgb3V0ZXJab25lID0gUFNEO1xuICAgICAgICAgIGlmIChwb3NzaWJsZUF3YWl0KVxuICAgICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgIHN3aXRjaFRvWm9uZSh6b25lLCB0cnVlKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclpvbmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgaWYgKGNsZWFudXApXG4gICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgfVxuICBmdW5jdGlvbiBleGVjSW5HbG9iYWxDb250ZXh0KGNiKSB7XG4gICAgICBpZiAoUHJvbWlzZSA9PT0gTmF0aXZlUHJvbWlzZSAmJiB0YXNrLmVjaG9lcyA9PT0gMCkge1xuICAgICAgICAgIGlmICh6b25lRWNob2VzID09PSAwKSB7XG4gICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrKGNiKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICAgIH1cbiAgfVxuICB2YXIgcmVqZWN0aW9uID0gRGV4aWVQcm9taXNlLnJlamVjdDtcblxuICBmdW5jdGlvbiB0ZW1wVHJhbnNhY3Rpb24oZGIsIG1vZGUsIHN0b3JlTmFtZXMsIGZuKSB7XG4gICAgICBpZiAoIWRiLmlkYmRiIHx8ICghZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSAmJiAoIVBTRC5sZXRUaHJvdWdoICYmICFkYi5fdmlwKSkpIHtcbiAgICAgICAgICBpZiAoZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKGRiLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRiLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgICAgICAgIGlmICghZGIuX3N0YXRlLmF1dG9PcGVuKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcbiAgICAgICAgICAgICAgZGIub3BlbigpLmNhdGNoKG5vcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYi5fc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB0ZW1wVHJhbnNhY3Rpb24oZGIsIG1vZGUsIHN0b3JlTmFtZXMsIGZuKTsgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0cmFucy5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID0gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgIGlmIChleC5uYW1lID09PSBlcnJuYW1lcy5JbnZhbGlkU3RhdGUgJiYgZGIuaXNPcGVuKCkgJiYgLS1kYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBOZWVkIHRvIHJlb3BlbiBkYicpO1xuICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoeyBkaXNhYmxlQXV0b09wZW46IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiLm9wZW4oKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlbXBUcmFuc2FjdGlvbihkYiwgbW9kZSwgc3RvcmVOYW1lcywgZm4pOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRyYW5zLl9wcm9taXNlKG1vZGUsIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIFBTRC50cmFucyA9IHRyYW5zO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKHJlc29sdmUsIHJlamVjdCwgdHJhbnMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkd3JpdGUnKVxuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFucy5pZGJ0cmFucy5jb21taXQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICAgIHJldHVybiBtb2RlID09PSAncmVhZG9ubHknID8gcmVzdWx0IDogdHJhbnMuX2NvbXBsZXRpb24udGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXN1bHQ7IH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICB9XG5cbiAgdmFyIERFWElFX1ZFUlNJT04gPSAnNC4zLjAnO1xuICB2YXIgbWF4U3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NTUzNSk7XG4gIHZhciBtaW5LZXkgPSAtSW5maW5pdHk7XG4gIHZhciBJTlZBTElEX0tFWV9BUkdVTUVOVCA9IFwiSW52YWxpZCBrZXkgcHJvdmlkZWQuIEtleXMgbXVzdCBiZSBvZiB0eXBlIHN0cmluZywgbnVtYmVyLCBEYXRlIG9yIEFycmF5PHN0cmluZyB8IG51bWJlciB8IERhdGU+LlwiO1xuICB2YXIgU1RSSU5HX0VYUEVDVEVEID0gXCJTdHJpbmcgZXhwZWN0ZWQuXCI7XG4gIHZhciBjb25uZWN0aW9ucyA9IFtdO1xuICB2YXIgREJOQU1FU19EQiA9ICdfX2RibmFtZXMnO1xuICB2YXIgUkVBRE9OTFkgPSAncmVhZG9ubHknO1xuICB2YXIgUkVBRFdSSVRFID0gJ3JlYWR3cml0ZSc7XG5cbiAgZnVuY3Rpb24gY29tYmluZShmaWx0ZXIxLCBmaWx0ZXIyKSB7XG4gICAgICByZXR1cm4gZmlsdGVyMSA/XG4gICAgICAgICAgZmlsdGVyMiA/XG4gICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpbHRlcjEuYXBwbHkodGhpcywgYXJndW1lbnRzKSAmJiBmaWx0ZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gOlxuICAgICAgICAgICAgICBmaWx0ZXIxIDpcbiAgICAgICAgICBmaWx0ZXIyO1xuICB9XG5cbiAgdmFyIEFueVJhbmdlID0ge1xuICAgICAgdHlwZTogMyAsXG4gICAgICBsb3dlcjogLUluZmluaXR5LFxuICAgICAgbG93ZXJPcGVuOiBmYWxzZSxcbiAgICAgIHVwcGVyOiBbW11dLFxuICAgICAgdXBwZXJPcGVuOiBmYWxzZVxuICB9O1xuXG4gIGZ1bmN0aW9uIHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpIHtcbiAgICAgIHJldHVybiB0eXBlb2Yga2V5UGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAhL1xcLi8udGVzdChrZXlQYXRoKVxuICAgICAgICAgID8gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICBpZiAob2JqW2tleVBhdGhdID09PSB1bmRlZmluZWQgJiYgKGtleVBhdGggaW4gb2JqKSkge1xuICAgICAgICAgICAgICAgICAgb2JqID0gZGVlcENsb25lKG9iaik7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleVBhdGhdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgfVxuICAgICAgICAgIDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqOyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gRW50aXR5KCkge1xuICAgICAgdGhyb3cgZXhjZXB0aW9ucy5UeXBlKFwiRW50aXR5IGluc3RhbmNlcyBtdXN0IG5ldmVyIGJlIG5ldzplZC4gSW5zdGFuY2VzIGFyZSBnZW5lcmF0ZWQgYnkgdGhlIGZyYW1ld29yayBieXBhc3NpbmcgdGhlIGNvbnN0cnVjdG9yLlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNtcChhLCBiKSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIHZhciB0YSA9IHR5cGUoYSk7XG4gICAgICAgICAgdmFyIHRiID0gdHlwZShiKTtcbiAgICAgICAgICBpZiAodGEgIT09IHRiKSB7XG4gICAgICAgICAgICAgIGlmICh0YSA9PT0gJ0FycmF5JylcbiAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICBpZiAodGIgPT09ICdBcnJheScpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgIGlmICh0YSA9PT0gJ2JpbmFyeScpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgaWYgKHRiID09PSAnYmluYXJ5JylcbiAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgaWYgKHRhID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICBpZiAodGIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICBpZiAodGEgPT09ICdEYXRlJylcbiAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICBpZiAodGIgIT09ICdEYXRlJylcbiAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoICh0YSkge1xuICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbiAgICAgICAgICAgICAgY2FzZSAnYmluYXJ5Jzoge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVVaW50OEFycmF5cyhnZXRVaW50OEFycmF5KGEpLCBnZXRVaW50OEFycmF5KGIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZUFycmF5cyhhLCBiKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgfVxuICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGEsIGIpIHtcbiAgICAgIHZhciBhbCA9IGEubGVuZ3RoO1xuICAgICAgdmFyIGJsID0gYi5sZW5ndGg7XG4gICAgICB2YXIgbCA9IGFsIDwgYmwgPyBhbCA6IGJsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICB2YXIgcmVzID0gY21wKGFbaV0sIGJbaV0pO1xuICAgICAgICAgIGlmIChyZXMgIT09IDApXG4gICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWwgPT09IGJsID8gMCA6IGFsIDwgYmwgPyAtMSA6IDE7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGFyZVVpbnQ4QXJyYXlzKGEsIGIpIHtcbiAgICAgIHZhciBhbCA9IGEubGVuZ3RoO1xuICAgICAgdmFyIGJsID0gYi5sZW5ndGg7XG4gICAgICB2YXIgbCA9IGFsIDwgYmwgPyBhbCA6IGJsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSlcbiAgICAgICAgICAgICAgcmV0dXJuIGFbaV0gPCBiW2ldID8gLTEgOiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsID09PSBibCA/IDAgOiBhbCA8IGJsID8gLTEgOiAxO1xuICB9XG4gIGZ1bmN0aW9uIHR5cGUoeCkge1xuICAgICAgdmFyIHQgPSB0eXBlb2YgeDtcbiAgICAgIGlmICh0ICE9PSAnb2JqZWN0JylcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoeCkpXG4gICAgICAgICAgcmV0dXJuICdiaW5hcnknO1xuICAgICAgdmFyIHRzVGFnID0gdG9TdHJpbmdUYWcoeCk7XG4gICAgICByZXR1cm4gdHNUYWcgPT09ICdBcnJheUJ1ZmZlcicgPyAnYmluYXJ5JyA6IHRzVGFnO1xuICB9XG4gIGZ1bmN0aW9uIGdldFVpbnQ4QXJyYXkoYSkge1xuICAgICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhhKSlcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWx0SW5EZWxldGlvblRyaWdnZXIodGFibGUsIGtleXMsIHJlcykge1xuICAgICAgdmFyIHlQcm9wcyA9IHRhYmxlLnNjaGVtYS55UHJvcHM7XG4gICAgICBpZiAoIXlQcm9wcylcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgaWYgKGtleXMgJiYgcmVzLm51bUZhaWx1cmVzID4gMClcbiAgICAgICAgICBrZXlzID0ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuICFyZXMuZmFpbHVyZXNbaV07IH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHlQcm9wcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgdmFyIHVwZGF0ZXNUYWJsZSA9IF9hLnVwZGF0ZXNUYWJsZTtcbiAgICAgICAgICByZXR1cm4ga2V5c1xuICAgICAgICAgICAgICA/IHRhYmxlLmRiLnRhYmxlKHVwZGF0ZXNUYWJsZSkud2hlcmUoJ2snKS5hbnlPZihrZXlzKS5kZWxldGUoKVxuICAgICAgICAgICAgICA6IHRhYmxlLmRiLnRhYmxlKHVwZGF0ZXNUYWJsZSkuY2xlYXIoKTtcbiAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlczsgfSk7XG4gIH1cblxuICB2YXIgUHJvcE1vZGlmaWNhdGlvbiA9ICAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUHJvcE1vZGlmaWNhdGlvbihzcGVjKSB7XG4gICAgICAgICAgdGhpc1tcIkBAcHJvcG1vZFwiXSA9IHNwZWM7XG4gICAgICB9XG4gICAgICBQcm9wTW9kaWZpY2F0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHZhciBzcGVjID0gdGhpc1tcIkBAcHJvcG1vZFwiXTtcbiAgICAgICAgICBpZiAoc3BlYy5hZGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgdGVybSA9IHNwZWMuYWRkO1xuICAgICAgICAgICAgICBpZiAoaXNBcnJheSh0ZXJtKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgKGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSksIHRydWUpLCB0ZXJtLCB0cnVlKS5zb3J0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXJtID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoTnVtYmVyKHZhbHVlKSB8fCAwKSArIHRlcm07XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVybSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkgKyB0ZXJtO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgwKSArIHRlcm07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGVybSBcIi5jb25jYXQodGVybSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3BlYy5yZW1vdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgc3VidHJhaGVuZF8xID0gc3BlYy5yZW1vdmU7XG4gICAgICAgICAgICAgIGlmIChpc0FycmF5KHN1YnRyYWhlbmRfMSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gIXN1YnRyYWhlbmRfMS5pbmNsdWRlcyhpdGVtKTsgfSkuc29ydCgpIDogW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJ0cmFoZW5kXzEgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgLSBzdWJ0cmFoZW5kXzE7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3VidHJhaGVuZF8xID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKSAtIHN1YnRyYWhlbmRfMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhdGNoIChfYykge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQoMCkgLSBzdWJ0cmFoZW5kXzE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3VidHJhaGVuZCBcIi5jb25jYXQoc3VidHJhaGVuZF8xKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwcmVmaXhUb1JlcGxhY2UgPSAoX2EgPSBzcGVjLnJlcGxhY2VQcmVmaXgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgICAgICAgICBpZiAocHJlZml4VG9SZXBsYWNlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuc3RhcnRzV2l0aChwcmVmaXhUb1JlcGxhY2UpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzcGVjLnJlcGxhY2VQcmVmaXhbMV0gKyB2YWx1ZS5zdWJzdHJpbmcocHJlZml4VG9SZXBsYWNlLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUHJvcE1vZGlmaWNhdGlvbjtcbiAgfSgpKTtcblxuICBmdW5jdGlvbiBhcHBseVVwZGF0ZVNwZWMob2JqLCBjaGFuZ2VzKSB7XG4gICAgICB2YXIga2V5UGF0aHMgPSBrZXlzKGNoYW5nZXMpO1xuICAgICAgdmFyIG51bUtleXMgPSBrZXlQYXRocy5sZW5ndGg7XG4gICAgICB2YXIgYW55dGhpbmdNb2RpZmllZCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICAgICAgICB2YXIga2V5UGF0aCA9IGtleVBhdGhzW2ldO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNoYW5nZXNba2V5UGF0aF07XG4gICAgICAgICAgdmFyIG9yaWdWYWx1ZSA9IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb3BNb2RpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdmFsdWUuZXhlY3V0ZShvcmlnVmFsdWUpKTtcbiAgICAgICAgICAgICAgYW55dGhpbmdNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKG9yaWdWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICBhbnl0aGluZ01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYW55dGhpbmdNb2RpZmllZDtcbiAgfVxuXG4gIHZhciBUYWJsZSA9ICAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGFibGUoKSB7XG4gICAgICB9XG4gICAgICBUYWJsZS5wcm90b3R5cGUuX3RyYW5zID0gZnVuY3Rpb24gKG1vZGUsIGZuLCB3cml0ZUxvY2tlZCkge1xuICAgICAgICAgIHZhciB0cmFucyA9IHRoaXMuX3R4IHx8IFBTRC50cmFucztcbiAgICAgICAgICB2YXIgdGFibGVOYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgIHZhciB0YXNrID0gZGVidWcgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuY3JlYXRlVGFzayAmJiBjb25zb2xlLmNyZWF0ZVRhc2soXCJEZXhpZTogXCIuY29uY2F0KG1vZGUgPT09ICdyZWFkb25seScgPyAncmVhZCcgOiAnd3JpdGUnLCBcIiBcIikuY29uY2F0KHRoaXMubmFtZSkpO1xuICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uKHJlc29sdmUsIHJlamVjdCwgdHJhbnMpIHtcbiAgICAgICAgICAgICAgaWYgKCF0cmFucy5zY2hlbWFbdGFibGVOYW1lXSlcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk5vdEZvdW5kKFwiVGFibGUgXCIgKyB0YWJsZU5hbWUgKyBcIiBub3QgcGFydCBvZiB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZuKHRyYW5zLmlkYnRyYW5zLCB0cmFucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB3YXNSb290RXhlYyA9IGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgcCA9IHRyYW5zICYmIHRyYW5zLmRiLl9ub3ZpcCA9PT0gdGhpcy5kYi5fbm92aXAgP1xuICAgICAgICAgICAgICAgICAgdHJhbnMgPT09IFBTRC50cmFucyA/XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnMuX3Byb21pc2UobW9kZSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24sIHdyaXRlTG9ja2VkKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnMuX3Byb21pc2UobW9kZSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24sIHdyaXRlTG9ja2VkKTsgfSwgeyB0cmFuczogdHJhbnMsIHRyYW5zbGVzczogUFNELnRyYW5zbGVzcyB8fCBQU0QgfSkgOlxuICAgICAgICAgICAgICAgICAgdGVtcFRyYW5zYWN0aW9uKHRoaXMuZGIsIG1vZGUsIFt0aGlzLm5hbWVdLCBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgICBwLl9jb25zb2xlVGFzayA9IHRhc2s7XG4gICAgICAgICAgICAgICAgICBwID0gcC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS50cmFjZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXJyKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKHdhc1Jvb3RFeGVjKVxuICAgICAgICAgICAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXlPckNyaXQsIGNiKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAoa2V5T3JDcml0ICYmIGtleU9yQ3JpdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShrZXlPckNyaXQpLmZpcnN0KGNiKTtcbiAgICAgICAgICBpZiAoa2V5T3JDcml0ID09IG51bGwpXG4gICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuVHlwZShcIkludmFsaWQgYXJndW1lbnQgdG8gVGFibGUuZ2V0KClcIikpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZG9ubHknLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvcmUuZ2V0KHsgdHJhbnM6IHRyYW5zLCBrZXk6IGtleU9yQ3JpdCB9KVxuICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gX3RoaXMuaG9vay5yZWFkaW5nLmZpcmUocmVzKTsgfSk7XG4gICAgICAgICAgfSkudGhlbihjYik7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLndoZXJlID0gZnVuY3Rpb24gKGluZGV4T3JDcml0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE9yQ3JpdCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBpbmRleE9yQ3JpdCk7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoaW5kZXhPckNyaXQpKVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgXCJbXCIuY29uY2F0KGluZGV4T3JDcml0LmpvaW4oJysnKSwgXCJdXCIpKTtcbiAgICAgICAgICB2YXIga2V5UGF0aHMgPSBrZXlzKGluZGV4T3JDcml0KTtcbiAgICAgICAgICBpZiAoa2V5UGF0aHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgICAgLndoZXJlKGtleVBhdGhzWzBdKVxuICAgICAgICAgICAgICAgICAgLmVxdWFscyhpbmRleE9yQ3JpdFtrZXlQYXRoc1swXV0pO1xuICAgICAgICAgIHZhciBjb21wb3VuZEluZGV4ID0gdGhpcy5zY2hlbWEuaW5kZXhlcy5jb25jYXQodGhpcy5zY2hlbWEucHJpbUtleSkuZmlsdGVyKGZ1bmN0aW9uIChpeCkge1xuICAgICAgICAgICAgICBpZiAoaXguY29tcG91bmQgJiZcbiAgICAgICAgICAgICAgICAgIGtleVBhdGhzLmV2ZXJ5KGZ1bmN0aW9uIChrZXlQYXRoKSB7IHJldHVybiBpeC5rZXlQYXRoLmluZGV4T2Yoa2V5UGF0aCkgPj0gMDsgfSkpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5UGF0aHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aHMuaW5kZXhPZihpeC5rZXlQYXRoW2ldKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmtleVBhdGgubGVuZ3RoIC0gYi5rZXlQYXRoLmxlbmd0aDsgfSlbMF07XG4gICAgICAgICAgaWYgKGNvbXBvdW5kSW5kZXggJiYgdGhpcy5kYi5fbWF4S2V5ICE9PSBtYXhTdHJpbmcpIHtcbiAgICAgICAgICAgICAgdmFyIGtleVBhdGhzSW5WYWxpZE9yZGVyID0gY29tcG91bmRJbmRleC5rZXlQYXRoLnNsaWNlKDAsIGtleVBhdGhzLmxlbmd0aCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgICAud2hlcmUoa2V5UGF0aHNJblZhbGlkT3JkZXIpXG4gICAgICAgICAgICAgICAgICAuZXF1YWxzKGtleVBhdGhzSW5WYWxpZE9yZGVyLm1hcChmdW5jdGlvbiAoa3ApIHsgcmV0dXJuIGluZGV4T3JDcml0W2twXTsgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvbXBvdW5kSW5kZXggJiYgZGVidWcpXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBxdWVyeSBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoaW5kZXhPckNyaXQpLCBcIiBvbiBcIikuY29uY2F0KHRoaXMubmFtZSwgXCIgd291bGQgYmVuZWZpdCBmcm9tIGEgXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiY29tcG91bmQgaW5kZXggW1wiLmNvbmNhdChrZXlQYXRocy5qb2luKCcrJyksIFwiXVwiKSk7XG4gICAgICAgICAgdmFyIGlkeEJ5TmFtZSA9IHRoaXMuc2NoZW1hLmlkeEJ5TmFtZTtcbiAgICAgICAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gY21wKGEsIGIpID09PSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgX2EgPSBrZXlQYXRocy5yZWR1Y2UoZnVuY3Rpb24gKF9hLCBrZXlQYXRoKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBfYVswXSwgcHJldkZpbHRlckZuID0gX2FbMV07XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IGlkeEJ5TmFtZVtrZXlQYXRoXTtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaW5kZXhPckNyaXRba2V5UGF0aF07XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICBwcmV2SW5kZXggfHwgaW5kZXgsXG4gICAgICAgICAgICAgICAgICBwcmV2SW5kZXggfHwgIWluZGV4ID9cbiAgICAgICAgICAgICAgICAgICAgICBjb21iaW5lKHByZXZGaWx0ZXJGbiwgaW5kZXggJiYgaW5kZXgubXVsdGkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBnZXRCeUtleVBhdGgoeCwga2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBcnJheShwcm9wKSAmJiBwcm9wLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGVxdWFscyh2YWx1ZSwgaXRlbSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGVxdWFscyh2YWx1ZSwgZ2V0QnlLZXlQYXRoKHgsIGtleVBhdGgpKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICA6IHByZXZGaWx0ZXJGblxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgIH0sIFtudWxsLCBudWxsXSksIGlkeCA9IF9hWzBdLCBmaWx0ZXJGdW5jdGlvbiA9IF9hWzFdO1xuICAgICAgICAgIHJldHVybiBpZHggP1xuICAgICAgICAgICAgICB0aGlzLndoZXJlKGlkeC5uYW1lKS5lcXVhbHMoaW5kZXhPckNyaXRbaWR4LmtleVBhdGhdKVxuICAgICAgICAgICAgICAgICAgLmZpbHRlcihmaWx0ZXJGdW5jdGlvbikgOlxuICAgICAgICAgICAgICBjb21wb3VuZEluZGV4ID9cbiAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyKGZpbHRlckZ1bmN0aW9uKSA6XG4gICAgICAgICAgICAgICAgICB0aGlzLndoZXJlKGtleVBhdGhzKS5lcXVhbHMoJycpO1xuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5hbmQoZmlsdGVyRnVuY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICh0aGVuU2hvcnRjdXQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5jb3VudCh0aGVuU2hvcnRjdXQpO1xuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkub2Zmc2V0KG9mZnNldCk7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLmxpbWl0ID0gZnVuY3Rpb24gKG51bVJvd3MpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5saW1pdChudW1Sb3dzKTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmVhY2goY2FsbGJhY2spO1xuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKHRoZW5TaG9ydGN1dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLnRvQXJyYXkodGhlblNob3J0Y3V0KTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUudG9Db2xsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5Db2xsZWN0aW9uKG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMpKTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUub3JkZXJCeSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5Db2xsZWN0aW9uKG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGlzQXJyYXkoaW5kZXgpID9cbiAgICAgICAgICAgICAgXCJbXCIuY29uY2F0KGluZGV4LmpvaW4oJysnKSwgXCJdXCIpIDpcbiAgICAgICAgICAgICAgaW5kZXgpKTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLm1hcFRvQ2xhc3MgPSBmdW5jdGlvbiAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBkYiA9IF9hLmRiLCB0YWJsZU5hbWUgPSBfYS5uYW1lO1xuICAgICAgICAgIHRoaXMuc2NoZW1hLm1hcHBlZENsYXNzID0gY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKGNvbnN0cnVjdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIEVudGl0eSkge1xuICAgICAgICAgICAgICBjb25zdHJ1Y3RvciA9ICAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJkYlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYjsgfSxcbiAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0YWJsZU5hbWU7IH07XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICAgICAgICAgICAgfShjb25zdHJ1Y3RvcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5oZXJpdGVkUHJvcHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgZm9yICh2YXIgcHJvdG8gPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7IHByb3RvOyBwcm90byA9IGdldFByb3RvKHByb3RvKSkge1xuICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHsgcmV0dXJuIGluaGVyaXRlZFByb3BzLmFkZChwcm9wTmFtZSk7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVhZEhvb2sgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUoY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBvYmopXG4gICAgICAgICAgICAgICAgICBpZiAoIWluaGVyaXRlZFByb3BzLmhhcyhtKSlcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXNbbV0gPSBvYmpbbV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICh0aGlzLnNjaGVtYS5yZWFkSG9vaykge1xuICAgICAgICAgICAgICB0aGlzLmhvb2sucmVhZGluZy51bnN1YnNjcmliZSh0aGlzLnNjaGVtYS5yZWFkSG9vayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2NoZW1hLnJlYWRIb29rID0gcmVhZEhvb2s7XG4gICAgICAgICAgdGhpcy5ob29rKFwicmVhZGluZ1wiLCByZWFkSG9vayk7XG4gICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS5kZWZpbmVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmdW5jdGlvbiBDbGFzcyhjb250ZW50KSB7XG4gICAgICAgICAgICAgIGV4dGVuZCh0aGlzLCBjb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFwVG9DbGFzcyhDbGFzcyk7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIF9hID0gdGhpcy5zY2hlbWEucHJpbUtleSwgYXV0byA9IF9hLmF1dG8sIGtleVBhdGggPSBfYS5rZXlQYXRoO1xuICAgICAgICAgIHZhciBvYmpUb0FkZCA9IG9iajtcbiAgICAgICAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG4gICAgICAgICAgICAgIG9ialRvQWRkID0gd29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkob2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAnYWRkJywga2V5czoga2V5ICE9IG51bGwgPyBba2V5XSA6IG51bGwsIHZhbHVlczogW29ialRvQWRkXSB9KTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHJlcy5sYXN0UmVzdWx0OyB9KVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAoa2V5UGF0aCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCBsYXN0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUudXBzZXJ0ID0gZnVuY3Rpb24gKGtleSwgbW9kaWZpY2F0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGtleVBhdGggPSB0aGlzLnNjaGVtYS5wcmltS2V5LmtleVBhdGg7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvcmUuZ2V0KHsgdHJhbnM6IHRyYW5zLCBrZXk6IGtleSB9KS50aGVuKGZ1bmN0aW9uIChleGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IGV4aXN0aW5nICE9PSBudWxsICYmIGV4aXN0aW5nICE9PSB2b2lkIDAgPyBleGlzdGluZyA6IHt9O1xuICAgICAgICAgICAgICAgICAgYXBwbHlVcGRhdGVTcGVjKG9iaiwgbW9kaWZpY2F0aW9ucyk7XG4gICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aClcbiAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBbb2JqXSxcbiAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICB1cHNlcnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgdXBkYXRlczogeyBrZXlzOiBba2V5XSwgY2hhbmdlU3BlY3M6IFttb2RpZmljYXRpb25zXSB9XG4gICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6ICEhZXhpc3Rpbmc7IH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGtleU9yT2JqZWN0LCBtb2RpZmljYXRpb25zKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXlPck9iamVjdCA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXkoa2V5T3JPYmplY3QpKSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBnZXRCeUtleVBhdGgoa2V5T3JPYmplY3QsIHRoaXMuc2NoZW1hLnByaW1LZXkua2V5UGF0aCk7XG4gICAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiR2l2ZW4gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gaXRzIHByaW1hcnkga2V5XCIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoXCI6aWRcIikuZXF1YWxzKGtleSkubW9kaWZ5KG1vZGlmaWNhdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoXCI6aWRcIikuZXF1YWxzKGtleU9yT2JqZWN0KS5tb2RpZnkobW9kaWZpY2F0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBfYSA9IHRoaXMuc2NoZW1hLnByaW1LZXksIGF1dG8gPSBfYS5hdXRvLCBrZXlQYXRoID0gX2Eua2V5UGF0aDtcbiAgICAgICAgICB2YXIgb2JqVG9BZGQgPSBvYmo7XG4gICAgICAgICAgaWYgKGtleVBhdGggJiYgYXV0bykge1xuICAgICAgICAgICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7IHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ3B1dCcsIHZhbHVlczogW29ialRvQWRkXSwga2V5czoga2V5ICE9IG51bGwgPyBba2V5XSA6IG51bGwgfSk7IH0pXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHJlcy5sYXN0UmVzdWx0OyB9KVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAoa2V5UGF0aCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCBsYXN0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHsgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAnZGVsZXRlJywga2V5czogW2tleV0gfSlcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gYnVpbHRJbkRlbGV0aW9uVHJpZ2dlcihfdGhpcywgW2tleV0sIHJlcyk7IH0pXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHVuZGVmaW5lZDsgfSk7IH0pO1xuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7IHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IEFueVJhbmdlIH0pXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIGJ1aWx0SW5EZWxldGlvblRyaWdnZXIoX3RoaXMsIG51bGwsIHJlcyk7IH0pOyB9KVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiB1bmRlZmluZWQ7IH0pO1xuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS5idWxrR2V0ID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZG9ubHknLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvcmUuZ2V0TWFueSh7XG4gICAgICAgICAgICAgICAgICBrZXlzOiBrZXlzLFxuICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zXG4gICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0Lm1hcChmdW5jdGlvbiAocmVzKSB7IHJldHVybiBfdGhpcy5ob29rLnJlYWRpbmcuZmlyZShyZXMpOyB9KTsgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVGFibGUucHJvdG90eXBlLmJ1bGtBZGQgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5c09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGtleXMgPSBBcnJheS5pc0FycmF5KGtleXNPck9wdGlvbnMpID8ga2V5c09yT3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCAoa2V5cyA/IHVuZGVmaW5lZCA6IGtleXNPck9wdGlvbnMpO1xuICAgICAgICAgIHZhciB3YW50UmVzdWx0cyA9IG9wdGlvbnMgPyBvcHRpb25zLmFsbEtleXMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuc2NoZW1hLnByaW1LZXksIGF1dG8gPSBfYS5hdXRvLCBrZXlQYXRoID0gX2Eua2V5UGF0aDtcbiAgICAgICAgICAgICAgaWYgKGtleVBhdGggJiYga2V5cylcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtBZGQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgICAgICAgICAgaWYgKGtleXMgJiYga2V5cy5sZW5ndGggIT09IG9iamVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG9iamVjdHMgYW5kIGtleXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgICAgICAgICAgICAgdmFyIG51bU9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgICAgICAgICAgdmFyIG9iamVjdHNUb0FkZCA9IGtleVBhdGggJiYgYXV0byA/XG4gICAgICAgICAgICAgICAgICBvYmplY3RzLm1hcCh3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKSkgOlxuICAgICAgICAgICAgICAgICAgb2JqZWN0cztcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAnYWRkJywga2V5czoga2V5cywgdmFsdWVzOiBvYmplY3RzVG9BZGQsIHdhbnRSZXN1bHRzOiB3YW50UmVzdWx0cyB9KVxuICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgcmVzdWx0cyA9IF9hLnJlc3VsdHMsIGxhc3RSZXN1bHQgPSBfYS5sYXN0UmVzdWx0LCBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHdhbnRSZXN1bHRzID8gcmVzdWx0cyA6IGxhc3RSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCIuYnVsa0FkZCgpOiBcIikuY29uY2F0KG51bUZhaWx1cmVzLCBcIiBvZiBcIikuY29uY2F0KG51bU9iamVjdHMsIFwiIG9wZXJhdGlvbnMgZmFpbGVkXCIpLCBmYWlsdXJlcyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFRhYmxlLnByb3RvdHlwZS5idWxrUHV0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleXNPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBrZXlzID0gQXJyYXkuaXNBcnJheShrZXlzT3JPcHRpb25zKSA/IGtleXNPck9wdGlvbnMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgKGtleXMgPyB1bmRlZmluZWQgOiBrZXlzT3JPcHRpb25zKTtcbiAgICAgICAgICB2YXIgd2FudFJlc3VsdHMgPSBvcHRpb25zID8gb3B0aW9ucy5hbGxLZXlzIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnNjaGVtYS5wcmltS2V5LCBhdXRvID0gX2EuYXV0bywga2V5UGF0aCA9IF9hLmtleVBhdGg7XG4gICAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJidWxrUHV0KCk6IGtleXMgYXJndW1lbnQgaW52YWxpZCBvbiB0YWJsZXMgd2l0aCBpbmJvdW5kIGtleXNcIik7XG4gICAgICAgICAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgICAgICAgIHZhciBudW1PYmplY3RzID0gb2JqZWN0cy5sZW5ndGg7XG4gICAgICAgICAgICAgIHZhciBvYmplY3RzVG9QdXQgPSBrZXlQYXRoICYmIGF1dG8gP1xuICAgICAgICAgICAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgICAgICAgICAgIG9iamVjdHM7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ3B1dCcsIGtleXM6IGtleXMsIHZhbHVlczogb2JqZWN0c1RvUHV0LCB3YW50UmVzdWx0czogd2FudFJlc3VsdHMgfSlcbiAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG51bUZhaWx1cmVzID0gX2EubnVtRmFpbHVyZXMsIHJlc3VsdHMgPSBfYS5yZXN1bHRzLCBsYXN0UmVzdWx0ID0gX2EubGFzdFJlc3VsdCwgZmFpbHVyZXMgPSBfYS5mYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB3YW50UmVzdWx0cyA/IHJlc3VsdHMgOiBsYXN0UmVzdWx0O1xuICAgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLmJ1bGtQdXQoKTogXCIpLmNvbmNhdChudW1GYWlsdXJlcywgXCIgb2YgXCIpLmNvbmNhdChudW1PYmplY3RzLCBcIiBvcGVyYXRpb25zIGZhaWxlZFwiKSwgZmFpbHVyZXMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa1VwZGF0ZSA9IGZ1bmN0aW9uIChrZXlzQW5kQ2hhbmdlcykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGNvcmVUYWJsZSA9IHRoaXMuY29yZTtcbiAgICAgICAgICB2YXIga2V5cyA9IGtleXNBbmRDaGFuZ2VzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LmtleTsgfSk7XG4gICAgICAgICAgdmFyIGNoYW5nZVNwZWNzID0ga2V5c0FuZENoYW5nZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkuY2hhbmdlczsgfSk7XG4gICAgICAgICAgdmFyIG9mZnNldE1hcCA9IFtdO1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb3JlVGFibGUuZ2V0TWFueSh7IHRyYW5zOiB0cmFucywga2V5czoga2V5cywgY2FjaGU6ICdjbG9uZScgfSkudGhlbihmdW5jdGlvbiAob2Jqcykge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdEtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRPYmpzID0gW107XG4gICAgICAgICAgICAgICAgICBrZXlzQW5kQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9hLmtleSwgY2hhbmdlcyA9IF9hLmNoYW5nZXM7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IG9ianNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2IgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKTsgX2kgPCBfYi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gX2JbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2hhbmdlc1trZXlQYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoID09PSBfdGhpcy5zY2hlbWEucHJpbUtleS5rZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNtcCh2YWx1ZSwga2V5KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Db25zdHJhaW50KFwiQ2Fubm90IHVwZGF0ZSBwcmltYXJ5IGtleSBpbiBidWxrVXBkYXRlKClcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldE1hcC5wdXNoKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpzLnB1c2gob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHZhciBudW1FbnRyaWVzID0gcmVzdWx0S2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29yZVRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwdXQnLFxuICAgICAgICAgICAgICAgICAgICAgIGtleXM6IHJlc3VsdEtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiByZXN1bHRPYmpzLFxuICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlU3BlY3M6IGNoYW5nZVNwZWNzXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgZmFpbHVyZXMgPSBfYS5mYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1FbnRyaWVzO1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2IgPSBPYmplY3Qua2V5cyhmYWlsdXJlcyk7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBfYltfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBwZWRPZmZzZXQgPSBvZmZzZXRNYXBbTnVtYmVyKG9mZnNldCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwcGVkT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlID0gZmFpbHVyZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmYWlsdXJlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXNbbWFwcGVkT2Zmc2V0XSA9IGZhaWx1cmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi5idWxrVXBkYXRlKCk6IFwiKS5jb25jYXQobnVtRmFpbHVyZXMsIFwiIG9mIFwiKS5jb25jYXQobnVtRW50cmllcywgXCIgb3BlcmF0aW9ucyBmYWlsZWRcIiksIGZhaWx1cmVzKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa0RlbGV0ZSA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2RlbGV0ZScsIGtleXM6IGtleXMgfSlcbiAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIGJ1aWx0SW5EZWxldGlvblRyaWdnZXIoX3RoaXMsIGtleXMsIHJlcyk7IH0pO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgIHZhciBudW1GYWlsdXJlcyA9IF9hLm51bUZhaWx1cmVzLCBsYXN0UmVzdWx0ID0gX2EubGFzdFJlc3VsdCwgZmFpbHVyZXMgPSBfYS5mYWlsdXJlcztcbiAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCIuYnVsa0RlbGV0ZSgpOiBcIikuY29uY2F0KG51bUZhaWx1cmVzLCBcIiBvZiBcIikuY29uY2F0KG51bUtleXMsIFwiIG9wZXJhdGlvbnMgZmFpbGVkXCIpLCBmYWlsdXJlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFRhYmxlO1xuICB9KCkpO1xuXG4gIGZ1bmN0aW9uIEV2ZW50cyhjdHgpIHtcbiAgICAgIHZhciBldnMgPSB7fTtcbiAgICAgIHZhciBydiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgICBpZiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSAtIDEpO1xuICAgICAgICAgICAgICB3aGlsZSAoLS1pKVxuICAgICAgICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgIGV2c1tldmVudE5hbWVdLnN1YnNjcmliZS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIChldmVudE5hbWUpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gZXZzW2V2ZW50TmFtZV07XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJ2LmFkZEV2ZW50VHlwZSA9IGFkZDtcbiAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgIGFkZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2O1xuICAgICAgZnVuY3Rpb24gYWRkKGV2ZW50TmFtZSwgY2hhaW5GdW5jdGlvbiwgZGVmYXVsdEZ1bmN0aW9uKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICByZXR1cm4gYWRkQ29uZmlndXJlZEV2ZW50cyhldmVudE5hbWUpO1xuICAgICAgICAgIGlmICghY2hhaW5GdW5jdGlvbilcbiAgICAgICAgICAgICAgY2hhaW5GdW5jdGlvbiA9IHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluO1xuICAgICAgICAgIGlmICghZGVmYXVsdEZ1bmN0aW9uKVxuICAgICAgICAgICAgICBkZWZhdWx0RnVuY3Rpb24gPSBub3A7XG4gICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgICAgICAgZmlyZTogZGVmYXVsdEZ1bmN0aW9uLFxuICAgICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc3Vic2NyaWJlcnMuaW5kZXhPZihjYikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycy5wdXNoKGNiKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjaGFpbkZ1bmN0aW9uKGNvbnRleHQuZmlyZSwgY2IpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzID0gY29udGV4dC5zdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbiAhPT0gY2I7IH0pO1xuICAgICAgICAgICAgICAgICAgY29udGV4dC5maXJlID0gY29udGV4dC5zdWJzY3JpYmVycy5yZWR1Y2UoY2hhaW5GdW5jdGlvbiwgZGVmYXVsdEZ1bmN0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgZXZzW2V2ZW50TmFtZV0gPSBydltldmVudE5hbWVdID0gY29udGV4dDtcbiAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGFkZENvbmZpZ3VyZWRFdmVudHMoY2ZnKSB7XG4gICAgICAgICAga2V5cyhjZmcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IGNmZ1tldmVudE5hbWVdO1xuICAgICAgICAgICAgICBpZiAoaXNBcnJheShhcmdzKSkge1xuICAgICAgICAgICAgICAgICAgYWRkKGV2ZW50TmFtZSwgY2ZnW2V2ZW50TmFtZV1bMF0sIGNmZ1tldmVudE5hbWVdWzFdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChhcmdzID09PSAnYXNhcCcpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gYWRkKGV2ZW50TmFtZSwgbWlycm9yLCBmdW5jdGlvbiBmaXJlKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXNhcCQxKGZ1bmN0aW9uIGZpcmVFdmVudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgZXZlbnQgY29uZmlnXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZUNsYXNzQ29uc3RydWN0b3IocHJvdG90eXBlLCBjb25zdHJ1Y3Rvcikge1xuICAgICAgZGVyaXZlKGNvbnN0cnVjdG9yKS5mcm9tKHsgcHJvdG90eXBlOiBwcm90b3R5cGUgfSk7XG4gICAgICByZXR1cm4gY29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVUYWJsZUNvbnN0cnVjdG9yKGRiKSB7XG4gICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVGFibGUucHJvdG90eXBlLCBmdW5jdGlvbiBUYWJsZShuYW1lLCB0YWJsZVNjaGVtYSwgdHJhbnMpIHtcbiAgICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgICAgdGhpcy5fdHggPSB0cmFucztcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuc2NoZW1hID0gdGFibGVTY2hlbWE7XG4gICAgICAgICAgdGhpcy5ob29rID0gZGIuX2FsbFRhYmxlc1tuYW1lXSA/IGRiLl9hbGxUYWJsZXNbbmFtZV0uaG9vayA6IEV2ZW50cyhudWxsLCB7XG4gICAgICAgICAgICAgIFwiY3JlYXRpbmdcIjogW2hvb2tDcmVhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICAgICAgICBcInJlYWRpbmdcIjogW3B1cmVGdW5jdGlvbkNoYWluLCBtaXJyb3JdLFxuICAgICAgICAgICAgICBcInVwZGF0aW5nXCI6IFtob29rVXBkYXRpbmdDaGFpbiwgbm9wXSxcbiAgICAgICAgICAgICAgXCJkZWxldGluZ1wiOiBbaG9va0RlbGV0aW5nQ2hhaW4sIG5vcF1cbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQbGFpbktleVJhbmdlKGN0eCwgaWdub3JlTGltaXRGaWx0ZXIpIHtcbiAgICAgIHJldHVybiAhKGN0eC5maWx0ZXIgfHwgY3R4LmFsZ29yaXRobSB8fCBjdHgub3IpICYmXG4gICAgICAgICAgKGlnbm9yZUxpbWl0RmlsdGVyID8gY3R4Lmp1c3RMaW1pdCA6ICFjdHgucmVwbGF5RmlsdGVyKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRGaWx0ZXIoY3R4LCBmbikge1xuICAgICAgY3R4LmZpbHRlciA9IGNvbWJpbmUoY3R4LmZpbHRlciwgZm4pO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFJlcGxheUZpbHRlcihjdHgsIGZhY3RvcnksIGlzTGltaXRGaWx0ZXIpIHtcbiAgICAgIHZhciBjdXJyID0gY3R4LnJlcGxheUZpbHRlcjtcbiAgICAgIGN0eC5yZXBsYXlGaWx0ZXIgPSBjdXJyID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tYmluZShjdXJyKCksIGZhY3RvcnkoKSk7IH0gOiBmYWN0b3J5O1xuICAgICAgY3R4Lmp1c3RMaW1pdCA9IGlzTGltaXRGaWx0ZXIgJiYgIWN1cnI7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTWF0Y2hGaWx0ZXIoY3R4LCBmbikge1xuICAgICAgY3R4LmlzTWF0Y2ggPSBjb21iaW5lKGN0eC5pc01hdGNoLCBmbik7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY29yZVNjaGVtYSkge1xuICAgICAgaWYgKGN0eC5pc1ByaW1LZXkpXG4gICAgICAgICAgcmV0dXJuIGNvcmVTY2hlbWEucHJpbWFyeUtleTtcbiAgICAgIHZhciBpbmRleCA9IGNvcmVTY2hlbWEuZ2V0SW5kZXhCeUtleVBhdGgoY3R4LmluZGV4KTtcbiAgICAgIGlmICghaW5kZXgpXG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiS2V5UGF0aCBcIiArIGN0eC5pbmRleCArIFwiIG9uIG9iamVjdCBzdG9yZSBcIiArIGNvcmVTY2hlbWEubmFtZSArIFwiIGlzIG5vdCBpbmRleGVkXCIpO1xuICAgICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIGZ1bmN0aW9uIG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIHRyYW5zKSB7XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlVGFibGUuc2NoZW1hKTtcbiAgICAgIHJldHVybiBjb3JlVGFibGUub3BlbkN1cnNvcih7XG4gICAgICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgICAgIHZhbHVlczogIWN0eC5rZXlzT25seSxcbiAgICAgICAgICByZXZlcnNlOiBjdHguZGlyID09PSAncHJldicsXG4gICAgICAgICAgdW5pcXVlOiAhIWN0eC51bmlxdWUsXG4gICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gaXRlcihjdHgsIGZuLCBjb3JlVHJhbnMsIGNvcmVUYWJsZSkge1xuICAgICAgdmFyIGZpbHRlciA9IGN0eC5yZXBsYXlGaWx0ZXIgPyBjb21iaW5lKGN0eC5maWx0ZXIsIGN0eC5yZXBsYXlGaWx0ZXIoKSkgOiBjdHguZmlsdGVyO1xuICAgICAgaWYgKCFjdHgub3IpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZShvcGVuQ3Vyc29yKGN0eCwgY29yZVRhYmxlLCBjb3JlVHJhbnMpLCBjb21iaW5lKGN0eC5hbGdvcml0aG0sIGZpbHRlciksIGZuLCAhY3R4LmtleXNPbmx5ICYmIGN0eC52YWx1ZU1hcHBlcik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgc2V0XzEgPSB7fTtcbiAgICAgICAgICB2YXIgdW5pb24gPSBmdW5jdGlvbiAoaXRlbSwgY3Vyc29yLCBhZHZhbmNlKSB7XG4gICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihjdXJzb3IsIGFkdmFuY2UsIGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIGN1cnNvci5zdG9wKHJlc3VsdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGN1cnNvci5mYWlsKGVycik7IH0pKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGN1cnNvci5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgdmFyIGtleSA9ICcnICsgcHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpXG4gICAgICAgICAgICAgICAgICAgICAga2V5ID0gJycgKyBuZXcgVWludDhBcnJheShwcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgIGlmICghaGFzT3duKHNldF8xLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0XzFba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgZm4oaXRlbSwgY3Vyc29yLCBhZHZhbmNlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgY3R4Lm9yLl9pdGVyYXRlKHVuaW9uLCBjb3JlVHJhbnMpLFxuICAgICAgICAgICAgICBpdGVyYXRlKG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIGNvcmVUcmFucyksIGN0eC5hbGdvcml0aG0sIHVuaW9uLCAhY3R4LmtleXNPbmx5ICYmIGN0eC52YWx1ZU1hcHBlcilcbiAgICAgICAgICBdKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpdGVyYXRlKGN1cnNvclByb21pc2UsIGZpbHRlciwgZm4sIHZhbHVlTWFwcGVyKSB7XG4gICAgICB2YXIgbWFwcGVkRm4gPSB2YWx1ZU1hcHBlciA/IGZ1bmN0aW9uICh4LCBjLCBhKSB7IHJldHVybiBmbih2YWx1ZU1hcHBlcih4KSwgYywgYSk7IH0gOiBmbjtcbiAgICAgIHZhciB3cmFwcGVkRm4gPSB3cmFwKG1hcHBlZEZuKTtcbiAgICAgIHJldHVybiBjdXJzb3JQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGN1cnNvcikge1xuICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5zdGFydChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGN1cnNvci5jb250aW51ZSgpOyB9O1xuICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGN1cnNvciwgZnVuY3Rpb24gKGFkdmFuY2VyKSB7IHJldHVybiBjID0gYWR2YW5jZXI7IH0sIGZ1bmN0aW9uICh2YWwpIHsgY3Vyc29yLnN0b3AodmFsKTsgYyA9IG5vcDsgfSwgZnVuY3Rpb24gKGUpIHsgY3Vyc29yLmZhaWwoZSk7IGMgPSBub3A7IH0pKVxuICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZWRGbihjdXJzb3IudmFsdWUsIGN1cnNvciwgZnVuY3Rpb24gKGFkdmFuY2VyKSB7IHJldHVybiBjID0gYWR2YW5jZXI7IH0pO1xuICAgICAgICAgICAgICAgICAgYygpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIHZhciBDb2xsZWN0aW9uID0gIChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKCkge1xuICAgICAgfVxuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoZm4sIGNiKSB7XG4gICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICByZXR1cm4gY3R4LmVycm9yID9cbiAgICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucyhudWxsLCByZWplY3Rpb24uYmluZChudWxsLCBjdHguZXJyb3IpKSA6XG4gICAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMoJ3JlYWRvbmx5JywgZm4pLnRoZW4oY2IpO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgcmV0dXJuIGN0eC5lcnJvciA/XG4gICAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMobnVsbCwgcmVqZWN0aW9uLmJpbmQobnVsbCwgY3R4LmVycm9yKSkgOlxuICAgICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKCdyZWFkd3JpdGUnLCBmbiwgXCJsb2NrZWRcIik7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuX2FkZEFsZ29yaXRobSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgY3R4LmFsZ29yaXRobSA9IGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZm4pO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl9pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCBjb3JlVHJhbnMpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcih0aGlzLl9jdHgsIGZuLCBjb3JlVHJhbnMsIHRoaXMuX2N0eC50YWJsZS5jb3JlKTtcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAgIHZhciBydiA9IE9iamVjdC5jcmVhdGUodGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpLCBjdHggPSBPYmplY3QuY3JlYXRlKHRoaXMuX2N0eCk7XG4gICAgICAgICAgaWYgKHByb3BzKVxuICAgICAgICAgICAgICBleHRlbmQoY3R4LCBwcm9wcyk7XG4gICAgICAgICAgcnYuX2N0eCA9IGN0eDtcbiAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2N0eC52YWx1ZU1hcHBlciA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHRyYW5zKSB7IHJldHVybiBpdGVyKGN0eCwgZm4sIHRyYW5zLCBjdHgudGFibGUuY29yZSk7IH0pO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgdmFyIGN0eCA9IF90aGlzLl9jdHg7XG4gICAgICAgICAgICAgIHZhciBjb3JlVGFibGUgPSBjdHgudGFibGUuY29yZTtcbiAgICAgICAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29yZVRhYmxlLmNvdW50KHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoY291bnQpIHsgcmV0dXJuIE1hdGgubWluKGNvdW50LCBjdHgubGltaXQpOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaXRlcihjdHgsIGZ1bmN0aW9uICgpIHsgKytjb3VudDsgcmV0dXJuIGZhbHNlOyB9LCB0cmFucywgY29yZVRhYmxlKVxuICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvdW50OyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLnRoZW4oY2IpO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnNvcnRCeSA9IGZ1bmN0aW9uIChrZXlQYXRoLCBjYikge1xuICAgICAgICAgIHZhciBwYXJ0cyA9IGtleVBhdGguc3BsaXQoJy4nKS5yZXZlcnNlKCksIGxhc3RQYXJ0ID0gcGFydHNbMF0sIGxhc3RJbmRleCA9IHBhcnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgZnVuY3Rpb24gZ2V0dmFsKG9iaiwgaSkge1xuICAgICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXR2YWwob2JqW3BhcnRzW2ldXSwgaSAtIDEpO1xuICAgICAgICAgICAgICByZXR1cm4gb2JqW2xhc3RQYXJ0XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9yZGVyID0gdGhpcy5fY3R4LmRpciA9PT0gXCJuZXh0XCIgPyAxIDogLTE7XG4gICAgICAgICAgZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgICAgICAgICAgICAgdmFyIGFWYWwgPSBnZXR2YWwoYSwgbGFzdEluZGV4KSwgYlZhbCA9IGdldHZhbChiLCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgICByZXR1cm4gY21wKGFWYWwsIGJWYWwpICogb3JkZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGEuc29ydChzb3J0ZXIpO1xuICAgICAgICAgIH0pLnRoZW4oY2IpO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgICB2YXIgY3R4ID0gX3RoaXMuX2N0eDtcbiAgICAgICAgICAgICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFsdWVNYXBwZXJfMSA9IGN0eC52YWx1ZU1hcHBlcjtcbiAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGN0eC50YWJsZS5jb3JlLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICBsaW1pdDogY3R4LmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfYS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlTWFwcGVyXzEgPyByZXN1bHQubWFwKHZhbHVlTWFwcGVyXzEpIDogcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYV8xID0gW107XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaXRlcihjdHgsIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBhXzEucHVzaChpdGVtKTsgfSwgdHJhbnMsIGN0eC50YWJsZS5jb3JlKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFfMTsgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBjYik7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgaWYgKG9mZnNldCA8PSAwKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICBjdHgub2Zmc2V0ICs9IG9mZnNldDtcbiAgICAgICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCkpIHtcbiAgICAgICAgICAgICAgYWRkUmVwbGF5RmlsdGVyKGN0eCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRMZWZ0ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAtLW9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlKG9mZnNldExlZnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICgtLW9mZnNldExlZnQgPCAwKTsgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmxpbWl0ID0gZnVuY3Rpb24gKG51bVJvd3MpIHtcbiAgICAgICAgICB0aGlzLl9jdHgubGltaXQgPSBNYXRoLm1pbih0aGlzLl9jdHgubGltaXQsIG51bVJvd3MpO1xuICAgICAgICAgIGFkZFJlcGxheUZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHJvd3NMZWZ0ID0gbnVtUm93cztcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgtLXJvd3NMZWZ0IDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByb3dzTGVmdCA+PSAwO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnVudGlsID0gZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uLCBiSW5jbHVkZVN0b3BFbnRyeSkge1xuICAgICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgaWYgKGZpbHRlckZ1bmN0aW9uKGN1cnNvci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYkluY2x1ZGVTdG9wRW50cnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGltaXQoMSkudG9BcnJheShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVswXTsgfSkudGhlbihjYik7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maXJzdChjYik7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgICAgYWRkRmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKGN1cnNvcikge1xuICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb24oY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhZGRNYXRjaEZpbHRlcih0aGlzLl9jdHgsIGZpbHRlckZ1bmN0aW9uKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZpbHRlcik7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAoaW5kZXhOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMuX2N0eC50YWJsZSwgaW5kZXhOYW1lLCB0aGlzKTtcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2N0eC5kaXIgPSAodGhpcy5fY3R4LmRpciA9PT0gXCJwcmV2XCIgPyBcIm5leHRcIiA6IFwicHJldlwiKTtcbiAgICAgICAgICBpZiAodGhpcy5fb25kaXJlY3Rpb25jaGFuZ2UpXG4gICAgICAgICAgICAgIHRoaXMuX29uZGlyZWN0aW9uY2hhbmdlKHRoaXMuX2N0eC5kaXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmRlc2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2hLZXkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2YWwsIGN1cnNvcikgeyBjYihjdXJzb3Iua2V5LCBjdXJzb3IpOyB9KTtcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoVW5pcXVlS2V5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaEtleShjYik7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZWFjaFByaW1hcnlLZXkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2YWwsIGN1cnNvcikgeyBjYihjdXJzb3IucHJpbWFyeUtleSwgY3Vyc29yKTsgfSk7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaXRlbSwgY3Vyc29yKSB7XG4gICAgICAgICAgICAgIGEucHVzaChjdXJzb3Iua2V5KTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgfSkudGhlbihjYik7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucHJpbWFyeUtleXMgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgIGlmIChjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGN0eC50YWJsZS5jb3JlLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiBjdHgubGltaXQsXG4gICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2EucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfSkudGhlbihjYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGl0ZW0sIGN1cnNvcikge1xuICAgICAgICAgICAgICBhLnB1c2goY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICB9KS50aGVuKGNiKTtcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS51bmlxdWVLZXlzID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMua2V5cyhjYik7XG4gICAgICB9O1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZmlyc3RLZXkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5saW1pdCgxKS5rZXlzKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWzBdOyB9KS50aGVuKGNiKTtcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5sYXN0S2V5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpcnN0S2V5KGNiKTtcbiAgICAgIH07XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5kaXN0aW5jdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LCBpZHggPSBjdHguaW5kZXggJiYgY3R4LnRhYmxlLnNjaGVtYS5pZHhCeU5hbWVbY3R4LmluZGV4XTtcbiAgICAgICAgICBpZiAoIWlkeCB8fCAhaWR4Lm11bHRpKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB2YXIgc2V0ID0ge307XG4gICAgICAgICAgYWRkRmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKGN1cnNvcikge1xuICAgICAgICAgICAgICB2YXIgc3RyS2V5ID0gY3Vyc29yLnByaW1hcnlLZXkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgdmFyIGZvdW5kID0gaGFzT3duKHNldCwgc3RyS2V5KTtcbiAgICAgICAgICAgICAgc2V0W3N0cktleV0gPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm1vZGlmeSA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgIHJldHVybiB0aGlzLl93cml0ZShmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgdmFyIG1vZGlmeWVyO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgIG1vZGlmeWVyID0gY2hhbmdlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1vZGlmeWVyID0gZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGFwcGx5VXBkYXRlU3BlYyhpdGVtLCBjaGFuZ2VzKTsgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgY29yZVRhYmxlID0gY3R4LnRhYmxlLmNvcmU7XG4gICAgICAgICAgICAgIHZhciBfYSA9IGNvcmVUYWJsZS5zY2hlbWEucHJpbWFyeUtleSwgb3V0Ym91bmQgPSBfYS5vdXRib3VuZCwgZXh0cmFjdEtleSA9IF9hLmV4dHJhY3RLZXk7XG4gICAgICAgICAgICAgIHZhciBsaW1pdCA9IDIwMDtcbiAgICAgICAgICAgICAgdmFyIG1vZGlmeUNodW5rU2l6ZSA9IF90aGlzLmRiLl9vcHRpb25zLm1vZGlmeUNodW5rU2l6ZTtcbiAgICAgICAgICAgICAgaWYgKG1vZGlmeUNodW5rU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZnlDaHVua1NpemUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsaW1pdCA9IG1vZGlmeUNodW5rU2l6ZVtjb3JlVGFibGUubmFtZV0gfHwgbW9kaWZ5Q2h1bmtTaXplWycqJ10gfHwgMjAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGltaXQgPSBtb2RpZnlDaHVua1NpemU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHRvdGFsRmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICAgICAgICAgIHZhciBmYWlsZWRLZXlzID0gW107XG4gICAgICAgICAgICAgIHZhciBhcHBseU11dGF0ZVJlc3VsdCA9IGZ1bmN0aW9uIChleHBlY3RlZENvdW50LCByZXMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlcyA9IHJlcy5mYWlsdXJlcywgbnVtRmFpbHVyZXMgPSByZXMubnVtRmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgICBzdWNjZXNzQ291bnQgKz0gZXhwZWN0ZWRDb3VudCAtIG51bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGtleXMoZmFpbHVyZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxGYWlsdXJlcy5wdXNoKGZhaWx1cmVzW3Bvc10pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB2YXIgaXNVbmNvbmRpdGlvbmFsRGVsZXRlID0gY2hhbmdlcyA9PT0gZGVsZXRlQ2FsbGJhY2s7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jbG9uZSgpLnByaW1hcnlLZXlzKCkudGhlbihmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgICAgICAgdmFyIGNyaXRlcmlhID0gaXNQbGFpbktleVJhbmdlKGN0eCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjdHgubGltaXQgPT09IEluZmluaXR5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBjaGFuZ2VzICE9PSAnZnVuY3Rpb24nIHx8IGlzVW5jb25kaXRpb25hbERlbGV0ZSkgJiYge1xuICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjdHguaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q2h1bmsgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gTWF0aC5taW4obGltaXQsIGtleXMubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5c0luQ2h1bmsgPSBrZXlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXNVbmNvbmRpdGlvbmFsRGVsZXRlID8gUHJvbWlzZS5yZXNvbHZlKFtdKSA6IGNvcmVUYWJsZS5nZXRNYW55KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBrZXlzSW5DaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IFwiaW1tdXRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB1dFZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHV0S2V5cyA9IG91dGJvdW5kID8gW10gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZXRlS2V5cyA9IGlzVW5jb25kaXRpb25hbERlbGV0ZSA/IGtleXNJbkNodW5rIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNVbmNvbmRpdGlvbmFsRGVsZXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdWYWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3R4XzEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkZWVwQ2xvbmUob3JpZ1ZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleToga2V5c1tvZmZzZXQgKyBpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmeWVyLmNhbGwoY3R4XzEsIGN0eF8xLnZhbHVlLCBjdHhfMSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHhfMS52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnB1c2goa2V5c1tvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIW91dGJvdW5kICYmIGNtcChleHRyYWN0S2V5KG9yaWdWYWx1ZSksIGV4dHJhY3RLZXkoY3R4XzEudmFsdWUpKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5wdXNoKGtleXNbb2Zmc2V0ICsgaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmFsdWVzLnB1c2goY3R4XzEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0VmFsdWVzLnB1c2goY3R4XzEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dEtleXMucHVzaChrZXlzW29mZnNldCArIGldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhZGRWYWx1ZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2FkZCcsIHZhbHVlczogYWRkVmFsdWVzIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHBvcyBpbiByZXMuZmFpbHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5zcGxpY2UocGFyc2VJbnQocG9zKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5TXV0YXRlUmVzdWx0KGFkZFZhbHVlcy5sZW5ndGgsIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiAocHV0VmFsdWVzLmxlbmd0aCA+IDAgfHwgKGNyaXRlcmlhICYmIHR5cGVvZiBjaGFuZ2VzID09PSAnb2JqZWN0JykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlVGFibGUubXV0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czogcHV0S2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHB1dFZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcml0ZXJpYTogY3JpdGVyaWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlU3BlYzogdHlwZW9mIGNoYW5nZXMgIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2hhbmdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FkZGl0aW9uYWxDaHVuazogb2Zmc2V0ID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiBhcHBseU11dGF0ZVJlc3VsdChwdXRWYWx1ZXMubGVuZ3RoLCByZXMpOyB9KTsgfSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiAoZGVsZXRlS2V5cy5sZW5ndGggPiAwIHx8IChjcml0ZXJpYSAmJiBpc1VuY29uZGl0aW9uYWxEZWxldGUpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkZWxldGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGRlbGV0ZUtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JpdGVyaWE6IGNyaXRlcmlhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWRkaXRpb25hbENodW5rOiBvZmZzZXQgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIGJ1aWx0SW5EZWxldGlvblRyaWdnZXIoY3R4LnRhYmxlLCBkZWxldGVLZXlzLCByZXMpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIGFwcGx5TXV0YXRlUmVzdWx0KGRlbGV0ZUtleXMubGVuZ3RoLCByZXMpOyB9KTsgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5sZW5ndGggPiBvZmZzZXQgKyBjb3VudCAmJiBuZXh0Q2h1bmsob2Zmc2V0ICsgbGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENodW5rKDApLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbEZhaWx1cmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNb2RpZnlFcnJvcihcIkVycm9yIG1vZGlmeWluZyBvbmUgb3IgbW9yZSBvYmplY3RzXCIsIHRvdGFsRmFpbHVyZXMsIHN1Y2Nlc3NDb3VudCwgZmFpbGVkS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LCByYW5nZSA9IGN0eC5yYW5nZTtcbiAgICAgICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCkgJiZcbiAgICAgICAgICAgICAgIWN0eC50YWJsZS5zY2hlbWEueVByb3BzICYmXG4gICAgICAgICAgICAgIChjdHguaXNQcmltS2V5IHx8IHJhbmdlLnR5cGUgPT09IDMgKSlcbiAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGUoZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGN0eC50YWJsZS5jb3JlLnNjaGVtYS5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgdmFyIGNvcmVSYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLmNvdW50KHsgdHJhbnM6IHRyYW5zLCBxdWVyeTogeyBpbmRleDogcHJpbWFyeUtleSwgcmFuZ2U6IGNvcmVSYW5nZSB9IH0pLnRoZW4oZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IGNvcmVSYW5nZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVzID0gX2EuZmFpbHVyZXMsIG51bUZhaWx1cmVzID0gX2EubnVtRmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNb2RpZnlFcnJvcihcIkNvdWxkIG5vdCBkZWxldGUgc29tZSB2YWx1ZXNcIiwgT2JqZWN0LmtleXMoZmFpbHVyZXMpLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBmYWlsdXJlc1twb3NdOyB9KSwgY291bnQgLSBudW1GYWlsdXJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudCAtIG51bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5tb2RpZnkoZGVsZXRlQ2FsbGJhY2spO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDb2xsZWN0aW9uO1xuICB9KCkpO1xuICB2YXIgZGVsZXRlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUsIGN0eCkgeyByZXR1cm4gY3R4LnZhbHVlID0gbnVsbDsgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IoZGIpIHtcbiAgICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihDb2xsZWN0aW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwga2V5UmFuZ2VHZW5lcmF0b3IpIHtcbiAgICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgICAgdmFyIGtleVJhbmdlID0gQW55UmFuZ2UsIGVycm9yID0gbnVsbDtcbiAgICAgICAgICBpZiAoa2V5UmFuZ2VHZW5lcmF0b3IpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBrZXlSYW5nZSA9IGtleVJhbmdlR2VuZXJhdG9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHdoZXJlQ3R4ID0gd2hlcmVDbGF1c2UuX2N0eDtcbiAgICAgICAgICB2YXIgdGFibGUgPSB3aGVyZUN0eC50YWJsZTtcbiAgICAgICAgICB2YXIgcmVhZGluZ0hvb2sgPSB0YWJsZS5ob29rLnJlYWRpbmcuZmlyZTtcbiAgICAgICAgICB0aGlzLl9jdHggPSB7XG4gICAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgICAgaW5kZXg6IHdoZXJlQ3R4LmluZGV4LFxuICAgICAgICAgICAgICBpc1ByaW1LZXk6ICghd2hlcmVDdHguaW5kZXggfHwgKHRhYmxlLnNjaGVtYS5wcmltS2V5LmtleVBhdGggJiYgd2hlcmVDdHguaW5kZXggPT09IHRhYmxlLnNjaGVtYS5wcmltS2V5Lm5hbWUpKSxcbiAgICAgICAgICAgICAgcmFuZ2U6IGtleVJhbmdlLFxuICAgICAgICAgICAgICBrZXlzT25seTogZmFsc2UsXG4gICAgICAgICAgICAgIGRpcjogXCJuZXh0XCIsXG4gICAgICAgICAgICAgIHVuaXF1ZTogXCJcIixcbiAgICAgICAgICAgICAgYWxnb3JpdGhtOiBudWxsLFxuICAgICAgICAgICAgICBmaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICAgIHJlcGxheUZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgICAganVzdExpbWl0OiB0cnVlLFxuICAgICAgICAgICAgICBpc01hdGNoOiBudWxsLFxuICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgIGxpbWl0OiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICBvcjogd2hlcmVDdHgub3IsXG4gICAgICAgICAgICAgIHZhbHVlTWFwcGVyOiByZWFkaW5nSG9vayAhPT0gbWlycm9yID8gcmVhZGluZ0hvb2sgOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2ltcGxlQ29tcGFyZShhLCBiKSB7XG4gICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbiAgfVxuICBmdW5jdGlvbiBzaW1wbGVDb21wYXJlUmV2ZXJzZShhLCBiKSB7XG4gICAgICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhaWwoY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UsIGVyciwgVCkge1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSBpbnN0YW5jZW9mIFdoZXJlQ2xhdXNlID9cbiAgICAgICAgICBuZXcgY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UuQ29sbGVjdGlvbihjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSkgOlxuICAgICAgICAgIGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlO1xuICAgICAgY29sbGVjdGlvbi5fY3R4LmVycm9yID0gVCA/IG5ldyBUKGVycikgOiBuZXcgVHlwZUVycm9yKGVycik7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBlbXB0eUNvbGxlY3Rpb24od2hlcmVDbGF1c2UpIHtcbiAgICAgIHJldHVybiBuZXcgd2hlcmVDbGF1c2UuQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmFuZ2VFcXVhbChcIlwiKTsgfSkubGltaXQoMCk7XG4gIH1cbiAgZnVuY3Rpb24gdXBwZXJGYWN0b3J5KGRpcikge1xuICAgICAgcmV0dXJuIGRpciA9PT0gXCJuZXh0XCIgP1xuICAgICAgICAgIGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvVXBwZXJDYXNlKCk7IH0gOlxuICAgICAgICAgIGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvTG93ZXJDYXNlKCk7IH07XG4gIH1cbiAgZnVuY3Rpb24gbG93ZXJGYWN0b3J5KGRpcikge1xuICAgICAgcmV0dXJuIGRpciA9PT0gXCJuZXh0XCIgP1xuICAgICAgICAgIGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvTG93ZXJDYXNlKCk7IH0gOlxuICAgICAgICAgIGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvVXBwZXJDYXNlKCk7IH07XG4gIH1cbiAgZnVuY3Rpb24gbmV4dENhc2luZyhrZXksIGxvd2VyS2V5LCB1cHBlck5lZWRsZSwgbG93ZXJOZWVkbGUsIGNtcCwgZGlyKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oa2V5Lmxlbmd0aCwgbG93ZXJOZWVkbGUubGVuZ3RoKTtcbiAgICAgIHZhciBsbHAgPSAtMTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgbHdyS2V5Q2hhciA9IGxvd2VyS2V5W2ldO1xuICAgICAgICAgIGlmIChsd3JLZXlDaGFyICE9PSBsb3dlck5lZWRsZVtpXSkge1xuICAgICAgICAgICAgICBpZiAoY21wKGtleVtpXSwgdXBwZXJOZWVkbGVbaV0pIDwgMClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGkpICsgdXBwZXJOZWVkbGVbaV0gKyB1cHBlck5lZWRsZS5zdWJzdHIoaSArIDEpO1xuICAgICAgICAgICAgICBpZiAoY21wKGtleVtpXSwgbG93ZXJOZWVkbGVbaV0pIDwgMClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGkpICsgbG93ZXJOZWVkbGVbaV0gKyB1cHBlck5lZWRsZS5zdWJzdHIoaSArIDEpO1xuICAgICAgICAgICAgICBpZiAobGxwID49IDApXG4gICAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBsbHApICsgbG93ZXJLZXlbbGxwXSArIHVwcGVyTmVlZGxlLnN1YnN0cihsbHAgKyAxKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCBsd3JLZXlDaGFyKSA8IDApXG4gICAgICAgICAgICAgIGxscCA9IGk7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoIDwgbG93ZXJOZWVkbGUubGVuZ3RoICYmIGRpciA9PT0gXCJuZXh0XCIpXG4gICAgICAgICAgcmV0dXJuIGtleSArIHVwcGVyTmVlZGxlLnN1YnN0cihrZXkubGVuZ3RoKTtcbiAgICAgIGlmIChsZW5ndGggPCBrZXkubGVuZ3RoICYmIGRpciA9PT0gXCJwcmV2XCIpXG4gICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgdXBwZXJOZWVkbGUubGVuZ3RoKTtcbiAgICAgIHJldHVybiAobGxwIDwgMCA/IG51bGwgOiBrZXkuc3Vic3RyKDAsIGxscCkgKyBsb3dlck5lZWRsZVtsbHBdICsgdXBwZXJOZWVkbGUuc3Vic3RyKGxscCArIDEpKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHdoZXJlQ2xhdXNlLCBtYXRjaCwgbmVlZGxlcywgc3VmZml4KSB7XG4gICAgICB2YXIgdXBwZXIsIGxvd2VyLCBjb21wYXJlLCB1cHBlck5lZWRsZXMsIGxvd2VyTmVlZGxlcywgZGlyZWN0aW9uLCBuZXh0S2V5U3VmZml4LCBuZWVkbGVzTGVuID0gbmVlZGxlcy5sZW5ndGg7XG4gICAgICBpZiAoIW5lZWRsZXMuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJzsgfSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFpbCh3aGVyZUNsYXVzZSwgU1RSSU5HX0VYUEVDVEVEKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGluaXREaXJlY3Rpb24oZGlyKSB7XG4gICAgICAgICAgdXBwZXIgPSB1cHBlckZhY3RvcnkoZGlyKTtcbiAgICAgICAgICBsb3dlciA9IGxvd2VyRmFjdG9yeShkaXIpO1xuICAgICAgICAgIGNvbXBhcmUgPSAoZGlyID09PSBcIm5leHRcIiA/IHNpbXBsZUNvbXBhcmUgOiBzaW1wbGVDb21wYXJlUmV2ZXJzZSk7XG4gICAgICAgICAgdmFyIG5lZWRsZUJvdW5kcyA9IG5lZWRsZXMubWFwKGZ1bmN0aW9uIChuZWVkbGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgbG93ZXI6IGxvd2VyKG5lZWRsZSksIHVwcGVyOiB1cHBlcihuZWVkbGUpIH07XG4gICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZShhLmxvd2VyLCBiLmxvd2VyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB1cHBlck5lZWRsZXMgPSBuZWVkbGVCb3VuZHMubWFwKGZ1bmN0aW9uIChuYikgeyByZXR1cm4gbmIudXBwZXI7IH0pO1xuICAgICAgICAgIGxvd2VyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKSB7IHJldHVybiBuYi5sb3dlcjsgfSk7XG4gICAgICAgICAgZGlyZWN0aW9uID0gZGlyO1xuICAgICAgICAgIG5leHRLZXlTdWZmaXggPSAoZGlyID09PSBcIm5leHRcIiA/IFwiXCIgOiBzdWZmaXgpO1xuICAgICAgfVxuICAgICAgaW5pdERpcmVjdGlvbihcIm5leHRcIik7XG4gICAgICB2YXIgYyA9IG5ldyB3aGVyZUNsYXVzZS5Db2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZSh1cHBlck5lZWRsZXNbMF0sIGxvd2VyTmVlZGxlc1tuZWVkbGVzTGVuIC0gMV0gKyBzdWZmaXgpOyB9KTtcbiAgICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICAgIGluaXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICB2YXIgZmlyc3RQb3NzaWJsZU5lZWRsZSA9IDA7XG4gICAgICBjLl9hZGRBbGdvcml0aG0oZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHZhciBsb3dlcktleSA9IGxvd2VyKGtleSk7XG4gICAgICAgICAgaWYgKG1hdGNoKGxvd2VyS2V5LCBsb3dlck5lZWRsZXMsIGZpcnN0UG9zc2libGVOZWVkbGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0UG9zc2libGVOZWVkbGU7IGkgPCBuZWVkbGVzTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjYXNpbmcgPSBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlc1tpXSwgbG93ZXJOZWVkbGVzW2ldLCBjb21wYXJlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgaWYgKGNhc2luZyA9PT0gbnVsbCAmJiBsb3dlc3RQb3NzaWJsZUNhc2luZyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICBmaXJzdFBvc3NpYmxlTmVlZGxlID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChsb3dlc3RQb3NzaWJsZUNhc2luZyA9PT0gbnVsbCB8fCBjb21wYXJlKGxvd2VzdFBvc3NpYmxlQ2FzaW5nLCBjYXNpbmcpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID0gY2FzaW5nO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsb3dlc3RQb3NzaWJsZUNhc2luZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7IGN1cnNvci5jb250aW51ZShsb3dlc3RQb3NzaWJsZUNhc2luZyArIG5leHRLZXlTdWZmaXgpOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGM7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUmFuZ2UobG93ZXIsIHVwcGVyLCBsb3dlck9wZW4sIHVwcGVyT3Blbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAyICxcbiAgICAgICAgICBsb3dlcjogbG93ZXIsXG4gICAgICAgICAgdXBwZXI6IHVwcGVyLFxuICAgICAgICAgIGxvd2VyT3BlbjogbG93ZXJPcGVuLFxuICAgICAgICAgIHVwcGVyT3BlbjogdXBwZXJPcGVuXG4gICAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHJhbmdlRXF1YWwodmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogMSAsXG4gICAgICAgICAgbG93ZXI6IHZhbHVlLFxuICAgICAgICAgIHVwcGVyOiB2YWx1ZVxuICAgICAgfTtcbiAgfVxuXG4gIHZhciBXaGVyZUNsYXVzZSA9ICAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gV2hlcmVDbGF1c2UoKSB7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2hlcmVDbGF1c2UucHJvdG90eXBlLCBcIkNvbGxlY3Rpb25cIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3R4LnRhYmxlLmRiLkNvbGxlY3Rpb247XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmJldHdlZW4gPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyLCBpbmNsdWRlTG93ZXIsIGluY2x1ZGVVcHBlcikge1xuICAgICAgICAgIGluY2x1ZGVMb3dlciA9IGluY2x1ZGVMb3dlciAhPT0gZmFsc2U7XG4gICAgICAgICAgaW5jbHVkZVVwcGVyID0gaW5jbHVkZVVwcGVyID09PSB0cnVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICgodGhpcy5fY21wKGxvd2VyLCB1cHBlcikgPiAwKSB8fFxuICAgICAgICAgICAgICAgICAgKHRoaXMuX2NtcChsb3dlciwgdXBwZXIpID09PSAwICYmIChpbmNsdWRlTG93ZXIgfHwgaW5jbHVkZVVwcGVyKSAmJiAhKGluY2x1ZGVMb3dlciAmJiBpbmNsdWRlVXBwZXIpKSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKGxvd2VyLCB1cHBlciwgIWluY2x1ZGVMb3dlciwgIWluY2x1ZGVVcHBlcik7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhbmdlRXF1YWwodmFsdWUpOyB9KTtcbiAgICAgIH07XG4gICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYWJvdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHZhbHVlLCB1bmRlZmluZWQsIHRydWUpOyB9KTtcbiAgICAgIH07XG4gICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYWJvdmVPckVxdWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZSh2YWx1ZSwgdW5kZWZpbmVkLCBmYWxzZSk7IH0pO1xuICAgICAgfTtcbiAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5iZWxvdyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UodW5kZWZpbmVkLCB2YWx1ZSwgZmFsc2UsIHRydWUpOyB9KTtcbiAgICAgIH07XG4gICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYmVsb3dPckVxdWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZSh1bmRlZmluZWQsIHZhbHVlKTsgfSk7XG4gICAgICB9O1xuICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBTVFJJTkdfRVhQRUNURUQpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmJldHdlZW4oc3RyLCBzdHIgKyBtYXhTdHJpbmcsIHRydWUsIHRydWUpO1xuICAgICAgfTtcbiAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5zdGFydHNXaXRoSWdub3JlQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICBpZiAoc3RyID09PSBcIlwiKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydHNXaXRoKHN0cik7XG4gICAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgZnVuY3Rpb24gKHgsIGEpIHsgcmV0dXJuIHguaW5kZXhPZihhWzBdKSA9PT0gMDsgfSwgW3N0cl0sIG1heFN0cmluZyk7XG4gICAgICB9O1xuICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmVxdWFsc0lnbm9yZUNhc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgZnVuY3Rpb24gKHgsIGEpIHsgcmV0dXJuIHggPT09IGFbMF07IH0sIFtzdHJdLCBcIlwiKTtcbiAgICAgIH07XG4gICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYW55T2ZJZ25vcmVDYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgZnVuY3Rpb24gKHgsIGEpIHsgcmV0dXJuIGEuaW5kZXhPZih4KSAhPT0gLTE7IH0sIHNldCwgXCJcIik7XG4gICAgICB9O1xuICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLnN0YXJ0c1dpdGhBbnlPZklnbm9yZUNhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCBmdW5jdGlvbiAoeCwgYSkgeyByZXR1cm4gYS5zb21lKGZ1bmN0aW9uIChuKSB7IHJldHVybiB4LmluZGV4T2YobikgPT09IDA7IH0pOyB9LCBzZXQsIG1heFN0cmluZyk7XG4gICAgICB9O1xuICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmFueU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NtcDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzZXQuc29ydChjb21wYXJlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICB2YXIgYyA9IG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2Uoc2V0WzBdLCBzZXRbc2V0Lmxlbmd0aCAtIDFdKTsgfSk7XG4gICAgICAgICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbXBhcmUgPSAoZGlyZWN0aW9uID09PSBcIm5leHRcIiA/XG4gICAgICAgICAgICAgICAgICBfdGhpcy5fYXNjZW5kaW5nIDpcbiAgICAgICAgICAgICAgICAgIF90aGlzLl9kZXNjZW5kaW5nKTtcbiAgICAgICAgICAgICAgc2V0LnNvcnQoY29tcGFyZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgYy5fYWRkQWxnb3JpdGhtKGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGtleSwgc2V0W2ldKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgIGlmIChpID09PSBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkgeyBjdXJzb3IuY29udGludWUoc2V0W2ldKTsgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgIH07XG4gICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUubm90RXF1YWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKFtbbWluS2V5LCB2YWx1ZV0sIFt2YWx1ZSwgdGhpcy5kYi5fbWF4S2V5XV0sIHsgaW5jbHVkZUxvd2VyczogZmFsc2UsIGluY2x1ZGVVcHBlcnM6IGZhbHNlIH0pO1xuICAgICAgfTtcbiAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5ub25lT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc2V0LnNvcnQodGhpcy5fYXNjZW5kaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmFuZ2VzID0gc2V0LnJlZHVjZShmdW5jdGlvbiAocmVzLCB2YWwpIHsgcmV0dXJuIHJlcyA/XG4gICAgICAgICAgICAgIHJlcy5jb25jYXQoW1tyZXNbcmVzLmxlbmd0aCAtIDFdWzFdLCB2YWxdXSkgOlxuICAgICAgICAgICAgICBbW21pbktleSwgdmFsXV07IH0sIG51bGwpO1xuICAgICAgICAgIHJhbmdlcy5wdXNoKFtzZXRbc2V0Lmxlbmd0aCAtIDFdLCB0aGlzLmRiLl9tYXhLZXldKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKHJhbmdlcywgeyBpbmNsdWRlTG93ZXJzOiBmYWxzZSwgaW5jbHVkZVVwcGVyczogZmFsc2UgfSk7XG4gICAgICB9O1xuICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmluQW55UmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2VzLCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgY21wID0gdGhpcy5fY21wLCBhc2NlbmRpbmcgPSB0aGlzLl9hc2NlbmRpbmcsIGRlc2NlbmRpbmcgPSB0aGlzLl9kZXNjZW5kaW5nLCBtaW4gPSB0aGlzLl9taW4sIG1heCA9IHRoaXMuX21heDtcbiAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICBpZiAoIXJhbmdlcy5ldmVyeShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzBdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgIHJhbmdlWzFdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgIGFzY2VuZGluZyhyYW5nZVswXSwgcmFuZ2VbMV0pIDw9IDA7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgXCJGaXJzdCBhcmd1bWVudCB0byBpbkFueVJhbmdlKCkgbXVzdCBiZSBhbiBBcnJheSBvZiB0d28tdmFsdWUgQXJyYXlzIFtsb3dlcix1cHBlcl0gd2hlcmUgdXBwZXIgbXVzdCBub3QgYmUgbG93ZXIgdGhhbiBsb3dlclwiLCBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmNsdWRlTG93ZXJzID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5pbmNsdWRlTG93ZXJzICE9PSBmYWxzZTtcbiAgICAgICAgICB2YXIgaW5jbHVkZVVwcGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlVXBwZXJzID09PSB0cnVlO1xuICAgICAgICAgIGZ1bmN0aW9uIGFkZFJhbmdlKHJhbmdlcywgbmV3UmFuZ2UpIHtcbiAgICAgICAgICAgICAgdmFyIGkgPSAwLCBsID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgIGlmIChjbXAobmV3UmFuZ2VbMF0sIHJhbmdlWzFdKSA8IDAgJiYgY21wKG5ld1JhbmdlWzFdLCByYW5nZVswXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMF0gPSBtaW4ocmFuZ2VbMF0sIG5ld1JhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICByYW5nZVsxXSA9IG1heChyYW5nZVsxXSwgbmV3UmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpID09PSBsKVxuICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3UmFuZ2UpO1xuICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcbiAgICAgICAgICBmdW5jdGlvbiByYW5nZVNvcnRlcihhLCBiKSB7IHJldHVybiBzb3J0RGlyZWN0aW9uKGFbMF0sIGJbMF0pOyB9XG4gICAgICAgICAgdmFyIHNldDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzZXQgPSByYW5nZXMucmVkdWNlKGFkZFJhbmdlLCBbXSk7XG4gICAgICAgICAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJhbmdlUG9zID0gMDtcbiAgICAgICAgICB2YXIga2V5SXNCZXlvbmRDdXJyZW50RW50cnkgPSBpbmNsdWRlVXBwZXJzID9cbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPiAwOyB9IDpcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPj0gMDsgfTtcbiAgICAgICAgICB2YXIga2V5SXNCZWZvcmVDdXJyZW50RW50cnkgPSBpbmNsdWRlTG93ZXJzID9cbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZGVzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMF0pID4gMDsgfSA6XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGRlc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA+PSAwOyB9O1xuICAgICAgICAgIGZ1bmN0aW9uIGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICFrZXlJc0JleW9uZEN1cnJlbnRFbnRyeShrZXkpICYmICFrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeShrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2hlY2tLZXkgPSBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeTtcbiAgICAgICAgICB2YXIgYyA9IG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2Uoc2V0WzBdWzBdLCBzZXRbc2V0Lmxlbmd0aCAtIDFdWzFdLCAhaW5jbHVkZUxvd2VycywgIWluY2x1ZGVVcHBlcnMpOyB9KTtcbiAgICAgICAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZXlvbmRDdXJyZW50RW50cnk7XG4gICAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uID0gYXNjZW5kaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gPSBkZXNjZW5kaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgICB3aGlsZSAoY2hlY2tLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgKytyYW5nZVBvcztcbiAgICAgICAgICAgICAgICAgIGlmIChyYW5nZVBvcyA9PT0gc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChrZXlXaXRoaW5DdXJyZW50UmFuZ2Uoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuX2NtcChrZXksIHNldFtyYW5nZVBvc11bMV0pID09PSAwIHx8IF90aGlzLl9jbXAoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnREaXJlY3Rpb24gPT09IGFzY2VuZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHNldFtyYW5nZVBvc11bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHNldFtyYW5nZVBvc11bMV0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgIH07XG4gICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuc3RhcnRzV2l0aEFueU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKCFzZXQuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJzsgfSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgXCJzdGFydHNXaXRoQW55T2YoKSBvbmx5IHdvcmtzIHdpdGggc3RyaW5nc1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShzZXQubWFwKGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIFtzdHIsIHN0ciArIG1heFN0cmluZ107IH0pKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gV2hlcmVDbGF1c2U7XG4gIH0oKSk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3RvcihkYikge1xuICAgICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFdoZXJlQ2xhdXNlLnByb3RvdHlwZSwgZnVuY3Rpb24gV2hlcmVDbGF1c2UodGFibGUsIGluZGV4LCBvckNvbGxlY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgICAgdGhpcy5fY3R4ID0ge1xuICAgICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICAgIGluZGV4OiBpbmRleCA9PT0gXCI6aWRcIiA/IG51bGwgOiBpbmRleCxcbiAgICAgICAgICAgICAgb3I6IG9yQ29sbGVjdGlvblxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fY21wID0gdGhpcy5fYXNjZW5kaW5nID0gY21wO1xuICAgICAgICAgIHRoaXMuX2Rlc2NlbmRpbmcgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gY21wKGIsIGEpOyB9O1xuICAgICAgICAgIHRoaXMuX21heCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjbXAoYSwgYikgPiAwID8gYSA6IGI7IH07XG4gICAgICAgICAgdGhpcy5fbWluID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBhIDogYjsgfTtcbiAgICAgICAgICB0aGlzLl9JREJLZXlSYW5nZSA9IGRiLl9kZXBzLklEQktleVJhbmdlO1xuICAgICAgICAgIGlmICghdGhpcy5fSURCS2V5UmFuZ2UpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCkge1xuICAgICAgcmV0dXJuIHdyYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICB2YXIgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUgPSAnc3RvcmFnZW11dGF0ZWQnO1xuICB2YXIgU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FID0gJ3gtc3RvcmFnZW11dGF0ZWQtMSc7XG4gIHZhciBnbG9iYWxFdmVudHMgPSBFdmVudHMobnVsbCwgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUpO1xuXG4gIHZhciBUcmFuc2FjdGlvbiA9ICAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVHJhbnNhY3Rpb24oKSB7XG4gICAgICB9XG4gICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX2xvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYXNzZXJ0KCFQU0QuZ2xvYmFsKTtcbiAgICAgICAgICArK3RoaXMuX3JlY3Vsb2NrO1xuICAgICAgICAgIGlmICh0aGlzLl9yZWN1bG9jayA9PT0gMSAmJiAhUFNELmdsb2JhbClcbiAgICAgICAgICAgICAgUFNELmxvY2tPd25lckZvciA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl91bmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYXNzZXJ0KCFQU0QuZ2xvYmFsKTtcbiAgICAgICAgICBpZiAoLS10aGlzLl9yZWN1bG9jayA9PT0gMCkge1xuICAgICAgICAgICAgICBpZiAoIVBTRC5nbG9iYWwpXG4gICAgICAgICAgICAgICAgICBQU0QubG9ja093bmVyRm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2Jsb2NrZWRGdW5jcy5sZW5ndGggPiAwICYmICF0aGlzLl9sb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGZuQW5kUFNEID0gdGhpcy5fYmxvY2tlZEZ1bmNzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHVzZVBTRChmbkFuZFBTRFsxXSwgZm5BbmRQU0RbMF0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fbG9ja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN1bG9jayAmJiBQU0QubG9ja093bmVyRm9yICE9PSB0aGlzO1xuICAgICAgfTtcbiAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoaWRidHJhbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmICghdGhpcy5tb2RlKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB2YXIgaWRiZGIgPSB0aGlzLmRiLmlkYmRiO1xuICAgICAgICAgIHZhciBkYk9wZW5FcnJvciA9IHRoaXMuZGIuX3N0YXRlLmRiT3BlbkVycm9yO1xuICAgICAgICAgIGFzc2VydCghdGhpcy5pZGJ0cmFucyk7XG4gICAgICAgICAgaWYgKCFpZGJ0cmFucyAmJiAhaWRiZGIpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChkYk9wZW5FcnJvciAmJiBkYk9wZW5FcnJvci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiRGF0YWJhc2VDbG9zZWRFcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKGRiT3BlbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJNaXNzaW5nQVBJRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKGRiT3BlbkVycm9yLm1lc3NhZ2UsIGRiT3BlbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuT3BlbkZhaWxlZChkYk9wZW5FcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVHJhbnNhY3Rpb25JbmFjdGl2ZSgpO1xuICAgICAgICAgIGFzc2VydCh0aGlzLl9jb21wbGV0aW9uLl9zdGF0ZSA9PT0gbnVsbCk7XG4gICAgICAgICAgaWRidHJhbnMgPSB0aGlzLmlkYnRyYW5zID0gaWRidHJhbnMgfHxcbiAgICAgICAgICAgICAgKHRoaXMuZGIuY29yZVxuICAgICAgICAgICAgICAgICAgPyB0aGlzLmRiLmNvcmUudHJhbnNhY3Rpb24odGhpcy5zdG9yZU5hbWVzLCB0aGlzLm1vZGUsIHsgZHVyYWJpbGl0eTogdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgfSlcbiAgICAgICAgICAgICAgICAgIDogaWRiZGIudHJhbnNhY3Rpb24odGhpcy5zdG9yZU5hbWVzLCB0aGlzLm1vZGUsIHsgZHVyYWJpbGl0eTogdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgfSkpO1xuICAgICAgICAgIGlkYnRyYW5zLm9uZXJyb3IgPSB3cmFwKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldik7XG4gICAgICAgICAgICAgIF90aGlzLl9yZWplY3QoaWRidHJhbnMuZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlkYnRyYW5zLm9uYWJvcnQgPSB3cmFwKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldik7XG4gICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSAmJiBfdGhpcy5fcmVqZWN0KG5ldyBleGNlcHRpb25zLkFib3J0KGlkYnRyYW5zLmVycm9yKSk7XG4gICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBfdGhpcy5vbihcImFib3J0XCIpLmZpcmUoZXYpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlkYnRyYW5zLm9uY29tcGxldGUgPSB3cmFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIF90aGlzLl9yZXNvbHZlKCk7XG4gICAgICAgICAgICAgIGlmICgnbXV0YXRlZFBhcnRzJyBpbiBpZGJ0cmFucykge1xuICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLmZpcmUoaWRidHJhbnNbXCJtdXRhdGVkUGFydHNcIl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9wcm9taXNlID0gZnVuY3Rpb24gKG1vZGUsIGZuLCBiV3JpdGVMb2NrKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZScgJiYgdGhpcy5tb2RlICE9PSAncmVhZHdyaXRlJylcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlRyYW5zYWN0aW9uIGlzIHJlYWRvbmx5XCIpKTtcbiAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKSk7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvY2tlZCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLl9ibG9ja2VkRnVuY3MucHVzaChbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvbWlzZShtb2RlLCBmbiwgYldyaXRlTG9jaykudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgIH0sIFBTRF0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoYldyaXRlTG9jaykge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3U2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9jaygpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBydiA9IGZuKHJlc29sdmUsIHJlamVjdCwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChydiAmJiBydi50aGVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBydi50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHAuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdW5sb2NrKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgcC5fbGliID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcnYgPSBmbihyZXNvbHZlLCByZWplY3QsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgIGlmIChydiAmJiBydi50aGVuKVxuICAgICAgICAgICAgICAgICAgICAgIHJ2LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHAuX2xpYiA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX3Jvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuX3Jvb3QoKSA6IHRoaXM7XG4gICAgICB9O1xuICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLndhaXRGb3IgPSBmdW5jdGlvbiAocHJvbWlzZUxpa2UpIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3QoKTtcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHByb21pc2VMaWtlKTtcbiAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0Zvcikge1xuICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gcm9vdC5fd2FpdGluZ0Zvci50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb21pc2U7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IHByb21pc2U7XG4gICAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICB2YXIgc3RvcmUgPSByb290LmlkYnRyYW5zLm9iamVjdFN0b3JlKHJvb3Quc3RvcmVOYW1lc1swXSk7XG4gICAgICAgICAgICAgIChmdW5jdGlvbiBzcGluKCkge1xuICAgICAgICAgICAgICAgICAgKytyb290Ll9zcGluQ291bnQ7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAocm9vdC5fd2FpdGluZ1F1ZXVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAocm9vdC5fd2FpdGluZ1F1ZXVlLnNoaWZ0KCkpKCk7XG4gICAgICAgICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0ZvcilcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXQoLUluZmluaXR5KS5vbnN1Y2Nlc3MgPSBzcGluO1xuICAgICAgICAgICAgICB9KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY3VycmVudFdhaXRQcm9taXNlID0gcm9vdC5fd2FpdGluZ0ZvcjtcbiAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByb290Ll93YWl0aW5nUXVldWUucHVzaCh3cmFwKHJlc29sdmUuYmluZChudWxsLCByZXMpKSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJvb3QuX3dhaXRpbmdRdWV1ZS5wdXNoKHdyYXAocmVqZWN0LmJpbmQobnVsbCwgZXJyKSkpOyB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yID09PSBjdXJyZW50V2FpdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAodGhpcy5pZGJ0cmFucylcbiAgICAgICAgICAgICAgICAgIHRoaXMuaWRidHJhbnMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0KG5ldyBleGNlcHRpb25zLkFib3J0KCkpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgdmFyIG1lbW9pemVkVGFibGVzID0gKHRoaXMuX21lbW9pemVkVGFibGVzIHx8ICh0aGlzLl9tZW1vaXplZFRhYmxlcyA9IHt9KSk7XG4gICAgICAgICAgaWYgKGhhc093bihtZW1vaXplZFRhYmxlcywgdGFibGVOYW1lKSlcbiAgICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkVGFibGVzW3RhYmxlTmFtZV07XG4gICAgICAgICAgdmFyIHRhYmxlU2NoZW1hID0gdGhpcy5zY2hlbWFbdGFibGVOYW1lXTtcbiAgICAgICAgICBpZiAoIXRhYmxlU2NoZW1hKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk5vdEZvdW5kKFwiVGFibGUgXCIgKyB0YWJsZU5hbWUgKyBcIiBub3QgcGFydCBvZiB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRyYW5zYWN0aW9uQm91bmRUYWJsZSA9IG5ldyB0aGlzLmRiLlRhYmxlKHRhYmxlTmFtZSwgdGFibGVTY2hlbWEsIHRoaXMpO1xuICAgICAgICAgIHRyYW5zYWN0aW9uQm91bmRUYWJsZS5jb3JlID0gdGhpcy5kYi5jb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgbWVtb2l6ZWRUYWJsZXNbdGFibGVOYW1lXSA9IHRyYW5zYWN0aW9uQm91bmRUYWJsZTtcbiAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25Cb3VuZFRhYmxlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBUcmFuc2FjdGlvbjtcbiAgfSgpKTtcblxuICBmdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbkNvbnN0cnVjdG9yKGRiKSB7XG4gICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBmdW5jdGlvbiBUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5LCBwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChtb2RlICE9PSAncmVhZG9ubHknKVxuICAgICAgICAgICAgICBzdG9yZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgdmFyIHlQcm9wcyA9IChfYSA9IGRic2NoZW1hW3N0b3JlTmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS55UHJvcHM7XG4gICAgICAgICAgICAgICAgICBpZiAoeVByb3BzKVxuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZXMgPSBzdG9yZU5hbWVzLmNvbmNhdCh5UHJvcHMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnVwZGF0ZXNUYWJsZTsgfSkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgICB0aGlzLnN0b3JlTmFtZXMgPSBzdG9yZU5hbWVzO1xuICAgICAgICAgIHRoaXMuc2NoZW1hID0gZGJzY2hlbWE7XG4gICAgICAgICAgdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgPSBjaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHk7XG4gICAgICAgICAgdGhpcy5pZGJ0cmFucyA9IG51bGw7XG4gICAgICAgICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcImNvbXBsZXRlXCIsIFwiZXJyb3JcIiwgXCJhYm9ydFwiKTtcbiAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9yZWN1bG9jayA9IDA7XG4gICAgICAgICAgdGhpcy5fYmxvY2tlZEZ1bmNzID0gW107XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fcmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl93YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl93YWl0aW5nUXVldWUgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX3NwaW5Db3VudCA9IDA7XG4gICAgICAgICAgdGhpcy5fY29tcGxldGlvbiA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgIF90aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fY29tcGxldGlvbi50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIF90aGlzLm9uLmNvbXBsZXRlLmZpcmUoKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICB2YXIgd2FzQWN0aXZlID0gX3RoaXMuYWN0aXZlO1xuICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgX3RoaXMub24uZXJyb3IuZmlyZShlKTtcbiAgICAgICAgICAgICAgX3RoaXMucGFyZW50ID9cbiAgICAgICAgICAgICAgICAgIF90aGlzLnBhcmVudC5fcmVqZWN0KGUpIDpcbiAgICAgICAgICAgICAgICAgIHdhc0FjdGl2ZSAmJiBfdGhpcy5pZGJ0cmFucyAmJiBfdGhpcy5pZGJ0cmFucy5hYm9ydCgpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbmRleFNwZWMobmFtZSwga2V5UGF0aCwgdW5pcXVlLCBtdWx0aSwgYXV0bywgY29tcG91bmQsIGlzUHJpbUtleSwgdHlwZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgICAgdW5pcXVlOiB1bmlxdWUsXG4gICAgICAgICAgbXVsdGk6IG11bHRpLFxuICAgICAgICAgIGF1dG86IGF1dG8sXG4gICAgICAgICAgY29tcG91bmQ6IGNvbXBvdW5kLFxuICAgICAgICAgIHNyYzogKHVuaXF1ZSAmJiAhaXNQcmltS2V5ID8gJyYnIDogJycpICsgKG11bHRpID8gJyonIDogJycpICsgKGF1dG8gPyBcIisrXCIgOiBcIlwiKSArIG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKSxcbiAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID9cbiAgICAgICAgICBrZXlQYXRoIDpcbiAgICAgICAgICBrZXlQYXRoID8gKCdbJyArIFtdLmpvaW4uY2FsbChrZXlQYXRoLCAnKycpICsgJ10nKSA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVUYWJsZVNjaGVtYShuYW1lLCBwcmltS2V5LCBpbmRleGVzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgcHJpbUtleTogcHJpbUtleSxcbiAgICAgICAgICBpbmRleGVzOiBpbmRleGVzLFxuICAgICAgICAgIG1hcHBlZENsYXNzOiBudWxsLFxuICAgICAgICAgIGlkeEJ5TmFtZTogYXJyYXlUb09iamVjdChpbmRleGVzLCBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIFtpbmRleC5uYW1lLCBpbmRleF07IH0pLFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmFyaU11bHRpU3RvcmVGaXgoc3RvcmVOYW1lcykge1xuICAgICAgcmV0dXJuIHN0b3JlTmFtZXMubGVuZ3RoID09PSAxID8gc3RvcmVOYW1lc1swXSA6IHN0b3JlTmFtZXM7XG4gIH1cbiAgdmFyIGdldE1heEtleSA9IGZ1bmN0aW9uIChJZGJLZXlSYW5nZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBJZGJLZXlSYW5nZS5vbmx5KFtbXV0pO1xuICAgICAgICAgIGdldE1heEtleSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtbXV07IH07XG4gICAgICAgICAgcmV0dXJuIFtbXV07XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIGdldE1heEtleSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heFN0cmluZzsgfTtcbiAgICAgICAgICByZXR1cm4gbWF4U3RyaW5nO1xuICAgICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldEtleUV4dHJhY3RvcihrZXlQYXRoKSB7XG4gICAgICBpZiAoa2V5UGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBnZXRTaW5nbGVQYXRoS2V5RXh0cmFjdG9yKGtleVBhdGgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpOyB9O1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFNpbmdsZVBhdGhLZXlFeHRyYWN0b3Ioa2V5UGF0aCkge1xuICAgICAgdmFyIHNwbGl0ID0ga2V5UGF0aC5zcGxpdCgnLicpO1xuICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmpba2V5UGF0aF07IH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCk7IH07XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheWlmeShhcnJheUxpa2UpIHtcbiAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG4gIH1cbiAgdmFyIF9pZF9jb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpIHtcbiAgICAgIHJldHVybiBrZXlQYXRoID09IG51bGwgP1xuICAgICAgICAgIFwiOmlkXCIgOlxuICAgICAgICAgIHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICAgIGtleVBhdGggOlxuICAgICAgICAgICAgICBcIltcIi5jb25jYXQoa2V5UGF0aC5qb2luKCcrJyksIFwiXVwiKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVEQkNvcmUoZGIsIElkYktleVJhbmdlLCB0bXBUcmFucykge1xuICAgICAgZnVuY3Rpb24gZXh0cmFjdFNjaGVtYShkYiwgdHJhbnMpIHtcbiAgICAgICAgICB2YXIgdGFibGVzID0gYXJyYXlpZnkoZGIub2JqZWN0U3RvcmVOYW1lcyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBkYi5uYW1lLFxuICAgICAgICAgICAgICAgICAgdGFibGVzOiB0YWJsZXMubWFwKGZ1bmN0aW9uICh0YWJsZSkgeyByZXR1cm4gdHJhbnMub2JqZWN0U3RvcmUodGFibGUpOyB9KS5tYXAoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBzdG9yZS5rZXlQYXRoLCBhdXRvSW5jcmVtZW50ID0gc3RvcmUuYXV0b0luY3JlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG91bmQgPSBpc0FycmF5KGtleVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRib3VuZCA9IGtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhCeUtleVBhdGggPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdG9yZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmltYXJ5S2V5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQ6IG91dGJvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmQ6IGNvbXBvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aDoga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IGF1dG9JbmNyZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0S2V5OiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlczogYXJyYXlpZnkoc3RvcmUuaW5kZXhOYW1lcykubWFwKGZ1bmN0aW9uIChpbmRleE5hbWUpIHsgcmV0dXJuIHN0b3JlLmluZGV4KGluZGV4TmFtZSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBpbmRleC5uYW1lLCB1bmlxdWUgPSBpbmRleC51bmlxdWUsIG11bHRpRW50cnkgPSBpbmRleC5tdWx0aUVudHJ5LCBrZXlQYXRoID0gaW5kZXgua2V5UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wb3VuZCA9IGlzQXJyYXkoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmQ6IGNvbXBvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiB1bmlxdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlFbnRyeTogbXVsdGlFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0S2V5OiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldEluZGV4QnlLZXlQYXRoOiBmdW5jdGlvbiAoa2V5UGF0aCkgeyByZXR1cm4gaW5kZXhCeUtleVBhdGhbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXTsgfVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbXCI6aWRcIl0gPSByZXN1bHQucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV0gPSByZXN1bHQucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGhhc0dldEFsbDogdGFibGVzLmxlbmd0aCA+IDAgJiYgKCdnZXRBbGwnIGluIHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlc1swXSkpICYmXG4gICAgICAgICAgICAgICAgICAhKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICBbXS5jb25jYXQobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCopLykpWzFdIDwgNjA0KVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gMyApXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIGlmIChyYW5nZS50eXBlID09PSA0IClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgbmV2ZXIgdHlwZSB0byBJREJLZXlSYW5nZVwiKTtcbiAgICAgICAgICB2YXIgbG93ZXIgPSByYW5nZS5sb3dlciwgdXBwZXIgPSByYW5nZS51cHBlciwgbG93ZXJPcGVuID0gcmFuZ2UubG93ZXJPcGVuLCB1cHBlck9wZW4gPSByYW5nZS51cHBlck9wZW47XG4gICAgICAgICAgdmFyIGlkYlJhbmdlID0gbG93ZXIgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgIHVwcGVyID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgICBJZGJLZXlSYW5nZS51cHBlckJvdW5kKHVwcGVyLCAhIXVwcGVyT3BlbikgOlxuICAgICAgICAgICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgIElkYktleVJhbmdlLmxvd2VyQm91bmQobG93ZXIsICEhbG93ZXJPcGVuKSA6XG4gICAgICAgICAgICAgICAgICBJZGJLZXlSYW5nZS5ib3VuZChsb3dlciwgdXBwZXIsICEhbG93ZXJPcGVuLCAhIXVwcGVyT3Blbik7XG4gICAgICAgICAgcmV0dXJuIGlkYlJhbmdlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlRGJDb3JlVGFibGUodGFibGVTY2hlbWEpIHtcbiAgICAgICAgICB2YXIgdGFibGVOYW1lID0gdGFibGVTY2hlbWEubmFtZTtcbiAgICAgICAgICBmdW5jdGlvbiBtdXRhdGUoX2EpIHtcbiAgICAgICAgICAgICAgdmFyIHRyYW5zID0gX2EudHJhbnMsIHR5cGUgPSBfYS50eXBlLCBrZXlzID0gX2Eua2V5cywgdmFsdWVzID0gX2EudmFsdWVzLCByYW5nZSA9IF9hLnJhbmdlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgdmFyIG91dGJvdW5kID0gc3RvcmUua2V5UGF0aCA9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgdmFyIGlzQWRkT3JQdXQgPSB0eXBlID09PSBcInB1dFwiIHx8IHR5cGUgPT09IFwiYWRkXCI7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzQWRkT3JQdXQgJiYgdHlwZSAhPT0gJ2RlbGV0ZScgJiYgdHlwZSAhPT0gJ2RlbGV0ZVJhbmdlJylcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wZXJhdGlvbiB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IChrZXlzIHx8IHZhbHVlcyB8fCB7IGxlbmd0aDogMSB9KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiB2YWx1ZXMgJiYga2V5cy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHaXZlbiBrZXlzIGFycmF5IG11c3QgaGF2ZSBzYW1lIGxlbmd0aCBhcyBnaXZlbiB2YWx1ZXMgYXJyYXkuXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IG51bUZhaWx1cmVzOiAwLCBmYWlsdXJlczoge30sIHJlc3VsdHM6IFtdLCBsYXN0UmVzdWx0OiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVxO1xuICAgICAgICAgICAgICAgICAgdmFyIHJlcXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgdmFyIG51bUZhaWx1cmVzID0gMDtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICArK251bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RlbGV0ZVJhbmdlJykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS50eXBlID09PSA0IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBudW1GYWlsdXJlczogbnVtRmFpbHVyZXMsIGZhaWx1cmVzOiBmYWlsdXJlcywgcmVzdWx0czogW10sIGxhc3RSZXN1bHQ6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gMyApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZS5jbGVhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZS5kZWxldGUobWFrZUlEQktleVJhbmdlKHJhbmdlKSkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gaXNBZGRPclB1dCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dGJvdW5kID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZXMsIGtleXNdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZXMsIG51bGxdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2tleXMsIG51bGxdLCBhcmdzMSA9IF9hWzBdLCBhcmdzMiA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FkZE9yUHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSAoYXJnczIgJiYgYXJnczJbaV0gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbdHlwZV0oYXJnczFbaV0sIGFyZ3MyW2ldKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbdHlwZV0oYXJnczFbaV0pKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RSZXN1bHQgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgIHJlcXMuZm9yRWFjaChmdW5jdGlvbiAocmVxLCBpKSB7IHJldHVybiByZXEuZXJyb3IgIT0gbnVsbCAmJiAoZmFpbHVyZXNbaV0gPSByZXEuZXJyb3IpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtRmFpbHVyZXM6IG51bUZhaWx1cmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlczogZmFpbHVyZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IHR5cGUgPT09IFwiZGVsZXRlXCIgPyBrZXlzIDogcmVxcy5tYXAoZnVuY3Rpb24gKHJlcSkgeyByZXR1cm4gcmVxLnJlc3VsdDsgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZXN1bHQ6IGxhc3RSZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgZG9uZShldmVudCk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGRvbmU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBvcGVuQ3Vyc29yKF9hKSB7XG4gICAgICAgICAgICAgIHZhciB0cmFucyA9IF9hLnRyYW5zLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIHF1ZXJ5ID0gX2EucXVlcnksIHJldmVyc2UgPSBfYS5yZXZlcnNlLCB1bmlxdWUgPSBfYS51bmlxdWU7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHF1ZXJ5LmluZGV4LCByYW5nZSA9IHF1ZXJ5LnJhbmdlO1xuICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgP1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlIDpcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSByZXZlcnNlID9cbiAgICAgICAgICAgICAgICAgICAgICB1bmlxdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcInByZXZ1bmlxdWVcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwicHJldlwiIDpcbiAgICAgICAgICAgICAgICAgICAgICB1bmlxdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5leHR1bmlxdWVcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwibmV4dFwiO1xuICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHZhbHVlcyB8fCAhKCdvcGVuS2V5Q3Vyc29yJyBpbiBzb3VyY2UpID9cbiAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbkN1cnNvcihtYWtlSURCS2V5UmFuZ2UocmFuZ2UpLCBkaXJlY3Rpb24pIDpcbiAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbktleUN1cnNvcihtYWtlSURCS2V5UmFuZ2UocmFuZ2UpLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLl9fX2lkID0gKytfaWRfY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfY3Vyc29yQ29udGludWUgPSBjdXJzb3IuY29udGludWUuYmluZChjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSA9IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkuYmluZChjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfY3Vyc29yQWR2YW5jZSA9IGN1cnNvci5hZHZhbmNlLmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIG5vdCBzdGFydGVkXCIpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBkb1Rocm93Q3Vyc29ySXNTdG9wcGVkID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3Igbm90IHN0b3BwZWRcIik7IH07XG4gICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnRyYW5zID0gdHJhbnM7XG4gICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSBjdXJzb3IuY29udGludWUgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmFkdmFuY2UgPSBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkO1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsID0gd3JhcChyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ290T25lID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ290T25lLS0gPyBfdGhpcy5jb250aW51ZSgpIDogX3RoaXMuc3RvcCgpOyB9KS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdGFydCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlcmF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlSXRlcmF0aW9uLCByZWplY3RJdGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRpb24gPSB3cmFwKHJlc29sdmVJdGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0SXRlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsID0gcmVqZWN0SXRlcmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCA9IGN1cnNvci5jb250aW51ZSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkgPSBjdXJzb3IuYWR2YW5jZSA9IGRvVGhyb3dDdXJzb3JJc1N0b3BwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUl0ZXJhdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RhcnQgPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcihcIkN1cnNvciBiZWhpbmQgbGFzdCBlbnRyeVwiKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBndWFyZGVkQ2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWFyZGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSA9IF9jdXJzb3JDb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlID0gX2N1cnNvckFkdmFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0aW9uUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBxdWVyeShoYXNHZXRBbGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IHJlcXVlc3QudHJhbnMsIHZhbHVlcyA9IHJlcXVlc3QudmFsdWVzLCBsaW1pdCA9IHJlcXVlc3QubGltaXQsIHF1ZXJ5ID0gcmVxdWVzdC5xdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9uSW5maW5pdExpbWl0ID0gbGltaXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbGltaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcXVlcnkuaW5kZXgsIHJhbmdlID0gcXVlcnkucmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gaW5kZXguaXNQcmltYXJ5S2V5ID8gc3RvcmUgOiBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaWRiS2V5UmFuZ2UgPSBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQ6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNHZXRBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHZhbHVlcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuZ2V0QWxsKGlkYktleVJhbmdlLCBub25JbmZpbml0TGltaXQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5nZXRBbGxLZXlzKGlkYktleVJhbmdlLCBub25JbmZpbml0TGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiByZXNvbHZlKHsgcmVzdWx0OiBldmVudC50YXJnZXQucmVzdWx0IH0pOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50XzEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxXzEgPSB2YWx1ZXMgfHwgISgnb3BlbktleUN1cnNvcicgaW4gc291cmNlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbkN1cnNvcihpZGJLZXlSYW5nZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5LZXlDdXJzb3IoaWRiS2V5UmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxXzEub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxXzEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQ6IHJlc3VsdF8xIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzEucHVzaCh2YWx1ZXMgPyBjdXJzb3IudmFsdWUgOiBjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytjb3VudF8xID09PSBsaW1pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IHJlc3VsdDogcmVzdWx0XzEgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxXzEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuYW1lOiB0YWJsZU5hbWUsXG4gICAgICAgICAgICAgIHNjaGVtYTogdGFibGVTY2hlbWEsXG4gICAgICAgICAgICAgIG11dGF0ZTogbXV0YXRlLFxuICAgICAgICAgICAgICBnZXRNYW55OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IF9hLnRyYW5zLCBrZXlzID0gX2Eua2V5cztcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByZXE7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0W3JlcS5fcG9zXSA9IHJlcS5yZXN1bHQpICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NhbGxiYWNrQ291bnQgPT09IGtleUNvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gc3RvcmUuZ2V0KGtleXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLl9wb3MgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHN1Y2Nlc3NIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2tleUNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBfYS50cmFucywga2V5ID0gX2Eua2V5O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5KGhhc0dldEFsbCksXG4gICAgICAgICAgICAgIG9wZW5DdXJzb3I6IG9wZW5DdXJzb3IsXG4gICAgICAgICAgICAgIGNvdW50OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IF9hLnF1ZXJ5LCB0cmFucyA9IF9hLnRyYW5zO1xuICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcXVlcnkuaW5kZXgsIHJhbmdlID0gcXVlcnkucmFuZ2U7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGlkYktleVJhbmdlID0gbWFrZUlEQktleVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gaWRiS2V5UmFuZ2UgPyBzb3VyY2UuY291bnQoaWRiS2V5UmFuZ2UpIDogc291cmNlLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7IHJldHVybiByZXNvbHZlKGV2LnRhcmdldC5yZXN1bHQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIF9hID0gZXh0cmFjdFNjaGVtYShkYiwgdG1wVHJhbnMpLCBzY2hlbWEgPSBfYS5zY2hlbWEsIGhhc0dldEFsbCA9IF9hLmhhc0dldEFsbDtcbiAgICAgIHZhciB0YWJsZXMgPSBzY2hlbWEudGFibGVzLm1hcChmdW5jdGlvbiAodGFibGVTY2hlbWEpIHsgcmV0dXJuIGNyZWF0ZURiQ29yZVRhYmxlKHRhYmxlU2NoZW1hKTsgfSk7XG4gICAgICB2YXIgdGFibGVNYXAgPSB7fTtcbiAgICAgIHRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZSkgeyByZXR1cm4gdGFibGVNYXBbdGFibGUubmFtZV0gPSB0YWJsZTsgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiBkYi50cmFuc2FjdGlvbi5iaW5kKGRiKSxcbiAgICAgICAgICB0YWJsZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhYmxlTWFwW25hbWVdO1xuICAgICAgICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRhYmxlICdcIi5jb25jYXQobmFtZSwgXCInIG5vdCBmb3VuZFwiKSk7XG4gICAgICAgICAgICAgIHJldHVybiB0YWJsZU1hcFtuYW1lXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIE1JTl9LRVk6IC1JbmZpbml0eSxcbiAgICAgICAgICBNQVhfS0VZOiBnZXRNYXhLZXkoSWRiS2V5UmFuZ2UpLFxuICAgICAgICAgIHNjaGVtYTogc2NoZW1hXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZVN0YWNrKHN0YWNrSW1wbCwgbWlkZGxld2FyZXMpIHtcbiAgICAgIHJldHVybiBtaWRkbGV3YXJlcy5yZWR1Y2UoZnVuY3Rpb24gKGRvd24sIF9hKSB7XG4gICAgICAgICAgdmFyIGNyZWF0ZSA9IF9hLmNyZWF0ZTtcbiAgICAgICAgICByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb3duKSwgY3JlYXRlKGRvd24pKSk7XG4gICAgICB9LCBzdGFja0ltcGwpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVTdGFja3MobWlkZGxld2FyZXMsIGlkYmRiLCBfYSwgdG1wVHJhbnMpIHtcbiAgICAgIHZhciBJREJLZXlSYW5nZSA9IF9hLklEQktleVJhbmdlOyBfYS5pbmRleGVkREI7XG4gICAgICB2YXIgZGJjb3JlID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrKGNyZWF0ZURCQ29yZShpZGJkYiwgSURCS2V5UmFuZ2UsIHRtcFRyYW5zKSwgbWlkZGxld2FyZXMuZGJjb3JlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGJjb3JlOiBkYmNvcmVcbiAgICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCB0bXBUcmFucykge1xuICAgICAgdmFyIGlkYmRiID0gdG1wVHJhbnMuZGI7XG4gICAgICB2YXIgc3RhY2tzID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhkYi5fbWlkZGxld2FyZXMsIGlkYmRiLCBkYi5fZGVwcywgdG1wVHJhbnMpO1xuICAgICAgZGIuY29yZSA9IHN0YWNrcy5kYmNvcmU7XG4gICAgICBkYi50YWJsZXMuZm9yRWFjaChmdW5jdGlvbiAodGFibGUpIHtcbiAgICAgICAgICB2YXIgdGFibGVOYW1lID0gdGFibGUubmFtZTtcbiAgICAgICAgICBpZiAoZGIuY29yZS5zY2hlbWEudGFibGVzLnNvbWUoZnVuY3Rpb24gKHRibCkgeyByZXR1cm4gdGJsLm5hbWUgPT09IHRhYmxlTmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgdGFibGUuY29yZSA9IGRiLmNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgaWYgKGRiW3RhYmxlTmFtZV0gaW5zdGFuY2VvZiBkYi5UYWJsZSkge1xuICAgICAgICAgICAgICAgICAgZGJbdGFibGVOYW1lXS5jb3JlID0gdGFibGUuY29yZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0QXBpT25QbGFjZShkYiwgb2JqcywgdGFibGVOYW1lcywgZGJzY2hlbWEpIHtcbiAgICAgIHRhYmxlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgdmFyIHNjaGVtYSA9IGRic2NoZW1hW3RhYmxlTmFtZV07XG4gICAgICAgICAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BEZXNjID0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgdGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgaWYgKCFwcm9wRGVzYyB8fCAoXCJ2YWx1ZVwiIGluIHByb3BEZXNjICYmIHByb3BEZXNjLnZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAob2JqID09PSBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGUgfHwgb2JqIGluc3RhbmNlb2YgZGIuVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG9iaiwgdGFibGVOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50YWJsZSh0YWJsZU5hbWUpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgdGFibGVOYW1lLCB7IHZhbHVlOiB2YWx1ZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgb2JqW3RhYmxlTmFtZV0gPSBuZXcgZGIuVGFibGUodGFibGVOYW1lLCBzY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVUYWJsZXNBcGkoZGIsIG9ianMpIHtcbiAgICAgIG9ianMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICBpZiAob2JqW2tleV0gaW5zdGFuY2VvZiBkYi5UYWJsZSlcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBsb3dlclZlcnNpb25GaXJzdChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5fY2ZnLnZlcnNpb24gLSBiLl9jZmcudmVyc2lvbjtcbiAgfVxuICBmdW5jdGlvbiBydW5VcGdyYWRlcnMoZGIsIG9sZFZlcnNpb24sIGlkYlVwZ3JhZGVUcmFucywgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hO1xuICAgICAgaWYgKGlkYlVwZ3JhZGVUcmFucy5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCckbWV0YScpICYmICFnbG9iYWxTY2hlbWEuJG1ldGEpIHtcbiAgICAgICAgICBnbG9iYWxTY2hlbWEuJG1ldGEgPSBjcmVhdGVUYWJsZVNjaGVtYShcIiRtZXRhXCIsIHBhcnNlSW5kZXhTeW50YXgoXCJcIilbMF0sIFtdKTtcbiAgICAgICAgICBkYi5fc3RvcmVOYW1lcy5wdXNoKCckbWV0YScpO1xuICAgICAgfVxuICAgICAgdmFyIHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnLCBkYi5fc3RvcmVOYW1lcywgZ2xvYmFsU2NoZW1hKTtcbiAgICAgIHRyYW5zLmNyZWF0ZShpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgdHJhbnMuX2NvbXBsZXRpb24uY2F0Y2gocmVqZWN0KTtcbiAgICAgIHZhciByZWplY3RUcmFuc2FjdGlvbiA9IHRyYW5zLl9yZWplY3QuYmluZCh0cmFucyk7XG4gICAgICB2YXIgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gICAgICBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgUFNELnRyYW5zID0gdHJhbnM7XG4gICAgICAgICAgUFNELnRyYW5zbGVzcyA9IHRyYW5zbGVzcztcbiAgICAgICAgICBpZiAob2xkVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICBrZXlzKGdsb2JhbFNjaGVtYSkuZm9yRWFjaChmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJVcGdyYWRlVHJhbnMsIHRhYmxlTmFtZSwgZ2xvYmFsU2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgZ2xvYmFsU2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgICAgICAgIERleGllUHJvbWlzZS5mb2xsb3coZnVuY3Rpb24gKCkgeyByZXR1cm4gZGIub24ucG9wdWxhdGUuZmlyZSh0cmFucyk7IH0pLmNhdGNoKHJlamVjdFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEV4aXN0aW5nVmVyc2lvbihkYiwgdHJhbnMsIG9sZFZlcnNpb24pXG4gICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2xkVmVyc2lvbikgeyByZXR1cm4gdXBkYXRlVGFibGVzQW5kSW5kZXhlcyhkYiwgb2xkVmVyc2lvbiwgdHJhbnMsIGlkYlVwZ3JhZGVUcmFucyk7IH0pXG4gICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHBhdGNoQ3VycmVudFZlcnNpb24oZGIsIGlkYlVwZ3JhZGVUcmFucykge1xuICAgICAgY3JlYXRlTWlzc2luZ1RhYmxlcyhkYi5fZGJTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICBpZiAoaWRiVXBncmFkZVRyYW5zLmRiLnZlcnNpb24gJSAxMCA9PT0gMCAmJiAhaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJyRtZXRhJykpIHtcbiAgICAgICAgICBpZGJVcGdyYWRlVHJhbnMuZGIuY3JlYXRlT2JqZWN0U3RvcmUoJyRtZXRhJykuYWRkKE1hdGguY2VpbCgoaWRiVXBncmFkZVRyYW5zLmRiLnZlcnNpb24gLyAxMCkgLSAxKSwgJ3ZlcnNpb24nKTtcbiAgICAgIH1cbiAgICAgIHZhciBnbG9iYWxTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgZGIuX2RiU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgdmFyIGRpZmYgPSBnZXRTY2hlbWFEaWZmKGdsb2JhbFNjaGVtYSwgZGIuX2RiU2NoZW1hKTtcbiAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHRhYmxlQ2hhbmdlKSB7XG4gICAgICAgICAgaWYgKHRhYmxlQ2hhbmdlLmNoYW5nZS5sZW5ndGggfHwgdGFibGVDaGFuZ2UucmVjcmVhdGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5hYmxlIHRvIHBhdGNoIGluZGV4ZXMgb2YgdGFibGUgXCIuY29uY2F0KHRhYmxlQ2hhbmdlLm5hbWUsIFwiIGJlY2F1c2UgaXQgaGFzIGNoYW5nZXMgb24gdGhlIHR5cGUgb2YgaW5kZXggb3IgcHJpbWFyeSBrZXkuXCIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RvcmUgPSBpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmUodGFibGVDaGFuZ2UubmFtZSk7XG4gICAgICAgICAgdGFibGVDaGFuZ2UuYWRkLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICBpZiAoZGVidWcpXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiRGV4aWUgdXBncmFkZSBwYXRjaDogQ3JlYXRpbmcgbWlzc2luZyBpbmRleCBcIi5jb25jYXQodGFibGVDaGFuZ2UubmFtZSwgXCIuXCIpLmNvbmNhdChpZHguc3JjKSk7XG4gICAgICAgICAgICAgIGFkZEluZGV4KHN0b3JlLCBpZHgpO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBkaWZmLmNoYW5nZTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgdGFibGVDaGFuZ2UgPSBfYVtfaV07XG4gICAgICAgICAgdmFyIHN0YXRlXzEgPSBfbG9vcF8xKHRhYmxlQ2hhbmdlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlXzEgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHJldHVybiBzdGF0ZV8xLnZhbHVlO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldEV4aXN0aW5nVmVyc2lvbihkYiwgdHJhbnMsIG9sZFZlcnNpb24pIHtcbiAgICAgIGlmICh0cmFucy5zdG9yZU5hbWVzLmluY2x1ZGVzKCckbWV0YScpKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zLnRhYmxlKCckbWV0YScpLmdldCgndmVyc2lvbicpLnRoZW4oZnVuY3Rpb24gKG1ldGFWZXJzaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtZXRhVmVyc2lvbiAhPSBudWxsID8gbWV0YVZlcnNpb24gOiBvbGRWZXJzaW9uO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKG9sZFZlcnNpb24pO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMoZGIsIG9sZFZlcnNpb24sIHRyYW5zLCBpZGJVcGdyYWRlVHJhbnMpIHtcbiAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgdmFyIHZlcnNpb25zID0gZGIuX3ZlcnNpb25zO1xuICAgICAgdmFyIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBkYi5pZGJkYiwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgIHZhciB2ZXJzVG9SdW4gPSB2ZXJzaW9ucy5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuX2NmZy52ZXJzaW9uID49IG9sZFZlcnNpb247IH0pO1xuICAgICAgaWYgKHZlcnNUb1J1bi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHZlcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgICAgcXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBvbGRTY2hlbWEgPSBnbG9iYWxTY2hlbWE7XG4gICAgICAgICAgICAgIHZhciBuZXdTY2hlbWEgPSB2ZXJzaW9uLl9jZmcuZGJzY2hlbWE7XG4gICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBvbGRTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBuZXdTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgICAgICAgIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IG5ld1NjaGVtYTtcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBnZXRTY2hlbWFEaWZmKG9sZFNjaGVtYSwgbmV3U2NoZW1hKTtcbiAgICAgICAgICAgICAgZGlmZi5hZGQuZm9yRWFjaChmdW5jdGlvbiAodHVwbGUpIHtcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZVRhYmxlKGlkYlVwZ3JhZGVUcmFucywgdHVwbGVbMF0sIHR1cGxlWzFdLnByaW1LZXksIHR1cGxlWzFdLmluZGV4ZXMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnJlY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVXBncmFkZShcIk5vdCB5ZXQgc3VwcG9ydCBmb3IgY2hhbmdpbmcgcHJpbWFyeSBrZXlcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVfMSA9IGlkYlVwZ3JhZGVUcmFucy5vYmplY3RTdG9yZShjaGFuZ2UubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmFkZC5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIGFkZEluZGV4KHN0b3JlXzEsIGlkeCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5jaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlXzEuZGVsZXRlSW5kZXgoaWR4Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRJbmRleChzdG9yZV8xLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5kZWwuZm9yRWFjaChmdW5jdGlvbiAoaWR4TmFtZSkgeyByZXR1cm4gc3RvcmVfMS5kZWxldGVJbmRleChpZHhOYW1lKTsgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgY29udGVudFVwZ3JhZGUgPSB2ZXJzaW9uLl9jZmcuY29udGVudFVwZ3JhZGU7XG4gICAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZSAmJiB2ZXJzaW9uLl9jZmcudmVyc2lvbiA+IG9sZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgICAgICAgICAgICAgIHRyYW5zLl9tZW1vaXplZFRhYmxlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgdmFyIHVwZ3JhZGVTY2hlbWFfMSA9IHNoYWxsb3dDbG9uZShuZXdTY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgZGlmZi5kZWwuZm9yRWFjaChmdW5jdGlvbiAodGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB1cGdyYWRlU2NoZW1hXzFbdGFibGVdID0gb2xkU2NoZW1hW3RhYmxlXTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG4gICAgICAgICAgICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSwga2V5cyh1cGdyYWRlU2NoZW1hXzEpLCB1cGdyYWRlU2NoZW1hXzEpO1xuICAgICAgICAgICAgICAgICAgdHJhbnMuc2NoZW1hID0gdXBncmFkZVNjaGVtYV8xO1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRVcGdyYWRlSXNBc3luY18xID0gaXNBc3luY0Z1bmN0aW9uKGNvbnRlbnRVcGdyYWRlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZUlzQXN5bmNfMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWVfMTtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlRm9sbG93ZWQgPSBEZXhpZVByb21pc2UuZm9sbG93KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZV8xID0gY29udGVudFVwZ3JhZGUodHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZV8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZUlzQXN5bmNfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3JlbWVudG9yID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMuYmluZChudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlXzEudGhlbihkZWNyZW1lbnRvciwgZGVjcmVtZW50b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlXzEgJiYgdHlwZW9mIHJldHVyblZhbHVlXzEudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWVfMSkgOiBwcm9taXNlRm9sbG93ZWQudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXR1cm5WYWx1ZV8xOyB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBxdWV1ZS5wdXNoKGZ1bmN0aW9uIChpZGJ0cmFucykge1xuICAgICAgICAgICAgICB2YXIgbmV3U2NoZW1hID0gdmVyc2lvbi5fY2ZnLmRic2NoZW1hO1xuICAgICAgICAgICAgICBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpO1xuICAgICAgICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICAgICAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGRiLl9zdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEpO1xuICAgICAgICAgICAgICB0cmFucy5zY2hlbWEgPSBkYi5fZGJTY2hlbWE7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcXVldWUucHVzaChmdW5jdGlvbiAoaWRidHJhbnMpIHtcbiAgICAgICAgICAgICAgaWYgKGRiLmlkYmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJyRtZXRhJykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmNlaWwoZGIuaWRiZGIudmVyc2lvbiAvIDEwKSA9PT0gdmVyc2lvbi5fY2ZnLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICBkYi5pZGJkYi5kZWxldGVPYmplY3RTdG9yZSgnJG1ldGEnKTtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGIuX2RiU2NoZW1hLiRtZXRhO1xuICAgICAgICAgICAgICAgICAgICAgIGRiLl9zdG9yZU5hbWVzID0gZGIuX3N0b3JlTmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuYW1lICE9PSAnJG1ldGEnOyB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlkYnRyYW5zLm9iamVjdFN0b3JlKCckbWV0YScpLnB1dCh2ZXJzaW9uLl9jZmcudmVyc2lvbiwgJ3ZlcnNpb24nKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBmdW5jdGlvbiBydW5RdWV1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gcXVldWUubGVuZ3RoID8gRGV4aWVQcm9taXNlLnJlc29sdmUocXVldWUuc2hpZnQoKSh0cmFucy5pZGJ0cmFucykpLnRoZW4ocnVuUXVldWUpIDpcbiAgICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydW5RdWV1ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNyZWF0ZU1pc3NpbmdUYWJsZXMoZ2xvYmFsU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U2NoZW1hRGlmZihvbGRTY2hlbWEsIG5ld1NjaGVtYSkge1xuICAgICAgdmFyIGRpZmYgPSB7XG4gICAgICAgICAgZGVsOiBbXSxcbiAgICAgICAgICBhZGQ6IFtdLFxuICAgICAgICAgIGNoYW5nZTogW11cbiAgICAgIH07XG4gICAgICB2YXIgdGFibGU7XG4gICAgICBmb3IgKHRhYmxlIGluIG9sZFNjaGVtYSkge1xuICAgICAgICAgIGlmICghbmV3U2NoZW1hW3RhYmxlXSlcbiAgICAgICAgICAgICAgZGlmZi5kZWwucHVzaCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBmb3IgKHRhYmxlIGluIG5ld1NjaGVtYSkge1xuICAgICAgICAgIHZhciBvbGREZWYgPSBvbGRTY2hlbWFbdGFibGVdLCBuZXdEZWYgPSBuZXdTY2hlbWFbdGFibGVdO1xuICAgICAgICAgIGlmICghb2xkRGVmKSB7XG4gICAgICAgICAgICAgIGRpZmYuYWRkLnB1c2goW3RhYmxlLCBuZXdEZWZdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgICAgICAgIGRlZjogbmV3RGVmLFxuICAgICAgICAgICAgICAgICAgcmVjcmVhdGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgZGVsOiBbXSxcbiAgICAgICAgICAgICAgICAgIGFkZDogW10sXG4gICAgICAgICAgICAgICAgICBjaGFuZ2U6IFtdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmICgoXG4gICAgICAgICAgICAgICcnICsgKG9sZERlZi5wcmltS2V5LmtleVBhdGggfHwgJycpKSAhPT0gKCcnICsgKG5ld0RlZi5wcmltS2V5LmtleVBhdGggfHwgJycpKSB8fFxuICAgICAgICAgICAgICAgICAgKG9sZERlZi5wcmltS2V5LmF1dG8gIT09IG5ld0RlZi5wcmltS2V5LmF1dG8pKSB7XG4gICAgICAgICAgICAgICAgICBjaGFuZ2UucmVjcmVhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIG9sZEluZGV4ZXMgPSBvbGREZWYuaWR4QnlOYW1lO1xuICAgICAgICAgICAgICAgICAgdmFyIG5ld0luZGV4ZXMgPSBuZXdEZWYuaWR4QnlOYW1lO1xuICAgICAgICAgICAgICAgICAgdmFyIGlkeE5hbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICBmb3IgKGlkeE5hbWUgaW4gb2xkSW5kZXhlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV3SW5kZXhlc1tpZHhOYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmRlbC5wdXNoKGlkeE5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm9yIChpZHhOYW1lIGluIG5ld0luZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkSWR4ID0gb2xkSW5kZXhlc1tpZHhOYW1lXSwgbmV3SWR4ID0gbmV3SW5kZXhlc1tpZHhOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZElkeClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmFkZC5wdXNoKG5ld0lkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkSWR4LnNyYyAhPT0gbmV3SWR4LnNyYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmNoYW5nZS5wdXNoKG5ld0lkeCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLmRlbC5sZW5ndGggPiAwIHx8IGNoYW5nZS5hZGQubGVuZ3RoID4gMCB8fCBjaGFuZ2UuY2hhbmdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBkaWZmLmNoYW5nZS5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlmZjtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVUYWJsZShpZGJ0cmFucywgdGFibGVOYW1lLCBwcmltS2V5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgc3RvcmUgPSBpZGJ0cmFucy5kYi5jcmVhdGVPYmplY3RTdG9yZSh0YWJsZU5hbWUsIHByaW1LZXkua2V5UGF0aCA/XG4gICAgICAgICAgeyBrZXlQYXRoOiBwcmltS2V5LmtleVBhdGgsIGF1dG9JbmNyZW1lbnQ6IHByaW1LZXkuYXV0byB9IDpcbiAgICAgICAgICB7IGF1dG9JbmNyZW1lbnQ6IHByaW1LZXkuYXV0byB9KTtcbiAgICAgIGluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBhZGRJbmRleChzdG9yZSwgaWR4KTsgfSk7XG4gICAgICByZXR1cm4gc3RvcmU7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlTWlzc2luZ1RhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKSB7XG4gICAgICBrZXlzKG5ld1NjaGVtYSkuZm9yRWFjaChmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgaWYgKCFpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHRhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnRGV4aWU6IENyZWF0aW5nIG1pc3NpbmcgdGFibGUnLCB0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJ0cmFucywgdGFibGVOYW1lLCBuZXdTY2hlbWFbdGFibGVOYW1lXS5wcmltS2V5LCBuZXdTY2hlbWFbdGFibGVOYW1lXS5pbmRleGVzKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpIHtcbiAgICAgIFtdLnNsaWNlLmNhbGwoaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcykuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIG5ld1NjaGVtYVtzdG9yZU5hbWVdID09IG51bGwgJiYgaWRidHJhbnMuZGIuZGVsZXRlT2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFkZEluZGV4KHN0b3JlLCBpZHgpIHtcbiAgICAgIHN0b3JlLmNyZWF0ZUluZGV4KGlkeC5uYW1lLCBpZHgua2V5UGF0aCwgeyB1bmlxdWU6IGlkeC51bmlxdWUsIG11bHRpRW50cnk6IGlkeC5tdWx0aSB9KTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKSB7XG4gICAgICB2YXIgZ2xvYmFsU2NoZW1hID0ge307XG4gICAgICB2YXIgZGJTdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcywgMCk7XG4gICAgICBkYlN0b3JlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG4gICAgICAgICAgdmFyIHN0b3JlID0gdG1wVHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgICB2YXIga2V5UGF0aCA9IHN0b3JlLmtleVBhdGg7XG4gICAgICAgICAgdmFyIHByaW1LZXkgPSBjcmVhdGVJbmRleFNwZWMobmFtZUZyb21LZXlQYXRoKGtleVBhdGgpLCBrZXlQYXRoIHx8IFwiXCIsIHRydWUsIGZhbHNlLCAhIXN0b3JlLmF1dG9JbmNyZW1lbnQsIGtleVBhdGggJiYgdHlwZW9mIGtleVBhdGggIT09IFwic3RyaW5nXCIsIHRydWUpO1xuICAgICAgICAgIHZhciBpbmRleGVzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdG9yZS5pbmRleE5hbWVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgIHZhciBpZGJpbmRleCA9IHN0b3JlLmluZGV4KHN0b3JlLmluZGV4TmFtZXNbal0pO1xuICAgICAgICAgICAgICBrZXlQYXRoID0gaWRiaW5kZXgua2V5UGF0aDtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gY3JlYXRlSW5kZXhTcGVjKGlkYmluZGV4Lm5hbWUsIGtleVBhdGgsICEhaWRiaW5kZXgudW5pcXVlLCAhIWlkYmluZGV4Lm11bHRpRW50cnksIGZhbHNlLCBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSBcInN0cmluZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdsb2JhbFNjaGVtYVtzdG9yZU5hbWVdID0gY3JlYXRlVGFibGVTY2hlbWEoc3RvcmVOYW1lLCBwcmltS2V5LCBpbmRleGVzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGdsb2JhbFNjaGVtYTtcbiAgfVxuICBmdW5jdGlvbiByZWFkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpIHtcbiAgICAgIGRiLnZlcm5vID0gaWRiZGIudmVyc2lvbiAvIDEwO1xuICAgICAgdmFyIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpO1xuICAgICAgZGIuX3N0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzLCAwKTtcbiAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5fYWxsVGFibGVzXSwga2V5cyhnbG9iYWxTY2hlbWEpLCBnbG9iYWxTY2hlbWEpO1xuICB9XG4gIGZ1bmN0aW9uIHZlcmlmeUluc3RhbGxlZFNjaGVtYShkYiwgdG1wVHJhbnMpIHtcbiAgICAgIHZhciBpbnN0YWxsZWRTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIHRtcFRyYW5zKTtcbiAgICAgIHZhciBkaWZmID0gZ2V0U2NoZW1hRGlmZihpbnN0YWxsZWRTY2hlbWEsIGRiLl9kYlNjaGVtYSk7XG4gICAgICByZXR1cm4gIShkaWZmLmFkZC5sZW5ndGggfHwgZGlmZi5jaGFuZ2Uuc29tZShmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIGNoLmFkZC5sZW5ndGggfHwgY2guY2hhbmdlLmxlbmd0aDsgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBzY2hlbWEsIGlkYnRyYW5zKSB7XG4gICAgICB2YXIgc3RvcmVOYW1lcyA9IGlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3JlTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgc3RvcmVOYW1lID0gc3RvcmVOYW1lc1tpXTtcbiAgICAgICAgICB2YXIgc3RvcmUgPSBpZGJ0cmFucy5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICAgIGRiLl9oYXNHZXRBbGwgPSAnZ2V0QWxsJyBpbiBzdG9yZTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4TmFtZSA9IHN0b3JlLmluZGV4TmFtZXNbal07XG4gICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKS5rZXlQYXRoO1xuICAgICAgICAgICAgICB2YXIgZGV4aWVOYW1lID0gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8ga2V5UGF0aCA6IFwiW1wiICsgc2xpY2Uoa2V5UGF0aCkuam9pbignKycpICsgXCJdXCI7XG4gICAgICAgICAgICAgIGlmIChzY2hlbWFbc3RvcmVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGluZGV4U3BlYyA9IHNjaGVtYVtzdG9yZU5hbWVdLmlkeEJ5TmFtZVtkZXhpZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgaWYgKGluZGV4U3BlYykge1xuICAgICAgICAgICAgICAgICAgICAgIGluZGV4U3BlYy5uYW1lID0gaW5kZXhOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbaW5kZXhOYW1lXSA9IGluZGV4U3BlYztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgIS8oQ2hyb21lXFwvfEVkZ2VcXC8pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgX2dsb2JhbC5Xb3JrZXJHbG9iYWxTY29wZSAmJiBfZ2xvYmFsIGluc3RhbmNlb2YgX2dsb2JhbC5Xb3JrZXJHbG9iYWxTY29wZSAmJlxuICAgICAgICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpIHtcbiAgICAgICAgICBkYi5faGFzR2V0QWxsID0gZmFsc2U7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VJbmRleFN5bnRheChwcmltS2V5QW5kSW5kZXhlcykge1xuICAgICAgcmV0dXJuIHByaW1LZXlBbmRJbmRleGVzLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChpbmRleCwgaW5kZXhOdW0pIHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgdmFyIHR5cGVTcGxpdCA9IGluZGV4LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgdmFyIHR5cGUgPSAoX2EgPSB0eXBlU3BsaXRbMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmltKCk7XG4gICAgICAgICAgaW5kZXggPSB0eXBlU3BsaXRbMF0udHJpbSgpO1xuICAgICAgICAgIHZhciBuYW1lID0gaW5kZXgucmVwbGFjZSgvKFsmKl18XFwrXFwrKS9nLCBcIlwiKTtcbiAgICAgICAgICB2YXIga2V5UGF0aCA9IC9eXFxbLy50ZXN0KG5hbWUpID8gbmFtZS5tYXRjaCgvXlxcWyguKilcXF0kLylbMV0uc3BsaXQoJysnKSA6IG5hbWU7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUluZGV4U3BlYyhuYW1lLCBrZXlQYXRoIHx8IG51bGwsIC9cXCYvLnRlc3QoaW5kZXgpLCAvXFwqLy50ZXN0KGluZGV4KSwgL1xcK1xcKy8udGVzdChpbmRleCksIGlzQXJyYXkoa2V5UGF0aCksIGluZGV4TnVtID09PSAwLCB0eXBlKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgdmFyIFZlcnNpb24gPSAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZlcnNpb24oKSB7XG4gICAgICB9XG4gICAgICBWZXJzaW9uLnByb3RvdHlwZS5fY3JlYXRlVGFibGVTY2hlbWEgPSBmdW5jdGlvbiAobmFtZSwgcHJpbUtleSwgaW5kZXhlcykge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVUYWJsZVNjaGVtYShuYW1lLCBwcmltS2V5LCBpbmRleGVzKTtcbiAgICAgIH07XG4gICAgICBWZXJzaW9uLnByb3RvdHlwZS5fcGFyc2VJbmRleFN5bnRheCA9IGZ1bmN0aW9uIChwcmltS2V5QW5kSW5kZXhlcykge1xuICAgICAgICAgIHJldHVybiBwYXJzZUluZGV4U3ludGF4KHByaW1LZXlBbmRJbmRleGVzKTtcbiAgICAgIH07XG4gICAgICBWZXJzaW9uLnByb3RvdHlwZS5fcGFyc2VTdG9yZXNTcGVjID0gZnVuY3Rpb24gKHN0b3Jlcywgb3V0U2NoZW1hKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBrZXlzKHN0b3JlcykuZm9yRWFjaChmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgICAgIGlmIChzdG9yZXNbdGFibGVOYW1lXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBfdGhpcy5fcGFyc2VJbmRleFN5bnRheChzdG9yZXNbdGFibGVOYW1lXSk7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJpbUtleSA9IGluZGV4ZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgIGlmICghcHJpbUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYSgnSW52YWxpZCBzY2hlbWEgZm9yIHRhYmxlICcgKyB0YWJsZU5hbWUgKyAnOiAnICsgc3RvcmVzW3RhYmxlTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcHJpbUtleS51bmlxdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkubXVsdGkpXG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKCdQcmltYXJ5IGtleSBjYW5ub3QgYmUgbXVsdGlFbnRyeSonKTtcbiAgICAgICAgICAgICAgICAgIGluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeC5hdXRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoJ09ubHkgcHJpbWFyeSBrZXkgY2FuIGJlIG1hcmtlZCBhcyBhdXRvSW5jcmVtZW50ICgrKyknKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlkeC5rZXlQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoJ0luZGV4IG11c3QgaGF2ZSBhIG5hbWUgYW5kIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdmFyIHRibFNjaGVtYSA9IF90aGlzLl9jcmVhdGVUYWJsZVNjaGVtYSh0YWJsZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuICAgICAgICAgICAgICAgICAgb3V0U2NoZW1hW3RhYmxlTmFtZV0gPSB0YmxTY2hlbWE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBWZXJzaW9uLnByb3RvdHlwZS5zdG9yZXMgPSBmdW5jdGlvbiAoc3RvcmVzKSB7XG4gICAgICAgICAgdmFyIGRiID0gdGhpcy5kYjtcbiAgICAgICAgICB0aGlzLl9jZmcuc3RvcmVzU291cmNlID0gdGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZVxuICAgICAgICAgICAgICA/IGV4dGVuZCh0aGlzLl9jZmcuc3RvcmVzU291cmNlLCBzdG9yZXMpXG4gICAgICAgICAgICAgIDogc3RvcmVzO1xuICAgICAgICAgIHZhciB2ZXJzaW9ucyA9IGRiLl92ZXJzaW9ucztcbiAgICAgICAgICB2YXIgc3RvcmVzU3BlYyA9IHt9O1xuICAgICAgICAgIHZhciBkYnNjaGVtYSA9IHt9O1xuICAgICAgICAgIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgICAgICAgZXh0ZW5kKHN0b3Jlc1NwZWMsIHZlcnNpb24uX2NmZy5zdG9yZXNTb3VyY2UpO1xuICAgICAgICAgICAgICBkYnNjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYSA9IHt9O1xuICAgICAgICAgICAgICB2ZXJzaW9uLl9wYXJzZVN0b3Jlc1NwZWMoc3RvcmVzU3BlYywgZGJzY2hlbWEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRiLl9kYlNjaGVtYSA9IGRic2NoZW1hO1xuICAgICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLl9hbGxUYWJsZXMsIGRiLCBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuX2FsbFRhYmxlcywgZGIsIGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZSwgdGhpcy5fY2ZnLnRhYmxlc10sIGtleXMoZGJzY2hlbWEpLCBkYnNjaGVtYSk7XG4gICAgICAgICAgZGIuX3N0b3JlTmFtZXMgPSBrZXlzKGRic2NoZW1hKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBWZXJzaW9uLnByb3RvdHlwZS51cGdyYWRlID0gZnVuY3Rpb24gKHVwZ3JhZGVGdW5jdGlvbikge1xuICAgICAgICAgIHRoaXMuX2NmZy5jb250ZW50VXBncmFkZSA9IHByb21pc2FibGVDaGFpbih0aGlzLl9jZmcuY29udGVudFVwZ3JhZGUgfHwgbm9wLCB1cGdyYWRlRnVuY3Rpb24pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBWZXJzaW9uO1xuICB9KCkpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVZlcnNpb25Db25zdHJ1Y3RvcihkYikge1xuICAgICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFZlcnNpb24ucHJvdG90eXBlLCBmdW5jdGlvbiBWZXJzaW9uKHZlcnNpb25OdW1iZXIpIHtcbiAgICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgICAgdGhpcy5fY2ZnID0ge1xuICAgICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uTnVtYmVyLFxuICAgICAgICAgICAgICBzdG9yZXNTb3VyY2U6IG51bGwsXG4gICAgICAgICAgICAgIGRic2NoZW1hOiB7fSxcbiAgICAgICAgICAgICAgdGFibGVzOiB7fSxcbiAgICAgICAgICAgICAgY29udGVudFVwZ3JhZGU6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkge1xuICAgICAgdmFyIGRiTmFtZXNEQiA9IGluZGV4ZWREQltcIl9kYk5hbWVzREJcIl07XG4gICAgICBpZiAoIWRiTmFtZXNEQikge1xuICAgICAgICAgIGRiTmFtZXNEQiA9IGluZGV4ZWREQltcIl9kYk5hbWVzREJcIl0gPSBuZXcgRGV4aWUkMShEQk5BTUVTX0RCLCB7XG4gICAgICAgICAgICAgIGFkZG9uczogW10sXG4gICAgICAgICAgICAgIGluZGV4ZWREQjogaW5kZXhlZERCLFxuICAgICAgICAgICAgICBJREJLZXlSYW5nZTogSURCS2V5UmFuZ2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGJOYW1lc0RCLnZlcnNpb24oMSkuc3RvcmVzKHsgZGJuYW1lczogXCJuYW1lXCIgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGJOYW1lc0RCLnRhYmxlKFwiZGJuYW1lc1wiKTtcbiAgfVxuICBmdW5jdGlvbiBoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSB7XG4gICAgICByZXR1cm4gaW5kZXhlZERCICYmIHR5cGVvZiBpbmRleGVkREIuZGF0YWJhc2VzID09PSBcImZ1bmN0aW9uXCI7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RGF0YWJhc2VOYW1lcyhfYSkge1xuICAgICAgdmFyIGluZGV4ZWREQiA9IF9hLmluZGV4ZWREQiwgSURCS2V5UmFuZ2UgPSBfYS5JREJLZXlSYW5nZTtcbiAgICAgIHJldHVybiBoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKVxuICAgICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKGluZGV4ZWREQi5kYXRhYmFzZXMoKSkudGhlbihmdW5jdGlvbiAoaW5mb3MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZm9zXG4gICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpbmZvKSB7IHJldHVybiBpbmZvLm5hbWU7IH0pXG4gICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuYW1lICE9PSBEQk5BTUVTX0RCOyB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIDogZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLnRvQ29sbGVjdGlvbigpLnByaW1hcnlLZXlzKCk7XG4gIH1cbiAgZnVuY3Rpb24gX29uRGF0YWJhc2VDcmVhdGVkKF9hLCBuYW1lKSB7XG4gICAgICB2YXIgaW5kZXhlZERCID0gX2EuaW5kZXhlZERCLCBJREJLZXlSYW5nZSA9IF9hLklEQktleVJhbmdlO1xuICAgICAgIWhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpICYmXG4gICAgICAgICAgbmFtZSAhPT0gREJOQU1FU19EQiAmJlxuICAgICAgICAgIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS5wdXQoeyBuYW1lOiBuYW1lIH0pLmNhdGNoKG5vcCk7XG4gIH1cbiAgZnVuY3Rpb24gX29uRGF0YWJhc2VEZWxldGVkKF9hLCBuYW1lKSB7XG4gICAgICB2YXIgaW5kZXhlZERCID0gX2EuaW5kZXhlZERCLCBJREJLZXlSYW5nZSA9IF9hLklEQktleVJhbmdlO1xuICAgICAgIWhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpICYmXG4gICAgICAgICAgbmFtZSAhPT0gREJOQU1FU19EQiAmJlxuICAgICAgICAgIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS5kZWxldGUobmFtZSkuY2F0Y2gobm9wKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpcChmbikge1xuICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBQU0QubGV0VGhyb3VnaCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlkYlJlYWR5KCkge1xuICAgICAgdmFyIGlzU2FmYXJpID0gIW5hdmlnYXRvci51c2VyQWdlbnREYXRhICYmXG4gICAgICAgICAgL1NhZmFyaVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAgICEvQ2hyb20oZXxpdW0pXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgaWYgKCFpc1NhZmFyaSB8fCAhaW5kZXhlZERCLmRhdGFiYXNlcylcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB2YXIgaW50ZXJ2YWxJZDtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHZhciB0cnlJZGIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleGVkREIuZGF0YWJhc2VzKCkuZmluYWxseShyZXNvbHZlKTsgfTtcbiAgICAgICAgICBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodHJ5SWRiLCAxMDApO1xuICAgICAgICAgIHRyeUlkYigpO1xuICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBjbGVhckludGVydmFsKGludGVydmFsSWQpOyB9KTtcbiAgfVxuXG4gIHZhciBfYTtcbiAgZnVuY3Rpb24gaXNFbXB0eVJhbmdlKG5vZGUpIHtcbiAgICAgIHJldHVybiAhKFwiZnJvbVwiIGluIG5vZGUpO1xuICB9XG4gIHZhciBSYW5nZVNldCA9IGZ1bmN0aW9uIChmcm9tT3JUcmVlLCB0bykge1xuICAgICAgaWYgKHRoaXMpIHtcbiAgICAgICAgICBleHRlbmQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IHsgZDogMSwgZnJvbTogZnJvbU9yVHJlZSwgdG86IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gdG8gOiBmcm9tT3JUcmVlIH0gOiB7IGQ6IDAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcnYgPSBuZXcgUmFuZ2VTZXQoKTtcbiAgICAgICAgICBpZiAoZnJvbU9yVHJlZSAmJiAoXCJkXCIgaW4gZnJvbU9yVHJlZSkpIHtcbiAgICAgICAgICAgICAgZXh0ZW5kKHJ2LCBmcm9tT3JUcmVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfVxuICB9O1xuICBwcm9wcyhSYW5nZVNldC5wcm90b3R5cGUsIChfYSA9IHtcbiAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIChyYW5nZVNldCkge1xuICAgICAgICAgICAgICBtZXJnZVJhbmdlcyh0aGlzLCByYW5nZVNldCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkS2V5OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIGFkZFJhbmdlKHRoaXMsIGtleSwga2V5KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhZGRLZXlzOiBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYWRkUmFuZ2UoX3RoaXMsIGtleSwga2V5KTsgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFzS2V5OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIHZhciBub2RlID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcih0aGlzKS5uZXh0KGtleSkudmFsdWU7XG4gICAgICAgICAgICAgIHJldHVybiBub2RlICYmIGNtcChub2RlLmZyb20sIGtleSkgPD0gMCAmJiBjbXAobm9kZS50bywga2V5KSA+PSAwO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfYVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFJhbmdlU2V0SXRlcmF0b3IodGhpcyk7XG4gICAgICB9LFxuICAgICAgX2EpKTtcbiAgZnVuY3Rpb24gYWRkUmFuZ2UodGFyZ2V0LCBmcm9tLCB0bykge1xuICAgICAgdmFyIGRpZmYgPSBjbXAoZnJvbSwgdG8pO1xuICAgICAgaWYgKGlzTmFOKGRpZmYpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIGlmIChkaWZmID4gMClcbiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCk7XG4gICAgICBpZiAoaXNFbXB0eVJhbmdlKHRhcmdldCkpXG4gICAgICAgICAgcmV0dXJuIGV4dGVuZCh0YXJnZXQsIHsgZnJvbTogZnJvbSwgdG86IHRvLCBkOiAxIH0pO1xuICAgICAgdmFyIGxlZnQgPSB0YXJnZXQubDtcbiAgICAgIHZhciByaWdodCA9IHRhcmdldC5yO1xuICAgICAgaWYgKGNtcCh0bywgdGFyZ2V0LmZyb20pIDwgMCkge1xuICAgICAgICAgIGxlZnRcbiAgICAgICAgICAgICAgPyBhZGRSYW5nZShsZWZ0LCBmcm9tLCB0bylcbiAgICAgICAgICAgICAgOiAodGFyZ2V0LmwgPSB7IGZyb206IGZyb20sIHRvOiB0bywgZDogMSwgbDogbnVsbCwgcjogbnVsbCB9KTtcbiAgICAgICAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG4gICAgICB9XG4gICAgICBpZiAoY21wKGZyb20sIHRhcmdldC50bykgPiAwKSB7XG4gICAgICAgICAgcmlnaHRcbiAgICAgICAgICAgICAgPyBhZGRSYW5nZShyaWdodCwgZnJvbSwgdG8pXG4gICAgICAgICAgICAgIDogKHRhcmdldC5yID0geyBmcm9tOiBmcm9tLCB0bzogdG8sIGQ6IDEsIGw6IG51bGwsIHI6IG51bGwgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlYmFsYW5jZSh0YXJnZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGNtcChmcm9tLCB0YXJnZXQuZnJvbSkgPCAwKSB7XG4gICAgICAgICAgdGFyZ2V0LmZyb20gPSBmcm9tO1xuICAgICAgICAgIHRhcmdldC5sID0gbnVsbDtcbiAgICAgICAgICB0YXJnZXQuZCA9IHJpZ2h0ID8gcmlnaHQuZCArIDEgOiAxO1xuICAgICAgfVxuICAgICAgaWYgKGNtcCh0bywgdGFyZ2V0LnRvKSA+IDApIHtcbiAgICAgICAgICB0YXJnZXQudG8gPSB0bztcbiAgICAgICAgICB0YXJnZXQuciA9IG51bGw7XG4gICAgICAgICAgdGFyZ2V0LmQgPSB0YXJnZXQubCA/IHRhcmdldC5sLmQgKyAxIDogMTtcbiAgICAgIH1cbiAgICAgIHZhciByaWdodFdhc0N1dE9mZiA9ICF0YXJnZXQucjtcbiAgICAgIGlmIChsZWZ0ICYmICF0YXJnZXQubCkge1xuICAgICAgICAgIG1lcmdlUmFuZ2VzKHRhcmdldCwgbGVmdCk7XG4gICAgICB9XG4gICAgICBpZiAocmlnaHQgJiYgcmlnaHRXYXNDdXRPZmYpIHtcbiAgICAgICAgICBtZXJnZVJhbmdlcyh0YXJnZXQsIHJpZ2h0KTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZVJhbmdlcyh0YXJnZXQsIG5ld1NldCkge1xuICAgICAgZnVuY3Rpb24gX2FkZFJhbmdlU2V0KHRhcmdldCwgX2EpIHtcbiAgICAgICAgICB2YXIgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG8sIGwgPSBfYS5sLCByID0gX2EucjtcbiAgICAgICAgICBhZGRSYW5nZSh0YXJnZXQsIGZyb20sIHRvKTtcbiAgICAgICAgICBpZiAobClcbiAgICAgICAgICAgICAgX2FkZFJhbmdlU2V0KHRhcmdldCwgbCk7XG4gICAgICAgICAgaWYgKHIpXG4gICAgICAgICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIHIpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0VtcHR5UmFuZ2UobmV3U2V0KSlcbiAgICAgICAgICBfYWRkUmFuZ2VTZXQodGFyZ2V0LCBuZXdTZXQpO1xuICB9XG4gIGZ1bmN0aW9uIHJhbmdlc092ZXJsYXAocmFuZ2VTZXQxLCByYW5nZVNldDIpIHtcbiAgICAgIHZhciBpMSA9IGdldFJhbmdlU2V0SXRlcmF0b3IocmFuZ2VTZXQyKTtcbiAgICAgIHZhciBuZXh0UmVzdWx0MSA9IGkxLm5leHQoKTtcbiAgICAgIGlmIChuZXh0UmVzdWx0MS5kb25lKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBhID0gbmV4dFJlc3VsdDEudmFsdWU7XG4gICAgICB2YXIgaTIgPSBnZXRSYW5nZVNldEl0ZXJhdG9yKHJhbmdlU2V0MSk7XG4gICAgICB2YXIgbmV4dFJlc3VsdDIgPSBpMi5uZXh0KGEuZnJvbSk7XG4gICAgICB2YXIgYiA9IG5leHRSZXN1bHQyLnZhbHVlO1xuICAgICAgd2hpbGUgKCFuZXh0UmVzdWx0MS5kb25lICYmICFuZXh0UmVzdWx0Mi5kb25lKSB7XG4gICAgICAgICAgaWYgKGNtcChiLmZyb20sIGEudG8pIDw9IDAgJiYgY21wKGIudG8sIGEuZnJvbSkgPj0gMClcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgY21wKGEuZnJvbSwgYi5mcm9tKSA8IDBcbiAgICAgICAgICAgICAgPyAoYSA9IChuZXh0UmVzdWx0MSA9IGkxLm5leHQoYi5mcm9tKSkudmFsdWUpXG4gICAgICAgICAgICAgIDogKGIgPSAobmV4dFJlc3VsdDIgPSBpMi5uZXh0KGEuZnJvbSkpLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSYW5nZVNldEl0ZXJhdG9yKG5vZGUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGlzRW1wdHlSYW5nZShub2RlKSA/IG51bGwgOiB7IHM6IDAsIG46IG5vZGUgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICB2YXIga2V5UHJvdmlkZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UHJvdmlkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5uLmwgJiYgY21wKGtleSwgc3RhdGUubi5mcm9tKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IHVwOiBzdGF0ZSwgbjogc3RhdGUubi5sLCBzOiAxIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUubi5sKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4ubCwgczogMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXlQcm92aWRlZCB8fCBjbXAoa2V5LCBzdGF0ZS5uLnRvKSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHN0YXRlLm4sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUubi5yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4uciwgczogMCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGUudXA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgIH0sXG4gICAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHJlYmFsYW5jZSh0YXJnZXQpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICB2YXIgZGlmZiA9ICgoKF9hID0gdGFyZ2V0LnIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kKSB8fCAwKSAtICgoKF9iID0gdGFyZ2V0LmwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kKSB8fCAwKTtcbiAgICAgIHZhciByID0gZGlmZiA+IDEgPyBcInJcIiA6IGRpZmYgPCAtMSA/IFwibFwiIDogXCJcIjtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgICAgdmFyIGwgPSByID09PSBcInJcIiA/IFwibFwiIDogXCJyXCI7XG4gICAgICAgICAgdmFyIHJvb3RDbG9uZSA9IF9fYXNzaWduKHt9LCB0YXJnZXQpO1xuICAgICAgICAgIHZhciBvbGRSb290UmlnaHQgPSB0YXJnZXRbcl07XG4gICAgICAgICAgdGFyZ2V0LmZyb20gPSBvbGRSb290UmlnaHQuZnJvbTtcbiAgICAgICAgICB0YXJnZXQudG8gPSBvbGRSb290UmlnaHQudG87XG4gICAgICAgICAgdGFyZ2V0W3JdID0gb2xkUm9vdFJpZ2h0W3JdO1xuICAgICAgICAgIHJvb3RDbG9uZVtyXSA9IG9sZFJvb3RSaWdodFtsXTtcbiAgICAgICAgICB0YXJnZXRbbF0gPSByb290Q2xvbmU7XG4gICAgICAgICAgcm9vdENsb25lLmQgPSBjb21wdXRlRGVwdGgocm9vdENsb25lKTtcbiAgICAgIH1cbiAgICAgIHRhcmdldC5kID0gY29tcHV0ZURlcHRoKHRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcHV0ZURlcHRoKF9hKSB7XG4gICAgICB2YXIgciA9IF9hLnIsIGwgPSBfYS5sO1xuICAgICAgcmV0dXJuIChyID8gKGwgPyBNYXRoLm1heChyLmQsIGwuZCkgOiByLmQpIDogbCA/IGwuZCA6IDApICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQodGFyZ2V0LCBuZXdTZXQpIHtcbiAgICAgIGtleXMobmV3U2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgaWYgKHRhcmdldFtwYXJ0XSlcbiAgICAgICAgICAgICAgbWVyZ2VSYW5nZXModGFyZ2V0W3BhcnRdLCBuZXdTZXRbcGFydF0pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgdGFyZ2V0W3BhcnRdID0gY2xvbmVTaW1wbGVPYmplY3RUcmVlKG5ld1NldFtwYXJ0XSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBvYnNTZXRzT3ZlcmxhcChvczEsIG9zMikge1xuICAgICAgcmV0dXJuIG9zMS5hbGwgfHwgb3MyLmFsbCB8fCBPYmplY3Qua2V5cyhvczEpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gb3MyW2tleV0gJiYgcmFuZ2VzT3ZlcmxhcChvczJba2V5XSwgb3MxW2tleV0pOyB9KTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IHt9O1xuXG4gIHZhciB1bnNpZ25hbGVkUGFydHMgPSB7fTtcbiAgdmFyIGlzVGFza0VucXVldWVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5KHBhcnQsIG9wdGltaXN0aWMpIHtcbiAgICAgIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQodW5zaWduYWxlZFBhcnRzLCBwYXJ0KTtcbiAgICAgIGlmICghaXNUYXNrRW5xdWV1ZWQpIHtcbiAgICAgICAgICBpc1Rhc2tFbnF1ZXVlZCA9IHRydWU7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlzVGFza0VucXVldWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHVuc2lnbmFsZWRQYXJ0cztcbiAgICAgICAgICAgICAgdW5zaWduYWxlZFBhcnRzID0ge307XG4gICAgICAgICAgICAgIHNpZ25hbFN1YnNjcmliZXJzTm93KHBhcnRzLCBmYWxzZSk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2lnbmFsU3Vic2NyaWJlcnNOb3codXBkYXRlZFBhcnRzLCBkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcykge1xuICAgICAgaWYgKGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzID09PSB2b2lkIDApIHsgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMgPSBmYWxzZTsgfVxuICAgICAgdmFyIHF1ZXJpZXNUb1NpZ25hbCA9IG5ldyBTZXQoKTtcbiAgICAgIGlmICh1cGRhdGVkUGFydHMuYWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC52YWx1ZXMoY2FjaGUpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICB2YXIgdGJsQ2FjaGUgPSBfYVtfaV07XG4gICAgICAgICAgICAgIGNvbGxlY3RUYWJsZVN1YnNjcmliZXJzKHRibENhY2hlLCB1cGRhdGVkUGFydHMsIHF1ZXJpZXNUb1NpZ25hbCwgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiB1cGRhdGVkUGFydHMpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnRzID0gL15pZGJcXDpcXC9cXC8oLiopXFwvKC4qKVxcLy8uZXhlYyhrZXkpO1xuICAgICAgICAgICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkYk5hbWUgPSBwYXJ0c1sxXSwgdGFibGVOYW1lID0gcGFydHNbMl07XG4gICAgICAgICAgICAgICAgICB2YXIgdGJsQ2FjaGUgPSBjYWNoZVtcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQodGFibGVOYW1lKV07XG4gICAgICAgICAgICAgICAgICBpZiAodGJsQ2FjaGUpXG4gICAgICAgICAgICAgICAgICAgICAgY29sbGVjdFRhYmxlU3Vic2NyaWJlcnModGJsQ2FjaGUsIHVwZGF0ZWRQYXJ0cywgcXVlcmllc1RvU2lnbmFsLCBkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWVyaWVzVG9TaWduYWwuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVyeSkgeyByZXR1cm4gcmVxdWVyeSgpOyB9KTtcbiAgfVxuICBmdW5jdGlvbiBjb2xsZWN0VGFibGVTdWJzY3JpYmVycyh0YmxDYWNoZSwgdXBkYXRlZFBhcnRzLCBvdXRRdWVyaWVzVG9TaWduYWwsIGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKSB7XG4gICAgICB2YXIgdXBkYXRlZEVudHJ5TGlzdHMgPSBbXTtcbiAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyh0YmxDYWNoZS5xdWVyaWVzLnF1ZXJ5KTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIGluZGV4TmFtZSA9IF9iWzBdLCBlbnRyaWVzID0gX2JbMV07XG4gICAgICAgICAgdmFyIGZpbHRlcmVkRW50cmllcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9jID0gMCwgZW50cmllc18xID0gZW50cmllczsgX2MgPCBlbnRyaWVzXzEubGVuZ3RoOyBfYysrKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNfMVtfY107XG4gICAgICAgICAgICAgIGlmIChvYnNTZXRzT3ZlcmxhcCh1cGRhdGVkUGFydHMsIGVudHJ5Lm9ic1NldCkpIHtcbiAgICAgICAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIG91dFF1ZXJpZXNUb1NpZ25hbC5hZGQocmVxdWVyeSk7IH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICBmaWx0ZXJlZEVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKVxuICAgICAgICAgICAgICB1cGRhdGVkRW50cnlMaXN0cy5wdXNoKFtpbmRleE5hbWUsIGZpbHRlcmVkRW50cmllc10pO1xuICAgICAgfVxuICAgICAgaWYgKGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2QgPSAwLCB1cGRhdGVkRW50cnlMaXN0c18xID0gdXBkYXRlZEVudHJ5TGlzdHM7IF9kIDwgdXBkYXRlZEVudHJ5TGlzdHNfMS5sZW5ndGg7IF9kKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9lID0gdXBkYXRlZEVudHJ5TGlzdHNfMVtfZF0sIGluZGV4TmFtZSA9IF9lWzBdLCBmaWx0ZXJlZEVudHJpZXMgPSBfZVsxXTtcbiAgICAgICAgICAgICAgdGJsQ2FjaGUucXVlcmllcy5xdWVyeVtpbmRleE5hbWVdID0gZmlsdGVyZWRFbnRyaWVzO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRleGllT3BlbihkYikge1xuICAgICAgdmFyIHN0YXRlID0gZGIuX3N0YXRlO1xuICAgICAgdmFyIGluZGV4ZWREQiA9IGRiLl9kZXBzLmluZGV4ZWREQjtcbiAgICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkIHx8IGRiLmlkYmRiKVxuICAgICAgICAgIHJldHVybiBzdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRlLmRiT3BlbkVycm9yID9cbiAgICAgICAgICAgICAgcmVqZWN0aW9uKHN0YXRlLmRiT3BlbkVycm9yKSA6XG4gICAgICAgICAgICAgIGRiOyB9KTtcbiAgICAgIHN0YXRlLmlzQmVpbmdPcGVuZWQgPSB0cnVlO1xuICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBudWxsO1xuICAgICAgc3RhdGUub3BlbkNvbXBsZXRlID0gZmFsc2U7XG4gICAgICB2YXIgb3BlbkNhbmNlbGxlciA9IHN0YXRlLm9wZW5DYW5jZWxsZXI7XG4gICAgICB2YXIgbmF0aXZlVmVyVG9PcGVuID0gTWF0aC5yb3VuZChkYi52ZXJubyAqIDEwKTtcbiAgICAgIHZhciBzY2hlbWFQYXRjaE1vZGUgPSBmYWxzZTtcbiAgICAgIGZ1bmN0aW9uIHRocm93SWZDYW5jZWxsZWQoKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLm9wZW5DYW5jZWxsZXIgIT09IG9wZW5DYW5jZWxsZXIpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCdkYi5vcGVuKCkgd2FzIGNhbmNlbGxlZCcpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc29sdmVEYlJlYWR5ID0gc3RhdGUuZGJSZWFkeVJlc29sdmUsXG4gICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsLCB3YXNDcmVhdGVkID0gZmFsc2U7XG4gICAgICB2YXIgdHJ5T3BlbkRCID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZCgpO1xuICAgICAgICAgIGlmICghaW5kZXhlZERCKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7XG4gICAgICAgICAgdmFyIGRiTmFtZSA9IGRiLm5hbWU7XG4gICAgICAgICAgdmFyIHJlcSA9IHN0YXRlLmF1dG9TY2hlbWEgfHwgIW5hdGl2ZVZlclRvT3BlbiA/XG4gICAgICAgICAgICAgIGluZGV4ZWREQi5vcGVuKGRiTmFtZSkgOlxuICAgICAgICAgICAgICBpbmRleGVkREIub3BlbihkYk5hbWUsIG5hdGl2ZVZlclRvT3Blbik7XG4gICAgICAgICAgaWYgKCFyZXEpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgIHJlcS5vbmJsb2NrZWQgPSB3cmFwKGRiLl9maXJlT25CbG9ja2VkKTtcbiAgICAgICAgICByZXEub251cGdyYWRlbmVlZGVkID0gd3JhcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSByZXEudHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5hdXRvU2NoZW1hICYmICFkYi5fb3B0aW9ucy5hbGxvd0VtcHR5REIpIHtcbiAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcHJldmVudERlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIHJlcS5yZXN1bHQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBkZWxyZXEgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoZGJOYW1lKTtcbiAgICAgICAgICAgICAgICAgIGRlbHJlcS5vbnN1Y2Nlc3MgPSBkZWxyZXEub25lcnJvciA9IHdyYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5Ob1N1Y2hEYXRhYmFzZShcIkRhdGFiYXNlIFwiLmNvbmNhdChkYk5hbWUsIFwiIGRvZXNudCBleGlzdFwiKSkpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24ub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgdmFyIG9sZFZlciA9IGUub2xkVmVyc2lvbiA+IE1hdGgucG93KDIsIDYyKSA/IDAgOiBlLm9sZFZlcnNpb247XG4gICAgICAgICAgICAgICAgICB3YXNDcmVhdGVkID0gb2xkVmVyIDwgMTtcbiAgICAgICAgICAgICAgICAgIGRiLmlkYmRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFQYXRjaE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXRjaEN1cnJlbnRWZXJzaW9uKGRiLCB1cGdyYWRlVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcnVuVXBncmFkZXJzKGRiLCBvbGRWZXIgLyAxMCwgdXBncmFkZVRyYW5zYWN0aW9uLCByZWplY3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciBpZGJkYiA9IGRiLmlkYmRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgdmFyIG9iamVjdFN0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzKTtcbiAgICAgICAgICAgICAgaWYgKG9iamVjdFN0b3JlTmFtZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcFRyYW5zID0gaWRiZGIudHJhbnNhY3Rpb24oc2FmYXJpTXVsdGlTdG9yZUZpeChvYmplY3RTdG9yZU5hbWVzKSwgJ3JlYWRvbmx5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmF1dG9TY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBkYi5fZGJTY2hlbWEsIHRtcFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJpZnlJbnN0YWxsZWRTY2hlbWEoZGIsIHRtcFRyYW5zKSAmJiAhc2NoZW1hUGF0Y2hNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEZXhpZSBTY2hlbWFEaWZmOiBTY2hlbWEgd2FzIGV4dGVuZGVkIHdpdGhvdXQgaW5jcmVhc2luZyB0aGUgbnVtYmVyIHBhc3NlZCB0byBkYi52ZXJzaW9uKCkuIERleGllIHdpbGwgYWRkIG1pc3NpbmcgcGFydHMgYW5kIGluY3JlbWVudCBuYXRpdmUgdmVyc2lvbiBudW1iZXIgdG8gd29ya2Fyb3VuZCB0aGlzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkYmRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVWZXJUb09wZW4gPSBpZGJkYi52ZXJzaW9uICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVBhdGNoTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnlPcGVuREIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCB0bXBUcmFucyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25uZWN0aW9ucy5wdXNoKGRiKTtcbiAgICAgICAgICAgICAgaWRiZGIub252ZXJzaW9uY2hhbmdlID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnZjRmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgZGIub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWRiZGIub25jbG9zZSA9IHdyYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoeyBkaXNhYmxlQXV0b09wZW46IGZhbHNlIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHdhc0NyZWF0ZWQpXG4gICAgICAgICAgICAgICAgICBfb25EYXRhYmFzZUNyZWF0ZWQoZGIuX2RlcHMsIGRiTmFtZSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHN3aXRjaCAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLm5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIlVua25vd25FcnJvclwiOlxuICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLlBSMTM5OF9tYXhMb29wID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLlBSMTM5OF9tYXhMb29wLS07XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogV29ya2Fyb3VuZCBmb3IgQ2hyb21lIFVua25vd25FcnJvciBvbiBvcGVuKCknKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5T3BlbkRCKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIlZlcnNpb25FcnJvclwiOlxuICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZVZlclRvT3BlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVWZXJUb09wZW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlPcGVuREIoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgfSk7IH07XG4gICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJhY2UoW1xuICAgICAgICAgIG9wZW5DYW5jZWxsZXIsXG4gICAgICAgICAgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gRGV4aWVQcm9taXNlLnJlc29sdmUoKSA6IGlkYlJlYWR5KCkpLnRoZW4odHJ5T3BlbkRCKVxuICAgICAgXSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZCgpO1xuICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gW107XG4gICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHZpcChmdW5jdGlvbiAoKSB7IHJldHVybiBkYi5vbi5yZWFkeS5maXJlKGRiLnZpcCk7IH0pKS50aGVuKGZ1bmN0aW9uIGZpcmVSZW1haW5kZXJzKCkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUub25SZWFkeUJlaW5nRmlyZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmRlcnNfMSA9IHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLnJlZHVjZShwcm9taXNhYmxlQ2hhaW4sIG5vcCk7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHZpcChmdW5jdGlvbiAoKSB7IHJldHVybiByZW1haW5kZXJzXzEoZGIudmlwKTsgfSkpLnRoZW4oZmlyZVJlbWFpbmRlcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoc3RhdGUub3BlbkNhbmNlbGxlciA9PT0gb3BlbkNhbmNlbGxlcikge1xuICAgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCA9IG51bGw7XG4gICAgICAgICAgICAgIHN0YXRlLmlzQmVpbmdPcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBlcnI7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uICYmIHVwZ3JhZGVUcmFuc2FjdGlvbi5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgIGlmIChvcGVuQ2FuY2VsbGVyID09PSBzdGF0ZS5vcGVuQ2FuY2VsbGVyKSB7XG4gICAgICAgICAgICAgIGRiLl9jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGVycik7XG4gICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZS5vcGVuQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIHJlc29sdmVEYlJlYWR5KCk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAod2FzQ3JlYXRlZCkge1xuICAgICAgICAgICAgICB2YXIgZXZlcnl0aGluZ18xID0ge307XG4gICAgICAgICAgICAgIGRiLnRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgdGFibGUuc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBldmVyeXRoaW5nXzFbXCJpZGI6Ly9cIi5jb25jYXQoZGIubmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZS5uYW1lLCBcIi9cIikuY29uY2F0KGlkeC5uYW1lKV0gPSBuZXcgUmFuZ2VTZXQoLUluZmluaXR5LCBbW1tdXV0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBldmVyeXRoaW5nXzFbXCJpZGI6Ly9cIi5jb25jYXQoZGIubmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZS5uYW1lLCBcIi9cIildID0gZXZlcnl0aGluZ18xW1wiaWRiOi8vXCIuY29uY2F0KGRiLm5hbWUsIFwiL1wiKS5jb25jYXQodGFibGUubmFtZSwgXCIvOmRlbHNcIildID0gbmV3IFJhbmdlU2V0KC1JbmZpbml0eSwgW1tbXV1dKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSkuZmlyZShldmVyeXRoaW5nXzEpO1xuICAgICAgICAgICAgICBzaWduYWxTdWJzY3JpYmVyc05vdyhldmVyeXRoaW5nXzEsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGI7XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF3YWl0SXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICAgIHZhciBjYWxsTmV4dCA9IGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIGl0ZXJhdG9yLm5leHQocmVzdWx0KTsgfSwgZG9UaHJvdyA9IGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gaXRlcmF0b3IudGhyb3coZXJyb3IpOyB9LCBvblN1Y2Nlc3MgPSBzdGVwKGNhbGxOZXh0KSwgb25FcnJvciA9IHN0ZXAoZG9UaHJvdyk7XG4gICAgICBmdW5jdGlvbiBzdGVwKGdldE5leHQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICB2YXIgbmV4dCA9IGdldE5leHQodmFsKSwgdmFsdWUgPSBuZXh0LnZhbHVlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dC5kb25lID8gdmFsdWUgOlxuICAgICAgICAgICAgICAgICAgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUudGhlbiAhPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgICAgaXNBcnJheSh2YWx1ZSkgPyBQcm9taXNlLmFsbCh2YWx1ZSkudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpIDogb25TdWNjZXNzKHZhbHVlKSA6XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpKTtcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0ZXAoY2FsbE5leHQpKCk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0VHJhbnNhY3Rpb25BcmdzKG1vZGUsIF90YWJsZUFyZ3NfLCBzY29wZUZ1bmMpIHtcbiAgICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChpIDwgMilcbiAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJUb28gZmV3IGFyZ3VtZW50c1wiKTtcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgICAgIHdoaWxlICgtLWkpXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBzY29wZUZ1bmMgPSBhcmdzLnBvcCgpO1xuICAgICAgdmFyIHRhYmxlcyA9IGZsYXR0ZW4oYXJncyk7XG4gICAgICByZXR1cm4gW21vZGUsIHRhYmxlcywgc2NvcGVGdW5jXTtcbiAgfVxuICBmdW5jdGlvbiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoZGIsIG1vZGUsIHN0b3JlTmFtZXMsIHBhcmVudFRyYW5zYWN0aW9uLCBzY29wZUZ1bmMpIHtcbiAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0cmFuc2xlc3MgPSBQU0QudHJhbnNsZXNzIHx8IFBTRDtcbiAgICAgICAgICB2YXIgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hLCBwYXJlbnRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgdHJhbnMuZXhwbGljaXQgPSB0cnVlO1xuICAgICAgICAgIHZhciB6b25lUHJvcHMgPSB7XG4gICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgICAgICAgICAgdHJhbnNsZXNzOiB0cmFuc2xlc3NcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICB0cmFucy5pZGJ0cmFucyA9IHBhcmVudFRyYW5zYWN0aW9uLmlkYnRyYW5zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgICAgdHJhbnMuaWRidHJhbnMuX2V4cGxpY2l0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA9IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXgubmFtZSA9PT0gZXJybmFtZXMuSW52YWxpZFN0YXRlICYmIGRiLmlzT3BlbigpICYmIC0tZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IE5lZWQgdG8gcmVvcGVuIGRiJyk7XG4gICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoeyBkaXNhYmxlQXV0b09wZW46IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYi5vcGVuKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoZGIsIG1vZGUsIHN0b3JlTmFtZXMsIG51bGwsIHNjb3BlRnVuYyk7IH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24oc2NvcGVGdW5jKTtcbiAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmV0dXJuVmFsdWU7XG4gICAgICAgICAgdmFyIHByb21pc2VGb2xsb3dlZCA9IERleGllUHJvbWlzZS5mb2xsb3coZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHNjb3BlRnVuYy5jYWxsKHRyYW5zLCB0cmFucyk7XG4gICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50b3IgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cy5iaW5kKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4oZGVjcmVtZW50b3IsIGRlY3JlbWVudG9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXR1cm5WYWx1ZS5uZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gYXdhaXRJdGVyYXRvcihyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB6b25lUHJvcHMpO1xuICAgICAgICAgIHJldHVybiAocmV0dXJuVmFsdWUgJiYgdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSkudGhlbihmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHJhbnMuYWN0aXZlID9cbiAgICAgICAgICAgICAgICAgIHhcbiAgICAgICAgICAgICAgICAgIDogcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlByZW1hdHVyZUNvbW1pdChcIlRyYW5zYWN0aW9uIGNvbW1pdHRlZCB0b28gZWFybHkuIFNlZSBodHRwOi8vYml0Lmx5LzJrZGNrTW5cIikpOyB9KVxuICAgICAgICAgICAgICA6IHByb21pc2VGb2xsb3dlZC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHVyblZhbHVlOyB9KSkudGhlbihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgICB0cmFucy5fcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJhbnMuX2NvbXBsZXRpb24udGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICB0cmFucy5fcmVqZWN0KGUpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYWQoYSwgdmFsdWUsIGNvdW50KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gaXNBcnJheShhKSA/IGEuc2xpY2UoKSA6IFthXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSlcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxJbmRleE1pZGRsZXdhcmUoZG93bikge1xuICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb3duKSwgeyB0YWJsZTogZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgdGFibGUgPSBkb3duLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgIHZhciBzY2hlbWEgPSB0YWJsZS5zY2hlbWE7XG4gICAgICAgICAgICAgIHZhciBpbmRleExvb2t1cCA9IHt9O1xuICAgICAgICAgICAgICB2YXIgYWxsVmlydHVhbEluZGV4ZXMgPSBbXTtcbiAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkVmlydHVhbEluZGV4ZXMoa2V5UGF0aCwga2V5VGFpbCwgbG93TGV2ZWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGhBbGlhcyA9IGdldEtleVBhdGhBbGlhcyhrZXlQYXRoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBpbmRleExpc3QgPSAoaW5kZXhMb29rdXBba2V5UGF0aEFsaWFzXSA9IGluZGV4TG9va3VwW2tleVBhdGhBbGlhc10gfHwgW10pO1xuICAgICAgICAgICAgICAgICAgdmFyIGtleUxlbmd0aCA9IGtleVBhdGggPT0gbnVsbCA/IDAgOiB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgPyAxIDoga2V5UGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB2YXIgaXNWaXJ0dWFsID0ga2V5VGFpbCA+IDA7XG4gICAgICAgICAgICAgICAgICB2YXIgdmlydHVhbEluZGV4ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGxvd0xldmVsSW5kZXgpLCB7IG5hbWU6IGlzVmlydHVhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiXCIuY29uY2F0KGtleVBhdGhBbGlhcywgXCIodmlydHVhbC1mcm9tOlwiKS5jb25jYXQobG93TGV2ZWxJbmRleC5uYW1lLCBcIilcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBsb3dMZXZlbEluZGV4Lm5hbWUsIGxvd0xldmVsSW5kZXg6IGxvd0xldmVsSW5kZXgsIGlzVmlydHVhbDogaXNWaXJ0dWFsLCBrZXlUYWlsOiBrZXlUYWlsLCBrZXlMZW5ndGg6IGtleUxlbmd0aCwgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpLCB1bmlxdWU6ICFpc1ZpcnR1YWwgJiYgbG93TGV2ZWxJbmRleC51bmlxdWUgfSk7XG4gICAgICAgICAgICAgICAgICBpbmRleExpc3QucHVzaCh2aXJ0dWFsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKCF2aXJ0dWFsSW5kZXguaXNQcmltYXJ5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWxsVmlydHVhbEluZGV4ZXMucHVzaCh2aXJ0dWFsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGtleUxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlydHVhbEtleVBhdGggPSBrZXlMZW5ndGggPT09IDIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoWzBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aC5zbGljZSgwLCBrZXlMZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRWaXJ0dWFsSW5kZXhlcyh2aXJ0dWFsS2V5UGF0aCwga2V5VGFpbCArIDEsIGxvd0xldmVsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5kZXhMaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEua2V5VGFpbCAtIGIua2V5VGFpbDsgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmlydHVhbEluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBwcmltYXJ5S2V5ID0gYWRkVmlydHVhbEluZGV4ZXMoc2NoZW1hLnByaW1hcnlLZXkua2V5UGF0aCwgMCwgc2NoZW1hLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICBpbmRleExvb2t1cFtcIjppZFwiXSA9IFtwcmltYXJ5S2V5XTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHNjaGVtYS5pbmRleGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgYWRkVmlydHVhbEluZGV4ZXMoaW5kZXgua2V5UGF0aCwgMCwgaW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRCZXN0SW5kZXgoa2V5UGF0aCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGluZGV4TG9va3VwW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV07XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdFswXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSYW5nZShyYW5nZSwga2V5VGFpbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiByYW5nZS50eXBlID09PSAxICA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDIgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBsb3dlcjogcGFkKHJhbmdlLmxvd2VyLCByYW5nZS5sb3dlck9wZW4gPyBkb3duLk1BWF9LRVkgOiBkb3duLk1JTl9LRVksIGtleVRhaWwpLFxuICAgICAgICAgICAgICAgICAgICAgIGxvd2VyT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICB1cHBlcjogcGFkKHJhbmdlLnVwcGVyLCByYW5nZS51cHBlck9wZW4gPyBkb3duLk1JTl9LRVkgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpLFxuICAgICAgICAgICAgICAgICAgICAgIHVwcGVyT3BlbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSZXF1ZXN0KHJlcSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVxLnF1ZXJ5LmluZGV4O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4LmlzVmlydHVhbCA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXEpLCB7IHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleC5sb3dMZXZlbEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogdHJhbnNsYXRlUmFuZ2UocmVxLnF1ZXJ5LnJhbmdlLCBpbmRleC5rZXlUYWlsKVxuICAgICAgICAgICAgICAgICAgICAgIH0gfSkgOiByZXE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0YWJsZSksIHsgc2NoZW1hOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2NoZW1hKSwgeyBwcmltYXJ5S2V5OiBwcmltYXJ5S2V5LCBpbmRleGVzOiBhbGxWaXJ0dWFsSW5kZXhlcywgZ2V0SW5kZXhCeUtleVBhdGg6IGZpbmRCZXN0SW5kZXggfSksIGNvdW50OiBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmNvdW50KHRyYW5zbGF0ZVJlcXVlc3QocmVxKSk7XG4gICAgICAgICAgICAgICAgICB9LCBxdWVyeTogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5xdWVyeSh0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpO1xuICAgICAgICAgICAgICAgICAgfSwgb3BlbkN1cnNvcjogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHJlcS5xdWVyeS5pbmRleCwga2V5VGFpbCA9IF9hLmtleVRhaWwsIGlzVmlydHVhbCA9IF9hLmlzVmlydHVhbCwga2V5TGVuZ3RoID0gX2Eua2V5TGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNWaXJ0dWFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUub3BlbkN1cnNvcihyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxDdXJzb3IoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9jb250aW51ZShrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUocGFkKGtleSwgcmVxLnJldmVyc2UgPyBkb3duLk1BWF9LRVkgOiBkb3duLk1JTl9LRVksIGtleVRhaWwpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnVuaXF1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShjdXJzb3Iua2V5LnNsaWNlKDAsIGtleUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocmVxLnJldmVyc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZG93bi5NSU5fS0VZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRvd24uTUFYX0tFWSwga2V5VGFpbCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpcnR1YWxDdXJzb3IgPSBPYmplY3QuY3JlYXRlKGN1cnNvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU6IHsgdmFsdWU6IF9jb250aW51ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVQcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChrZXksIHByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleShwYWQoa2V5LCBkb3duLk1BWF9LRVksIGtleVRhaWwpLCBwcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleUxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlbMF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LnNsaWNlKDAsIGtleUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpcnR1YWxDdXJzb3I7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5vcGVuQ3Vyc29yKHRyYW5zbGF0ZVJlcXVlc3QocmVxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGN1cnNvcikgeyByZXR1cm4gY3Vyc29yICYmIGNyZWF0ZVZpcnR1YWxDdXJzb3IoY3Vyc29yKTsgfSk7XG4gICAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0gfSk7XG4gIH1cbiAgdmFyIHZpcnR1YWxJbmRleE1pZGRsZXdhcmUgPSB7XG4gICAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICAgIG5hbWU6IFwiVmlydHVhbEluZGV4TWlkZGxld2FyZVwiLFxuICAgICAgbGV2ZWw6IDEsXG4gICAgICBjcmVhdGU6IGNyZWF0ZVZpcnR1YWxJbmRleE1pZGRsZXdhcmVcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRPYmplY3REaWZmKGEsIGIsIHJ2LCBwcmZ4KSB7XG4gICAgICBydiA9IHJ2IHx8IHt9O1xuICAgICAgcHJmeCA9IHByZnggfHwgJyc7XG4gICAgICBrZXlzKGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICBpZiAoIWhhc093bihiLCBwcm9wKSkge1xuICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgYXAgPSBhW3Byb3BdLCBicCA9IGJbcHJvcF07XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgYXAgPT09ICdvYmplY3QnICYmIHR5cGVvZiBicCA9PT0gJ29iamVjdCcgJiYgYXAgJiYgYnApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhcFR5cGVOYW1lID0gdG9TdHJpbmdUYWcoYXApO1xuICAgICAgICAgICAgICAgICAgdmFyIGJwVHlwZU5hbWUgPSB0b1N0cmluZ1RhZyhicCk7XG4gICAgICAgICAgICAgICAgICBpZiAoYXBUeXBlTmFtZSAhPT0gYnBUeXBlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcFR5cGVOYW1lID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgIGdldE9iamVjdERpZmYoYXAsIGJwLCBydiwgcHJmeCArIHByb3AgKyAnLicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXAgIT09IGJwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChhcCAhPT0gYnApXG4gICAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAga2V5cyhiKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgaWYgKCFoYXNPd24oYSwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBydjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVmZmVjdGl2ZUtleXMocHJpbWFyeUtleSwgcmVxKSB7XG4gICAgICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGUnKVxuICAgICAgICAgIHJldHVybiByZXEua2V5cztcbiAgICAgIHJldHVybiByZXEua2V5cyB8fCByZXEudmFsdWVzLm1hcChwcmltYXJ5S2V5LmV4dHJhY3RLZXkpO1xuICB9XG5cbiAgdmFyIGhvb2tzTWlkZGxld2FyZSA9IHtcbiAgICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgICAgbmFtZTogXCJIb29rc01pZGRsZXdhcmVcIixcbiAgICAgIGxldmVsOiAyLFxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoZG93bkNvcmUpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG93bkNvcmUpLCB7IHRhYmxlOiBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgICAgIHZhciBkb3duVGFibGUgPSBkb3duQ29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGRvd25UYWJsZS5zY2hlbWEucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgdmFyIHRhYmxlTWlkZGxld2FyZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb3duVGFibGUpLCB7IG11dGF0ZTogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBkeFRyYW5zID0gUFNELnRyYW5zO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGR4VHJhbnMudGFibGUodGFibGVOYW1lKS5ob29rLCBkZWxldGluZyA9IF9hLmRlbGV0aW5nLCBjcmVhdGluZyA9IF9hLmNyZWF0aW5nLCB1cGRhdGluZyA9IF9hLnVwZGF0aW5nO1xuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmVxLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkUHV0T3JEZWxldGUocmVxKTsgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRpbmcuZmlyZSA9PT0gbm9wICYmIHVwZGF0aW5nLmZpcmUgPT09IG5vcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRQdXRPckRlbGV0ZShyZXEpOyB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkUHV0T3JEZWxldGUocmVxKTsgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZVJhbmdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVsZXRlUmFuZ2UocmVxKTsgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkUHV0T3JEZWxldGUocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeFRyYW5zID0gUFNELnRyYW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHJlcS5rZXlzIHx8IGdldEVmZmVjdGl2ZUtleXMocHJpbWFyeUtleSwgcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5cyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXEgPSByZXEudHlwZSA9PT0gJ2FkZCcgfHwgcmVxLnR5cGUgPT09ICdwdXQnID8gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlcSksIHsga2V5czoga2V5cyB9KSA6IF9fYXNzaWduKHt9LCByZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09ICdkZWxldGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlcyA9IF9fc3ByZWFkQXJyYXkoW10sIHJlcS52YWx1ZXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLmtleXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEua2V5cyA9IF9fc3ByZWFkQXJyYXkoW10sIHJlcS5rZXlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4aXN0aW5nVmFsdWVzKGRvd25UYWJsZSwgcmVxLCBrZXlzKS50aGVuKGZ1bmN0aW9uIChleGlzdGluZ1ZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHRzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0gZXhpc3RpbmdWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHsgb25lcnJvcjogbnVsbCwgb25zdWNjZXNzOiBudWxsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS50eXBlID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGluZy5maXJlLmNhbGwoY3R4LCBrZXksIGV4aXN0aW5nVmFsdWUsIGR4VHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXEudHlwZSA9PT0gJ2FkZCcgfHwgZXhpc3RpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZW5lcmF0ZWRQcmltYXJ5S2V5ID0gY3JlYXRpbmcuZmlyZS5jYWxsKGN0eCwga2V5LCByZXEudmFsdWVzW2ldLCBkeFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsICYmIGdlbmVyYXRlZFByaW1hcnlLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZ2VuZXJhdGVkUHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5rZXlzW2ldID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmltYXJ5S2V5Lm91dGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHJlcS52YWx1ZXNbaV0sIHByaW1hcnlLZXkua2V5UGF0aCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdERpZmYgPSBnZXRPYmplY3REaWZmKGV4aXN0aW5nVmFsdWUsIHJlcS52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkaXRpb25hbENoYW5nZXNfMSA9IHVwZGF0aW5nLmZpcmUuY2FsbChjdHgsIG9iamVjdERpZmYsIGtleSwgZXhpc3RpbmdWYWx1ZSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsQ2hhbmdlc18xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdGVkVmFsdWVfMSA9IHJlcS52YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhZGRpdGlvbmFsQ2hhbmdlc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093bihyZXF1ZXN0ZWRWYWx1ZV8xLCBrZXlQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRWYWx1ZV8xW2tleVBhdGhdID0gYWRkaXRpb25hbENoYW5nZXNfMVtrZXlQYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChyZXF1ZXN0ZWRWYWx1ZV8xLCBrZXlQYXRoLCBhZGRpdGlvbmFsQ2hhbmdlc18xW2tleVBhdGhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLm11dGF0ZShyZXEpLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVzID0gX2EuZmFpbHVyZXMsIHJlc3VsdHMgPSBfYS5yZXN1bHRzLCBudW1GYWlsdXJlcyA9IF9hLm51bUZhaWx1cmVzLCBsYXN0UmVzdWx0ID0gX2EubGFzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByaW1LZXkgPSByZXN1bHRzID8gcmVzdWx0c1tpXSA6IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSBjb250ZXh0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm9uZXJyb3IgJiYgY3R4Lm9uZXJyb3IoZmFpbHVyZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm9uc3VjY2VzcyAmJiBjdHgub25zdWNjZXNzKHJlcS50eXBlID09PSAncHV0JyAmJiBleGlzdGluZ1ZhbHVlc1tpXSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlc1tpXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmYWlsdXJlczogZmFpbHVyZXMsIHJlc3VsdHM6IHJlc3VsdHMsIG51bUZhaWx1cmVzOiBudW1GYWlsdXJlcywgbGFzdFJlc3VsdDogbGFzdFJlc3VsdCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dHMuZm9yRWFjaChmdW5jdGlvbiAoY3R4KSB7IHJldHVybiBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihlcnJvcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZVJhbmdlKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlTmV4dENodW5rKHJlcS50cmFucywgcmVxLnJhbmdlLCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZU5leHRDaHVuayh0cmFucywgcmFuZ2UsIGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUucXVlcnkoeyB0cmFuczogdHJhbnMsIHZhbHVlczogZmFsc2UsIHF1ZXJ5OiB7IGluZGV4OiBwcmltYXJ5S2V5LCByYW5nZTogcmFuZ2UgfSwgbGltaXQ6IGxpbWl0IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfYS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkUHV0T3JEZWxldGUoeyB0eXBlOiAnZGVsZXRlJywga2V5czogcmVzdWx0LCB0cmFuczogdHJhbnMgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZmFpbHVyZXM6IFtdLCBudW1GYWlsdXJlczogMCwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlTmV4dENodW5rKHRyYW5zLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmFuZ2UpLCB7IGxvd2VyOiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCBsb3dlck9wZW46IHRydWUgfSksIGxpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlTWlkZGxld2FyZTtcbiAgICAgICAgICB9IH0pKTsgfVxuICB9O1xuICBmdW5jdGlvbiBnZXRFeGlzdGluZ1ZhbHVlcyh0YWJsZSwgcmVxLCBlZmZlY3RpdmVLZXlzKSB7XG4gICAgICByZXR1cm4gcmVxLnR5cGUgPT09IFwiYWRkXCJcbiAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICAgICAgICA6IHRhYmxlLmdldE1hbnkoeyB0cmFuczogcmVxLnRyYW5zLCBrZXlzOiBlZmZlY3RpdmVLZXlzLCBjYWNoZTogXCJpbW11dGFibGVcIiB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKGtleXMsIGNhY2hlLCBjbG9uZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIWNhY2hlKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpZiAoY2FjaGUua2V5cy5sZW5ndGggPCBrZXlzLmxlbmd0aClcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGNhY2hlLmtleXMubGVuZ3RoICYmIGogPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmIChjbXAoY2FjaGUua2V5c1tpXSwga2V5c1tqXSkgIT09IDApXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2xvbmUgPyBkZWVwQ2xvbmUoY2FjaGUudmFsdWVzW2ldKSA6IGNhY2hlLnZhbHVlc1tpXSk7XG4gICAgICAgICAgICAgICsrajtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IGtleXMubGVuZ3RoID8gcmVzdWx0IDogbnVsbDtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9XG4gIHZhciBjYWNoZUV4aXN0aW5nVmFsdWVzTWlkZGxld2FyZSA9IHtcbiAgICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgICAgbGV2ZWw6IC0xLFxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoY29yZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRhYmxlOiBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBjb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHRhYmxlKSwgeyBnZXRNYW55OiBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVxLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUuZ2V0TWFueShyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShyZXEua2V5cywgcmVxLnRyYW5zW1wiX2NhY2hlXCJdLCByZXEuY2FjaGUgPT09IFwiY2xvbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShjYWNoZWRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5nZXRNYW55KHJlcSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudHJhbnNbXCJfY2FjaGVcIl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czogcmVxLmtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiByZXEuY2FjaGUgPT09IFwiY2xvbmVcIiA/IGRlZXBDbG9uZShyZXMpIDogcmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0sIG11dGF0ZTogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09IFwiYWRkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudHJhbnNbXCJfY2FjaGVcIl0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUubXV0YXRlKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgfSxcbiAgfTtcblxuICBmdW5jdGlvbiBpc0NhY2hhYmxlQ29udGV4dChjdHgsIHRhYmxlKSB7XG4gICAgICByZXR1cm4gKGN0eC50cmFucy5tb2RlID09PSAncmVhZG9ubHknICYmXG4gICAgICAgICAgISFjdHguc3Vic2NyICYmXG4gICAgICAgICAgIWN0eC50cmFucy5leHBsaWNpdCAmJlxuICAgICAgICAgIGN0eC50cmFucy5kYi5fb3B0aW9ucy5jYWNoZSAhPT0gJ2Rpc2FibGVkJyAmJlxuICAgICAgICAgICF0YWJsZS5zY2hlbWEucHJpbWFyeUtleS5vdXRib3VuZCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NhY2hhYmxlUmVxdWVzdCh0eXBlLCByZXEpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcS52YWx1ZXMgJiYgIXJlcS51bmlxdWU7XG4gICAgICAgICAgY2FzZSAnZ2V0JzpcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNhc2UgJ2dldE1hbnknOlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgY2FzZSAnY291bnQnOlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgY2FzZSAnb3BlbkN1cnNvcic6XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxuXG4gIHZhciBvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSA9IHtcbiAgICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgICAgbGV2ZWw6IDAsXG4gICAgICBuYW1lOiBcIk9ic2VydmFiaWxpdHlcIixcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgICB2YXIgZGJOYW1lID0gY29yZS5zY2hlbWEubmFtZTtcbiAgICAgICAgICB2YXIgRlVMTF9SQU5HRSA9IG5ldyBSYW5nZVNldChjb3JlLk1JTl9LRVksIGNvcmUuTUFYX0tFWSk7XG4gICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb3JlKSwgeyB0cmFuc2FjdGlvbjogZnVuY3Rpb24gKHN0b3JlcywgbW9kZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgaWYgKFBTRC5zdWJzY3IgJiYgbW9kZSAhPT0gJ3JlYWRvbmx5Jykge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlJlYWRPbmx5KFwiUmVhZHdyaXRlIHRyYW5zYWN0aW9uIGluIGxpdmVRdWVyeSBjb250ZXh0LiBRdWVyaWVyIHNvdXJjZTogXCIuY29uY2F0KFBTRC5xdWVyaWVyKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS50cmFuc2FjdGlvbihzdG9yZXMsIG1vZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICB9LCB0YWJsZTogZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHRhYmxlLnNjaGVtYTtcbiAgICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5S2V5ID0gc2NoZW1hLnByaW1hcnlLZXksIGluZGV4ZXMgPSBzY2hlbWEuaW5kZXhlcztcbiAgICAgICAgICAgICAgICAgIHZhciBleHRyYWN0S2V5ID0gcHJpbWFyeUtleS5leHRyYWN0S2V5LCBvdXRib3VuZCA9IHByaW1hcnlLZXkub3V0Ym91bmQ7XG4gICAgICAgICAgICAgICAgICB2YXIgaW5kZXhlc1dpdGhBdXRvSW5jUEsgPSBwcmltYXJ5S2V5LmF1dG9JbmNyZW1lbnQgJiYgaW5kZXhlcy5maWx0ZXIoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBpbmRleC5jb21wb3VuZCAmJiBpbmRleC5rZXlQYXRoLmluY2x1ZGVzKHByaW1hcnlLZXkua2V5UGF0aCk7IH0pO1xuICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlQ2xvbmUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGFibGUpLCB7IG11dGF0ZTogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSByZXEudHJhbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGVkUGFydHMgPSByZXEubXV0YXRlZFBhcnRzIHx8IChyZXEubXV0YXRlZFBhcnRzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UmFuZ2VTZXQgPSBmdW5jdGlvbiAoaW5kZXhOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IFwiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUsIFwiL1wiKS5jb25jYXQoaW5kZXhOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobXV0YXRlZFBhcnRzW3BhcnRdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG11dGF0ZWRQYXJ0c1twYXJ0XSA9IG5ldyBSYW5nZVNldCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwa1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxzUmFuZ2VTZXQgPSBnZXRSYW5nZVNldChcIjpkZWxzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHJlcS50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSByZXEudHlwZSA9PT0gXCJkZWxldGVSYW5nZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtyZXEucmFuZ2VdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlcS50eXBlID09PSBcImRlbGV0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcmVxLmtleXNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXEudmFsdWVzLmxlbmd0aCA8IDUwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW2dldEVmZmVjdGl2ZUtleXMocHJpbWFyeUtleSwgcmVxKS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBpZDsgfSksIHJlcS52YWx1ZXNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW10sIGtleXMgPSBfY1swXSwgbmV3T2JqcyA9IF9jWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQ2FjaGUgPSByZXEudHJhbnNbXCJfY2FjaGVcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZEtleXMoa2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkT2JqcyA9IHR5cGUgPT09ICdkZWxldGUnIHx8IGtleXMubGVuZ3RoID09PSBuZXdPYmpzLmxlbmd0aCA/IGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKGtleXMsIG9sZENhY2hlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZE9ianMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5cyhrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRPYmpzIHx8IG5ld09ianMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja0FmZmVjdGVkSW5kZXhlcyhnZXRSYW5nZVNldCwgc2NoZW1hLCBvbGRPYmpzLCBuZXdPYmpzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogKF9hID0ga2V5cy5sb3dlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29yZS5NSU5fS0VZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAoX2IgPSBrZXlzLnVwcGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb3JlLk1BWF9LRVlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkKEZVTExfUkFOR0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYS5pbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gZ2V0UmFuZ2VTZXQoaWR4Lm5hbWUpLmFkZChGVUxMX1JBTkdFKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleXMgJiYgKHJlcS50eXBlID09PSAnYWRkJyB8fCByZXEudHlwZSA9PT0gJ3B1dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKHJlcy5yZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhlc1dpdGhBdXRvSW5jUEspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1dpdGhBdXRvSW5jUEsuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4VmFscyA9IHJlcS52YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBpZHguZXh0cmFjdEtleSh2KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGtQb3MgPSBpZHgua2V5UGF0aC5maW5kSW5kZXgoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHByb3AgPT09IHByaW1hcnlLZXkua2V5UGF0aDsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVzLnJlc3VsdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHhWYWxzW2ldW3BrUG9zXSA9IHJlcy5yZXN1bHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UmFuZ2VTZXQoaWR4Lm5hbWUpLmFkZEtleXMoaWR4VmFscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLm11dGF0ZWRQYXJ0cyA9IGV4dGVuZE9ic2VydmFiaWxpdHlTZXQodHJhbnMubXV0YXRlZFBhcnRzIHx8IHt9LCBtdXRhdGVkUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgICAgIHZhciBnZXRSYW5nZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIF9kID0gX2EucXVlcnksIGluZGV4ID0gX2QuaW5kZXgsIHJhbmdlID0gX2QucmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBSYW5nZVNldCgoX2IgPSByYW5nZS5sb3dlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29yZS5NSU5fS0VZLCAoX2MgPSByYW5nZS51cHBlcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY29yZS5NQVhfS0VZKSxcbiAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHZhciByZWFkU3Vic2NyaWJlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAocmVxKSB7IHJldHVybiBbcHJpbWFyeUtleSwgbmV3IFJhbmdlU2V0KHJlcS5rZXkpXTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRNYW55OiBmdW5jdGlvbiAocmVxKSB7IHJldHVybiBbcHJpbWFyeUtleSwgbmV3IFJhbmdlU2V0KCkuYWRkS2V5cyhyZXEua2V5cyldOyB9LFxuICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBnZXRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogZ2V0UmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgb3BlbkN1cnNvcjogZ2V0UmFuZ2UsXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAga2V5cyhyZWFkU3Vic2NyaWJlcnMpLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xvbmVbbWV0aG9kXSA9IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjciA9IFBTRC5zdWJzY3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0xpdmVRdWVyeSA9ICEhc3Vic2NyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGFibGUgPSBpc0NhY2hhYmxlQ29udGV4dChQU0QsIHRhYmxlKSAmJiBpc0NhY2hhYmxlUmVxdWVzdChtZXRob2QsIHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYnNTZXQgPSBjYWNoYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXEub2JzU2V0ID0ge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc3Vic2NyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaXZlUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRSYW5nZVNldCA9IGZ1bmN0aW9uIChpbmRleE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IFwiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUsIFwiL1wiKS5jb25jYXQoaW5kZXhOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9ic1NldFtwYXJ0XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob2JzU2V0W3BhcnRdID0gbmV3IFJhbmdlU2V0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGtSYW5nZVNldF8xID0gZ2V0UmFuZ2VTZXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsc1JhbmdlU2V0XzEgPSBnZXRSYW5nZVNldChcIjpkZWxzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gcmVhZFN1YnNjcmliZXJzW21ldGhvZF0ocmVxKSwgcXVlcmllZEluZGV4ID0gX2FbMF0sIHF1ZXJpZWRSYW5nZXMgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdxdWVyeScgJiYgcXVlcmllZEluZGV4LmlzUHJpbWFyeUtleSAmJiAhcmVxLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZChxdWVyaWVkUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJhbmdlU2V0KHF1ZXJpZWRJbmRleC5uYW1lIHx8IFwiXCIpLmFkZChxdWVyaWVkUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcXVlcmllZEluZGV4LmlzUHJpbWFyeUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiY291bnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXRfMS5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5c1Byb21pc2VfMSA9IG1ldGhvZCA9PT0gXCJxdWVyeVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRib3VuZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUucXVlcnkoX19hc3NpZ24oX19hc3NpZ24oe30sIHJlcSksIHsgdmFsdWVzOiBmYWxzZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInF1ZXJ5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQgJiYgcmVxLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1Byb21pc2VfMS50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdGluZ0tleXMgPSBfYS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0XzEuYWRkS2V5cyhyZXN1bHRpbmdLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcEtleXMgPSByZXEudmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzLnJlc3VsdC5tYXAoZXh0cmFjdEtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXMucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXRfMS5hZGRLZXlzKHBLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZEtleXMocEtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJvcGVuQ3Vyc29yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yXzEgPSByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhbnRWYWx1ZXNfMSA9IHJlcS52YWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjdXJzb3JfMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKGN1cnNvcl8xLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0XzEuYWRkS2V5KGN1cnNvcl8xLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yXzEua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGtleSA9IGN1cnNvcl8xLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZEtleShwa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YW50VmFsdWVzXzEgJiYgcGtSYW5nZVNldF8xLmFkZEtleShjdXJzb3JfMS5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvcl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlW21ldGhvZF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVDbG9uZTtcbiAgICAgICAgICAgICAgfSB9KTtcbiAgICAgIH0sXG4gIH07XG4gIGZ1bmN0aW9uIHRyYWNrQWZmZWN0ZWRJbmRleGVzKGdldFJhbmdlU2V0LCBzY2hlbWEsIG9sZE9ianMsIG5ld09ianMpIHtcbiAgICAgIGZ1bmN0aW9uIGFkZEFmZmVjdGVkSW5kZXgoaXgpIHtcbiAgICAgICAgICB2YXIgcmFuZ2VTZXQgPSBnZXRSYW5nZVNldChpeC5uYW1lIHx8IFwiXCIpO1xuICAgICAgICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXkob2JqKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IGl4LmV4dHJhY3RLZXkob2JqKSA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhZGRLZXlPcktleXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBpeC5tdWx0aUVudHJ5ICYmIGlzQXJyYXkoa2V5KVxuICAgICAgICAgICAgICA/IGtleS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHJhbmdlU2V0LmFkZEtleShrZXkpOyB9KVxuICAgICAgICAgICAgICA6IHJhbmdlU2V0LmFkZEtleShrZXkpOyB9O1xuICAgICAgICAgIChvbGRPYmpzIHx8IG5ld09ianMpLmZvckVhY2goZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgICAgICAgICAgdmFyIG9sZEtleSA9IG9sZE9ianMgJiYgZXh0cmFjdEtleShvbGRPYmpzW2ldKTtcbiAgICAgICAgICAgICAgdmFyIG5ld0tleSA9IG5ld09ianMgJiYgZXh0cmFjdEtleShuZXdPYmpzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGNtcChvbGRLZXksIG5ld0tleSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChvbGRLZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICBhZGRLZXlPcktleXMob2xkS2V5KTtcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdLZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICBhZGRLZXlPcktleXMobmV3S2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChhZGRBZmZlY3RlZEluZGV4KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkanVzdE9wdGltaXN0aWNGcm9tRmFpbHVyZXModGJsQ2FjaGUsIHJlcSwgcmVzKSB7XG4gICAgICBpZiAocmVzLm51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgIHJldHVybiByZXE7XG4gICAgICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGVSYW5nZScpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBudW1CdWxrT3BzID0gcmVxLmtleXNcbiAgICAgICAgICA/IHJlcS5rZXlzLmxlbmd0aFxuICAgICAgICAgIDogJ3ZhbHVlcycgaW4gcmVxICYmIHJlcS52YWx1ZXNcbiAgICAgICAgICAgICAgPyByZXEudmFsdWVzLmxlbmd0aFxuICAgICAgICAgICAgICA6IDE7XG4gICAgICBpZiAocmVzLm51bUZhaWx1cmVzID09PSBudW1CdWxrT3BzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgY2xvbmUgPSBfX2Fzc2lnbih7fSwgcmVxKTtcbiAgICAgIGlmIChpc0FycmF5KGNsb25lLmtleXMpKSB7XG4gICAgICAgICAgY2xvbmUua2V5cyA9IGNsb25lLmtleXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiAhKGkgaW4gcmVzLmZhaWx1cmVzKTsgfSk7XG4gICAgICB9XG4gICAgICBpZiAoJ3ZhbHVlcycgaW4gY2xvbmUgJiYgaXNBcnJheShjbG9uZS52YWx1ZXMpKSB7XG4gICAgICAgICAgY2xvbmUudmFsdWVzID0gY2xvbmUudmFsdWVzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gIShpIGluIHJlcy5mYWlsdXJlcyk7IH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBYm92ZUxvd2VyKGtleSwgcmFuZ2UpIHtcbiAgICAgIHJldHVybiByYW5nZS5sb3dlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgOiByYW5nZS5sb3dlck9wZW5cbiAgICAgICAgICAgICAgPyBjbXAoa2V5LCByYW5nZS5sb3dlcikgPiAwXG4gICAgICAgICAgICAgIDogY21wKGtleSwgcmFuZ2UubG93ZXIpID49IDA7XG4gIH1cbiAgZnVuY3Rpb24gaXNCZWxvd1VwcGVyKGtleSwgcmFuZ2UpIHtcbiAgICAgIHJldHVybiByYW5nZS51cHBlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgOiByYW5nZS51cHBlck9wZW5cbiAgICAgICAgICAgICAgPyBjbXAoa2V5LCByYW5nZS51cHBlcikgPCAwXG4gICAgICAgICAgICAgIDogY21wKGtleSwgcmFuZ2UudXBwZXIpIDw9IDA7XG4gIH1cbiAgZnVuY3Rpb24gaXNXaXRoaW5SYW5nZShrZXksIHJhbmdlKSB7XG4gICAgICByZXR1cm4gaXNBYm92ZUxvd2VyKGtleSwgcmFuZ2UpICYmIGlzQmVsb3dVcHBlcihrZXksIHJhbmdlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5T3B0aW1pc3RpY09wcyhyZXN1bHQsIHJlcSwgb3BzLCB0YWJsZSwgY2FjaGVFbnRyeSwgaW1tdXRhYmxlKSB7XG4gICAgICBpZiAoIW9wcyB8fCBvcHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB2YXIgaW5kZXggPSByZXEucXVlcnkuaW5kZXg7XG4gICAgICB2YXIgbXVsdGlFbnRyeSA9IGluZGV4Lm11bHRpRW50cnk7XG4gICAgICB2YXIgcXVlcnlSYW5nZSA9IHJlcS5xdWVyeS5yYW5nZTtcbiAgICAgIHZhciBwcmltYXJ5S2V5ID0gdGFibGUuc2NoZW1hLnByaW1hcnlLZXk7XG4gICAgICB2YXIgZXh0cmFjdFByaW1LZXkgPSBwcmltYXJ5S2V5LmV4dHJhY3RLZXk7XG4gICAgICB2YXIgZXh0cmFjdEluZGV4ID0gaW5kZXguZXh0cmFjdEtleTtcbiAgICAgIHZhciBleHRyYWN0TG93TGV2ZWxJbmRleCA9IChpbmRleC5sb3dMZXZlbEluZGV4IHx8IGluZGV4KS5leHRyYWN0S2V5O1xuICAgICAgdmFyIGZpbmFsUmVzdWx0ID0gb3BzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBvcCkge1xuICAgICAgICAgIHZhciBtb2RpZmVkUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgIHZhciBpbmNsdWRlZFZhbHVlcyA9IFtdO1xuICAgICAgICAgIGlmIChvcC50eXBlID09PSAnYWRkJyB8fCBvcC50eXBlID09PSAncHV0Jykge1xuICAgICAgICAgICAgICB2YXIgaW5jbHVkZWRQS3MgPSBuZXcgUmFuZ2VTZXQoKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG9wLnZhbHVlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gb3AudmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgdmFyIHBrID0gZXh0cmFjdFByaW1LZXkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVkUEtzLmhhc0tleShwaykpXG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZXh0cmFjdEluZGV4KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtdWx0aUVudHJ5ICYmIGlzQXJyYXkoa2V5KVxuICAgICAgICAgICAgICAgICAgICAgID8ga2V5LnNvbWUoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGlzV2l0aGluUmFuZ2UoaywgcXVlcnlSYW5nZSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBpc1dpdGhpblJhbmdlKGtleSwgcXVlcnlSYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlZFBLcy5hZGRLZXkocGspO1xuICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVkVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICdhZGQnOiB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdLZXlzXzEgPSBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKHJlcS52YWx1ZXMgPyByZXN1bHQubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBleHRyYWN0UHJpbUtleSh2KTsgfSkgOiByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdC5jb25jYXQocmVxLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgID8gaW5jbHVkZWRWYWx1ZXMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBleHRyYWN0UHJpbUtleSh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nS2V5c18xLmhhc0tleShrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0tleXNfMS5hZGRLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGluY2x1ZGVkVmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGV4dHJhY3RQcmltS2V5KHYpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0tleXNfMS5oYXNLZXkoaykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nS2V5c18xLmFkZEtleShrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAncHV0Jzoge1xuICAgICAgICAgICAgICAgICAgdmFyIGtleVNldF8xID0gbmV3IFJhbmdlU2V0KCkuYWRkS2V5cyhvcC52YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBleHRyYWN0UHJpbUtleSh2KTsgfSkpO1xuICAgICAgICAgICAgICAgICAgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gIWtleVNldF8xLmhhc0tleShyZXEudmFsdWVzID8gZXh0cmFjdFByaW1LZXkoaXRlbSkgOiBpdGVtKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgID8gaW5jbHVkZWRWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICA6IGluY2x1ZGVkVmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gZXh0cmFjdFByaW1LZXkodik7IH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgICAgICB2YXIga2V5c1RvRGVsZXRlXzEgPSBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKG9wLmtleXMpO1xuICAgICAgICAgICAgICAgICAgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWtleXNUb0RlbGV0ZV8xLmhhc0tleShyZXEudmFsdWVzID8gZXh0cmFjdFByaW1LZXkoaXRlbSkgOiBpdGVtKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZVJhbmdlJzpcbiAgICAgICAgICAgICAgICAgIHZhciByYW5nZV8xID0gb3AucmFuZ2U7XG4gICAgICAgICAgICAgICAgICBtb2RpZmVkUmVzdWx0ID0gcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gIWlzV2l0aGluUmFuZ2UoZXh0cmFjdFByaW1LZXkoaXRlbSksIHJhbmdlXzEpOyB9KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbW9kaWZlZFJlc3VsdDtcbiAgICAgIH0sIHJlc3VsdCk7XG4gICAgICBpZiAoZmluYWxSZXN1bHQgPT09IHJlc3VsdClcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgZmluYWxSZXN1bHQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBjbXAoZXh0cmFjdExvd0xldmVsSW5kZXgoYSksIGV4dHJhY3RMb3dMZXZlbEluZGV4KGIpKSB8fFxuICAgICAgICAgICAgICBjbXAoZXh0cmFjdFByaW1LZXkoYSksIGV4dHJhY3RQcmltS2V5KGIpKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlcS5saW1pdCAmJiByZXEubGltaXQgPCBJbmZpbml0eSkge1xuICAgICAgICAgIGlmIChmaW5hbFJlc3VsdC5sZW5ndGggPiByZXEubGltaXQpIHtcbiAgICAgICAgICAgICAgZmluYWxSZXN1bHQubGVuZ3RoID0gcmVxLmxpbWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChyZXN1bHQubGVuZ3RoID09PSByZXEubGltaXQgJiYgZmluYWxSZXN1bHQubGVuZ3RoIDwgcmVxLmxpbWl0KSB7XG4gICAgICAgICAgICAgIGNhY2hlRW50cnkuZGlydHkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbW11dGFibGUgPyBPYmplY3QuZnJlZXplKGZpbmFsUmVzdWx0KSA6IGZpbmFsUmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gYXJlUmFuZ2VzRXF1YWwocjEsIHIyKSB7XG4gICAgICByZXR1cm4gKGNtcChyMS5sb3dlciwgcjIubG93ZXIpID09PSAwICYmXG4gICAgICAgICAgY21wKHIxLnVwcGVyLCByMi51cHBlcikgPT09IDAgJiZcbiAgICAgICAgICAhIXIxLmxvd2VyT3BlbiA9PT0gISFyMi5sb3dlck9wZW4gJiZcbiAgICAgICAgICAhIXIxLnVwcGVyT3BlbiA9PT0gISFyMi51cHBlck9wZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZUxvd2Vycyhsb3dlcjEsIGxvd2VyMiwgbG93ZXJPcGVuMSwgbG93ZXJPcGVuMikge1xuICAgICAgaWYgKGxvd2VyMSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiBsb3dlcjIgIT09IHVuZGVmaW5lZCA/IC0xIDogMDtcbiAgICAgIGlmIChsb3dlcjIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgIHZhciBjID0gY21wKGxvd2VyMSwgbG93ZXIyKTtcbiAgICAgIGlmIChjID09PSAwKSB7XG4gICAgICAgICAgaWYgKGxvd2VyT3BlbjEgJiYgbG93ZXJPcGVuMilcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgaWYgKGxvd2VyT3BlbjEpXG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIGlmIChsb3dlck9wZW4yKVxuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgfVxuICBmdW5jdGlvbiBjb21wYXJlVXBwZXJzKHVwcGVyMSwgdXBwZXIyLCB1cHBlck9wZW4xLCB1cHBlck9wZW4yKSB7XG4gICAgICBpZiAodXBwZXIxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIHVwcGVyMiAhPT0gdW5kZWZpbmVkID8gMSA6IDA7XG4gICAgICBpZiAodXBwZXIyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgdmFyIGMgPSBjbXAodXBwZXIxLCB1cHBlcjIpO1xuICAgICAgaWYgKGMgPT09IDApIHtcbiAgICAgICAgICBpZiAodXBwZXJPcGVuMSAmJiB1cHBlck9wZW4yKVxuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICBpZiAodXBwZXJPcGVuMSlcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmICh1cHBlck9wZW4yKVxuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICB9XG4gIGZ1bmN0aW9uIGlzU3VwZXJSYW5nZShyMSwgcjIpIHtcbiAgICAgIHJldHVybiAoY29tcGFyZUxvd2VycyhyMS5sb3dlciwgcjIubG93ZXIsIHIxLmxvd2VyT3BlbiwgcjIubG93ZXJPcGVuKSA8PSAwICYmXG4gICAgICAgICAgY29tcGFyZVVwcGVycyhyMS51cHBlciwgcjIudXBwZXIsIHIxLnVwcGVyT3BlbiwgcjIudXBwZXJPcGVuKSA+PSAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRDb21wYXRpYmxlUXVlcnkoZGJOYW1lLCB0YWJsZU5hbWUsIHR5cGUsIHJlcSkge1xuICAgICAgdmFyIHRibENhY2hlID0gY2FjaGVbXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSldO1xuICAgICAgaWYgKCF0YmxDYWNoZSlcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICB2YXIgcXVlcmllcyA9IHRibENhY2hlLnF1ZXJpZXNbdHlwZV07XG4gICAgICBpZiAoIXF1ZXJpZXMpXG4gICAgICAgICAgcmV0dXJuIFtudWxsLCBmYWxzZSwgdGJsQ2FjaGUsIG51bGxdO1xuICAgICAgdmFyIGluZGV4TmFtZSA9IHJlcS5xdWVyeSA/IHJlcS5xdWVyeS5pbmRleC5uYW1lIDogbnVsbDtcbiAgICAgIHZhciBlbnRyaWVzID0gcXVlcmllc1tpbmRleE5hbWUgfHwgJyddO1xuICAgICAgaWYgKCFlbnRyaWVzKVxuICAgICAgICAgIHJldHVybiBbbnVsbCwgZmFsc2UsIHRibENhY2hlLCBudWxsXTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgICAgICAgICAgdmFyIGVxdWFsRW50cnkgPSBlbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkucmVxLmxpbWl0ID09PSByZXEubGltaXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZXEudmFsdWVzID09PSByZXEudmFsdWVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgYXJlUmFuZ2VzRXF1YWwoZW50cnkucmVxLnF1ZXJ5LnJhbmdlLCByZXEucXVlcnkucmFuZ2UpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGVxdWFsRW50cnkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgIGVxdWFsRW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLFxuICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgdmFyIHN1cGVyRW50cnkgPSBlbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbGltaXQgPSAnbGltaXQnIGluIGVudHJ5LnJlcSA/IGVudHJ5LnJlcS5saW1pdCA6IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChsaW1pdCA+PSByZXEubGltaXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAocmVxLnZhbHVlcyA/IGVudHJ5LnJlcS52YWx1ZXMgOiB0cnVlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGlzU3VwZXJSYW5nZShlbnRyeS5yZXEucXVlcnkucmFuZ2UsIHJlcS5xdWVyeS5yYW5nZSkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtzdXBlckVudHJ5LCBmYWxzZSwgdGJsQ2FjaGUsIGVudHJpZXNdO1xuICAgICAgICAgIGNhc2UgJ2NvdW50JzpcbiAgICAgICAgICAgICAgdmFyIGNvdW50UXVlcnkgPSBlbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXJlUmFuZ2VzRXF1YWwoZW50cnkucmVxLnF1ZXJ5LnJhbmdlLCByZXEucXVlcnkucmFuZ2UpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjb3VudFF1ZXJ5LCAhIWNvdW50UXVlcnksIHRibENhY2hlLCBlbnRyaWVzXTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN1YnNjcmliZVRvQ2FjaGVFbnRyeShjYWNoZUVudHJ5LCBjb250YWluZXIsIHJlcXVlcnksIHNpZ25hbCkge1xuICAgICAgY2FjaGVFbnRyeS5zdWJzY3JpYmVycy5hZGQocmVxdWVyeSk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWNoZUVudHJ5LnN1YnNjcmliZXJzLmRlbGV0ZShyZXF1ZXJ5KTtcbiAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5zdWJzY3JpYmVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgIGVucXVlRm9yRGVsZXRpb24oY2FjaGVFbnRyeSwgY29udGFpbmVyKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBlbnF1ZUZvckRlbGV0aW9uKGNhY2hlRW50cnksIGNvbnRhaW5lcikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNhY2hlRW50cnkuc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oY29udGFpbmVyLCBjYWNoZUVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICB9LCAzMDAwKTtcbiAgfVxuXG4gIHZhciBjYWNoZU1pZGRsZXdhcmUgPSB7XG4gICAgICBzdGFjazogJ2RiY29yZScsXG4gICAgICBsZXZlbDogMCxcbiAgICAgIG5hbWU6ICdDYWNoZScsXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIChjb3JlKSB7XG4gICAgICAgICAgdmFyIGRiTmFtZSA9IGNvcmUuc2NoZW1hLm5hbWU7XG4gICAgICAgICAgdmFyIGNvcmVNVyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb3JlKSwgeyB0cmFuc2FjdGlvbjogZnVuY3Rpb24gKHN0b3JlcywgbW9kZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgdmFyIGlkYnRyYW5zID0gY29yZS50cmFuc2FjdGlvbihzdG9yZXMsIG1vZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkd3JpdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGFjXzEgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ25hbCA9IGFjXzEuc2lnbmFsO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh3YXNDb21taXR0ZWQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWNfMS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZmZlY3RlZFN1YnNjcmliZXJzXzEgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN0b3Jlc18xID0gc3RvcmVzOyBfaSA8IHN0b3Jlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSBzdG9yZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRibENhY2hlID0gY2FjaGVbXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHN0b3JlTmFtZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YmxDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBjb3JlLnRhYmxlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHMgPSB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLmZpbHRlcihmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLnRyYW5zID09PSBpZGJ0cmFuczsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZGJ0cmFucy5fZXhwbGljaXQgJiYgd2FzQ29tbWl0dGVkICYmIGlkYnRyYW5zLm11dGF0ZWRQYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IE9iamVjdC52YWx1ZXModGJsQ2FjaGUucXVlcmllcy5xdWVyeSk7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBfYltfYV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSAwLCBfZCA9IGVudHJpZXMuc2xpY2UoKTsgX2MgPCBfZC5sZW5ndGg7IF9jKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2RbX2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JzU2V0c092ZXJsYXAoZW50cnkub2JzU2V0LCBpZGJ0cmFucy5tdXRhdGVkUGFydHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oZW50cmllcywgZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVyeSkgeyByZXR1cm4gYWZmZWN0ZWRTdWJzY3JpYmVyc18xLmFkZChyZXF1ZXJ5KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlLm9wdGltaXN0aWNPcHMgPSB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLmZpbHRlcihmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLnRyYW5zICE9PSBpZGJ0cmFuczsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZSA9IDAsIF9mID0gT2JqZWN0LnZhbHVlcyh0YmxDYWNoZS5xdWVyaWVzLnF1ZXJ5KTsgX2UgPCBfZi5sZW5ndGg7IF9lKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IF9mW19lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZyA9IDAsIF9oID0gZW50cmllcy5zbGljZSgpOyBfZyA8IF9oLmxlbmd0aDsgX2crKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBfaFtfZ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5yZXMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRidHJhbnMubXV0YXRlZFBhcnRzXG4gICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhc0NvbW1pdHRlZCAmJiAhZW50cnkuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJlZXplUmVzdWx0cyA9IE9iamVjdC5pc0Zyb3plbihlbnRyeS5yZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RSZXMgPSBhcHBseU9wdGltaXN0aWNPcHMoZW50cnkucmVzLCBlbnRyeS5yZXEsIG9wcywgdGFibGUsIGVudHJ5LCBmcmVlemVSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGVudHJpZXMsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVyeSkgeyByZXR1cm4gYWZmZWN0ZWRTdWJzY3JpYmVyc18xLmFkZChyZXF1ZXJ5KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZFJlcyAhPT0gZW50cnkucmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJlcyA9IG1vZFJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHsgcmVzdWx0OiBtb2RSZXMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbShlbnRyaWVzLCBlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIGFmZmVjdGVkU3Vic2NyaWJlcnNfMS5hZGQocmVxdWVyeSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRTdWJzY3JpYmVyc18xLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIHJlcXVlcnkoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9OyB9O1xuICAgICAgICAgICAgICAgICAgICAgIGlkYnRyYW5zLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZW5kVHJhbnNhY3Rpb24oZmFsc2UpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGlkYnRyYW5zLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZW5kVHJhbnNhY3Rpb24oZmFsc2UpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGlkYnRyYW5zLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgZW5kVHJhbnNhY3Rpb24odHJ1ZSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWRidHJhbnM7XG4gICAgICAgICAgICAgIH0sIHRhYmxlOiBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZG93blRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgdmFyIHByaW1LZXkgPSBkb3duVGFibGUuc2NoZW1hLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICB2YXIgdGFibGVNVyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb3duVGFibGUpLCB7IG11dGF0ZTogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBQU0QudHJhbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmltS2V5Lm91dGJvdW5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFucy5kYi5fb3B0aW9ucy5jYWNoZSA9PT0gJ2Rpc2FibGVkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMuZXhwbGljaXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zLm1vZGUgIT09ICdyZWFkd3JpdGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGJsQ2FjaGUgPSBjYWNoZVtcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQodGFibGVOYW1lKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGJsQ2FjaGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGRvd25UYWJsZS5tdXRhdGUocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXEudHlwZSA9PT0gJ2FkZCcgfHwgcmVxLnR5cGUgPT09ICdwdXQnKSAmJiAocmVxLnZhbHVlcy5sZW5ndGggPj0gNTAgfHwgZ2V0RWZmZWN0aXZlS2V5cyhwcmltS2V5LCByZXEpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5ID09IG51bGw7IH0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxV2l0aFJlc29sdmVkS2V5cyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXEpLCB7IHZhbHVlczogcmVxLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmZhaWx1cmVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZVdpdGhLZXkgPSAoKF9hID0gcHJpbUtleS5rZXlQYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJy4nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRlZXBDbG9uZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IF9fYXNzaWduKHt9LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgodmFsdWVXaXRoS2V5LCBwcmltS2V5LmtleVBhdGgsIHJlcy5yZXN1bHRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVdpdGhLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGp1c3RlZFJlcSA9IGFkanVzdE9wdGltaXN0aWNGcm9tRmFpbHVyZXModGJsQ2FjaGUsIHJlcVdpdGhSZXNvbHZlZEtleXMsIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5wdXNoKGFkanVzdGVkUmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiByZXEubXV0YXRlZFBhcnRzICYmIHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5KHJlcS5tdXRhdGVkUGFydHMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5wdXNoKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEubXV0YXRlZFBhcnRzICYmIHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5KHJlcS5tdXRhdGVkUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0odGJsQ2FjaGUub3B0aW1pc3RpY09wcywgcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkanVzdGVkUmVxID0gYWRqdXN0T3B0aW1pc3RpY0Zyb21GYWlsdXJlcyh0YmxDYWNoZSwgcmVxLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqdXN0ZWRSZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlLm9wdGltaXN0aWNPcHMucHVzaChhZGp1c3RlZFJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm11dGF0ZWRQYXJ0cyAmJiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShyZXEubXV0YXRlZFBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbSh0YmxDYWNoZS5vcHRpbWlzdGljT3BzLCByZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5tdXRhdGVkUGFydHMgJiYgc2lnbmFsU3Vic2NyaWJlcnNMYXppbHkocmVxLm11dGF0ZWRQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCBxdWVyeTogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNDYWNoYWJsZUNvbnRleHQoUFNELCBkb3duVGFibGUpIHx8ICFpc0NhY2hhYmxlUmVxdWVzdChcInF1ZXJ5XCIsIHJlcSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLnF1ZXJ5KHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmVlemVSZXN1bHRzID0gKChfYSA9IFBTRC50cmFucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRiLl9vcHRpb25zLmNhY2hlKSA9PT0gJ2ltbXV0YWJsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IFBTRCwgcmVxdWVyeSA9IF9iLnJlcXVlcnksIHNpZ25hbCA9IF9iLnNpZ25hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gZmluZENvbXBhdGlibGVRdWVyeShkYk5hbWUsIHRhYmxlTmFtZSwgJ3F1ZXJ5JywgcmVxKSwgY2FjaGVFbnRyeSA9IF9jWzBdLCBleGFjdE1hdGNoID0gX2NbMV0sIHRibENhY2hlID0gX2NbMl0sIGNvbnRhaW5lciA9IF9jWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVFbnRyeSAmJiBleGFjdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUVudHJ5Lm9ic1NldCA9IHJlcS5vYnNTZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGRvd25UYWJsZS5xdWVyeShyZXEpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUVudHJ5LnJlcyA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJlZXplUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUocmVzdWx0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucmVzdWx0ID0gZGVlcENsb25lKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyICYmIGNhY2hlRW50cnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbShjb250YWluZXIsIGNhY2hlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlRW50cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzU2V0OiByZXEub2JzU2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncXVlcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcTogcmVxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnR5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnB1c2goY2FjaGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSBbY2FjaGVFbnRyeV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YmxDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZSA9IGNhY2hlW1wiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ianM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNPcHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zaWduYWxlZFBhcnRzOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZS5xdWVyaWVzLnF1ZXJ5W3JlcS5xdWVyeS5pbmRleC5uYW1lIHx8ICcnXSA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVUb0NhY2hlRW50cnkoY2FjaGVFbnRyeSwgY29udGFpbmVyLCByZXF1ZXJ5LCBzaWduYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVFbnRyeS5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGFwcGx5T3B0aW1pc3RpY09wcyhyZXMucmVzdWx0LCByZXEsIHRibENhY2hlID09PSBudWxsIHx8IHRibENhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLCBkb3duVGFibGUsIGNhY2hlRW50cnksIGZyZWV6ZVJlc3VsdHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZU1XO1xuICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgIHJldHVybiBjb3JlTVc7XG4gICAgICB9LFxuICB9O1xuXG4gIGZ1bmN0aW9uIHZpcGlmeSh0YXJnZXQsIHZpcERiKSB7XG4gICAgICByZXR1cm4gbmV3IFByb3h5KHRhcmdldCwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdkYicpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmlwRGI7XG4gICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIHZhciBEZXhpZSQxID0gIChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEZXhpZShuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9taWRkbGV3YXJlcyA9IHt9O1xuICAgICAgICAgIHRoaXMudmVybm8gPSAwO1xuICAgICAgICAgIHZhciBkZXBzID0gRGV4aWUuZGVwZW5kZW5jaWVzO1xuICAgICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zID0gX19hc3NpZ24oe1xuICAgICAgICAgICAgICBhZGRvbnM6IERleGllLmFkZG9ucywgYXV0b09wZW46IHRydWUsXG4gICAgICAgICAgICAgIGluZGV4ZWREQjogZGVwcy5pbmRleGVkREIsIElEQktleVJhbmdlOiBkZXBzLklEQktleVJhbmdlLCBjYWNoZTogJ2Nsb25lZCcgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5fZGVwcyA9IHtcbiAgICAgICAgICAgICAgaW5kZXhlZERCOiBvcHRpb25zLmluZGV4ZWREQixcbiAgICAgICAgICAgICAgSURCS2V5UmFuZ2U6IG9wdGlvbnMuSURCS2V5UmFuZ2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBhZGRvbnMgPSBvcHRpb25zLmFkZG9ucztcbiAgICAgICAgICB0aGlzLl9kYlNjaGVtYSA9IHt9O1xuICAgICAgICAgIHRoaXMuX3ZlcnNpb25zID0gW107XG4gICAgICAgICAgdGhpcy5fc3RvcmVOYW1lcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2FsbFRhYmxlcyA9IHt9O1xuICAgICAgICAgIHRoaXMuaWRiZGIgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX25vdmlwID0gdGhpcztcbiAgICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICAgIGRiT3BlbkVycm9yOiBudWxsLFxuICAgICAgICAgICAgICBpc0JlaW5nT3BlbmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgb25SZWFkeUJlaW5nRmlyZWQ6IG51bGwsXG4gICAgICAgICAgICAgIG9wZW5Db21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgIGRiUmVhZHlSZXNvbHZlOiBub3AsXG4gICAgICAgICAgICAgIGRiUmVhZHlQcm9taXNlOiBudWxsLFxuICAgICAgICAgICAgICBjYW5jZWxPcGVuOiBub3AsXG4gICAgICAgICAgICAgIG9wZW5DYW5jZWxsZXI6IG51bGwsXG4gICAgICAgICAgICAgIGF1dG9TY2hlbWE6IHRydWUsXG4gICAgICAgICAgICAgIFBSMTM5OF9tYXhMb29wOiAzLFxuICAgICAgICAgICAgICBhdXRvT3Blbjogb3B0aW9ucy5hdXRvT3BlbixcbiAgICAgICAgICB9O1xuICAgICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdGUub3BlbkNhbmNlbGxlciA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuICAgICAgICAgICAgICBzdGF0ZS5jYW5jZWxPcGVuID0gcmVqZWN0O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLm9uID0gRXZlbnRzKHRoaXMsIFwicG9wdWxhdGVcIiwgXCJibG9ja2VkXCIsIFwidmVyc2lvbmNoYW5nZVwiLCBcImNsb3NlXCIsIHsgcmVhZHk6IFtwcm9taXNhYmxlQ2hhaW4sIG5vcF0gfSk7XG4gICAgICAgICAgdGhpcy5vbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfdGhpcy5vbihldmVudCkudW5zdWJzY3JpYmUoZm4pO1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMub24oZXZlbnQsIGZuKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMub24ucmVhZHkuc3Vic2NyaWJlID0gb3ZlcnJpZGUodGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUsIGZ1bmN0aW9uIChzdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBiU3RpY2t5KSB7XG4gICAgICAgICAgICAgICAgICBEZXhpZS52aXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IF90aGlzLl9zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUub3BlbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuZGJPcGVuRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZSgpLnRoZW4oc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiU3RpY2t5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYlN0aWNreSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiXzEgPSBfdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiU3RpY2t5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiXzEub24ucmVhZHkudW5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGJfMS5vbi5yZWFkeS51bnN1YnNjcmliZSh1bnN1YnNjcmliZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLkNvbGxlY3Rpb24gPSBjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgdGhpcy5UYWJsZSA9IGNyZWF0ZVRhYmxlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgdGhpcy5UcmFuc2FjdGlvbiA9IGNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgdGhpcy5WZXJzaW9uID0gY3JlYXRlVmVyc2lvbkNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgIHRoaXMuV2hlcmVDbGF1c2UgPSBjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgIHRoaXMub24oXCJ2ZXJzaW9uY2hhbmdlXCIsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBpZiAoZXYubmV3VmVyc2lvbiA+IDApXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBbm90aGVyIGNvbm5lY3Rpb24gd2FudHMgdG8gdXBncmFkZSBkYXRhYmFzZSAnXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiJy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSB1cGdyYWRlLlwiKSk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkFub3RoZXIgY29ubmVjdGlvbiB3YW50cyB0byBkZWxldGUgZGF0YWJhc2UgJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicuIENsb3NpbmcgZGIgbm93IHRvIHJlc3VtZSB0aGUgZGVsZXRlIHJlcXVlc3QuXCIpKTtcbiAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoeyBkaXNhYmxlQXV0b09wZW46IGZhbHNlIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMub24oXCJibG9ja2VkXCIsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBpZiAoIWV2Lm5ld1ZlcnNpb24gfHwgZXYubmV3VmVyc2lvbiA8IGV2Lm9sZFZlcnNpb24pXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEZXhpZS5kZWxldGUoJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicpIHdhcyBibG9ja2VkXCIpKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVXBncmFkZSAnXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiJyBibG9ja2VkIGJ5IG90aGVyIGNvbm5lY3Rpb24gaG9sZGluZyB2ZXJzaW9uIFwiKS5jb25jYXQoZXYub2xkVmVyc2lvbiAvIDEwKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fbWF4S2V5ID0gZ2V0TWF4S2V5KG9wdGlvbnMuSURCS2V5UmFuZ2UpO1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCBwYXJlbnRUcmFuc2FjdGlvbikgeyByZXR1cm4gbmV3IF90aGlzLlRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCBfdGhpcy5fb3B0aW9ucy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksIHBhcmVudFRyYW5zYWN0aW9uKTsgfTtcbiAgICAgICAgICB0aGlzLl9maXJlT25CbG9ja2VkID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgIF90aGlzLm9uKFwiYmxvY2tlZFwiKS5maXJlKGV2KTtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMubmFtZSA9PT0gX3RoaXMubmFtZSAmJiBjICE9PSBfdGhpcyAmJiAhYy5fc3RhdGUudmNGaXJlZDsgfSlcbiAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpOyB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMudXNlKGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlKTtcbiAgICAgICAgICB0aGlzLnVzZShjYWNoZU1pZGRsZXdhcmUpO1xuICAgICAgICAgIHRoaXMudXNlKG9ic2VydmFiaWxpdHlNaWRkbGV3YXJlKTtcbiAgICAgICAgICB0aGlzLnVzZSh2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlKTtcbiAgICAgICAgICB0aGlzLnVzZShob29rc01pZGRsZXdhcmUpO1xuICAgICAgICAgIHZhciB2aXBEQiA9IG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKF8sIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ192aXAnKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICd0YWJsZScpXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YWJsZU5hbWUpIHsgcmV0dXJuIHZpcGlmeShfdGhpcy50YWJsZSh0YWJsZU5hbWUpLCB2aXBEQik7IH07XG4gICAgICAgICAgICAgICAgICB2YXIgcnYgPSBSZWZsZWN0LmdldChfLCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICBpZiAocnYgaW5zdGFuY2VvZiBUYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlwaWZ5KHJ2LCB2aXBEQik7XG4gICAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3RhYmxlcycpXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ2Lm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdmlwaWZ5KHQsIHZpcERCKTsgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ19jcmVhdGVUcmFuc2FjdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4ID0gcnYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpcGlmeSh0eCwgdmlwREIpO1xuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnZpcCA9IHZpcERCO1xuICAgICAgICAgIGFkZG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhZGRvbikgeyByZXR1cm4gYWRkb24oX3RoaXMpOyB9KTtcbiAgICAgIH1cbiAgICAgIERleGllLnByb3RvdHlwZS52ZXJzaW9uID0gZnVuY3Rpb24gKHZlcnNpb25OdW1iZXIpIHtcbiAgICAgICAgICBpZiAoaXNOYU4odmVyc2lvbk51bWJlcikgfHwgdmVyc2lvbk51bWJlciA8IDAuMSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVHlwZShcIkdpdmVuIHZlcnNpb24gaXMgbm90IGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICAgIHZlcnNpb25OdW1iZXIgPSBNYXRoLnJvdW5kKHZlcnNpb25OdW1iZXIgKiAxMCkgLyAxMDtcbiAgICAgICAgICBpZiAodGhpcy5pZGJkYiB8fCB0aGlzLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJDYW5ub3QgYWRkIHZlcnNpb24gd2hlbiBkYXRhYmFzZSBpcyBvcGVuXCIpO1xuICAgICAgICAgIHRoaXMudmVybm8gPSBNYXRoLm1heCh0aGlzLnZlcm5vLCB2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICB2YXIgdmVyc2lvbnMgPSB0aGlzLl92ZXJzaW9ucztcbiAgICAgICAgICB2YXIgdmVyc2lvbkluc3RhbmNlID0gdmVyc2lvbnMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2Ll9jZmcudmVyc2lvbiA9PT0gdmVyc2lvbk51bWJlcjsgfSlbMF07XG4gICAgICAgICAgaWYgKHZlcnNpb25JbnN0YW5jZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb25JbnN0YW5jZTtcbiAgICAgICAgICB2ZXJzaW9uSW5zdGFuY2UgPSBuZXcgdGhpcy5WZXJzaW9uKHZlcnNpb25OdW1iZXIpO1xuICAgICAgICAgIHZlcnNpb25zLnB1c2godmVyc2lvbkluc3RhbmNlKTtcbiAgICAgICAgICB2ZXJzaW9ucy5zb3J0KGxvd2VyVmVyc2lvbkZpcnN0KTtcbiAgICAgICAgICB2ZXJzaW9uSW5zdGFuY2Uuc3RvcmVzKHt9KTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZS5hdXRvU2NoZW1hID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIHZlcnNpb25JbnN0YW5jZTtcbiAgICAgIH07XG4gICAgICBEZXhpZS5wcm90b3R5cGUuX3doZW5SZWFkeSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLmlkYmRiICYmICh0aGlzLl9zdGF0ZS5vcGVuQ29tcGxldGUgfHwgUFNELmxldFRocm91Z2ggfHwgdGhpcy5fdmlwKSkgPyBmbigpIDogbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKF90aGlzLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghX3RoaXMuX3N0YXRlLmlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3N0YXRlLmF1dG9PcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF90aGlzLm9wZW4oKS5jYXRjaChub3ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzLl9zdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSkudGhlbihmbik7XG4gICAgICB9O1xuICAgICAgRGV4aWUucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgIHZhciBzdGFjayA9IF9hLnN0YWNrLCBjcmVhdGUgPSBfYS5jcmVhdGUsIGxldmVsID0gX2EubGV2ZWwsIG5hbWUgPSBfYS5uYW1lO1xuICAgICAgICAgIGlmIChuYW1lKVxuICAgICAgICAgICAgICB0aGlzLnVudXNlKHsgc3RhY2s6IHN0YWNrLCBuYW1lOiBuYW1lIH0pO1xuICAgICAgICAgIHZhciBtaWRkbGV3YXJlcyA9IHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSB8fCAodGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdID0gW10pO1xuICAgICAgICAgIG1pZGRsZXdhcmVzLnB1c2goeyBzdGFjazogc3RhY2ssIGNyZWF0ZTogY3JlYXRlLCBsZXZlbDogbGV2ZWwgPT0gbnVsbCA/IDEwIDogbGV2ZWwsIG5hbWU6IG5hbWUgfSk7XG4gICAgICAgICAgbWlkZGxld2FyZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5sZXZlbCAtIGIubGV2ZWw7IH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIERleGllLnByb3RvdHlwZS51bnVzZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgIHZhciBzdGFjayA9IF9hLnN0YWNrLCBuYW1lID0gX2EubmFtZSwgY3JlYXRlID0gX2EuY3JlYXRlO1xuICAgICAgICAgIGlmIChzdGFjayAmJiB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10pIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdID0gdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdLmZpbHRlcihmdW5jdGlvbiAobXcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUgPyBtdy5jcmVhdGUgIT09IGNyZWF0ZSA6XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZSA/IG13Lm5hbWUgIT09IG5hbWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIERleGllLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIHVzZVBTRChnbG9iYWxQU0QsXG4gICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGV4aWVPcGVuKF90aGlzKTsgfSk7XG4gICAgICB9O1xuICAgICAgRGV4aWUucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLm9uLmNsb3NlLmZpcmUobmV3IEN1c3RvbUV2ZW50KCdjbG9zZScpKTtcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICB2YXIgaWR4ID0gY29ubmVjdGlvbnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICBpZiAoaWR4ID49IDApXG4gICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgIGlmICh0aGlzLmlkYmRiKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmlkYmRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICB0aGlzLmlkYmRiID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc3RhdGUub3BlbkNhbmNlbGxlciA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgc3RhdGUuY2FuY2VsT3BlbiA9IHJlamVjdDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIERleGllLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7IGRpc2FibGVBdXRvT3BlbjogdHJ1ZSB9IDogX2EsIGRpc2FibGVBdXRvT3BlbiA9IF9iLmRpc2FibGVBdXRvT3BlbjtcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICBpZiAoZGlzYWJsZUF1dG9PcGVuKSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5jYW5jZWxPcGVuKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgICAgICAgICAgIHN0YXRlLmF1dG9PcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgICAgICAgICAgIHN0YXRlLmF1dG9PcGVuID0gdGhpcy5fb3B0aW9ucy5hdXRvT3BlbiB8fFxuICAgICAgICAgICAgICAgICAgc3RhdGUuaXNCZWluZ09wZW5lZDtcbiAgICAgICAgICAgICAgc3RhdGUub3BlbkNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRGV4aWUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChjbG9zZU9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChjbG9zZU9wdGlvbnMgPT09IHZvaWQgMCkgeyBjbG9zZU9wdGlvbnMgPSB7IGRpc2FibGVBdXRvT3BlbjogdHJ1ZSB9OyB9XG4gICAgICAgICAgdmFyIGhhc0ludmFsaWRBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0JztcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHZhciBkb0RlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKGNsb3NlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVxID0gX3RoaXMuX2RlcHMuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKF90aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIF9vbkRhdGFiYXNlRGVsZXRlZChfdGhpcy5fZGVwcywgX3RoaXMubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgcmVxLm9uYmxvY2tlZCA9IF90aGlzLl9maXJlT25CbG9ja2VkO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoaGFzSW52YWxpZEFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgY2xvc2VPcHRpb25zIGFyZ3VtZW50IHRvIGRiLmRlbGV0ZSgpXCIpO1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihkb0RlbGV0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBkb0RlbGV0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgRGV4aWUucHJvdG90eXBlLmJhY2tlbmREQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pZGJkYjtcbiAgICAgIH07XG4gICAgICBEZXhpZS5wcm90b3R5cGUuaXNPcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlkYmRiICE9PSBudWxsO1xuICAgICAgfTtcbiAgICAgIERleGllLnByb3RvdHlwZS5oYXNCZWVuQ2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBkYk9wZW5FcnJvciA9IHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yO1xuICAgICAgICAgIHJldHVybiBkYk9wZW5FcnJvciAmJiAoZGJPcGVuRXJyb3IubmFtZSA9PT0gJ0RhdGFiYXNlQ2xvc2VkJyk7XG4gICAgICB9O1xuICAgICAgRGV4aWUucHJvdG90eXBlLmhhc0ZhaWxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZGJPcGVuRXJyb3IgIT09IG51bGw7XG4gICAgICB9O1xuICAgICAgRGV4aWUucHJvdG90eXBlLmR5bmFtaWNhbGx5T3BlbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5hdXRvU2NoZW1hO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZXhpZS5wcm90b3R5cGUsIFwidGFibGVzXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgcmV0dXJuIGtleXModGhpcy5fYWxsVGFibGVzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLl9hbGxUYWJsZXNbbmFtZV07IH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIERleGllLnByb3RvdHlwZS50cmFuc2FjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgICAgRGV4aWUucHJvdG90eXBlLl90cmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChtb2RlLCB0YWJsZXMsIHNjb3BlRnVuYykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHBhcmVudFRyYW5zYWN0aW9uID0gUFNELnRyYW5zO1xuICAgICAgICAgIGlmICghcGFyZW50VHJhbnNhY3Rpb24gfHwgcGFyZW50VHJhbnNhY3Rpb24uZGIgIT09IHRoaXMgfHwgbW9kZS5pbmRleE9mKCchJykgIT09IC0xKVxuICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgdmFyIG9ubHlJZkNvbXBhdGlibGUgPSBtb2RlLmluZGV4T2YoJz8nKSAhPT0gLTE7XG4gICAgICAgICAgbW9kZSA9IG1vZGUucmVwbGFjZSgnIScsICcnKS5yZXBsYWNlKCc/JywgJycpO1xuICAgICAgICAgIHZhciBpZGJNb2RlLCBzdG9yZU5hbWVzO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlTmFtZXMgPSB0YWJsZXMubWFwKGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlTmFtZSA9IHRhYmxlIGluc3RhbmNlb2YgX3RoaXMuVGFibGUgPyB0YWJsZS5uYW1lIDogdGFibGU7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlTmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGFibGUgYXJndW1lbnQgdG8gRGV4aWUudHJhbnNhY3Rpb24oKS4gT25seSBUYWJsZSBvciBTdHJpbmcgYXJlIGFsbG93ZWRcIik7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmVOYW1lO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKG1vZGUgPT0gXCJyXCIgfHwgbW9kZSA9PT0gUkVBRE9OTFkpXG4gICAgICAgICAgICAgICAgICBpZGJNb2RlID0gUkVBRE9OTFk7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT0gXCJyd1wiIHx8IG1vZGUgPT0gUkVBRFdSSVRFKVxuICAgICAgICAgICAgICAgICAgaWRiTW9kZSA9IFJFQURXUklURTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiSW52YWxpZCB0cmFuc2FjdGlvbiBtb2RlOiBcIiArIG1vZGUpO1xuICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbi5tb2RlID09PSBSRUFET05MWSAmJiBpZGJNb2RlID09PSBSRUFEV1JJVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU3ViVHJhbnNhY3Rpb24oXCJDYW5ub3QgZW50ZXIgYSBzdWItdHJhbnNhY3Rpb24gd2l0aCBSRUFEV1JJVEUgbW9kZSB3aGVuIHBhcmVudCB0cmFuc2FjdGlvbiBpcyBSRUFET05MWVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbiAmJiBwYXJlbnRUcmFuc2FjdGlvbi5zdG9yZU5hbWVzLmluZGV4T2Yoc3RvcmVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiVGFibGUgXCIgKyBzdG9yZU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBub3QgaW5jbHVkZWQgaW4gcGFyZW50IHRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUgJiYgcGFyZW50VHJhbnNhY3Rpb24gJiYgIXBhcmVudFRyYW5zYWN0aW9uLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyZW50VHJhbnNhY3Rpb24gP1xuICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24uX3Byb21pc2UobnVsbCwgZnVuY3Rpb24gKF8sIHJlamVjdCkgeyByZWplY3QoZSk7IH0pIDpcbiAgICAgICAgICAgICAgICAgIHJlamVjdGlvbihlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVudGVyVHJhbnNhY3Rpb24gPSBlbnRlclRyYW5zYWN0aW9uU2NvcGUuYmluZChudWxsLCB0aGlzLCBpZGJNb2RlLCBzdG9yZU5hbWVzLCBwYXJlbnRUcmFuc2FjdGlvbiwgc2NvcGVGdW5jKTtcbiAgICAgICAgICByZXR1cm4gKHBhcmVudFRyYW5zYWN0aW9uID9cbiAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24uX3Byb21pc2UoaWRiTW9kZSwgZW50ZXJUcmFuc2FjdGlvbiwgXCJsb2NrXCIpIDpcbiAgICAgICAgICAgICAgUFNELnRyYW5zID9cbiAgICAgICAgICAgICAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fd2hlblJlYWR5KGVudGVyVHJhbnNhY3Rpb24pOyB9KSA6XG4gICAgICAgICAgICAgICAgICB0aGlzLl93aGVuUmVhZHkoZW50ZXJUcmFuc2FjdGlvbikpO1xuICAgICAgfTtcbiAgICAgIERleGllLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc093bih0aGlzLl9hbGxUYWJsZXMsIHRhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZFRhYmxlKFwiVGFibGUgXCIuY29uY2F0KHRhYmxlTmFtZSwgXCIgZG9lcyBub3QgZXhpc3RcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fYWxsVGFibGVzW3RhYmxlTmFtZV07XG4gICAgICB9O1xuICAgICAgcmV0dXJuIERleGllO1xuICB9KCkpO1xuXG4gIHZhciBzeW1ib2xPYnNlcnZhYmxlID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIm9ic2VydmFibGVcIiBpbiBTeW1ib2xcbiAgICAgID8gU3ltYm9sLm9ic2VydmFibGVcbiAgICAgIDogXCJAQG9ic2VydmFibGVcIjtcbiAgdmFyIE9ic2VydmFibGUgPSAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG4gICAgICAgICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgICAgfVxuICAgICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHgsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoIXggfHwgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHsgbmV4dDogeCwgZXJyb3I6IGVycm9yLCBjb21wbGV0ZTogY29tcGxldGUgfSA6IHgpO1xuICAgICAgfTtcbiAgICAgIE9ic2VydmFibGUucHJvdG90eXBlW3N5bWJvbE9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBPYnNlcnZhYmxlO1xuICB9KCkpO1xuXG4gIHZhciBkb21EZXBzO1xuICB0cnkge1xuICAgICAgZG9tRGVwcyA9IHtcbiAgICAgICAgICBpbmRleGVkREI6IF9nbG9iYWwuaW5kZXhlZERCIHx8IF9nbG9iYWwubW96SW5kZXhlZERCIHx8IF9nbG9iYWwud2Via2l0SW5kZXhlZERCIHx8IF9nbG9iYWwubXNJbmRleGVkREIsXG4gICAgICAgICAgSURCS2V5UmFuZ2U6IF9nbG9iYWwuSURCS2V5UmFuZ2UgfHwgX2dsb2JhbC53ZWJraXRJREJLZXlSYW5nZVxuICAgICAgfTtcbiAgfVxuICBjYXRjaCAoZSkge1xuICAgICAgZG9tRGVwcyA9IHsgaW5kZXhlZERCOiBudWxsLCBJREJLZXlSYW5nZTogbnVsbCB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGl2ZVF1ZXJ5KHF1ZXJpZXIpIHtcbiAgICAgIHZhciBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgdmFyIGN1cnJlbnRWYWx1ZTtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgdmFyIHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24ocXVlcmllcik7XG4gICAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZShjdHgpIHtcbiAgICAgICAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gbmV3U2NvcGUocXVlcmllciwgY3R4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcnYgPSBydi5maW5hbGx5KGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIHdhc1Jvb3RFeGVjICYmIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgICAgdmFyIGFjY3VtTXV0cyA9IHt9O1xuICAgICAgICAgIHZhciBjdXJyZW50T2JzID0ge307XG4gICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZWQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyKVxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ZWRMaXN0ZW5pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLnVuc3Vic2NyaWJlKG11dGF0aW9uTGlzdGVuZXIpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgICAgb2JzZXJ2ZXIuc3RhcnQgJiYgb2JzZXJ2ZXIuc3RhcnQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICB2YXIgc3RhcnRlZExpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICAgIHZhciBkb1F1ZXJ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhlY0luR2xvYmFsQ29udGV4dChfZG9RdWVyeSk7IH07XG4gICAgICAgICAgZnVuY3Rpb24gc2hvdWxkTm90aWZ5KCkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JzU2V0c092ZXJsYXAoY3VycmVudE9icywgYWNjdW1NdXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG11dGF0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbiAocGFydHMpIHtcbiAgICAgICAgICAgICAgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldChhY2N1bU11dHMsIHBhcnRzKTtcbiAgICAgICAgICAgICAgaWYgKHNob3VsZE5vdGlmeSgpKSB7XG4gICAgICAgICAgICAgICAgICBkb1F1ZXJ5KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBfZG9RdWVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGNsb3NlZCB8fFxuICAgICAgICAgICAgICAgICAgIWRvbURlcHMuaW5kZXhlZERCKVxuICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFjY3VtTXV0cyA9IHt9O1xuICAgICAgICAgICAgICB2YXIgc3Vic2NyID0ge307XG4gICAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIpXG4gICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgICB2YXIgY3R4ID0ge1xuICAgICAgICAgICAgICAgICAgc3Vic2NyOiBzdWJzY3IsXG4gICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgICAgICByZXF1ZXJ5OiBkb1F1ZXJ5LFxuICAgICAgICAgICAgICAgICAgcXVlcmllcjogcXVlcmllcixcbiAgICAgICAgICAgICAgICAgIHRyYW5zOiBudWxsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHZhciByZXQgPSBleGVjdXRlKGN0eCk7XG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShyZXQpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlZCB8fCBjdHguc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBhY2N1bU11dHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRPYnMgPSBzdWJzY3I7XG4gICAgICAgICAgICAgICAgICBpZiAoIW9iamVjdElzRW1wdHkoY3VycmVudE9icykgJiYgIXN0YXJ0ZWRMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIG11dGF0aW9uTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWRMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZXhlY0luR2xvYmFsQ29udGV4dChmdW5jdGlvbiAoKSB7IHJldHVybiAhY2xvc2VkICYmIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dChyZXN1bHQpOyB9KTtcbiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGlmICghWydEYXRhYmFzZUNsb3NlZEVycm9yJywgJ0Fib3J0RXJyb3InXS5pbmNsdWRlcyhlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0luR2xvYmFsQ29udGV4dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yICYmIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHNldFRpbWVvdXQoZG9RdWVyeSwgMCk7XG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgIH0pO1xuICAgICAgb2JzZXJ2YWJsZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc1ZhbHVlOyB9O1xuICAgICAgb2JzZXJ2YWJsZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGN1cnJlbnRWYWx1ZTsgfTtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICB9XG5cbiAgdmFyIERleGllID0gRGV4aWUkMTtcbiAgcHJvcHMoRGV4aWUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBmdWxsTmFtZUV4Y2VwdGlvbnMpLCB7XG4gICAgICBkZWxldGU6IGZ1bmN0aW9uIChkYXRhYmFzZU5hbWUpIHtcbiAgICAgICAgICB2YXIgZGIgPSBuZXcgRGV4aWUoZGF0YWJhc2VOYW1lLCB7IGFkZG9uczogW10gfSk7XG4gICAgICAgICAgcmV0dXJuIGRiLmRlbGV0ZSgpO1xuICAgICAgfSxcbiAgICAgIGV4aXN0czogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERleGllKG5hbWUsIHsgYWRkb25zOiBbXSB9KS5vcGVuKCkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSkuY2F0Y2goJ05vU3VjaERhdGFiYXNlRXJyb3InLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0RGF0YWJhc2VOYW1lczogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldERhdGFiYXNlTmFtZXMoRGV4aWUuZGVwZW5kZW5jaWVzKS50aGVuKGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVmaW5lQ2xhc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmdW5jdGlvbiBDbGFzcyhjb250ZW50KSB7XG4gICAgICAgICAgICAgIGV4dGVuZCh0aGlzLCBjb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIENsYXNzO1xuICAgICAgfSwgaWdub3JlVHJhbnNhY3Rpb246IGZ1bmN0aW9uIChzY29wZUZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gUFNELnRyYW5zID9cbiAgICAgICAgICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsIHNjb3BlRnVuYykgOlxuICAgICAgICAgICAgICBzY29wZUZ1bmMoKTtcbiAgICAgIH0sIHZpcDogdmlwLCBhc3luYzogZnVuY3Rpb24gKGdlbmVyYXRvckZuKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBydiA9IGF3YWl0SXRlcmF0b3IoZ2VuZXJhdG9yRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIXJ2IHx8IHR5cGVvZiBydi50aGVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShydik7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgfSwgc3Bhd246IGZ1bmN0aW9uIChnZW5lcmF0b3JGbiwgYXJncywgdGhpeikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBydiA9IGF3YWl0SXRlcmF0b3IoZ2VuZXJhdG9yRm4uYXBwbHkodGhpeiwgYXJncyB8fCBbXSkpO1xuICAgICAgICAgICAgICBpZiAoIXJ2IHx8IHR5cGVvZiBydi50aGVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHJ2KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjdXJyZW50VHJhbnNhY3Rpb246IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBTRC50cmFucyB8fCBudWxsOyB9XG4gICAgICB9LCB3YWl0Rm9yOiBmdW5jdGlvbiAocHJvbWlzZU9yRnVuY3Rpb24sIG9wdGlvbmFsVGltZW91dCkge1xuICAgICAgICAgIHZhciBwcm9taXNlID0gRGV4aWVQcm9taXNlLnJlc29sdmUodHlwZW9mIHByb21pc2VPckZ1bmN0aW9uID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24ocHJvbWlzZU9yRnVuY3Rpb24pIDpcbiAgICAgICAgICAgICAgcHJvbWlzZU9yRnVuY3Rpb24pXG4gICAgICAgICAgICAgIC50aW1lb3V0KG9wdGlvbmFsVGltZW91dCB8fCA2MDAwMCk7XG4gICAgICAgICAgcmV0dXJuIFBTRC50cmFucyA/XG4gICAgICAgICAgICAgIFBTRC50cmFucy53YWl0Rm9yKHByb21pc2UpIDpcbiAgICAgICAgICAgICAgcHJvbWlzZTtcbiAgICAgIH0sXG4gICAgICBQcm9taXNlOiBEZXhpZVByb21pc2UsXG4gICAgICBkZWJ1Zzoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVidWc7IH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgc2V0RGVidWcodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXJpdmU6IGRlcml2ZSwgZXh0ZW5kOiBleHRlbmQsIHByb3BzOiBwcm9wcywgb3ZlcnJpZGU6IG92ZXJyaWRlLFxuICAgICAgRXZlbnRzOiBFdmVudHMsIG9uOiBnbG9iYWxFdmVudHMsIGxpdmVRdWVyeTogbGl2ZVF1ZXJ5LCBleHRlbmRPYnNlcnZhYmlsaXR5U2V0OiBleHRlbmRPYnNlcnZhYmlsaXR5U2V0LFxuICAgICAgZ2V0QnlLZXlQYXRoOiBnZXRCeUtleVBhdGgsIHNldEJ5S2V5UGF0aDogc2V0QnlLZXlQYXRoLCBkZWxCeUtleVBhdGg6IGRlbEJ5S2V5UGF0aCwgc2hhbGxvd0Nsb25lOiBzaGFsbG93Q2xvbmUsIGRlZXBDbG9uZTogZGVlcENsb25lLCBnZXRPYmplY3REaWZmOiBnZXRPYmplY3REaWZmLCBjbXA6IGNtcCwgYXNhcDogYXNhcCQxLFxuICAgICAgbWluS2V5OiBtaW5LZXksXG4gICAgICBhZGRvbnM6IFtdLFxuICAgICAgY29ubmVjdGlvbnM6IGNvbm5lY3Rpb25zLFxuICAgICAgZXJybmFtZXM6IGVycm5hbWVzLFxuICAgICAgZGVwZW5kZW5jaWVzOiBkb21EZXBzLCBjYWNoZTogY2FjaGUsXG4gICAgICBzZW1WZXI6IERFWElFX1ZFUlNJT04sIHZlcnNpb246IERFWElFX1ZFUlNJT04uc3BsaXQoJy4nKVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHBhcnNlSW50KG4pOyB9KVxuICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMsIGkpIHsgcmV0dXJuIHAgKyAoYyAvIE1hdGgucG93KDEwLCBpICogMikpOyB9KSB9KSk7XG4gIERleGllLm1heEtleSA9IGdldE1heEtleShEZXhpZS5kZXBlbmRlbmNpZXMuSURCS2V5UmFuZ2UpO1xuXG4gIGlmICh0eXBlb2YgZGlzcGF0Y2hFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIGZ1bmN0aW9uICh1cGRhdGVkUGFydHMpIHtcbiAgICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICAgICAgICB2YXIgZXZlbnRfMTtcbiAgICAgICAgICAgICAgZXZlbnRfMSA9IG5ldyBDdXN0b21FdmVudChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsIHtcbiAgICAgICAgICAgICAgICAgIGRldGFpbDogdXBkYXRlZFBhcnRzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB0cnVlO1xuICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50KGV2ZW50XzEpO1xuICAgICAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICB2YXIgZGV0YWlsID0gX2EuZGV0YWlsO1xuICAgICAgICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICAgICAgICAgIHByb3BhZ2F0ZUxvY2FsbHkoZGV0YWlsKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBwcm9wYWdhdGVMb2NhbGx5KHVwZGF0ZVBhcnRzKSB7XG4gICAgICB2YXIgd2FzTWUgPSBwcm9wYWdhdGluZ0xvY2FsbHk7XG4gICAgICB0cnkge1xuICAgICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHRydWU7XG4gICAgICAgICAgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLmZpcmUodXBkYXRlUGFydHMpO1xuICAgICAgICAgIHNpZ25hbFN1YnNjcmliZXJzTm93KHVwZGF0ZVBhcnRzLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsbHkge1xuICAgICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHdhc01lO1xuICAgICAgfVxuICB9XG4gIHZhciBwcm9wYWdhdGluZ0xvY2FsbHkgPSBmYWxzZTtcblxuICB2YXIgYmM7XG4gIHZhciBjcmVhdGVCQyA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgaWYgKHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY3JlYXRlQkMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYmMgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUpO1xuICAgICAgICAgIGJjLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikgeyByZXR1cm4gZXYuZGF0YSAmJiBwcm9wYWdhdGVMb2NhbGx5KGV2LmRhdGEpOyB9O1xuICAgICAgfTtcbiAgICAgIGNyZWF0ZUJDKCk7XG4gICAgICBpZiAodHlwZW9mIGJjLnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYmMudW5yZWYoKTtcbiAgICAgIH1cbiAgICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgZnVuY3Rpb24gKGNoYW5nZWRQYXJ0cykge1xuICAgICAgICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICAgICAgICAgIGJjLnBvc3RNZXNzYWdlKGNoYW5nZWRQYXJ0cyk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmICghRGV4aWUkMS5kaXNhYmxlQmZDYWNoZSAmJiBldmVudC5wZXJzaXN0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnRGV4aWU6IGhhbmRsaW5nIHBlcnNpc3RlZCBwYWdlaGlkZScpO1xuICAgICAgICAgICAgICBiYyA9PT0gbnVsbCB8fCBiYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjb25uZWN0aW9uc18xID0gY29ubmVjdGlvbnM7IF9pIDwgY29ubmVjdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkYiA9IGNvbm5lY3Rpb25zXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoeyBkaXNhYmxlQXV0b09wZW46IGZhbHNlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmICghRGV4aWUkMS5kaXNhYmxlQmZDYWNoZSAmJiBldmVudC5wZXJzaXN0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnRGV4aWU6IGhhbmRsaW5nIHBlcnNpc3RlZCBwYWdlc2hvdycpO1xuICAgICAgICAgICAgICBjcmVhdGVCQygpO1xuICAgICAgICAgICAgICBwcm9wYWdhdGVMb2NhbGx5KHsgYWxsOiBuZXcgUmFuZ2VTZXQoLUluZmluaXR5LCBbW11dKSB9KTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9wTW9kaWZpY2F0aW9uKHsgYWRkOiB2YWx1ZSB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9wTW9kaWZpY2F0aW9uKHsgcmVtb3ZlOiB2YWx1ZSB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VQcmVmaXgoYSwgYikge1xuICAgICAgcmV0dXJuIG5ldyBQcm9wTW9kaWZpY2F0aW9uKHsgcmVwbGFjZVByZWZpeDogW2EsIGJdIH0pO1xuICB9XG5cbiAgRGV4aWVQcm9taXNlLnJlamVjdGlvbk1hcHBlciA9IG1hcEVycm9yO1xuICBzZXREZWJ1ZyhkZWJ1Zyk7XG5cbiAgdmFyIG5hbWVkRXhwb3J0cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgRGV4aWU6IERleGllJDEsXG4gICAgRW50aXR5OiBFbnRpdHksXG4gICAgUHJvcE1vZGlmaWNhdGlvbjogUHJvcE1vZGlmaWNhdGlvbixcbiAgICBSYW5nZVNldDogUmFuZ2VTZXQsXG4gICAgYWRkOiBhZGQsXG4gICAgY21wOiBjbXAsXG4gICAgZGVmYXVsdDogRGV4aWUkMSxcbiAgICBsaXZlUXVlcnk6IGxpdmVRdWVyeSxcbiAgICBtZXJnZVJhbmdlczogbWVyZ2VSYW5nZXMsXG4gICAgcmFuZ2VzT3ZlcmxhcDogcmFuZ2VzT3ZlcmxhcCxcbiAgICByZW1vdmU6IHJlbW92ZSxcbiAgICByZXBsYWNlUHJlZml4OiByZXBsYWNlUHJlZml4XG4gIH0pO1xuXG4gIF9fYXNzaWduKERleGllJDEsIG5hbWVkRXhwb3J0cywgeyBkZWZhdWx0OiBEZXhpZSQxIH0pO1xuXG4gIHJldHVybiBEZXhpZSQxO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXhpZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/dexie/dist/dexie.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/dexie/import-wrapper.mjs":
/*!***********************************************!*\
  !*** ./node_modules/dexie/import-wrapper.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dexie: () => (/* binding */ Dexie),\n/* harmony export */   DexieYProvider: () => (/* binding */ DexieYProvider),\n/* harmony export */   Entity: () => (/* binding */ Entity),\n/* harmony export */   PropModification: () => (/* binding */ PropModification),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   cmp: () => (/* binding */ cmp),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   liveQuery: () => (/* binding */ liveQuery),\n/* harmony export */   mergeRanges: () => (/* binding */ mergeRanges),\n/* harmony export */   rangesOverlap: () => (/* binding */ rangesOverlap),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   replacePrefix: () => (/* binding */ replacePrefix)\n/* harmony export */ });\n/* harmony import */ var _dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/dexie.js */ \"(app-pages-browser)/./node_modules/dexie/dist/dexie.js\");\n// Making the module version consumable via require - to prohibit\n// multiple occurrancies of the same module in the same app\n// (dual package hazard, https://nodejs.org/api/packages.html#dual-package-hazard)\n\nconst DexieSymbol = Symbol.for(\"Dexie\");\nconst Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__);\nif (_dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__.semVer !== Dexie.semVer) {\n    throw new Error(`Two different versions of Dexie loaded in the same app: ${_dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__.semVer} and ${Dexie.semVer}`);\n}\nconst { liveQuery, mergeRanges, rangesOverlap, RangeSet, cmp, Entity,\n    PropModification, replacePrefix, add, remove,\n    DexieYProvider } = Dexie;\n\n    \n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dexie);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZXhpZS9pbXBvcnQtd3JhcHBlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDcUM7QUFDckM7QUFDQSxvRUFBb0UsMkNBQU07QUFDMUUsSUFBSSxrREFBYTtBQUNqQiwrRUFBK0Usa0RBQWEsRUFBRSxNQUFNLGFBQWE7QUFDakg7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQkFBcUI7QUFHRDtBQUNwQjtBQUNBLGlFQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3RpbW90aHllZGliby9wcm9qZWN0cy9wZXJzb25hbC9ibHVlY291bnRzL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9kZXhpZS9pbXBvcnQtd3JhcHBlci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTWFraW5nIHRoZSBtb2R1bGUgdmVyc2lvbiBjb25zdW1hYmxlIHZpYSByZXF1aXJlIC0gdG8gcHJvaGliaXRcbi8vIG11bHRpcGxlIG9jY3VycmFuY2llcyBvZiB0aGUgc2FtZSBtb2R1bGUgaW4gdGhlIHNhbWUgYXBwXG4vLyAoZHVhbCBwYWNrYWdlIGhhemFyZCwgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYWNrYWdlcy5odG1sI2R1YWwtcGFja2FnZS1oYXphcmQpXG5pbXBvcnQgX0RleGllIGZyb20gXCIuL2Rpc3QvZGV4aWUuanNcIjtcbmNvbnN0IERleGllU3ltYm9sID0gU3ltYm9sLmZvcihcIkRleGllXCIpO1xuY29uc3QgRGV4aWUgPSBnbG9iYWxUaGlzW0RleGllU3ltYm9sXSB8fCAoZ2xvYmFsVGhpc1tEZXhpZVN5bWJvbF0gPSBfRGV4aWUpO1xuaWYgKF9EZXhpZS5zZW1WZXIgIT09IERleGllLnNlbVZlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVHdvIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBEZXhpZSBsb2FkZWQgaW4gdGhlIHNhbWUgYXBwOiAke19EZXhpZS5zZW1WZXJ9IGFuZCAke0RleGllLnNlbVZlcn1gKTtcbn1cbmNvbnN0IHsgbGl2ZVF1ZXJ5LCBtZXJnZVJhbmdlcywgcmFuZ2VzT3ZlcmxhcCwgUmFuZ2VTZXQsIGNtcCwgRW50aXR5LFxuICAgIFByb3BNb2RpZmljYXRpb24sIHJlcGxhY2VQcmVmaXgsIGFkZCwgcmVtb3ZlLFxuICAgIERleGllWVByb3ZpZGVyIH0gPSBEZXhpZTtcbmV4cG9ydCB7IGxpdmVRdWVyeSwgbWVyZ2VSYW5nZXMsIHJhbmdlc092ZXJsYXAsIFJhbmdlU2V0LCBjbXAsIERleGllLCBFbnRpdHksXG4gICAgUHJvcE1vZGlmaWNhdGlvbiwgcmVwbGFjZVByZWZpeCwgYWRkLCByZW1vdmUsXG4gICAgRGV4aWVZUHJvdmlkZXJ9O1xuICAgIFxuZXhwb3J0IGRlZmF1bHQgRGV4aWU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/dexie/import-wrapper.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Ftimothyedibo%2Fprojects%2Fpersonal%2Fbluecounts%2Ffrontend%2Fsrc%2Fapp%2F(dashboard)%2Finventory%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Ftimothyedibo%2Fprojects%2Fpersonal%2Fbluecounts%2Ffrontend%2Fsrc%2Fapp%2F(dashboard)%2Finventory%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/(dashboard)/inventory/page.tsx */ \"(app-pages-browser)/./src/app/(dashboard)/inventory/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZ0aW1vdGh5ZWRpYm8lMkZwcm9qZWN0cyUyRnBlcnNvbmFsJTJGYmx1ZWNvdW50cyUyRmZyb250ZW5kJTJGc3JjJTJGYXBwJTJGKGRhc2hib2FyZCklMkZpbnZlbnRvcnklMkZwYWdlLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDBNQUFxSSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3RpbW90aHllZGliby9wcm9qZWN0cy9wZXJzb25hbC9ibHVlY291bnRzL2Zyb250ZW5kL3NyYy9hcHAvKGRhc2hib2FyZCkvaW52ZW50b3J5L3BhZ2UudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Ftimothyedibo%2Fprojects%2Fpersonal%2Fbluecounts%2Ffrontend%2Fsrc%2Fapp%2F(dashboard)%2Finventory%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-dir/link.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/app-dir/link.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    /**\n * A React component that extends the HTML `<a>` element to provide\n * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation. This is the primary way to navigate between routes in Next.js.\n *\n * @remarks\n * - Prefetching is only enabled in production.\n *\n * @see https://nextjs.org/docs/app/api-reference/components/link\n */ default: function() {\n        return LinkComponent;\n    },\n    useLinkStatus: function() {\n        return useLinkStatus;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _formaturl = __webpack_require__(/*! ../../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _usemergedref = __webpack_require__(/*! ../use-merged-ref */ \"(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\");\nconst _utils = __webpack_require__(/*! ../../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _warnonce = __webpack_require__(/*! ../../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _links = __webpack_require__(/*! ../components/links */ \"(app-pages-browser)/./node_modules/next/dist/client/components/links.js\");\nconst _islocalurl = __webpack_require__(/*! ../../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _approuterinstance = __webpack_require__(/*! ../components/app-router-instance */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-instance.js\");\nconst _erroronce = __webpack_require__(/*! ../../shared/lib/utils/error-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/error-once.js\");\nconst _segmentcache = __webpack_require__(/*! ../components/segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute('target');\n    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === 'A';\n    if (isAnchorNodeName && isModifiedEvent(e) || e.currentTarget.hasAttribute('download')) {\n        // ignore click for browsers default behavior\n        return;\n    }\n    if (!(0, _islocalurl.isLocalURL)(href)) {\n        if (replace) {\n            // browser default behavior does not replace the history state\n            // so we need to do it manually\n            e.preventDefault();\n            location.replace(href);\n        }\n        // ignore click for browsers default behavior\n        return;\n    }\n    e.preventDefault();\n    if (onNavigate) {\n        let isDefaultPrevented = false;\n        onNavigate({\n            preventDefault: ()=>{\n                isDefaultPrevented = true;\n            }\n        });\n        if (isDefaultPrevented) {\n            return;\n        }\n    }\n    _react.default.startTransition(()=>{\n        (0, _approuterinstance.dispatchNavigateAction)(as || href, replace ? 'replace' : 'push', scroll != null ? scroll : true, linkInstanceRef.current);\n    });\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === 'string') {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\nfunction LinkComponent(props) {\n    _s();\n    const [linkStatus, setOptimisticLinkStatus] = (0, _react.useOptimistic)(_links.IDLE_LINK_STATUS);\n    let children;\n    const linkInstanceRef = (0, _react.useRef)(null);\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, onNavigate, ref: forwardedRef, unstable_dynamicOnHover, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const router = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const prefetchEnabled = prefetchProp !== false;\n    const fetchStrategy = prefetchProp !== false ? getFetchStrategyFromPrefetchProp(prefetchProp) : _segmentcache.FetchStrategy.PPR;\n    if (true) {\n        function createPropError(args) {\n            return Object.defineProperty(new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0)), \"__NEXT_ERROR_CODE\", {\n                value: \"E319\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === 'href') {\n                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: props[key] === null ? 'null' : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            unstable_dynamicOnHover: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true,\n            onNavigate: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === 'as') {\n                if (props[key] && valType !== 'string' && valType !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart' || key === 'onNavigate') {\n                if (props[key] && valType !== 'function') {\n                    throw createPropError({\n                        key,\n                        expected: '`function`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'legacyBehavior' || key === 'unstable_dynamicOnHover') {\n                if (props[key] != null && valType !== 'boolean') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'prefetch') {\n                if (props[key] != null && valType !== 'boolean' && props[key] !== 'auto' && props[key] !== 'unstable_forceStale') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean | \"auto\" | \"unstable_forceStale\"`',\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n    }\n    if (true) {\n        if (props.locale) {\n            (0, _warnonce.warnOnce)('The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization');\n        }\n        if (!asProp) {\n            let href;\n            if (typeof hrefProp === 'string') {\n                href = hrefProp;\n            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));\n                if (hasDynamicSegment) {\n                    throw Object.defineProperty(new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\"), \"__NEXT_ERROR_CODE\", {\n                        value: \"E267\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo({\n        \"LinkComponent.useMemo\": ()=>{\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n    }[\"LinkComponent.useMemo\"], [\n        hrefProp,\n        asProp\n    ]);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw Object.defineProperty(new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\"), \"__NEXT_ERROR_CODE\", {\n                        value: \"E320\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                throw Object.defineProperty(new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0)), \"__NEXT_ERROR_CODE\", {\n                    value: \"E266\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === 'a') {\n                throw Object.defineProperty(new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E209\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;\n    // Use a callback ref to attach an IntersectionObserver to the anchor tag on\n    // mount. In the future we will also use this to keep track of all the\n    // currently mounted <Link> instances, e.g. so we can re-prefetch them after\n    // a revalidation or refresh.\n    const observeLinkVisibilityOnMount = _react.default.useCallback({\n        \"LinkComponent.useCallback[observeLinkVisibilityOnMount]\": (element)=>{\n            if (router !== null) {\n                linkInstanceRef.current = (0, _links.mountLinkInstance)(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus);\n            }\n            return ({\n                \"LinkComponent.useCallback[observeLinkVisibilityOnMount]\": ()=>{\n                    if (linkInstanceRef.current) {\n                        (0, _links.unmountLinkForCurrentNavigation)(linkInstanceRef.current);\n                        linkInstanceRef.current = null;\n                    }\n                    (0, _links.unmountPrefetchableInstance)(element);\n                }\n            })[\"LinkComponent.useCallback[observeLinkVisibilityOnMount]\"];\n        }\n    }[\"LinkComponent.useCallback[observeLinkVisibilityOnMount]\"], [\n        prefetchEnabled,\n        href,\n        router,\n        fetchStrategy,\n        setOptimisticLinkStatus\n    ]);\n    const mergedRef = (0, _usemergedref.useMergedRef)(observeLinkVisibilityOnMount, childRef);\n    const childProps = {\n        ref: mergedRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw Object.defineProperty(new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E312\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            if (!legacyBehavior && typeof onClick === 'function') {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled || \"development\" === 'development') {\n                return;\n            }\n            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;\n            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);\n        },\n        onTouchStart:  false ? 0 : function onTouchStart(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled) {\n                return;\n            }\n            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;\n            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the basePath.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {\n        childProps.href = (0, _addbasepath.addBasePath)(as);\n    }\n    let link;\n    if (legacyBehavior) {\n        if (true) {\n            (0, _erroronce.errorOnce)('`legacyBehavior` is deprecated and will be removed in a future ' + 'release. A codemod is available to upgrade your components:\\n\\n' + 'npx @next/codemod@latest new-link .\\n\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components');\n        }\n        link = /*#__PURE__*/ _react.default.cloneElement(child, childProps);\n    } else {\n        link = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            ...restProps,\n            ...childProps,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(LinkStatusContext.Provider, {\n        value: linkStatus,\n        children: link\n    });\n}\n_s(LinkComponent, \"MNV6IdWv8Lu3MKc7Fm4v59uGRY0=\");\n_c = LinkComponent;\nconst LinkStatusContext = /*#__PURE__*/ (0, _react.createContext)(_links.IDLE_LINK_STATUS);\nconst useLinkStatus = ()=>{\n    return (0, _react.useContext)(LinkStatusContext);\n};\nfunction getFetchStrategyFromPrefetchProp(prefetchProp) {\n    if (false) {} else {\n        return prefetchProp === null || prefetchProp === 'auto' ? _segmentcache.FetchStrategy.PPR : // (although invalid values should've been filtered out by prop validation in dev)\n        _segmentcache.FetchStrategy.Full;\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c;\n$RefreshReg$(_c, \"LinkComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1kaXIvbGluay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQW9UQTs7Ozs7Ozs7O0NBU0MsR0FDRCxPQWthQztlQWxhdUJBOztJQXdhWEMsYUFBYTtlQUFiQTs7Ozs7NkVBcHVCMkQ7dUNBRTlDOzJEQUNPOzBDQUNKO21DQUNDO3lDQUNGO3NDQUNIO21DQVNsQjt3Q0FDb0I7K0NBQ1k7dUNBQ2I7MENBSW5CO0FBME1QLFNBQVNDLGdCQUFnQkMsS0FBdUI7SUFDOUMsTUFBTUMsY0FBY0QsTUFBTUUsYUFBYTtJQUN2QyxNQUFNQyxTQUFTRixZQUFZRyxZQUFZLENBQUM7SUFDeEMsT0FDR0QsVUFBVUEsV0FBVyxXQUN0QkgsTUFBTUssT0FBTyxJQUNiTCxNQUFNTSxPQUFPLElBQ2JOLE1BQU1PLFFBQVEsSUFDZFAsTUFBTVEsTUFBTSxJQUFJLDZCQUE2QjtJQUM1Q1IsTUFBTVMsV0FBVyxJQUFJVCxNQUFNUyxXQUFXLENBQUNDLEtBQUssS0FBSztBQUV0RDtBQUVBLFNBQVNDLFlBQ1BDLENBQW1CLEVBQ25CQyxJQUFZLEVBQ1pDLEVBQVUsRUFDVkMsZUFBcUQsRUFDckRDLE9BQWlCLEVBQ2pCQyxNQUFnQixFQUNoQkMsVUFBbUM7SUFFbkMsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR1AsRUFBRVYsYUFBYTtJQUVwQyxrREFBa0Q7SUFDbEQsTUFBTWtCLG1CQUFtQkQsU0FBU0UsV0FBVyxPQUFPO0lBRXBELElBQ0dELG9CQUFvQnJCLGdCQUFnQmEsTUFDckNBLEVBQUVWLGFBQWEsQ0FBQ29CLFlBQVksQ0FBQyxhQUM3QjtRQUNBLDhDQUE4QztRQUM5QztJQUNGO0lBRUEsSUFBSSxDQUFDQyxDQUFBQSxHQUFBQSxZQUFBQSxVQUFBQSxFQUFXVixPQUFPO1FBQ3JCLElBQUlHLFNBQVM7WUFDWCw4REFBOEQ7WUFDOUQsK0JBQStCO1lBQy9CSixFQUFFWSxjQUFj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QztJQUNwQixPQUFPLElBQ0wsQ0FBQ3VDLGtCQUNEUCxZQUNDbUQsTUFBTU0sSUFBSSxLQUFLLE9BQU8sQ0FBRSxXQUFVTixNQUFNL0QsS0FBQUEsR0FDekM7UUFDQStFLFdBQVdwRyxJQUFJLEdBQUcyRyxDQUFBQSxHQUFBQSxhQUFBQSxXQUFXLEVBQUMxRztJQUNoQztJQUVBLElBQUkyRztJQUVKLElBQUlwRSxnQkFBZ0I7UUFDbEIsSUFBSWMsSUFBb0IsRUFBb0I7WUFDMUN1RCxDQUFBQSxHQUFBQSxXQUFBQSxTQUFBQSxFQUNFLG9FQUNFLG9FQUNBLDRDQUNBO1FBRU47UUFDQUQsT0FBQUEsV0FBQUEsR0FBTzlGLE9BQUFBLE9BQUssQ0FBQ2dHLFlBQVksQ0FBQzFCLE9BQU9nQjtJQUNuQyxPQUFPO1FBQ0xRLE9BQUFBLFdBQUFBLEdBQ0UscUJBQUMvRCxLQUFBQTtZQUFHLEdBQUdELFNBQVM7WUFBRyxHQUFHd0QsVUFBVTtzQkFDN0IxRTs7SUFHUDtJQUVBLHFCQUNFLHFCQUFDcUYsa0JBQWtCQyxRQUFRO1FBQUNDLE9BQU8zRjtrQkFDaENzRjs7QUFHUDs7S0FsYXdCNUg7QUFvYXhCLE1BQU0rSCxvQkFBQUEsV0FBQUEsR0FBb0JHLENBQUFBLEdBQUFBLE9BQUFBLGFBQUFBLEVBRXhCekYsT0FBQUEsZ0JBQWdCO0FBRVgsTUFBTXhDLGdCQUFnQjtJQUMzQixPQUFPOEQsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV2dFO0FBQ3BCO0FBRUEsU0FBUzVELGlDQUNQbkIsWUFBK0Q7SUFFL0QsSUFDRXNCLEtBQ3VDLEVBQ3ZDLEVBb0JELE1BQU07UUFDTCxPQUFPdEIsaUJBQWlCLFFBQVFBLGlCQUFpQixTQUU3QyxjQUNBb0IsYUFBYSxDQUFDQyxHQUFHLEdBRWpCLDREQUg4RixzQkFJWjtRQUNsRkQsY0FBQUEsYUFBYSxDQUFDa0UsSUFBSTtJQUN4QjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdGltb3RoeWVkaWJvL3Byb2plY3RzL3NyYy9jbGllbnQvYXBwLWRpci9saW5rLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU9wdGltaXN0aWMsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgeyBmb3JtYXRVcmwgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJ1xuaW1wb3J0IHsgQXBwUm91dGVyQ29udGV4dCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgdXNlTWVyZ2VkUmVmIH0gZnJvbSAnLi4vdXNlLW1lcmdlZC1yZWYnXG5pbXBvcnQgeyBpc0Fic29sdXRlVXJsIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi91dGlscydcbmltcG9ydCB7IGFkZEJhc2VQYXRoIH0gZnJvbSAnLi4vYWRkLWJhc2UtcGF0aCdcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi91dGlscy93YXJuLW9uY2UnXG5pbXBvcnQgdHlwZSB7IFBFTkRJTkdfTElOS19TVEFUVVMgfSBmcm9tICcuLi9jb21wb25lbnRzL2xpbmtzJ1xuaW1wb3J0IHtcbiAgSURMRV9MSU5LX1NUQVRVUyxcbiAgbW91bnRMaW5rSW5zdGFuY2UsXG4gIG9uTmF2aWdhdGlvbkludGVudCxcbiAgdW5tb3VudExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbixcbiAgdW5tb3VudFByZWZldGNoYWJsZUluc3RhbmNlLFxuICB0eXBlIExpbmtJbnN0YW5jZSxcbn0gZnJvbSAnLi4vY29tcG9uZW50cy9saW5rcydcbmltcG9ydCB7IGlzTG9jYWxVUkwgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1sb2NhbC11cmwnXG5pbXBvcnQgeyBkaXNwYXRjaE5hdmlnYXRlQWN0aW9uIH0gZnJvbSAnLi4vY29tcG9uZW50cy9hcHAtcm91dGVyLWluc3RhbmNlJ1xuaW1wb3J0IHsgZXJyb3JPbmNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi91dGlscy9lcnJvci1vbmNlJ1xuaW1wb3J0IHtcbiAgRmV0Y2hTdHJhdGVneSxcbiAgdHlwZSBQcmVmZXRjaFRhc2tGZXRjaFN0cmF0ZWd5LFxufSBmcm9tICcuLi9jb21wb25lbnRzL3NlZ21lbnQtY2FjaGUnXG5cbnR5cGUgVXJsID0gc3RyaW5nIHwgVXJsT2JqZWN0XG50eXBlIFJlcXVpcmVkS2V5czxUPiA9IHtcbiAgW0sgaW4ga2V5b2YgVF0tPzoge30gZXh0ZW5kcyBQaWNrPFQsIEs+ID8gbmV2ZXIgOiBLXG59W2tleW9mIFRdXG50eXBlIE9wdGlvbmFsS2V5czxUPiA9IHtcbiAgW0sgaW4ga2V5b2YgVF0tPzoge30gZXh0ZW5kcyBQaWNrPFQsIEs+ID8gSyA6IG5ldmVyXG59W2tleW9mIFRdXG5cbnR5cGUgT25OYXZpZ2F0ZUV2ZW50SGFuZGxlciA9IChldmVudDogeyBwcmV2ZW50RGVmYXVsdDogKCkgPT4gdm9pZCB9KSA9PiB2b2lkXG5cbnR5cGUgSW50ZXJuYWxMaW5rUHJvcHMgPSB7XG4gIC8qKlxuICAgKiAqKlJlcXVpcmVkKiouIFRoZSBwYXRoIG9yIFVSTCB0byBuYXZpZ2F0ZSB0by4gSXQgY2FuIGFsc28gYmUgYW4gb2JqZWN0IChzaW1pbGFyIHRvIGBVUkxgKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIC8vIE5hdmlnYXRlIHRvIC9kYXNoYm9hcmQ6XG4gICAqIDxMaW5rIGhyZWY9XCIvZGFzaGJvYXJkXCI+RGFzaGJvYXJkPC9MaW5rPlxuICAgKlxuICAgKiAvLyBOYXZpZ2F0ZSB0byAvYWJvdXQ/bmFtZT10ZXN0OlxuICAgKiA8TGluayBocmVmPXt7IHBhdGhuYW1lOiAnL2Fib3V0JywgcXVlcnk6IHsgbmFtZTogJ3Rlc3QnIH0gfX0+XG4gICAqICAgQWJvdXRcbiAgICogPC9MaW5rPlxuICAgKiBgYGBcbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogLSBGb3IgZXh0ZXJuYWwgVVJMcywgdXNlIGEgZnVsbHkgcXVhbGlmaWVkIFVSTCBzdWNoIGFzIGBodHRwczovLy4uLmAuXG4gICAqIC0gSW4gdGhlIEFwcCBSb3V0ZXIsIGR5bmFtaWMgcm91dGVzIG11c3Qgbm90IGluY2x1ZGUgYnJhY2tldGVkIHNlZ21lbnRzIGluIGBocmVmYC5cbiAgICovXG4gIGhyZWY6IFVybFxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB2MTAuMC4wOiBgaHJlZmAgcHJvcHMgcG9pbnRpbmcgdG8gYSBkeW5hbWljIHJvdXRlIGFyZVxuICAgKiBhdXRvbWF0aWNhbGx5IHJlc29sdmVkIGFuZCBubyBsb25nZXIgcmVxdWlyZSB0aGUgYGFzYCBwcm9wLlxuICAgKi9cbiAgYXM/OiBVcmxcblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgY3VycmVudCBgaGlzdG9yeWAgc3RhdGUgaW5zdGVhZCBvZiBhZGRpbmcgYSBuZXcgVVJMIGludG8gdGhlIHN0YWNrLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIDxMaW5rIGhyZWY9XCIvYWJvdXRcIiByZXBsYWNlPlxuICAgKiAgIEFib3V0IChyZXBsYWNlcyB0aGUgaGlzdG9yeSBzdGF0ZSlcbiAgICogPC9MaW5rPlxuICAgKiBgYGBcbiAgICovXG4gIHJlcGxhY2U/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2Nyb2xsIGJlaGF2aW9yLiBJZiBgdHJ1ZWAsIE5leHQuanMgYXR0ZW1wdHMgdG8gbWFpbnRhaW5cbiAgICogdGhlIHNjcm9sbCBwb3NpdGlvbiBpZiB0aGUgbmV3bHkgbmF2aWdhdGVkIHBhZ2UgaXMgc3RpbGwgdmlzaWJsZS4gSWYgbm90LCBpdCBzY3JvbGxzIHRvIHRoZSB0b3AuXG4gICAqXG4gICAqIElmIGBmYWxzZWAsIE5leHQuanMgd2lsbCBub3QgbW9kaWZ5IHRoZSBzY3JvbGwgYmVoYXZpb3IgYXQgYWxsLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogPExpbmsgaHJlZj1cIi9kYXNoYm9hcmRcIiBzY3JvbGw9e2ZhbHNlfT5cbiAgICogICBObyBhdXRvIHNjcm9sbFxuICAgKiA8L0xpbms+XG4gICAqIGBgYFxuICAgKi9cbiAgc2Nyb2xsPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBhdGggb2YgdGhlIGN1cnJlbnQgcGFnZSB3aXRob3V0IHJlcnVubmluZyBkYXRhIGZldGNoaW5nIG1ldGhvZHNcbiAgICogbGlrZSBgZ2V0U3RhdGljUHJvcHNgLCBgZ2V0U2VydmVyU2lkZVByb3BzYCwgb3IgYGdldEluaXRpYWxQcm9wc2AuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIGBzaGFsbG93YCBvbmx5IGFwcGxpZXMgdG8gdGhlIFBhZ2VzIFJvdXRlci4gRm9yIHRoZSBBcHAgUm91dGVyLCBzZWUgdGhlXG4gICAqIFtmb2xsb3dpbmcgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9saW5raW5nLWFuZC1uYXZpZ2F0aW5nI3VzaW5nLXRoZS1uYXRpdmUtaGlzdG9yeS1hcGkpLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIDxMaW5rIGhyZWY9XCIvYmxvZ1wiIHNoYWxsb3c+XG4gICAqICAgU2hhbGxvdyBuYXZpZ2F0aW9uXG4gICAqIDwvTGluaz5cbiAgICogYGBgXG4gICAqL1xuICBzaGFsbG93PzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYExpbmtgIHRvIHBhc3MgaXRzIGBocmVmYCB0byB0aGUgY2hpbGQgY29tcG9uZW50LiBVc2VmdWwgaWYgdGhlIGNoaWxkIGlzIGEgY3VzdG9tXG4gICAqIGNvbXBvbmVudCB0aGF0IHdyYXBzIGFuIGA8YT5gIHRhZywgb3IgaWYgeW91J3JlIHVzaW5nIGNlcnRhaW4gc3R5bGluZyBsaWJyYXJpZXMuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogPExpbmsgaHJlZj1cIi9kYXNoYm9hcmRcIiBwYXNzSHJlZj5cbiAgICogICA8TXlTdHlsZWRBbmNob3I+RGFzaGJvYXJkPC9NeVN0eWxlZEFuY2hvcj5cbiAgICogPC9MaW5rPlxuICAgKiBgYGBcbiAgICovXG4gIHBhc3NIcmVmPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBQcmVmZXRjaCB0aGUgcGFnZSBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICogQW55IGA8TGluayAvPmAgdGhhdCBpcyBpbiB0aGUgdmlld3BvcnQgKGluaXRpYWxseSBvciB0aHJvdWdoIHNjcm9sbCkgd2lsbCBiZSBwcmVmZXRjaGVkLlxuICAgKiBQcmVmZXRjaCBjYW4gYmUgZGlzYWJsZWQgYnkgcGFzc2luZyBgcHJlZmV0Y2g9e2ZhbHNlfWAuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFByZWZldGNoaW5nIGlzIG9ubHkgZW5hYmxlZCBpbiBwcm9kdWN0aW9uLlxuICAgKlxuICAgKiAtIEluIHRoZSAqKkFwcCBSb3V0ZXIqKjpcbiAgICogICAtIGBcImF1dG9cImAsIGBudWxsYCwgYHVuZGVmaW5lZGAgKGRlZmF1bHQpOiBQcmVmZXRjaCBiZWhhdmlvciBkZXBlbmRzIG9uIHN0YXRpYyB2cyBkeW5hbWljIHJvdXRlczpcbiAgICogICAgIC0gU3RhdGljIHJvdXRlczogZnVsbHkgcHJlZmV0Y2hlZFxuICAgKiAgICAgLSBEeW5hbWljIHJvdXRlczogcGFydGlhbCBwcmVmZXRjaCB0byB0aGUgbmVhcmVzdCBzZWdtZW50IHdpdGggYSBgbG9hZGluZy5qc2BcbiAgICogICAtIGB0cnVlYDogQWx3YXlzIHByZWZldGNoIHRoZSBmdWxsIHJvdXRlIGFuZCBkYXRhLlxuICAgKiAgIC0gYGZhbHNlYDogRGlzYWJsZSBwcmVmZXRjaGluZyBvbiBib3RoIHZpZXdwb3J0IGFuZCBob3Zlci5cbiAgICogLSBJbiB0aGUgKipQYWdlcyBSb3V0ZXIqKjpcbiAgICogICAtIGB0cnVlYCAoZGVmYXVsdCk6IFByZWZldGNoZXMgdGhlIHJvdXRlIGFuZCBkYXRhIGluIHRoZSBiYWNrZ3JvdW5kIG9uIHZpZXdwb3J0IG9yIGhvdmVyLlxuICAgKiAgIC0gYGZhbHNlYDogUHJlZmV0Y2ggb25seSBvbiBob3Zlciwgbm90IG9uIHZpZXdwb3J0LlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYCAoUGFnZXMgUm91dGVyKSBvciBgbnVsbGAgKEFwcCBSb3V0ZXIpXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiA8TGluayBocmVmPVwiL2Rhc2hib2FyZFwiIHByZWZldGNoPXtmYWxzZX0+XG4gICAqICAgRGFzaGJvYXJkXG4gICAqIDwvTGluaz5cbiAgICogYGBgXG4gICAqL1xuICBwcmVmZXRjaD86IGJvb2xlYW4gfCAnYXV0bycgfCBudWxsIHwgJ3Vuc3RhYmxlX2ZvcmNlU3RhbGUnXG5cbiAgLyoqXG4gICAqICh1bnN0YWJsZSkgU3dpdGNoIHRvIGEgZnVsbCBwcmVmZXRjaCBvbiBob3Zlci4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXNcbiAgICogdXBkYXRpbmcgdGhlIHByZWZldGNoIHByb3AgdG8gYHRydWVgIGluIGEgbW91c2UgZXZlbnQuXG4gICAqL1xuICB1bnN0YWJsZV9keW5hbWljT25Ib3Zlcj86IGJvb2xlYW5cblxuICAvKipcbiAgICogVGhlIGFjdGl2ZSBsb2NhbGUgaXMgYXV0b21hdGljYWxseSBwcmVwZW5kZWQgaW4gdGhlIFBhZ2VzIFJvdXRlci4gYGxvY2FsZWAgYWxsb3dzIGZvciBwcm92aWRpbmdcbiAgICogYSBkaWZmZXJlbnQgbG9jYWxlLCBvciBjYW4gYmUgc2V0IHRvIGBmYWxzZWAgdG8gb3B0IG91dCBvZiBhdXRvbWF0aWMgbG9jYWxlIGJlaGF2aW9yLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBOb3RlOiBsb2NhbGUgb25seSBhcHBsaWVzIGluIHRoZSBQYWdlcyBSb3V0ZXIgYW5kIGlzIGlnbm9yZWQgaW4gdGhlIEFwcCBSb3V0ZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiAvLyBVc2UgdGhlICdmcicgbG9jYWxlOlxuICAgKiA8TGluayBocmVmPVwiL2Fib3V0XCIgbG9jYWxlPVwiZnJcIj5cbiAgICogICBBYm91dCAoRnJlbmNoKVxuICAgKiA8L0xpbms+XG4gICAqXG4gICAqIC8vIERpc2FibGUgbG9jYWxlIHByZWZpeDpcbiAgICogPExpbmsgaHJlZj1cIi9hYm91dFwiIGxvY2FsZT17ZmFsc2V9PlxuICAgKiAgIEFib3V0IChubyBsb2NhbGUgcHJlZml4KVxuICAgKiA8L0xpbms+XG4gICAqIGBgYFxuICAgKi9cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2VcblxuICAvKipcbiAgICogRW5hYmxlIGxlZ2FjeSBsaW5rIGJlaGF2aW9yLCByZXF1aXJpbmcgYW4gYDxhPmAgdGFnIHRvIHdyYXAgdGhlIGNoaWxkIGNvbnRlbnRcbiAgICogaWYgdGhlIGNoaWxkIGlzIGEgc3RyaW5nIG9yIG51bWJlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdjE2XG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9jb21taXQvNDg5ZTY1ZWQ5ODU0NGU2OWIwYWZkN2UwY2ZjM2Y5ZjZjMmI4MDNiN1xuICAgKi9cbiAgbGVnYWN5QmVoYXZpb3I/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gdGhlIG1vdXNlIHBvaW50ZXIgaXMgbW92ZWQgb250byB0aGUgYDxMaW5rPmAuXG4gICAqL1xuICBvbk1vdXNlRW50ZXI/OiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cblxuICAvKipcbiAgICogT3B0aW9uYWwgZXZlbnQgaGFuZGxlciBmb3Igd2hlbiB0aGUgYDxMaW5rPmAgaXMgdG91Y2hlZC5cbiAgICovXG4gIG9uVG91Y2hTdGFydD86IFJlYWN0LlRvdWNoRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBldmVudCBoYW5kbGVyIGZvciB3aGVuIHRoZSBgPExpbms+YCBpcyBjbGlja2VkLlxuICAgKi9cbiAgb25DbGljaz86IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBldmVudCBoYW5kbGVyIGZvciB3aGVuIHRoZSBgPExpbms+YCBpcyBuYXZpZ2F0ZWQuXG4gICAqL1xuICBvbk5hdmlnYXRlPzogT25OYXZpZ2F0ZUV2ZW50SGFuZGxlclxufVxuXG4vLyBUT0RPLUFQUDogSW5jbHVkZSB0aGUgZnVsbCBzZXQgb2YgQW5jaG9yIHByb3BzXG4vLyBhZGRpbmcgdGhpcyB0byB0aGUgcHVibGljbHkgZXhwb3J0ZWQgdHlwZSBjdXJyZW50bHkgYnJlYWtzIGV4aXN0aW5nIGFwcHNcblxuLy8gYFJvdXRlSW5mZXJUeXBlYCBpcyBhIHN0dWIgaGVyZSB0byBhdm9pZCBicmVha2luZyBgdHlwZWRSb3V0ZXNgIHdoZW4gdGhlIHR5cGVcbi8vIGlzbid0IGdlbmVyYXRlZCB5ZXQuIEl0IHdpbGwgYmUgcmVwbGFjZWQgd2hlbiB0eXBlIGdlbmVyYXRpb24gcnVucy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmV4cG9ydCB0eXBlIExpbmtQcm9wczxSb3V0ZUluZmVyVHlwZSA9IGFueT4gPSBJbnRlcm5hbExpbmtQcm9wc1xudHlwZSBMaW5rUHJvcHNSZXF1aXJlZCA9IFJlcXVpcmVkS2V5czxMaW5rUHJvcHM+XG50eXBlIExpbmtQcm9wc09wdGlvbmFsID0gT3B0aW9uYWxLZXlzPE9taXQ8SW50ZXJuYWxMaW5rUHJvcHMsICdsb2NhbGUnPj5cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50KTogYm9vbGVhbiB7XG4gIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0JylcbiAgcmV0dXJuIChcbiAgICAodGFyZ2V0ICYmIHRhcmdldCAhPT0gJ19zZWxmJykgfHxcbiAgICBldmVudC5tZXRhS2V5IHx8XG4gICAgZXZlbnQuY3RybEtleSB8fFxuICAgIGV2ZW50LnNoaWZ0S2V5IHx8XG4gICAgZXZlbnQuYWx0S2V5IHx8IC8vIHRyaWdnZXJzIHJlc291cmNlIGRvd25sb2FkXG4gICAgKGV2ZW50Lm5hdGl2ZUV2ZW50ICYmIGV2ZW50Lm5hdGl2ZUV2ZW50LndoaWNoID09PSAyKVxuICApXG59XG5cbmZ1bmN0aW9uIGxpbmtDbGlja2VkKFxuICBlOiBSZWFjdC5Nb3VzZUV2ZW50LFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIGxpbmtJbnN0YW5jZVJlZjogUmVhY3QuUmVmT2JqZWN0PExpbmtJbnN0YW5jZSB8IG51bGw+LFxuICByZXBsYWNlPzogYm9vbGVhbixcbiAgc2Nyb2xsPzogYm9vbGVhbixcbiAgb25OYXZpZ2F0ZT86IE9uTmF2aWdhdGVFdmVudEhhbmRsZXJcbik6IHZvaWQge1xuICBjb25zdCB7IG5vZGVOYW1lIH0gPSBlLmN1cnJlbnRUYXJnZXRcblxuICAvLyBhbmNob3JzIGluc2lkZSBhbiBzdmcgaGF2ZSBhIGxvd2VyY2FzZSBub2RlTmFtZVxuICBjb25zdCBpc0FuY2hvck5vZGVOYW1lID0gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0EnXG5cbiAgaWYgKFxuICAgIChpc0FuY2hvck5vZGVOYW1lICYmIGlzTW9kaWZpZWRFdmVudChlKSkgfHxcbiAgICBlLmN1cnJlbnRUYXJnZXQuaGFzQXR0cmlidXRlKCdkb3dubG9hZCcpXG4gICkge1xuICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKCFpc0xvY2FsVVJMKGhyZWYpKSB7XG4gICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgIC8vIGJyb3dzZXIgZGVmYXVsdCBiZWhhdmlvciBkb2VzIG5vdCByZXBsYWNlIHRoZSBoaXN0b3J5IHN0YXRlXG4gICAgICAvLyBzbyB3ZSBuZWVkIHRvIGRvIGl0IG1hbnVhbGx5XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGxvY2F0aW9uLnJlcGxhY2UoaHJlZilcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICByZXR1cm5cbiAgfVxuXG4gIGUucHJldmVudERlZmF1bHQoKVxuXG4gIGlmIChvbk5hdmlnYXRlKSB7XG4gICAgbGV0IGlzRGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlXG5cbiAgICBvbk5hdmlnYXRlKHtcbiAgICAgIHByZXZlbnREZWZhdWx0OiAoKSA9PiB7XG4gICAgICAgIGlzRGVmYXVsdFByZXZlbnRlZCA9IHRydWVcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIGlmIChpc0RlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgZGlzcGF0Y2hOYXZpZ2F0ZUFjdGlvbihcbiAgICAgIGFzIHx8IGhyZWYsXG4gICAgICByZXBsYWNlID8gJ3JlcGxhY2UnIDogJ3B1c2gnLFxuICAgICAgc2Nyb2xsID8/IHRydWUsXG4gICAgICBsaW5rSW5zdGFuY2VSZWYuY3VycmVudFxuICAgIClcbiAgfSlcbn1cblxuZnVuY3Rpb24gZm9ybWF0U3RyaW5nT3JVcmwodXJsT2JqT3JTdHJpbmc6IFVybE9iamVjdCB8IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgdXJsT2JqT3JTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHVybE9iak9yU3RyaW5nXG4gIH1cblxuICByZXR1cm4gZm9ybWF0VXJsKHVybE9iak9yU3RyaW5nKVxufVxuXG4vKipcbiAqIEEgUmVhY3QgY29tcG9uZW50IHRoYXQgZXh0ZW5kcyB0aGUgSFRNTCBgPGE+YCBlbGVtZW50IHRvIHByb3ZpZGVcbiAqIFtwcmVmZXRjaGluZ10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9saW5raW5nLWFuZC1uYXZpZ2F0aW5nIzItcHJlZmV0Y2hpbmcpXG4gKiBhbmQgY2xpZW50LXNpZGUgbmF2aWdhdGlvbi4gVGhpcyBpcyB0aGUgcHJpbWFyeSB3YXkgdG8gbmF2aWdhdGUgYmV0d2VlbiByb3V0ZXMgaW4gTmV4dC5qcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogLSBQcmVmZXRjaGluZyBpcyBvbmx5IGVuYWJsZWQgaW4gcHJvZHVjdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvbGlua1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMaW5rQ29tcG9uZW50KFxuICBwcm9wczogTGlua1Byb3BzICYge1xuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbiAgICByZWY6IFJlYWN0LlJlZjxIVE1MQW5jaG9yRWxlbWVudD5cbiAgfVxuKSB7XG4gIGNvbnN0IFtsaW5rU3RhdHVzLCBzZXRPcHRpbWlzdGljTGlua1N0YXR1c10gPSB1c2VPcHRpbWlzdGljKElETEVfTElOS19TVEFUVVMpXG5cbiAgbGV0IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcblxuICBjb25zdCBsaW5rSW5zdGFuY2VSZWYgPSB1c2VSZWY8TGlua0luc3RhbmNlIHwgbnVsbD4obnVsbClcblxuICBjb25zdCB7XG4gICAgaHJlZjogaHJlZlByb3AsXG4gICAgYXM6IGFzUHJvcCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5Qcm9wLFxuICAgIHByZWZldGNoOiBwcmVmZXRjaFByb3AgPSBudWxsLFxuICAgIHBhc3NIcmVmLFxuICAgIHJlcGxhY2UsXG4gICAgc2hhbGxvdyxcbiAgICBzY3JvbGwsXG4gICAgb25DbGljayxcbiAgICBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlclByb3AsXG4gICAgb25Ub3VjaFN0YXJ0OiBvblRvdWNoU3RhcnRQcm9wLFxuICAgIGxlZ2FjeUJlaGF2aW9yID0gZmFsc2UsXG4gICAgb25OYXZpZ2F0ZSxcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICB1bnN0YWJsZV9keW5hbWljT25Ib3ZlcixcbiAgICAuLi5yZXN0UHJvcHNcbiAgfSA9IHByb3BzXG5cbiAgY2hpbGRyZW4gPSBjaGlsZHJlblByb3BcblxuICBpZiAoXG4gICAgbGVnYWN5QmVoYXZpb3IgJiZcbiAgICAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGRyZW4gPT09ICdudW1iZXInKVxuICApIHtcbiAgICBjaGlsZHJlbiA9IDxhPntjaGlsZHJlbn08L2E+XG4gIH1cblxuICBjb25zdCByb3V0ZXIgPSBSZWFjdC51c2VDb250ZXh0KEFwcFJvdXRlckNvbnRleHQpXG5cbiAgY29uc3QgcHJlZmV0Y2hFbmFibGVkID0gcHJlZmV0Y2hQcm9wICE9PSBmYWxzZVxuXG4gIGNvbnN0IGZldGNoU3RyYXRlZ3kgPVxuICAgIHByZWZldGNoUHJvcCAhPT0gZmFsc2VcbiAgICAgID8gZ2V0RmV0Y2hTdHJhdGVneUZyb21QcmVmZXRjaFByb3AocHJlZmV0Y2hQcm9wKVxuICAgICAgOiAvLyBUT0RPOiBpdCBtYWtlcyBubyBzZW5zZSB0byBhc3NpZ24gYSBmZXRjaFN0cmF0ZWd5IHdoZW4gcHJlZmV0Y2hpbmcgaXMgZGlzYWJsZWQuXG4gICAgICAgIEZldGNoU3RyYXRlZ3kuUFBSXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9wRXJyb3IoYXJnczoge1xuICAgICAga2V5OiBzdHJpbmdcbiAgICAgIGV4cGVjdGVkOiBzdHJpbmdcbiAgICAgIGFjdHVhbDogc3RyaW5nXG4gICAgfSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgK1xuICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCJcbiAgICAgICAgICAgIDogJycpXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNSZXF1aXJlZCwgdHJ1ZT4gPSB7XG4gICAgICBocmVmOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCByZXF1aXJlZFByb3BzOiBMaW5rUHJvcHNSZXF1aXJlZFtdID0gT2JqZWN0LmtleXMoXG4gICAgICByZXF1aXJlZFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc1JlcXVpcmVkW11cbiAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzUmVxdWlyZWQpID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcHNba2V5XSA9PSBudWxsIHx8XG4gICAgICAgICAgKHR5cGVvZiBwcm9wc1trZXldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ29iamVjdCcpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNPcHRpb25hbCwgdHJ1ZT4gPSB7XG4gICAgICBhczogdHJ1ZSxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBzY3JvbGw6IHRydWUsXG4gICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgIHVuc3RhYmxlX2R5bmFtaWNPbkhvdmVyOiB0cnVlLFxuICAgICAgb25DbGljazogdHJ1ZSxcbiAgICAgIG9uTW91c2VFbnRlcjogdHJ1ZSxcbiAgICAgIG9uVG91Y2hTdGFydDogdHJ1ZSxcbiAgICAgIGxlZ2FjeUJlaGF2aW9yOiB0cnVlLFxuICAgICAgb25OYXZpZ2F0ZTogdHJ1ZSxcbiAgICB9IGFzIGNvbnN0XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wczogTGlua1Byb3BzT3B0aW9uYWxbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgb3B0aW9uYWxQcm9wc0d1YXJkXG4gICAgKSBhcyBMaW5rUHJvcHNPcHRpb25hbFtdXG4gICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc09wdGlvbmFsKSA9PiB7XG4gICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV1cblxuICAgICAgaWYgKGtleSA9PT0gJ2FzJykge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBrZXkgPT09ICdvbkNsaWNrJyB8fFxuICAgICAgICBrZXkgPT09ICdvbk1vdXNlRW50ZXInIHx8XG4gICAgICAgIGtleSA9PT0gJ29uVG91Y2hTdGFydCcgfHxcbiAgICAgICAga2V5ID09PSAnb25OYXZpZ2F0ZSdcbiAgICAgICkge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYGZ1bmN0aW9uYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAga2V5ID09PSAncmVwbGFjZScgfHxcbiAgICAgICAga2V5ID09PSAnc2Nyb2xsJyB8fFxuICAgICAgICBrZXkgPT09ICdzaGFsbG93JyB8fFxuICAgICAgICBrZXkgPT09ICdwYXNzSHJlZicgfHxcbiAgICAgICAga2V5ID09PSAnbGVnYWN5QmVoYXZpb3InIHx8XG4gICAgICAgIGtleSA9PT0gJ3Vuc3RhYmxlX2R5bmFtaWNPbkhvdmVyJ1xuICAgICAgKSB7XG4gICAgICAgIGlmIChwcm9wc1trZXldICE9IG51bGwgJiYgdmFsVHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYGJvb2xlYW5gJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3ByZWZldGNoJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcHNba2V5XSAhPSBudWxsICYmXG4gICAgICAgICAgdmFsVHlwZSAhPT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgICAgcHJvcHNba2V5XSAhPT0gJ2F1dG8nICYmXG4gICAgICAgICAgcHJvcHNba2V5XSAhPT0gJ3Vuc3RhYmxlX2ZvcmNlU3RhbGUnXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2Bib29sZWFuIHwgXCJhdXRvXCIgfCBcInVuc3RhYmxlX2ZvcmNlU3RhbGVcImAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAocHJvcHMubG9jYWxlKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgJ1RoZSBgbG9jYWxlYCBwcm9wIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYG5leHQvbGlua2Agd2hpbGUgdXNpbmcgdGhlIGBhcHBgIHJvdXRlci4gUmVhZCBtb3JlIGFib3V0IGFwcCByb3V0ZXIgaW50ZXJuYWxpemF0aW9uOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL2ludGVybmF0aW9uYWxpemF0aW9uJ1xuICAgICAgKVxuICAgIH1cbiAgICBpZiAoIWFzUHJvcCkge1xuICAgICAgbGV0IGhyZWY6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgICAgaWYgKHR5cGVvZiBocmVmUHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaHJlZiA9IGhyZWZQcm9wXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlb2YgaHJlZlByb3AgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiBocmVmUHJvcC5wYXRobmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICkge1xuICAgICAgICBocmVmID0gaHJlZlByb3AucGF0aG5hbWVcbiAgICAgIH1cblxuICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgY29uc3QgaGFzRHluYW1pY1NlZ21lbnQgPSBocmVmXG4gICAgICAgICAgLnNwbGl0KCcvJylcbiAgICAgICAgICAuc29tZSgoc2VnbWVudCkgPT4gc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKVxuXG4gICAgICAgIGlmIChoYXNEeW5hbWljU2VnbWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBEeW5hbWljIGhyZWYgXFxgJHtocmVmfVxcYCBmb3VuZCBpbiA8TGluaz4gd2hpbGUgdXNpbmcgdGhlIFxcYC9hcHBcXGAgcm91dGVyLCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvYXBwLWRpci1keW5hbWljLWhyZWZgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgeyBocmVmLCBhcyB9ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZm9ybWF0U3RyaW5nT3JVcmwoaHJlZlByb3ApXG4gICAgcmV0dXJuIHtcbiAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgIGFzOiBhc1Byb3AgPyBmb3JtYXRTdHJpbmdPclVybChhc1Byb3ApIDogcmVzb2x2ZWRIcmVmLFxuICAgIH1cbiAgfSwgW2hyZWZQcm9wLCBhc1Byb3BdKVxuXG4gIC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNoaWxkLCBpZiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICBsZXQgY2hpbGQ6IGFueVxuICBpZiAobGVnYWN5QmVoYXZpb3IpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgXCJvbkNsaWNrXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbkNsaWNrIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rYFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAob25Nb3VzZUVudGVyUHJvcCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFwib25Nb3VzZUVudGVyXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbk1vdXNlRW50ZXIgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNoaWxkID0gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbilcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYE5vIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IG9uZSBjaGlsZCBpcyByZXF1aXJlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW5vLWNoaWxkcmVuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE11bHRpcGxlIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IG9ubHkgb25lIGNoaWxkIGlzIHN1cHBvcnRlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW11bHRpcGxlLWNoaWxkcmVuYCArXG4gICAgICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgPyBcIiBcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiXG4gICAgICAgICAgICAgIDogJycpXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmICgoY2hpbGRyZW4gYXMgYW55KT8udHlwZSA9PT0gJ2EnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCA8TGluaz4gd2l0aCA8YT4gY2hpbGQuIFBsZWFzZSByZW1vdmUgPGE+IG9yIHVzZSA8TGluayBsZWdhY3lCZWhhdmlvcj4uXFxuTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1uZXctbGluay13aXRoLWV4dHJhLWFuY2hvcidcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNoaWxkUmVmOiBhbnkgPSBsZWdhY3lCZWhhdmlvclxuICAgID8gY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJiBjaGlsZC5yZWZcbiAgICA6IGZvcndhcmRlZFJlZlxuXG4gIC8vIFVzZSBhIGNhbGxiYWNrIHJlZiB0byBhdHRhY2ggYW4gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgdG8gdGhlIGFuY2hvciB0YWcgb25cbiAgLy8gbW91bnQuIEluIHRoZSBmdXR1cmUgd2Ugd2lsbCBhbHNvIHVzZSB0aGlzIHRvIGtlZXAgdHJhY2sgb2YgYWxsIHRoZVxuICAvLyBjdXJyZW50bHkgbW91bnRlZCA8TGluaz4gaW5zdGFuY2VzLCBlLmcuIHNvIHdlIGNhbiByZS1wcmVmZXRjaCB0aGVtIGFmdGVyXG4gIC8vIGEgcmV2YWxpZGF0aW9uIG9yIHJlZnJlc2guXG4gIGNvbnN0IG9ic2VydmVMaW5rVmlzaWJpbGl0eU9uTW91bnQgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZWxlbWVudDogSFRNTEFuY2hvckVsZW1lbnQgfCBTVkdBRWxlbWVudCkgPT4ge1xuICAgICAgaWYgKHJvdXRlciAhPT0gbnVsbCkge1xuICAgICAgICBsaW5rSW5zdGFuY2VSZWYuY3VycmVudCA9IG1vdW50TGlua0luc3RhbmNlKFxuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgaHJlZixcbiAgICAgICAgICByb3V0ZXIsXG4gICAgICAgICAgZmV0Y2hTdHJhdGVneSxcbiAgICAgICAgICBwcmVmZXRjaEVuYWJsZWQsXG4gICAgICAgICAgc2V0T3B0aW1pc3RpY0xpbmtTdGF0dXNcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAobGlua0luc3RhbmNlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICB1bm1vdW50TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uKGxpbmtJbnN0YW5jZVJlZi5jdXJyZW50KVxuICAgICAgICAgIGxpbmtJbnN0YW5jZVJlZi5jdXJyZW50ID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHVubW91bnRQcmVmZXRjaGFibGVJbnN0YW5jZShlbGVtZW50KVxuICAgICAgfVxuICAgIH0sXG4gICAgW3ByZWZldGNoRW5hYmxlZCwgaHJlZiwgcm91dGVyLCBmZXRjaFN0cmF0ZWd5LCBzZXRPcHRpbWlzdGljTGlua1N0YXR1c11cbiAgKVxuXG4gIGNvbnN0IG1lcmdlZFJlZiA9IHVzZU1lcmdlZFJlZihvYnNlcnZlTGlua1Zpc2liaWxpdHlPbk1vdW50LCBjaGlsZFJlZilcblxuICBjb25zdCBjaGlsZFByb3BzOiB7XG4gICAgb25Ub3VjaFN0YXJ0PzogUmVhY3QuVG91Y2hFdmVudEhhbmRsZXI8SFRNTEFuY2hvckVsZW1lbnQ+XG4gICAgb25Nb3VzZUVudGVyOiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cbiAgICBvbkNsaWNrOiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cbiAgICBocmVmPzogc3RyaW5nXG4gICAgcmVmPzogYW55XG4gIH0gPSB7XG4gICAgcmVmOiBtZXJnZWRSZWYsXG4gICAgb25DbGljayhlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ29tcG9uZW50IHJlbmRlcmVkIGluc2lkZSBuZXh0L2xpbmsgaGFzIHRvIHBhc3MgY2xpY2sgZXZlbnQgdG8gXCJvbkNsaWNrXCIgcHJvcC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25DbGljayhlKVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGxlZ2FjeUJlaGF2aW9yICYmXG4gICAgICAgIGNoaWxkLnByb3BzICYmXG4gICAgICAgIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbGlua0NsaWNrZWQoZSwgaHJlZiwgYXMsIGxpbmtJbnN0YW5jZVJlZiwgcmVwbGFjZSwgc2Nyb2xsLCBvbk5hdmlnYXRlKVxuICAgIH0sXG4gICAgb25Nb3VzZUVudGVyKGUpIHtcbiAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uTW91c2VFbnRlclByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25Nb3VzZUVudGVyUHJvcChlKVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGxlZ2FjeUJlaGF2aW9yICYmXG4gICAgICAgIGNoaWxkLnByb3BzICYmXG4gICAgICAgIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSlcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICghcHJlZmV0Y2hFbmFibGVkIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2ggPSB1bnN0YWJsZV9keW5hbWljT25Ib3ZlciA9PT0gdHJ1ZVxuICAgICAgb25OYXZpZ2F0aW9uSW50ZW50KFxuICAgICAgICBlLmN1cnJlbnRUYXJnZXQgYXMgSFRNTEFuY2hvckVsZW1lbnQgfCBTVkdBRWxlbWVudCxcbiAgICAgICAgdXBncmFkZVRvRHluYW1pY1ByZWZldGNoXG4gICAgICApXG4gICAgfSxcbiAgICBvblRvdWNoU3RhcnQ6IHByb2Nlc3MuZW52Ll9fTkVYVF9MSU5LX05PX1RPVUNIX1NUQVJUXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uVG91Y2hTdGFydFByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydFByb3AoZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBsZWdhY3lCZWhhdmlvciAmJlxuICAgICAgICAgICAgY2hpbGQucHJvcHMgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjaGlsZC5wcm9wcy5vblRvdWNoU3RhcnQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydChlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXByZWZldGNoRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdXBncmFkZVRvRHluYW1pY1ByZWZldGNoID0gdW5zdGFibGVfZHluYW1pY09uSG92ZXIgPT09IHRydWVcbiAgICAgICAgICBvbk5hdmlnYXRpb25JbnRlbnQoXG4gICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQgYXMgSFRNTEFuY2hvckVsZW1lbnQgfCBTVkdBRWxlbWVudCxcbiAgICAgICAgICAgIHVwZ3JhZGVUb0R5bmFtaWNQcmVmZXRjaFxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgfVxuXG4gIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAvLyBkZWZpbmVkLCB3ZSBzcGVjaWZ5IHRoZSBjdXJyZW50ICdocmVmJywgc28gdGhhdCByZXBldGl0aW9uIGlzIG5vdCBuZWVkZWQgYnkgdGhlIHVzZXIuXG4gIC8vIElmIHRoZSB1cmwgaXMgYWJzb2x1dGUsIHdlIGNhbiBieXBhc3MgdGhlIGxvZ2ljIHRvIHByZXBlbmQgdGhlIGJhc2VQYXRoLlxuICBpZiAoaXNBYnNvbHV0ZVVybChhcykpIHtcbiAgICBjaGlsZFByb3BzLmhyZWYgPSBhc1xuICB9IGVsc2UgaWYgKFxuICAgICFsZWdhY3lCZWhhdmlvciB8fFxuICAgIHBhc3NIcmVmIHx8XG4gICAgKGNoaWxkLnR5cGUgPT09ICdhJyAmJiAhKCdocmVmJyBpbiBjaGlsZC5wcm9wcykpXG4gICkge1xuICAgIGNoaWxkUHJvcHMuaHJlZiA9IGFkZEJhc2VQYXRoKGFzKVxuICB9XG5cbiAgbGV0IGxpbms6IFJlYWN0LlJlYWN0Tm9kZVxuXG4gIGlmIChsZWdhY3lCZWhhdmlvcikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgZXJyb3JPbmNlKFxuICAgICAgICAnYGxlZ2FjeUJlaGF2aW9yYCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgJyArXG4gICAgICAgICAgJ3JlbGVhc2UuIEEgY29kZW1vZCBpcyBhdmFpbGFibGUgdG8gdXBncmFkZSB5b3VyIGNvbXBvbmVudHM6XFxuXFxuJyArXG4gICAgICAgICAgJ25weCBAbmV4dC9jb2RlbW9kQGxhdGVzdCBuZXctbGluayAuXFxuXFxuJyArXG4gICAgICAgICAgJ0xlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3VwZ3JhZGluZy9jb2RlbW9kcyNyZW1vdmUtYS10YWdzLWZyb20tbGluay1jb21wb25lbnRzJ1xuICAgICAgKVxuICAgIH1cbiAgICBsaW5rID0gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKVxuICB9IGVsc2Uge1xuICAgIGxpbmsgPSAoXG4gICAgICA8YSB7Li4ucmVzdFByb3BzfSB7Li4uY2hpbGRQcm9wc30+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvYT5cbiAgICApXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxMaW5rU3RhdHVzQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bGlua1N0YXR1c30+XG4gICAgICB7bGlua31cbiAgICA8L0xpbmtTdGF0dXNDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG5cbmNvbnN0IExpbmtTdGF0dXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxcbiAgdHlwZW9mIFBFTkRJTkdfTElOS19TVEFUVVMgfCB0eXBlb2YgSURMRV9MSU5LX1NUQVRVU1xuPihJRExFX0xJTktfU1RBVFVTKVxuXG5leHBvcnQgY29uc3QgdXNlTGlua1N0YXR1cyA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoTGlua1N0YXR1c0NvbnRleHQpXG59XG5cbmZ1bmN0aW9uIGdldEZldGNoU3RyYXRlZ3lGcm9tUHJlZmV0Y2hQcm9wKFxuICBwcmVmZXRjaFByb3A6IEV4Y2x1ZGU8TGlua1Byb3BzWydwcmVmZXRjaCddLCB1bmRlZmluZWQgfCBmYWxzZT5cbik6IFByZWZldGNoVGFza0ZldGNoU3RyYXRlZ3kge1xuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuX19ORVhUX0NBQ0hFX0NPTVBPTkVOVFMgJiZcbiAgICBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgKSB7XG4gICAgLy8gSW4gdGhlIG5ldyBpbXBsZW1lbnRhdGlvbjpcbiAgICAvLyAtIGBwcmVmZXRjaD17dHJ1ZX1gIGlzIGEgcnVudGltZSBwcmVmZXRjaFxuICAgIC8vICAgKGluY2x1ZGVzIGNhY2hlZCBJTyArIHBhcmFtcyArIGNvb2tpZXMsIHdpdGggZHluYW1pYyBob2xlcyBmb3IgdW5jYWNoZWQgSU8pLlxuICAgIC8vIC0gYHVuc3RhYmxlX2ZvcmNlU3RhbGVgIGlzIGEgXCJmdWxsXCIgcHJlZmV0Y2hcbiAgICAvLyAgIChmb3JjZXMgaW5jbHVzaW9uIG9mIGFsbCBkeW5hbWljIGRhdGEsIGkuZS4gdGhlIG9sZCBiZWhhdmlvciBvZiBgcHJlZmV0Y2g9e3RydWV9YClcbiAgICBpZiAocHJlZmV0Y2hQcm9wID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gRmV0Y2hTdHJhdGVneS5QUFJSdW50aW1lXG4gICAgfVxuICAgIGlmIChwcmVmZXRjaFByb3AgPT09ICd1bnN0YWJsZV9mb3JjZVN0YWxlJykge1xuICAgICAgcmV0dXJuIEZldGNoU3RyYXRlZ3kuRnVsbFxuICAgIH1cblxuICAgIC8vIGBudWxsYCBvciBgXCJhdXRvXCJgOiB0aGlzIGlzIHRoZSBkZWZhdWx0IFwiYXV0b1wiIG1vZGUsIHdoZXJlIHdlIHdpbGwgcHJlZmV0Y2ggcGFydGlhbGx5IGlmIHRoZSBsaW5rIGlzIGluIHRoZSB2aWV3cG9ydC5cbiAgICAvLyBUaGlzIHdpbGwgYWxzbyBpbmNsdWRlIGludmFsaWQgcHJvcCB2YWx1ZXMgdGhhdCBkb24ndCBtYXRjaCB0aGUgdHlwZXMgc3BlY2lmaWVkIGhlcmUuXG4gICAgLy8gKGFsdGhvdWdoIHRob3NlIHNob3VsZCd2ZSBiZWVuIGZpbHRlcmVkIG91dCBieSBwcm9wIHZhbGlkYXRpb24gaW4gZGV2KVxuICAgIHByZWZldGNoUHJvcCBzYXRpc2ZpZXMgbnVsbCB8ICdhdXRvJ1xuICAgIC8vIEluIGBjbGllbnRTZWdtZW50Q2FjaGVgLCB3ZSBkZWZhdWx0IHRvIFBQUiwgYW5kIHdlJ2xsIGRpc2NvdmVyIHdoZXRoZXIgb3Igbm90IHRoZSByb3V0ZSBzdXBwb3J0cyBpdCB3aXRoIHRoZSBpbml0aWFsIHByZWZldGNoLlxuICAgIC8vIElmIHdlJ3JlIG5vdCB1c2luZyBgY2xpZW50U2VnbWVudENhY2hlYCwgdGhpcyB3aWxsIGJlIGNvbnZlcnRlZCBpbnRvIGEgYFByZWZldGNoS2luZC5BVVRPYC5cbiAgICByZXR1cm4gRmV0Y2hTdHJhdGVneS5QUFJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZmV0Y2hQcm9wID09PSBudWxsIHx8IHByZWZldGNoUHJvcCA9PT0gJ2F1dG8nXG4gICAgICA/IC8vIEluIGBjbGllbnRTZWdtZW50Q2FjaGVgLCB3ZSBkZWZhdWx0IHRvIFBQUiwgYW5kIHdlJ2xsIGRpc2NvdmVyIHdoZXRoZXIgb3Igbm90IHRoZSByb3V0ZSBzdXBwb3J0cyBpdCB3aXRoIHRoZSBpbml0aWFsIHByZWZldGNoLlxuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgdXNpbmcgYGNsaWVudFNlZ21lbnRDYWNoZWAsIHRoaXMgd2lsbCBiZSBjb252ZXJ0ZWQgaW50byBhIGBQcmVmZXRjaEtpbmQuQVVUT2AuXG4gICAgICAgIEZldGNoU3RyYXRlZ3kuUFBSXG4gICAgICA6IC8vIEluIHRoZSBvbGQgaW1wbGVtZW50YXRpb24gd2l0aG91dCBydW50aW1lIHByZWZldGNoZXMsIGBwcmVmZXRjaD17dHJ1ZX1gIGZvcmNlcyBhbGwgZHluYW1pYyBkYXRhIHRvIGJlIHByZWZldGNoZWQuXG4gICAgICAgIC8vIFRvIHByZXNlcnZlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCBhbnl0aGluZyBvdGhlciB0aGFuIGBmYWxzZWAsIGBudWxsYCwgb3IgYFwiYXV0b1wiYCByZXN1bHRzIGluIGEgZnVsbCBwcmVmZXRjaC5cbiAgICAgICAgLy8gKGFsdGhvdWdoIGludmFsaWQgdmFsdWVzIHNob3VsZCd2ZSBiZWVuIGZpbHRlcmVkIG91dCBieSBwcm9wIHZhbGlkYXRpb24gaW4gZGV2KVxuICAgICAgICBGZXRjaFN0cmF0ZWd5LkZ1bGxcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkxpbmtDb21wb25lbnQiLCJ1c2VMaW5rU3RhdHVzIiwiaXNNb2RpZmllZEV2ZW50IiwiZXZlbnQiLCJldmVudFRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJtZXRhS2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwibmF0aXZlRXZlbnQiLCJ3aGljaCIsImxpbmtDbGlja2VkIiwiZSIsImhyZWYiLCJhcyIsImxpbmtJbnN0YW5jZVJlZiIsInJlcGxhY2UiLCJzY3JvbGwiLCJvbk5hdmlnYXRlIiwibm9kZU5hbWUiLCJpc0FuY2hvck5vZGVOYW1lIiwidG9VcHBlckNhc2UiLCJoYXNBdHRyaWJ1dGUiLCJpc0xvY2FsVVJMIiwicHJldmVudERlZmF1bHQiLCJsb2NhdGlvbiIsImlzRGVmYXVsdFByZXZlbnRlZCIsIlJlYWN0Iiwic3RhcnRUcmFuc2l0aW9uIiwiZGlzcGF0Y2hOYXZpZ2F0ZUFjdGlvbiIsImN1cnJlbnQiLCJmb3JtYXRTdHJpbmdPclVybCIsInVybE9iak9yU3RyaW5nIiwiZm9ybWF0VXJsIiwicHJvcHMiLCJsaW5rU3RhdHVzIiwic2V0T3B0aW1pc3RpY0xpbmtTdGF0dXMiLCJ1c2VPcHRpbWlzdGljIiwiSURMRV9MSU5LX1NUQVRVUyIsImNoaWxkcmVuIiwidXNlUmVmIiwiaHJlZlByb3AiLCJhc1Byb3AiLCJjaGlsZHJlblByb3AiLCJwcmVmZXRjaCIsInByZWZldGNoUHJvcCIsInBhc3NIcmVmIiwic2hhbGxvdyIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlRW50ZXJQcm9wIiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaFN0YXJ0UHJvcCIsImxlZ2FjeUJlaGF2aW9yIiwicmVmIiwiZm9yd2FyZGVkUmVmIiwidW5zdGFibGVfZHluYW1pY09uSG92ZXIiLCJyZXN0UHJvcHMiLCJhIiwicm91dGVyIiwidXNlQ29udGV4dCIsIkFwcFJvdXRlckNvbnRleHQiLCJwcmVmZXRjaEVuYWJsZWQiLCJmZXRjaFN0cmF0ZWd5IiwiZ2V0RmV0Y2hTdHJhdGVneUZyb21QcmVmZXRjaFByb3AiLCJGZXRjaFN0cmF0ZWd5IiwiUFBSIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY3JlYXRlUHJvcEVycm9yIiwiYXJncyIsIkVycm9yIiwia2V5IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJ3aW5kb3ciLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJfIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJsb2NhbGUiLCJ3YXJuT25jZSIsInBhdGhuYW1lIiwiaGFzRHluYW1pY1NlZ21lbnQiLCJzcGxpdCIsInNvbWUiLCJzZWdtZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidXNlTWVtbyIsInJlc29sdmVkSHJlZiIsImNoaWxkIiwiY29uc29sZSIsIndhcm4iLCJDaGlsZHJlbiIsIm9ubHkiLCJlcnIiLCJ0eXBlIiwiY2hpbGRSZWYiLCJvYnNlcnZlTGlua1Zpc2liaWxpdHlPbk1vdW50IiwidXNlQ2FsbGJhY2siLCJlbGVtZW50IiwibW91bnRMaW5rSW5zdGFuY2UiLCJ1bm1vdW50TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uIiwidW5tb3VudFByZWZldGNoYWJsZUluc3RhbmNlIiwibWVyZ2VkUmVmIiwidXNlTWVyZ2VkUmVmIiwiY2hpbGRQcm9wcyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJ1cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2giLCJvbk5hdmlnYXRpb25JbnRlbnQiLCJfX05FWFRfTElOS19OT19UT1VDSF9TVEFSVCIsInVuZGVmaW5lZCIsImlzQWJzb2x1dGVVcmwiLCJhZGRCYXNlUGF0aCIsImxpbmsiLCJlcnJvck9uY2UiLCJjbG9uZUVsZW1lbnQiLCJMaW5rU3RhdHVzQ29udGV4dCIsIlByb3ZpZGVyIiwidmFsdWUiLCJjcmVhdGVDb250ZXh0IiwiX19ORVhUX0NBQ0hFX0NPTVBPTkVOVFMiLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJQUFJSdW50aW1lIiwiRnVsbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-dir/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/client/use-merged-ref.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useMergedRef\", ({\n    enumerable: true,\n    get: function() {\n        return useMergedRef;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction useMergedRef(refA, refB) {\n    const cleanupA = (0, _react.useRef)(null);\n    const cleanupB = (0, _react.useRef)(null);\n    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.\n    // (this happens often if the user doesn't pass a ref to Link/Form/Image)\n    // But this can cause us to leak a cleanup-ref into user code (e.g. via `<Link legacyBehavior>`),\n    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs\n    // (because it hasn't been updated for React 19)\n    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.\n    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.\n    return (0, _react.useCallback)((current)=>{\n        if (current === null) {\n            const cleanupFnA = cleanupA.current;\n            if (cleanupFnA) {\n                cleanupA.current = null;\n                cleanupFnA();\n            }\n            const cleanupFnB = cleanupB.current;\n            if (cleanupFnB) {\n                cleanupB.current = null;\n                cleanupFnB();\n            }\n        } else {\n            if (refA) {\n                cleanupA.current = applyRef(refA, current);\n            }\n            if (refB) {\n                cleanupB.current = applyRef(refB, current);\n            }\n        }\n    }, [\n        refA,\n        refB\n    ]);\n}\nfunction applyRef(refA, current) {\n    if (typeof refA === 'function') {\n        const cleanup = refA(current);\n        if (typeof cleanup === 'function') {\n            return cleanup;\n        } else {\n            return ()=>refA(null);\n        }\n    } else {\n        refA.current = current;\n        return ()=>{\n            refA.current = null;\n        };\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-merged-ref.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1tZXJnZWQtcmVmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Z0RBU2dCQTs7O2VBQUFBOzs7bUNBVDhCO0FBU3ZDLFNBQVNBLGFBQ2RDLElBQW1CLEVBQ25CQyxJQUFtQjtJQUVuQixNQUFNQyxXQUFXQyxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUE0QjtJQUM3QyxNQUFNQyxXQUFXRCxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUE0QjtJQUU3QyxtRkFBbUY7SUFDbkYseUVBQXlFO0lBQ3pFLGlHQUFpRztJQUNqRyw4RkFBOEY7SUFDOUYsZ0RBQWdEO0lBQ2hELG1HQUFtRztJQUNuRyx3RkFBd0Y7SUFDeEYsT0FBT0UsQ0FBQUEsR0FBQUEsT0FBQUEsV0FBQUEsRUFDTCxDQUFDQztRQUNDLElBQUlBLFlBQVksTUFBTTtZQUNwQixNQUFNQyxhQUFhTCxTQUFTSSxPQUFPO1lBQ25DLElBQUlDLFlBQVk7Z0JBQ2RMLFNBQVNJLE9BQU8sR0FBRztnQkFDbkJDO1lBQ0Y7WUFDQSxNQUFNQyxhQUFhSixTQUFTRSxPQUFPO1lBQ25DLElBQUlFLFlBQVk7Z0JBQ2RKLFNBQVNFLE9BQU8sR0FBRztnQkFDbkJFO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsSUFBSVIsTUFBTTtnQkFDUkUsU0FBU0ksT0FBTyxHQUFHRyxTQUFTVCxNQUFNTTtZQUNwQztZQUNBLElBQUlMLE1BQU07Z0JBQ1JHLFNBQVNFLE9BQU8sR0FBR0csU0FBU1IsTUFBTUs7WUFDcEM7UUFDRjtJQUNGLEdBQ0E7UUFBQ047UUFBTUM7S0FBSztBQUVoQjtBQUVBLFNBQVNRLFNBQ1BULElBQWdDLEVBQ2hDTSxPQUFpQjtJQUVqQixJQUFJLE9BQU9OLFNBQVMsWUFBWTtRQUM5QixNQUFNVSxVQUFVVixLQUFLTTtRQUNyQixJQUFJLE9BQU9JLFlBQVksWUFBWTtZQUNqQyxPQUFPQTtRQUNULE9BQU87WUFDTCxPQUFPLElBQU1WLEtBQUs7UUFDcEI7SUFDRixPQUFPO1FBQ0xBLEtBQUtNLE9BQU8sR0FBR0E7UUFDZixPQUFPO1lBQ0xOLEtBQUtNLE9BQU8sR0FBRztRQUNqQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90aW1vdGh5ZWRpYm8vcHJvamVjdHMvcGVyc29uYWwvc3JjL2NsaWVudC91c2UtbWVyZ2VkLXJlZi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmLCB0eXBlIFJlZiB9IGZyb20gJ3JlYWN0J1xuXG4vLyBUaGlzIGlzIGEgY29tcGF0aWJpbGl0eSBob29rIHRvIHN1cHBvcnQgUmVhY3QgMTggYW5kIDE5IHJlZnMuXG4vLyBJbiAxOSwgYSBjbGVhbnVwIGZ1bmN0aW9uIGZyb20gcmVmcyBtYXkgYmUgcmV0dXJuZWQuXG4vLyBJbiAxOCwgcmV0dXJuaW5nIGEgY2xlYW51cCBmdW5jdGlvbiBjcmVhdGVzIGEgd2FybmluZy5cbi8vIFNpbmNlIHdlIHRha2UgdXNlcnNwYWNlIHJlZnMsIHdlIGRvbid0IGtub3cgYWhlYWQgb2YgdGltZSBpZiBhIGNsZWFudXAgZnVuY3Rpb24gd2lsbCBiZSByZXR1cm5lZC5cbi8vIFRoaXMgaW1wbGVtZW50cyBjbGVhbnVwIGZ1bmN0aW9ucyB3aXRoIHRoZSBvbGQgYmVoYXZpb3IgaW4gMTguXG4vLyBXZSBrbm93IHJlZnMgYXJlIGFsd2F5cyBjYWxsZWQgYWx0ZXJuYXRpbmcgd2l0aCBgbnVsbGAgYW5kIHRoZW4gYFRgLlxuLy8gU28gYSBjYWxsIHdpdGggYG51bGxgIG1lYW5zIHdlIG5lZWQgdG8gY2FsbCB0aGUgcHJldmlvdXMgY2xlYW51cCBmdW5jdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmPFRFbGVtZW50PihcbiAgcmVmQTogUmVmPFRFbGVtZW50PixcbiAgcmVmQjogUmVmPFRFbGVtZW50PlxuKTogUmVmPFRFbGVtZW50PiB7XG4gIGNvbnN0IGNsZWFudXBBID0gdXNlUmVmPCgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpXG4gIGNvbnN0IGNsZWFudXBCID0gdXNlUmVmPCgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpXG5cbiAgLy8gTk9URTogSW4gdGhlb3J5LCB3ZSBjb3VsZCBza2lwIHRoZSB3cmFwcGluZyBpZiBvbmx5IG9uZSBvZiB0aGUgcmVmcyBpcyBub24tbnVsbC5cbiAgLy8gKHRoaXMgaGFwcGVucyBvZnRlbiBpZiB0aGUgdXNlciBkb2Vzbid0IHBhc3MgYSByZWYgdG8gTGluay9Gb3JtL0ltYWdlKVxuICAvLyBCdXQgdGhpcyBjYW4gY2F1c2UgdXMgdG8gbGVhayBhIGNsZWFudXAtcmVmIGludG8gdXNlciBjb2RlIChlLmcuIHZpYSBgPExpbmsgbGVnYWN5QmVoYXZpb3I+YCksXG4gIC8vIGFuZCB0aGUgdXNlciBtaWdodCBwYXNzIHRoYXQgcmVmIGludG8gcmVmLW1lcmdpbmcgbGlicmFyeSB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBjbGVhbnVwIHJlZnNcbiAgLy8gKGJlY2F1c2UgaXQgaGFzbid0IGJlZW4gdXBkYXRlZCBmb3IgUmVhY3QgMTkpXG4gIC8vIHdoaWNoIGNhbiB0aGVuIGNhdXNlIHRoaW5ncyB0byBibG93IHVwLCBiZWNhdXNlIGEgY2xlYW51cC1yZXR1cm5pbmcgcmVmIGdldHMgY2FsbGVkIHdpdGggYG51bGxgLlxuICAvLyBTbyBpbiBwcmFjdGljZSwgaXQncyBzYWZlciB0byBiZSBkZWZlbnNpdmUgYW5kIGFsd2F5cyB3cmFwIHRoZSByZWYsIGV2ZW4gb24gUmVhY3QgMTkuXG4gIHJldHVybiB1c2VDYWxsYmFjayhcbiAgICAoY3VycmVudDogVEVsZW1lbnQgfCBudWxsKTogdm9pZCA9PiB7XG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjbGVhbnVwRm5BID0gY2xlYW51cEEuY3VycmVudFxuICAgICAgICBpZiAoY2xlYW51cEZuQSkge1xuICAgICAgICAgIGNsZWFudXBBLmN1cnJlbnQgPSBudWxsXG4gICAgICAgICAgY2xlYW51cEZuQSgpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xlYW51cEZuQiA9IGNsZWFudXBCLmN1cnJlbnRcbiAgICAgICAgaWYgKGNsZWFudXBGbkIpIHtcbiAgICAgICAgICBjbGVhbnVwQi5jdXJyZW50ID0gbnVsbFxuICAgICAgICAgIGNsZWFudXBGbkIoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVmQSkge1xuICAgICAgICAgIGNsZWFudXBBLmN1cnJlbnQgPSBhcHBseVJlZihyZWZBLCBjdXJyZW50KVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZCKSB7XG4gICAgICAgICAgY2xlYW51cEIuY3VycmVudCA9IGFwcGx5UmVmKHJlZkIsIGN1cnJlbnQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtyZWZBLCByZWZCXVxuICApXG59XG5cbmZ1bmN0aW9uIGFwcGx5UmVmPFRFbGVtZW50PihcbiAgcmVmQTogTm9uTnVsbGFibGU8UmVmPFRFbGVtZW50Pj4sXG4gIGN1cnJlbnQ6IFRFbGVtZW50XG4pIHtcbiAgaWYgKHR5cGVvZiByZWZBID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgY2xlYW51cCA9IHJlZkEoY3VycmVudClcbiAgICBpZiAodHlwZW9mIGNsZWFudXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjbGVhbnVwXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoKSA9PiByZWZBKG51bGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlZkEuY3VycmVudCA9IGN1cnJlbnRcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVmQS5jdXJyZW50ID0gbnVsbFxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbInVzZU1lcmdlZFJlZiIsInJlZkEiLCJyZWZCIiwiY2xlYW51cEEiLCJ1c2VSZWYiLCJjbGVhbnVwQiIsInVzZUNhbGxiYWNrIiwiY3VycmVudCIsImNsZWFudXBGbkEiLCJjbGVhbnVwRm5CIiwiYXBwbHlSZWYiLCJjbGVhbnVwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, props, owner, debugStack, debugTask) {\n      var refProp = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== refProp ? refProp : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        maybeKey,\n        getOwner(),\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (type, config, maybeKey, isStaticChildren) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0dBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksY0FBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIi9Vc2Vycy90aW1vdGh5ZWRpYm8vcHJvamVjdHMvcGVyc29uYWwvYmx1ZWNvdW50cy9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfQUNUSVZJVFlfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJBY3Rpdml0eVwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29uc29sZTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5lcnJvcjtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICBcIk9iamVjdFwiO1xuICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QuY2FsbChcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQsXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGFza05hbWUodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHJldHVybiBcIjw+XCI7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFXG4gICAgICApXG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBcIjxcIiArIG5hbWUgKyBcIj5cIiA6IFwiPC4uLj5cIjtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVua25vd25Pd25lcigpIHtcbiAgICAgIHJldHVybiBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29uZmlnLmtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICBmdW5jdGlvbiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkoKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIHx8XG4gICAgICAgICAgKChzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3BlY2lhbC1wcm9wcylcIixcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSAhMDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodGhpcy50eXBlKTtcbiAgICAgIGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgKChkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQWNjZXNzaW5nIGVsZW1lbnQucmVmIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiByZWYgaXMgbm93IGEgcmVndWxhciBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgSlNYIEVsZW1lbnQgdHlwZSBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiXG4gICAgICAgICkpO1xuICAgICAgY29tcG9uZW50TmFtZSA9IHRoaXMucHJvcHMucmVmO1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29tcG9uZW50TmFtZSA/IGNvbXBvbmVudE5hbWUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCBwcm9wcywgb3duZXIsIGRlYnVnU3RhY2ssIGRlYnVnVGFzaykge1xuICAgICAgdmFyIHJlZlByb3AgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gcmVmUHJvcCA/IHJlZlByb3AgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnU3RhY2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnVGFza1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1Rhc2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24ganN4REVWSW1wbChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjb25maWcuY2hpbGRyZW47XG4gICAgICBpZiAodm9pZCAwICE9PSBjaGlsZHJlbilcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPCBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4rK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpc1N0YXRpY0NoaWxkcmVuXSk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiBZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuIFVzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIGVsc2UgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4pO1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICBjaGlsZHJlbiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBcImtleVwiICE9PSBrO1xuICAgICAgICB9KTtcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgMCA8IGtleXMubGVuZ3RoXG4gICAgICAgICAgICA/IFwie2tleTogc29tZUtleSwgXCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIlxuICAgICAgICAgICAgOiBcIntrZXk6IHNvbWVLZXl9XCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dIHx8XG4gICAgICAgICAgKChrZXlzID1cbiAgICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aCA/IFwie1wiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcInt9XCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyB7Li4ucHJvcHN9IC8+XFxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLFxuICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAga2V5cyxcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgdm9pZCAwICE9PSBtYXliZUtleSAmJlxuICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBtYXliZUtleSkpO1xuICAgICAgaGFzVmFsaWRLZXkoY29uZmlnKSAmJlxuICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIGNvbmZpZy5rZXkpKTtcbiAgICAgIGlmIChcImtleVwiIGluIGNvbmZpZykge1xuICAgICAgICBtYXliZUtleSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBjb25maWcpXG4gICAgICAgICAgXCJrZXlcIiAhPT0gcHJvcE5hbWUgJiYgKG1heWJlS2V5W3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV0pO1xuICAgICAgfSBlbHNlIG1heWJlS2V5ID0gY29uZmlnO1xuICAgICAgY2hpbGRyZW4gJiZcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIoXG4gICAgICAgICAgbWF5YmVLZXksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZVxuICAgICAgICAgICAgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgOiB0eXBlXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KFxuICAgICAgICB0eXBlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGdldE93bmVyKCksXG4gICAgICAgIGRlYnVnU3RhY2ssXG4gICAgICAgIGRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSkge1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbnVsbCAhPT0gbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgJiZcbiAgICAgICAgbm9kZS5fc3RvcmUgJiZcbiAgICAgICAgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgIH1cbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICBSZWFjdCA9IHtcbiAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKGNhbGxTdGFja0ZvckVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsU3RhY2tGb3JFcnJvcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnU3RhY2sgPSBSZWFjdC5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChcbiAgICAgIFJlYWN0LFxuICAgICAgVW5rbm93bk93bmVyXG4gICAgKSgpO1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1Rhc2sgPSBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKFVua25vd25Pd25lcikpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICB2YXIgdHJhY2tBY3R1YWxPd25lciA9XG4gICAgICAgIDFlNCA+IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzKys7XG4gICAgICByZXR1cm4ganN4REVWSW1wbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lclxuICAgICAgICAgID8gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIilcbiAgICAgICAgICA6IHVua25vd25Pd25lckRlYnVnU3RhY2ssXG4gICAgICAgIHRyYWNrQWN0dWFsT3duZXIgPyBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKHR5cGUpKSA6IHVua25vd25Pd25lckRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9O1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy90aW1vdGh5ZWRpYm8vcHJvamVjdHMvcGVyc29uYWwvYmx1ZWNvdW50cy9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || '';\n    let pathname = urlObj.pathname || '';\n    let hash = urlObj.hash || '';\n    let query = urlObj.query || '';\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(':') ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += ':' + urlObj.port;\n        }\n    }\n    if (query && typeof query === 'object') {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || '';\n    if (protocol && !protocol.endsWith(':')) protocol += ':';\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n    } else if (!host) {\n        host = '';\n    }\n    if (hash && hash[0] !== '#') hash = '#' + hash;\n    if (search && search[0] !== '?') search = '?' + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace('#', '%23');\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    'auth',\n    'hash',\n    'host',\n    'hostname',\n    'href',\n    'path',\n    'pathname',\n    'port',\n    'protocol',\n    'query',\n    'search',\n    'slashes'\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === 'object') {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5Qzs7Ozs7Ozs7Ozs7OztJQVF6QkEsU0FBUztlQUFUQTs7SUE2REFDLG9CQUFvQjtlQUFwQkE7O0lBZkhDLGFBQWE7ZUFBYkE7Ozs7bUZBbERnQjtBQUU3QixNQUFNQyxtQkFBbUI7QUFFbEIsU0FBU0gsVUFBVUksTUFBaUI7SUFDekMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUN6QixJQUFJRyxXQUFXSCxPQUFPRyxRQUFRLElBQUk7SUFDbEMsSUFBSUMsV0FBV0osT0FBT0ksUUFBUSxJQUFJO0lBQ2xDLElBQUlDLE9BQU9MLE9BQU9LLElBQUksSUFBSTtJQUMxQixJQUFJQyxRQUFRTixPQUFPTSxLQUFLLElBQUk7SUFDNUIsSUFBSUMsT0FBdUI7SUFFM0JOLE9BQU9BLE9BQU9PLG1CQUFtQlAsTUFBTVEsT0FBTyxDQUFDLFFBQVEsT0FBTyxNQUFNO0lBRXBFLElBQUlULE9BQU9PLElBQUksRUFBRTtRQUNmQSxPQUFPTixPQUFPRCxPQUFPTyxJQUFJO0lBQzNCLE9BQU8sSUFBSUwsVUFBVTtRQUNuQkssT0FBT04sT0FBUSxFQUFDQyxTQUFTUSxPQUFPLENBQUMsT0FBUSxNQUFHUixXQUFTLE1BQUtBLFFBQUFBLENBQU87UUFDakUsSUFBSUYsT0FBT1csSUFBSSxFQUFFO1lBQ2ZKLFFBQVEsTUFBTVAsT0FBT1csSUFBSTtRQUMzQjtJQUNGO0lBRUEsSUFBSUwsU0FBUyxPQUFPQSxVQUFVLFVBQVU7UUFDdENBLFFBQVFNLE9BQU9DLGFBQVlDLHNCQUFzQixDQUFDUjtJQUNwRDtJQUVBLElBQUlTLFNBQVNmLE9BQU9lLE1BQU0sSUFBS1QsU0FBVSxNQUFHQSxTQUFZO0lBRXhELElBQUlILFlBQVksQ0FBQ0EsU0FBU2EsUUFBUSxDQUFDLE1BQU1iLFlBQVk7SUFFckQsSUFDRUgsT0FBT2lCLE9BQU8sSUFDWixFQUFDZCxZQUFZSixpQkFBaUJtQixJQUFJLENBQUNmLFNBQUFBLENBQVEsSUFBTUksU0FBUyxPQUM1RDtRQUNBQSxPQUFPLE9BQVFBLENBQUFBLFFBQVEsR0FBQztRQUN4QixJQUFJSCxZQUFZQSxRQUFRLENBQUMsRUFBRSxLQUFLLEtBQUtBLFdBQVcsTUFBTUE7SUFDeEQsT0FBTyxJQUFJLENBQUNHLE1BQU07UUFDaEJBLE9BQU87SUFDVDtJQUVBLElBQUlGLFFBQVFBLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBS0EsT0FBTyxNQUFNQTtJQUMxQyxJQUFJVSxVQUFVQSxNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUtBLFNBQVMsTUFBTUE7SUFFaERYLFdBQVdBLFNBQVNLLE9BQU8sQ0FBQyxTQUFTRDtJQUNyQ08sU0FBU0EsT0FBT04sT0FBTyxDQUFDLEtBQUs7SUFFN0IsT0FBUSxLQUFFTixXQUFXSSxPQUFPSCxXQUFXVyxTQUFTVjtBQUNsRDtBQUVPLE1BQU1QLGdCQUFnQjtJQUMzQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVNLFNBQVNELHFCQUFxQnNCLEdBQWM7SUFDakQsSUFBSUMsSUFBb0IsRUFBb0I7UUFDMUMsSUFBSUQsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtZQUMzQ0ksT0FBT0MsSUFBSSxDQUFDTCxLQUFLTSxPQUFPLENBQUMsQ0FBQ0M7Z0JBQ3hCLElBQUksQ0FBQzVCLGNBQWM2QixRQUFRLENBQUNELE1BQU07b0JBQ2hDRSxRQUFRQyxJQUFJLENBQ1QsdURBQW9ESDtnQkFFekQ7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPOUIsVUFBVXVCO0FBQ25CIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHR5cGUgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgdHlwZSB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqOiBVcmxPYmplY3QpIHtcbiAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9ialxuICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgJydcbiAgbGV0IHBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcnXG4gIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgJydcbiAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8ICcnXG4gIGxldCBob3N0OiBzdHJpbmcgfCBmYWxzZSA9IGZhbHNlXG5cbiAgYXV0aCA9IGF1dGggPyBlbmNvZGVVUklDb21wb25lbnQoYXV0aCkucmVwbGFjZSgvJTNBL2ksICc6JykgKyAnQCcgOiAnJ1xuXG4gIGlmICh1cmxPYmouaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3RcbiAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKCc6JykgPyBgWyR7aG9zdG5hbWV9XWAgOiBob3N0bmFtZSlcbiAgICBpZiAodXJsT2JqLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdXJsT2JqLnBvcnRcbiAgICB9XG4gIH1cblxuICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkgYXMgUGFyc2VkVXJsUXVlcnkpKVxuICB9XG5cbiAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgKHF1ZXJ5ICYmIGA/JHtxdWVyeX1gKSB8fCAnJ1xuXG4gIGlmIChwcm90b2NvbCAmJiAhcHJvdG9jb2wuZW5kc1dpdGgoJzonKSkgcHJvdG9jb2wgKz0gJzonXG5cbiAgaWYgKFxuICAgIHVybE9iai5zbGFzaGVzIHx8XG4gICAgKCghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29scy50ZXN0KHByb3RvY29sKSkgJiYgaG9zdCAhPT0gZmFsc2UpXG4gICkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpXG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lWzBdICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWVcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJ1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaFswXSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaFxuICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2hcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZW5jb2RlVVJJQ29tcG9uZW50KVxuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKVxuXG4gIHJldHVybiBgJHtwcm90b2NvbH0ke2hvc3R9JHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9YFxufVxuXG5leHBvcnQgY29uc3QgdXJsT2JqZWN0S2V5cyA9IFtcbiAgJ2F1dGgnLFxuICAnaGFzaCcsXG4gICdob3N0JyxcbiAgJ2hvc3RuYW1lJyxcbiAgJ2hyZWYnLFxuICAncGF0aCcsXG4gICdwYXRobmFtZScsXG4gICdwb3J0JyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3F1ZXJ5JyxcbiAgJ3NlYXJjaCcsXG4gICdzbGFzaGVzJyxcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHVybDogVXJsT2JqZWN0KTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKCF1cmxPYmplY3RLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JtYXRVcmwodXJsKVxufVxuIl0sIm5hbWVzIjpbImZvcm1hdFVybCIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsT2JqZWN0S2V5cyIsInNsYXNoZWRQcm90b2NvbHMiLCJ1cmxPYmoiLCJhdXRoIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwiaGFzaCIsInF1ZXJ5IiwiaG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJpbmRleE9mIiwicG9ydCIsIlN0cmluZyIsInF1ZXJ5c3RyaW5nIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaCIsImVuZHNXaXRoIiwic2xhc2hlcyIsInRlc3QiLCJ1cmwiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OENBTWdCQTs7O2VBQUFBOzs7bUNBTmlDO3lDQUNyQjtBQUtyQixTQUFTQSxXQUFXQyxHQUFXO0lBQ3BDLGdFQUFnRTtJQUNoRSxJQUFJLENBQUNDLENBQUFBLEdBQUFBLE9BQUFBLGFBQUFBLEVBQWNELE1BQU0sT0FBTztJQUNoQyxJQUFJO1FBQ0YsNERBQTREO1FBQzVELE1BQU1FLGlCQUFpQkMsQ0FBQUEsR0FBQUEsT0FBQUEsaUJBQUFBO1FBQ3ZCLE1BQU1DLFdBQVcsSUFBSUMsSUFBSUwsS0FBS0U7UUFDOUIsT0FBT0UsU0FBU0UsTUFBTSxLQUFLSixrQkFBa0JLLENBQUFBLEdBQUFBLGFBQUFBLFdBQUFBLEVBQVlILFNBQVNJLFFBQVE7SUFDNUUsRUFBRSxPQUFPQyxHQUFHO1FBQ1YsT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzQWJzb2x1dGVVcmwsIGdldExvY2F0aW9uT3JpZ2luIH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5pbXBvcnQgeyBoYXNCYXNlUGF0aCB9IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9oYXMtYmFzZS1wYXRoJ1xuXG4vKipcbiAqIERldGVjdHMgd2hldGhlciBhIGdpdmVuIHVybCBpcyByb3V0YWJsZSBieSB0aGUgTmV4dC5qcyByb3V0ZXIgKGJyb3dzZXIgb25seSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2FsVVJMKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIHByZXZlbnQgYSBoeWRyYXRpb24gbWlzbWF0Y2ggb24gaHJlZiBmb3IgdXJsIHdpdGggYW5jaG9yIHJlZnNcbiAgaWYgKCFpc0Fic29sdXRlVXJsKHVybCkpIHJldHVybiB0cnVlXG4gIHRyeSB7XG4gICAgLy8gYWJzb2x1dGUgdXJscyBjYW4gYmUgbG9jYWwgaWYgdGhleSBhcmUgb24gdGhlIHNhbWUgb3JpZ2luXG4gICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gICAgY29uc3QgcmVzb2x2ZWQgPSBuZXcgVVJMKHVybCwgbG9jYXRpb25PcmlnaW4pXG4gICAgcmV0dXJuIHJlc29sdmVkLm9yaWdpbiA9PT0gbG9jYXRpb25PcmlnaW4gJiYgaGFzQmFzZVBhdGgocmVzb2x2ZWQucGF0aG5hbWUpXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIl0sIm5hbWVzIjpbImlzTG9jYWxVUkwiLCJ1cmwiLCJpc0Fic29sdXRlVXJsIiwibG9jYXRpb25PcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiVVJMIiwib3JpZ2luIiwiaGFzQmFzZVBhdGgiLCJwYXRobmFtZSIsIl8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    assign: function() {\n        return assign;\n    },\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    for (const [key, value] of searchParams.entries()){\n        const existing = query[key];\n        if (typeof existing === 'undefined') {\n            query[key] = value;\n        } else if (Array.isArray(existing)) {\n            existing.push(value);\n        } else {\n            query[key] = [\n                existing,\n                value\n            ];\n        }\n    }\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === 'string') {\n        return param;\n    }\n    if (typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {\n        return String(param);\n    } else {\n        return '';\n    }\n}\nfunction urlQueryToSearchParams(query) {\n    const searchParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(query)){\n        if (Array.isArray(value)) {\n            for (const item of value){\n                searchParams.append(key, stringifyUrlQueryParam(item));\n            }\n        } else {\n            searchParams.set(key, stringifyUrlQueryParam(value));\n        }\n    }\n    return searchParams;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    for (const searchParams of searchParamsList){\n        for (const key of searchParams.keys()){\n            target.delete(key);\n        }\n        for (const [key, value] of searchParams.entries()){\n            target.append(key, value);\n        }\n    }\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBZ0RnQkEsTUFBTTtlQUFOQTs7SUE5Q0FDLHNCQUFzQjtlQUF0QkE7O0lBZ0NBQyxzQkFBc0I7ZUFBdEJBOzs7QUFoQ1QsU0FBU0QsdUJBQ2RFLFlBQTZCO0lBRTdCLE1BQU1DLFFBQXdCLENBQUM7SUFDL0IsS0FBSyxNQUFNLENBQUNDLEtBQUtDLE1BQU0sSUFBSUgsYUFBYUksT0FBTyxHQUFJO1FBQ2pELE1BQU1DLFdBQVdKLEtBQUssQ0FBQ0MsSUFBSTtRQUMzQixJQUFJLE9BQU9HLGFBQWEsYUFBYTtZQUNuQ0osS0FBSyxDQUFDQyxJQUFJLEdBQUdDO1FBQ2YsT0FBTyxJQUFJRyxNQUFNQyxPQUFPLENBQUNGLFdBQVc7WUFDbENBLFNBQVNHLElBQUksQ0FBQ0w7UUFDaEIsT0FBTztZQUNMRixLQUFLLENBQUNDLElBQUksR0FBRztnQkFBQ0c7Z0JBQVVGO2FBQU07UUFDaEM7SUFDRjtJQUNBLE9BQU9GO0FBQ1Q7QUFFQSxTQUFTUSx1QkFBdUJDLEtBQWM7SUFDNUMsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDN0IsT0FBT0E7SUFDVDtJQUVBLElBQ0csT0FBT0EsVUFBVSxZQUFZLENBQUNDLE1BQU1ELFVBQ3JDLE9BQU9BLFVBQVUsV0FDakI7UUFDQSxPQUFPRSxPQUFPRjtJQUNoQixPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7QUFFTyxTQUFTWCx1QkFBdUJFLEtBQXFCO0lBQzFELE1BQU1ELGVBQWUsSUFBSWE7SUFDekIsS0FBSyxNQUFNLENBQUNYLEtBQUtDLE1BQU0sSUFBSVcsT0FBT1YsT0FBTyxDQUFDSCxPQUFRO1FBQ2hELElBQUlLLE1BQU1DLE9BQU8sQ0FBQ0osUUFBUTtZQUN4QixLQUFLLE1BQU1ZLFFBQVFaLE1BQU87Z0JBQ3hCSCxhQUFhZ0IsTUFBTSxDQUFDZCxLQUFLTyx1QkFBdUJNO1lBQ2xEO1FBQ0YsT0FBTztZQUNMZixhQUFhaUIsR0FBRyxDQUFDZixLQUFLTyx1QkFBdUJOO1FBQy9DO0lBQ0Y7SUFDQSxPQUFPSDtBQUNUO0FBRU8sU0FBU0gsT0FDZHFCLE1BQXVCO0lBQ3ZCLGlDQUFHQyxtQkFBSDtRQUFHQSxnQkFBQUEsQ0FBSCwyQkFBc0M7O0lBRXRDLEtBQUssTUFBTW5CLGdCQUFnQm1CLGlCQUFrQjtRQUMzQyxLQUFLLE1BQU1qQixPQUFPRixhQUFhb0IsSUFBSSxHQUFJO1lBQ3JDRixPQUFPRyxNQUFNLENBQUNuQjtRQUNoQjtRQUVBLEtBQUssTUFBTSxDQUFDQSxLQUFLQyxNQUFNLElBQUlILGFBQWFJLE9BQU8sR0FBSTtZQUNqRGMsT0FBT0YsTUFBTSxDQUFDZCxLQUFLQztRQUNyQjtJQUNGO0lBRUEsT0FBT2U7QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc1xuKTogUGFyc2VkVXJsUXVlcnkge1xuICBjb25zdCBxdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzZWFyY2hQYXJhbXMuZW50cmllcygpKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBxdWVyeVtrZXldXG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgIGV4aXN0aW5nLnB1c2godmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSBbZXhpc3RpbmcsIHZhbHVlXVxuICAgIH1cbiAgfVxuICByZXR1cm4gcXVlcnlcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5VXJsUXVlcnlQYXJhbShwYXJhbTogdW5rbm93bik6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcmFtXG4gIH1cblxuICBpZiAoXG4gICAgKHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHBhcmFtKSkgfHxcbiAgICB0eXBlb2YgcGFyYW0gPT09ICdib29sZWFuJ1xuICApIHtcbiAgICByZXR1cm4gU3RyaW5nKHBhcmFtKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJ1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zKHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSk6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhxdWVyeSkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbShpdGVtKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VhcmNoUGFyYW1zLnNldChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0odmFsdWUpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2VhcmNoUGFyYW1zXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24oXG4gIHRhcmdldDogVVJMU2VhcmNoUGFyYW1zLFxuICAuLi5zZWFyY2hQYXJhbXNMaXN0OiBVUkxTZWFyY2hQYXJhbXNbXVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgZm9yIChjb25zdCBzZWFyY2hQYXJhbXMgb2Ygc2VhcmNoUGFyYW1zTGlzdCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHNlYXJjaFBhcmFtcy5rZXlzKCkpIHtcbiAgICAgIHRhcmdldC5kZWxldGUoa2V5KVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICAgIHRhcmdldC5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0XG59XG4iXSwibmFtZXMiOlsiYXNzaWduIiwic2VhcmNoUGFyYW1zVG9VcmxRdWVyeSIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsImtleSIsInZhbHVlIiwiZW50cmllcyIsImV4aXN0aW5nIiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJwYXJhbSIsImlzTmFOIiwiU3RyaW5nIiwiVVJMU2VhcmNoUGFyYW1zIiwiT2JqZWN0IiwiaXRlbSIsImFwcGVuZCIsInNldCIsInRhcmdldCIsInNlYXJjaFBhcmFtc0xpc3QiLCJrZXlzIiwiZGVsZXRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DecodeError: function() {\n        return DecodeError;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    'CLS',\n    'FCP',\n    'FID',\n    'INP',\n    'LCP',\n    'TTFB'\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? ':' + port : '');\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split('?');\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, '/').replace(/\\/\\/+/g, '/') + (urlParts[1] ? \"?\" + urlParts.slice(1).join('?') : '');\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== 'undefined';\nconst ST = SP && [\n    'mark',\n    'measure',\n    'getEntriesByName'\n].every((method)=>typeof performance[method] === 'function');\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = 'ENOENT';\n        this.name = 'PageNotFoundError';\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = 'ENOENT';\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFvYWFBLFdBQVc7ZUFBWEE7O0lBb0JBQyx1QkFBdUI7ZUFBdkJBOztJQVBBQyxpQkFBaUI7ZUFBakJBOztJQVpBQyxjQUFjO2VBQWRBOztJQUNBQyxpQkFBaUI7ZUFBakJBOztJQVRBQyxFQUFFO2VBQUZBOztJQUNBQyxFQUFFO2VBQUZBOztJQWxYQUMsVUFBVTtlQUFWQTs7SUFzUUdDLFFBQVE7ZUFBUkE7O0lBK0JBQyxjQUFjO2VBQWRBOztJQVhBQyxpQkFBaUI7ZUFBakJBOztJQUtBQyxNQUFNO2VBQU5BOztJQVBIQyxhQUFhO2VBQWJBOztJQW1CR0MsU0FBUztlQUFUQTs7SUFrQk1DLG1CQUFtQjtlQUFuQkE7O0lBZE5DLHdCQUF3QjtlQUF4QkE7O0lBK0dBQyxjQUFjO2VBQWRBOzs7QUE5WlQsTUFBTVQsYUFBYTtJQUFDO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztDQUFPO0FBc1E5RCxTQUFTQyxTQUNkUyxFQUFLO0lBRUwsSUFBSUMsT0FBTztJQUNYLElBQUlDO0lBRUosT0FBUTt5Q0FBSUMsT0FBQUEsSUFBQUEsTUFBQUEsT0FBQUEsT0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsT0FBQUE7WUFBQUEsSUFBQUEsQ0FBQUEsS0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUEsS0FBQUE7O1FBQ1YsSUFBSSxDQUFDRixNQUFNO1lBQ1RBLE9BQU87WUFDUEMsU0FBU0YsTUFBTUc7UUFDakI7UUFDQSxPQUFPRDtJQUNUO0FBQ0Y7QUFFQSwwREFBMEQ7QUFDMUQsZ0VBQWdFO0FBQ2hFLE1BQU1FLHFCQUFxQjtBQUNwQixNQUFNVCxnQkFBZ0IsQ0FBQ1UsTUFBZ0JELG1CQUFtQkUsSUFBSSxDQUFDRDtBQUUvRCxTQUFTWjtJQUNkLE1BQU0sRUFBRWMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLElBQUksRUFBRSxH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QUksR0FBRztRQUNaLElBQUksQ0FBQzlCLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ2lCLE9BQU8sR0FBSSxrQ0FBK0JZO0lBQ2pEO0FBQ0Y7QUFFTyxNQUFNOUQsMEJBQTBCbUQ7SUFDckNVLFlBQVlDLElBQVksRUFBRVosT0FBZSxDQUFFO1FBQ3pDLEtBQUs7UUFDTCxJQUFJLENBQUNBLE9BQU8sR0FBSSwwQ0FBdUNZLE9BQUssTUFBR1o7SUFDakU7QUFDRjtBQUVPLE1BQU1uRCxnQ0FBZ0NvRDtJQUUzQ1UsYUFBYztRQUNaLEtBQUs7UUFDTCxJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ2IsT0FBTyxHQUFJO0lBQ2xCO0FBQ0Y7QUFXTyxTQUFTcEMsZUFBZWtELEtBQVk7SUFDekMsT0FBT0MsS0FBS0MsU0FBUyxDQUFDO1FBQUVoQixTQUFTYyxNQUFNZCxPQUFPO1FBQUVpQixPQUFPSCxNQUFNRyxLQUFLO0lBQUM7QUFDckUiLCJzb3VyY2VzIjpbIi9Vc2Vycy90aW1vdGh5ZWRpYm8vcHJvamVjdHMvc3JjL3NoYXJlZC9saWIvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBIdG1sUHJvcHMgfSBmcm9tICcuL2h0bWwtY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50VHlwZSwgSlNYIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IERvbWFpbkxvY2FsZSB9IGZyb20gJy4uLy4uL3NlcnZlci9jb25maWcnXG5pbXBvcnQgdHlwZSB7IEVudiB9IGZyb20gJ0BuZXh0L2VudidcbmltcG9ydCB0eXBlIHsgSW5jb21pbmdNZXNzYWdlLCBTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJ2h0dHAnXG5pbXBvcnQgdHlwZSB7IE5leHRSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgdHlwZSB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgdHlwZSB7IFByZXZpZXdEYXRhIH0gZnJvbSAnLi4vLi4vdHlwZXMnXG5pbXBvcnQgdHlwZSB7IENPTVBJTEVSX05BTUVTIH0gZnJvbSAnLi9jb25zdGFudHMnXG5pbXBvcnQgdHlwZSBmcyBmcm9tICdmcydcblxuZXhwb3J0IHR5cGUgTmV4dENvbXBvbmVudFR5cGU8XG4gIENvbnRleHQgZXh0ZW5kcyBCYXNlQ29udGV4dCA9IE5leHRQYWdlQ29udGV4dCxcbiAgSW5pdGlhbFByb3BzID0ge30sXG4gIFByb3BzID0ge30sXG4+ID0gQ29tcG9uZW50VHlwZTxQcm9wcz4gJiB7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBpbml0aWFsIHBhZ2UgbG9hZCBkYXRhIHBvcHVsYXRpb24uIERhdGEgcmV0dXJuZWQgZnJvbSBgZ2V0SW5pdGlhbFByb3BzYCBpcyBzZXJpYWxpemVkIHdoZW4gc2VydmVyIHJlbmRlcmVkLlxuICAgKiBNYWtlIHN1cmUgdG8gcmV0dXJuIHBsYWluIGBPYmplY3RgIHdpdGhvdXQgdXNpbmcgYERhdGVgLCBgTWFwYCwgYFNldGAuXG4gICAqIEBwYXJhbSBjb250ZXh0IENvbnRleHQgb2YgYHBhZ2VgXG4gICAqL1xuICBnZXRJbml0aWFsUHJvcHM/KGNvbnRleHQ6IENvbnRleHQpOiBJbml0aWFsUHJvcHMgfCBQcm9taXNlPEluaXRpYWxQcm9wcz5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRUeXBlID0gTmV4dENvbXBvbmVudFR5cGU8XG4gIERvY3VtZW50Q29udGV4dCxcbiAgRG9jdW1lbnRJbml0aWFsUHJvcHMsXG4gIERvY3VtZW50UHJvcHNcbj5cblxuZXhwb3J0IHR5cGUgQXBwVHlwZTxQID0ge30+ID0gTmV4dENvbXBvbmVudFR5cGU8XG4gIEFwcENvbnRleHRUeXBlLFxuICBQLFxuICBBcHBQcm9wc1R5cGU8YW55LCBQPlxuPlxuXG5leHBvcnQgdHlwZSBBcHBUcmVlVHlwZSA9IENvbXBvbmVudFR5cGU8XG4gIEFwcEluaXRpYWxQcm9wcyAmIHsgW25hbWU6IHN0cmluZ106IGFueSB9XG4+XG5cbi8qKlxuICogV2ViIHZpdGFscyBwcm92aWRlZCB0byBfYXBwLnJlcG9ydFdlYlZpdGFscyBieSBDb3JlIFdlYiBWaXRhbHMgcGx1Z2luIGRldmVsb3BlZCBieSBHb29nbGUgQ2hyb21lIHRlYW0uXG4gKiBodHRwczovL25leHRqcy5vcmcvYmxvZy9uZXh0LTktNCNpbnRlZ3JhdGVkLXdlYi12aXRhbHMtcmVwb3J0aW5nXG4gKi9cbmV4cG9ydCBjb25zdCBXRUJfVklUQUxTID0gWydDTFMnLCAnRkNQJywgJ0ZJRCcsICdJTlAnLCAnTENQJywgJ1RURkInXSBhcyBjb25zdFxuZXhwb3J0IHR5cGUgTmV4dFdlYlZpdGFsc01ldHJpYyA9IHtcbiAgaWQ6IHN0cmluZ1xuICBzdGFydFRpbWU6IG51bWJlclxuICB2YWx1ZTogbnVtYmVyXG4gIGF0dHJpYnV0aW9uPzogeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH1cbn0gJiAoXG4gIHwge1xuICAgICAgbGFiZWw6ICd3ZWItdml0YWwnXG4gICAgICBuYW1lOiAodHlwZW9mIFdFQl9WSVRBTFMpW251bWJlcl1cbiAgICB9XG4gIHwge1xuICAgICAgbGFiZWw6ICdjdXN0b20nXG4gICAgICBuYW1lOlxuICAgICAgICB8ICdOZXh0LmpzLWh5ZHJhdGlvbidcbiAgICAgICAgfCAnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJ1xuICAgICAgICB8ICdOZXh0LmpzLXJlbmRlcidcbiAgICB9XG4pXG5cbmV4cG9ydCB0eXBlIEVuaGFuY2VyPEM+ID0gKENvbXBvbmVudDogQykgPT4gQ1xuXG5leHBvcnQgdHlwZSBDb21wb25lbnRzRW5oYW5jZXIgPVxuICB8IHtcbiAgICAgIGVuaGFuY2VBcHA/OiBFbmhhbmNlcjxBcHBUeXBlPlxuICAgICAgZW5oYW5jZUNvbXBvbmVudD86IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuICAgIH1cbiAgfCBFbmhhbmNlcjxOZXh0Q29tcG9uZW50VHlwZT5cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZVJlc3VsdCA9IHtcbiAgaHRtbDogc3RyaW5nXG4gIGhlYWQ/OiBBcnJheTxKU1guRWxlbWVudCB8IG51bGw+XG59XG5cbmV4cG9ydCB0eXBlIFJlbmRlclBhZ2UgPSAoXG4gIG9wdGlvbnM/OiBDb21wb25lbnRzRW5oYW5jZXJcbikgPT4gRG9jdW1lbnRJbml0aWFsUHJvcHMgfCBQcm9taXNlPERvY3VtZW50SW5pdGlhbFByb3BzPlxuXG5leHBvcnQgdHlwZSBCYXNlQ29udGV4dCA9IHtcbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgW2s6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgdHlwZSBORVhUX0RBVEEgPSB7XG4gIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHBhZ2U6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYnVpbGRJZDogc3RyaW5nXG4gIGFzc2V0UHJlZml4Pzogc3RyaW5nXG4gIHJ1bnRpbWVDb25maWc/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIG5leHRFeHBvcnQ/OiBib29sZWFuXG4gIGF1dG9FeHBvcnQ/OiBib29sZWFuXG4gIGlzRmFsbGJhY2s/OiBib29sZWFuXG4gIGlzRXhwZXJpbWVudGFsQ29tcGlsZT86IGJvb2xlYW5cbiAgZHluYW1pY0lkcz86IChzdHJpbmcgfCBudW1iZXIpW11cbiAgZXJyPzogRXJyb3IgJiB7XG4gICAgc3RhdHVzQ29kZT86IG51bWJlclxuICAgIHNvdXJjZT86IHR5cGVvZiBDT01QSUxFUl9OQU1FUy5zZXJ2ZXIgfCB0eXBlb2YgQ09NUElMRVJfTkFNRVMuZWRnZVNlcnZlclxuICB9XG4gIGdzcD86IGJvb2xlYW5cbiAgZ3NzcD86IGJvb2xlYW5cbiAgY3VzdG9tU2VydmVyPzogYm9vbGVhblxuICBnaXA/OiBib29sZWFuXG4gIGFwcEdpcD86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiByZWFkb25seSBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gIGRvbWFpbkxvY2FsZXM/OiByZWFkb25seSBEb21haW5Mb2NhbGVbXVxuICBzY3JpcHRMb2FkZXI/OiBhbnlbXVxuICBpc1ByZXZpZXc/OiBib29sZWFuXG4gIG5vdEZvdW5kU3JjUGFnZT86IHN0cmluZ1xufVxuXG4vKipcbiAqIGBOZXh0YCBjb250ZXh0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dFBhZ2VDb250ZXh0IHtcbiAgLyoqXG4gICAqIEVycm9yIG9iamVjdCBpZiBlbmNvdW50ZXJlZCBkdXJpbmcgcmVuZGVyaW5nXG4gICAqL1xuICBlcnI/OiAoRXJyb3IgJiB7IHN0YXR1c0NvZGU/OiBudW1iZXIgfSkgfCBudWxsXG4gIC8qKlxuICAgKiBgSFRUUGAgcmVxdWVzdCBvYmplY3QuXG4gICAqL1xuICByZXE/OiBJbmNvbWluZ01lc3NhZ2VcbiAgLyoqXG4gICAqIGBIVFRQYCByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICAvKipcbiAgICogUGF0aCBzZWN0aW9uIG9mIGBVUkxgLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZ1xuICAvKipcbiAgICogUXVlcnkgc3RyaW5nIHNlY3Rpb24gb2YgYFVSTGAgcGFyc2VkIGFzIGFuIG9iamVjdC5cbiAgICovXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICAvKipcbiAgICogYFN0cmluZ2Agb2YgdGhlIGFjdHVhbCBwYXRoIGluY2x1ZGluZyBxdWVyeS5cbiAgICovXG4gIGFzUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgbG9jYWxlXG4gICAqL1xuICBsb2NhbGU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEFsbCBjb25maWd1cmVkIGxvY2FsZXNcbiAgICovXG4gIGxvY2FsZXM/OiByZWFkb25seSBzdHJpbmdbXVxuICAvKipcbiAgICogVGhlIGNvbmZpZ3VyZWQgZGVmYXVsdCBsb2NhbGVcbiAgICovXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIGBDb21wb25lbnRgIHRoZSB0cmVlIG9mIHRoZSBBcHAgdG8gdXNlIGlmIG5lZWRpbmcgdG8gcmVuZGVyIHNlcGFyYXRlbHlcbiAgICovXG4gIEFwcFRyZWU6IEFwcFRyZWVUeXBlXG59XG5cbmV4cG9ydCB0eXBlIEFwcENvbnRleHRUeXBlPFJvdXRlciBleHRlbmRzIE5leHRSb3V0ZXIgPSBOZXh0Um91dGVyPiA9IHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQ+XG4gIEFwcFRyZWU6IEFwcFRyZWVUeXBlXG4gIGN0eDogTmV4dFBhZ2VDb250ZXh0XG4gIHJvdXRlcjogUm91dGVyXG59XG5cbmV4cG9ydCB0eXBlIEFwcEluaXRpYWxQcm9wczxQYWdlUHJvcHMgPSBhbnk+ID0ge1xuICBwYWdlUHJvcHM6IFBhZ2VQcm9wc1xufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wc1R5cGU8XG4gIFJvdXRlciBleHRlbmRzIE5leHRSb3V0ZXIgPSBOZXh0Um91dGVyLFxuICBQYWdlUHJvcHMgPSB7fSxcbj4gPSBBcHBJbml0aWFsUHJvcHM8UGFnZVByb3BzPiAmIHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQsIGFueSwgYW55PlxuICByb3V0ZXI6IFJvdXRlclxuICBfX05fU1NHPzogYm9vbGVhblxuICBfX05fU1NQPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudENvbnRleHQgPSBOZXh0UGFnZUNvbnRleHQgJiB7XG4gIHJlbmRlclBhZ2U6IFJlbmRlclBhZ2VcbiAgZGVmYXVsdEdldEluaXRpYWxQcm9wcyhcbiAgICBjdHg6IERvY3VtZW50Q29udGV4dCxcbiAgICBvcHRpb25zPzogeyBub25jZT86IHN0cmluZyB9XG4gICk6IFByb21pc2U8RG9jdW1lbnRJbml0aWFsUHJvcHM+XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50SW5pdGlhbFByb3BzID0gUmVuZGVyUGFnZVJlc3VsdCAmIHtcbiAgc3R5bGVzPzogUmVhY3QuUmVhY3RFbGVtZW50W10gfCBJdGVyYWJsZTxSZWFjdC5SZWFjdE5vZGU+IHwgSlNYLkVsZW1lbnRcbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRQcm9wcyA9IERvY3VtZW50SW5pdGlhbFByb3BzICYgSHRtbFByb3BzXG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dEFwaVJlcXVlc3QgZXh0ZW5kcyBJbmNvbWluZ01lc3NhZ2Uge1xuICAvKipcbiAgICogT2JqZWN0IG9mIGBxdWVyeWAgdmFsdWVzIGZyb20gdXJsXG4gICAqL1xuICBxdWVyeTogUGFydGlhbDx7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW11cbiAgfT5cbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgY29va2llc2AgZnJvbSBoZWFkZXJcbiAgICovXG4gIGNvb2tpZXM6IFBhcnRpYWw8e1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9PlxuXG4gIGJvZHk6IGFueVxuXG4gIGVudjogRW52XG5cbiAgZHJhZnRNb2RlPzogYm9vbGVhblxuXG4gIHByZXZpZXc/OiBib29sZWFuXG4gIC8qKlxuICAgKiBQcmV2aWV3IGRhdGEgc2V0IG9uIHRoZSByZXF1ZXN0LCBpZiBhbnlcbiAgICogKi9cbiAgcHJldmlld0RhdGE/OiBQcmV2aWV3RGF0YVxufVxuXG4vKipcbiAqIFNlbmQgYm9keSBvZiByZXNwb25zZVxuICovXG50eXBlIFNlbmQ8VD4gPSAoYm9keTogVCkgPT4gdm9pZFxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaVJlc3BvbnNlPERhdGEgPSBhbnk+ID0gU2VydmVyUmVzcG9uc2UgJiB7XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGFueWAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAgc2VuZDogU2VuZDxEYXRhPlxuICAvKipcbiAgICogU2VuZCBkYXRhIGBqc29uYCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBqc29uOiBTZW5kPERhdGE+XG4gIHN0YXR1czogKHN0YXR1c0NvZGU6IG51bWJlcikgPT4gTmV4dEFwaVJlc3BvbnNlPERhdGE+XG4gIHJlZGlyZWN0KHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPERhdGE+XG4gIHJlZGlyZWN0KHN0YXR1czogbnVtYmVyLCB1cmw6IHN0cmluZyk6IE5leHRBcGlSZXNwb25zZTxEYXRhPlxuXG4gIC8qKlxuICAgKiBTZXQgZHJhZnQgbW9kZVxuICAgKi9cbiAgc2V0RHJhZnRNb2RlOiAob3B0aW9uczogeyBlbmFibGU6IGJvb2xlYW4gfSkgPT4gTmV4dEFwaVJlc3BvbnNlPERhdGE+XG5cbiAgLyoqXG4gICAqIFNldCBwcmV2aWV3IGRhdGEgZm9yIE5leHQuanMnIHByZXJlbmRlciBtb2RlXG4gICAqL1xuICBzZXRQcmV2aWV3RGF0YTogKFxuICAgIGRhdGE6IG9iamVjdCB8IHN0cmluZyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWZpZXMgdGhlIG51bWJlciAoaW4gc2Vjb25kcykgZm9yIHRoZSBwcmV2aWV3IHNlc3Npb24gdG8gbGFzdCBmb3IuXG4gICAgICAgKiBUaGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmUgY29udmVydGVkIHRvIGFuIGludGVnZXIgYnkgcm91bmRpbmcgZG93bi5cbiAgICAgICAqIEJ5IGRlZmF1bHQsIG5vIG1heGltdW0gYWdlIGlzIHNldCBhbmQgdGhlIHByZXZpZXcgc2Vzc2lvbiBmaW5pc2hlc1xuICAgICAgICogd2hlbiB0aGUgY2xpZW50IHNodXRzIGRvd24gKGJyb3dzZXIgaXMgY2xvc2VkKS5cbiAgICAgICAqL1xuICAgICAgbWF4QWdlPzogbnVtYmVyXG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgcGF0aCBmb3IgdGhlIHByZXZpZXcgc2Vzc2lvbiB0byB3b3JrIHVuZGVyLiBCeSBkZWZhdWx0LFxuICAgICAgICogdGhlIHBhdGggaXMgY29uc2lkZXJlZCB0aGUgXCJkZWZhdWx0IHBhdGhcIiwgaS5lLiwgYW55IHBhZ2VzIHVuZGVyIFwiL1wiLlxuICAgICAgICovXG4gICAgICBwYXRoPzogc3RyaW5nXG4gICAgfVxuICApID0+IE5leHRBcGlSZXNwb25zZTxEYXRhPlxuXG4gIC8qKlxuICAgKiBDbGVhciBwcmV2aWV3IGRhdGEgZm9yIE5leHQuanMnIHByZXJlbmRlciBtb2RlXG4gICAqL1xuICBjbGVhclByZXZpZXdEYXRhOiAob3B0aW9ucz86IHsgcGF0aD86IHN0cmluZyB9KSA9PiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cblxuICAvKipcbiAgICogUmV2YWxpZGF0ZSBhIHNwZWNpZmljIHBhZ2UgYW5kIHJlZ2VuZXJhdGUgaXQgdXNpbmcgT24tRGVtYW5kIEluY3JlbWVudGFsXG4gICAqIFN0YXRpYyBSZWdlbmVyYXRpb24uXG4gICAqIFRoZSBwYXRoIHNob3VsZCBiZSBhbiBhY3R1YWwgcGF0aCwgbm90IGEgcmV3cml0dGVuIHBhdGguIEUuZy4gZm9yXG4gICAqIFwiL2Jsb2cvW3NsdWddXCIgdGhpcyBzaG91bGQgYmUgXCIvYmxvZy9wb3N0LTFcIi5cbiAgICogQGxpbmsgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vZGF0YS1mZXRjaGluZy9pbmNyZW1lbnRhbC1zdGF0aWMtcmVnZW5lcmF0aW9uI29uLWRlbWFuZC1yZXZhbGlkYXRpb24td2l0aC1yZXZhbGlkYXRlcGF0aFxuICAgKi9cbiAgcmV2YWxpZGF0ZTogKFxuICAgIHVybFBhdGg6IHN0cmluZyxcbiAgICBvcHRzPzoge1xuICAgICAgdW5zdGFibGVfb25seUdlbmVyYXRlZD86IGJvb2xlYW5cbiAgICB9XG4gICkgPT4gUHJvbWlzZTx2b2lkPlxufVxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgaGFuZGxlclxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpSGFuZGxlcjxUID0gYW55PiA9IChcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2U8VD5cbikgPT4gdW5rbm93biB8IFByb21pc2U8dW5rbm93bj5cblxuLyoqXG4gKiBVdGlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY09uY2U8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gUmV0dXJuVHlwZTxUPj4oXG4gIGZuOiBUXG4pOiBUIHtcbiAgbGV0IHVzZWQgPSBmYWxzZVxuICBsZXQgcmVzdWx0OiBSZXR1cm5UeXBlPFQ+XG5cbiAgcmV0dXJuICgoLi4uYXJnczogYW55W10pID0+IHtcbiAgICBpZiAoIXVzZWQpIHtcbiAgICAgIHVzZWQgPSB0cnVlXG4gICAgICByZXN1bHQgPSBmbiguLi5hcmdzKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pIGFzIFRcbn1cblxuLy8gU2NoZW1lOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuMVxuLy8gQWJzb2x1dGUgVVJMOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTQuM1xuY29uc3QgQUJTT0xVVEVfVVJMX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVpcXGQrXFwtLl0qPzovXG5leHBvcnQgY29uc3QgaXNBYnNvbHV0ZVVybCA9ICh1cmw6IHN0cmluZykgPT4gQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QodXJsKVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYXRpb25PcmlnaW4oKSB7XG4gIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0IH0gPSB3aW5kb3cubG9jYXRpb25cbiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0bmFtZX0ke3BvcnQgPyAnOicgKyBwb3J0IDogJyd9YFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VVJMKCkge1xuICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvblxuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWU8UD4oQ29tcG9uZW50OiBDb21wb25lbnRUeXBlPFA+KSB7XG4gIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICAgID8gQ29tcG9uZW50XG4gICAgOiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc1NlbnQocmVzOiBTZXJ2ZXJSZXNwb25zZSkge1xuICByZXR1cm4gcmVzLmZpbmlzaGVkIHx8IHJlcy5oZWFkZXJzU2VudFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKHVybDogc3RyaW5nKSB7XG4gIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KCc/JylcbiAgY29uc3QgdXJsTm9RdWVyeSA9IHVybFBhcnRzWzBdXG5cbiAgcmV0dXJuIChcbiAgICB1cmxOb1F1ZXJ5XG4gICAgICAvLyBmaXJzdCB3ZSByZXBsYWNlIGFueSBub24tZW5jb2RlZCBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmRcbiAgICAgIC8vIHRoZW4gbm9ybWFsaXplIHJlcGVhdGVkIGZvcndhcmQgc2xhc2hlc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuICAgICAgLnJlcGxhY2UoL1xcL1xcLysvZywgJy8nKSArXG4gICAgKHVybFBhcnRzWzFdID8gYD8ke3VybFBhcnRzLnNsaWNlKDEpLmpvaW4oJz8nKX1gIDogJycpXG4gIClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRHZXRJbml0aWFsUHJvcHM8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9LFxuPihBcHA6IE5leHRDb21wb25lbnRUeXBlPEMsIElQLCBQPiwgY3R4OiBDKTogUHJvbWlzZTxJUD4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChBcHAucHJvdG90eXBlPy5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgICBBcHBcbiAgICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgfVxuICB9XG4gIC8vIHdoZW4gY2FsbGVkIGZyb20gX2FwcCBgY3R4YCBpcyBuZXN0ZWQgaW4gYGN0eGBcbiAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCAoY3R4LmN0eCAmJiBjdHguY3R4LnJlcylcblxuICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlUHJvcHM6IGF3YWl0IGxvYWRHZXRJbml0aWFsUHJvcHMoY3R4LkNvbXBvbmVudCwgY3R4LmN0eCksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fSBhcyBJUFxuICB9XG5cbiAgY29uc3QgcHJvcHMgPSBhd2FpdCBBcHAuZ2V0SW5pdGlhbFByb3BzKGN0eClcblxuICBpZiAocmVzICYmIGlzUmVzU2VudChyZXMpKSB7XG4gICAgcmV0dXJuIHByb3BzXG4gIH1cblxuICBpZiAoIXByb3BzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICBBcHBcbiAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIHNob3VsZCByZXNvbHZlIHRvIGFuIG9iamVjdC4gQnV0IGZvdW5kIFwiJHtwcm9wc31cIiBpbnN0ZWFkLmBcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYCR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgICAgQXBwXG4gICAgICAgICl9IHJldHVybmVkIGFuIGVtcHR5IG9iamVjdCBmcm9tIFxcYGdldEluaXRpYWxQcm9wc1xcYC4gVGhpcyBkZS1vcHRpbWl6ZXMgYW5kIHByZXZlbnRzIGF1dG9tYXRpYyBzdGF0aWMgb3B0aW1pemF0aW9uLiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9lbXB0eS1vYmplY3QtZ2V0SW5pdGlhbFByb3BzYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wc1xufVxuXG5leHBvcnQgY29uc3QgU1AgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnXG5leHBvcnQgY29uc3QgU1QgPVxuICBTUCAmJlxuICAoWydtYXJrJywgJ21lYXN1cmUnLCAnZ2V0RW50cmllc0J5TmFtZSddIGFzIGNvbnN0KS5ldmVyeShcbiAgICAobWV0aG9kKSA9PiB0eXBlb2YgcGVyZm9ybWFuY2VbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJ1xuICApXG5cbmV4cG9ydCBjbGFzcyBEZWNvZGVFcnJvciBleHRlbmRzIEVycm9yIHt9XG5leHBvcnQgY2xhc3MgTm9ybWFsaXplRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuZXhwb3J0IGNsYXNzIFBhZ2VOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihwYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5jb2RlID0gJ0VOT0VOVCdcbiAgICB0aGlzLm5hbWUgPSAnUGFnZU5vdEZvdW5kRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gYENhbm5vdCBmaW5kIG1vZHVsZSBmb3IgcGFnZTogJHtwYWdlfWBcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWlzc2luZ1N0YXRpY1BhZ2UgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhZ2U6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMubWVzc2FnZSA9IGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgZmlsZSBmb3IgcGFnZTogJHtwYWdlfSAke21lc3NhZ2V9YFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNaWRkbGV3YXJlTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29kZTogc3RyaW5nXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmNvZGUgPSAnRU5PRU5UJ1xuICAgIHRoaXMubWVzc2FnZSA9IGBDYW5ub3QgZmluZCB0aGUgbWlkZGxld2FyZSBtb2R1bGVgXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWNoZUZzIHtcbiAgZXhpc3RzU3luYzogdHlwZW9mIGZzLmV4aXN0c1N5bmNcbiAgcmVhZEZpbGU6IHR5cGVvZiBmcy5wcm9taXNlcy5yZWFkRmlsZVxuICByZWFkRmlsZVN5bmM6IHR5cGVvZiBmcy5yZWFkRmlsZVN5bmNcbiAgd3JpdGVGaWxlKGY6IHN0cmluZywgZDogYW55KTogUHJvbWlzZTx2b2lkPlxuICBta2RpcihkaXI6IHN0cmluZyk6IFByb21pc2U8dm9pZCB8IHN0cmluZz5cbiAgc3RhdChmOiBzdHJpbmcpOiBQcm9taXNlPHsgbXRpbWU6IERhdGUgfT5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeUVycm9yKGVycm9yOiBFcnJvcikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeyBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLCBzdGFjazogZXJyb3Iuc3RhY2sgfSlcbn1cbiJdLCJuYW1lcyI6WyJEZWNvZGVFcnJvciIsIk1pZGRsZXdhcmVOb3RGb3VuZEVycm9yIiwiTWlzc2luZ1N0YXRpY1BhZ2UiLCJOb3JtYWxpemVFcnJvciIsIlBhZ2VOb3RGb3VuZEVycm9yIiwiU1AiLCJTVCIsIldFQl9WSVRBTFMiLCJleGVjT25jZSIsImdldERpc3BsYXlOYW1lIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJnZXRVUkwiLCJpc0Fic29sdXRlVXJsIiwiaXNSZXNTZW50IiwibG9hZEdldEluaXRpYWxQcm9wcyIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsInN0cmluZ2lmeUVycm9yIiwiZm4iLCJ1c2VkIiwicmVzdWx0IiwiYXJncyIsIkFCU09MVVRFX1VSTF9SRUdFWCIsInVybCIsInRlc3QiLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsIm9yaWdpbiIsInN1YnN0cmluZyIsImxlbmd0aCIsIkNvbXBvbmVudCIsImRpc3BsYXlOYW1lIiwibmFtZSIsInJlcyIsImZpbmlzaGVkIiwiaGVhZGVyc1NlbnQiLCJ1cmxQYXJ0cyIsInNwbGl0IiwidXJsTm9RdWVyeSIsInJlcGxhY2UiLCJzbGljZSIsImpvaW4iLCJBcHAiLCJjdHgiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJwcm90b3R5cGUiLCJnZXRJbml0aWFsUHJvcHMiLCJtZXNzYWdlIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJwcm9wcyIsIk9iamVjdCIsImtleXMiLCJjb25zb2xlIiwid2FybiIsInBlcmZvcm1hbmNlIiwiZXZlcnkiLCJtZXRob2QiLCJjb25zdHJ1Y3RvciIsInBhZ2UiLCJjb2RlIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhY2siXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/error-once.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils/error-once.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"errorOnce\", ({\n    enumerable: true,\n    get: function() {\n        return errorOnce;\n    }\n}));\nlet errorOnce = (_)=>{};\nif (true) {\n    const errors = new Set();\n    errorOnce = (msg)=>{\n        if (!errors.has(msg)) {\n            console.error(msg);\n        }\n        errors.add(msg);\n    };\n} //# sourceMappingURL=error-once.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy9lcnJvci1vbmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7NkNBV1NBOzs7ZUFBQUE7OztBQVhULElBQUlBLFlBQVksQ0FBQ0MsS0FBZTtBQUNoQyxJQUFJQyxJQUFvQixFQUFtQjtJQUN6QyxNQUFNRyxTQUFTLElBQUlDO0lBQ25CTixZQUFZLENBQUNPO1FBQ1gsSUFBSSxDQUFDRixPQUFPRyxHQUFHLENBQUNELE1BQU07WUFDcEJFLFFBQVFDLEtBQUssQ0FBQ0g7UUFDaEI7UUFDQUYsT0FBT00sR0FBRyxDQUFDSjtJQUNiO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90aW1vdGh5ZWRpYm8vc3JjL3NoYXJlZC9saWIvdXRpbHMvZXJyb3Itb25jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZXJyb3JPbmNlID0gKF86IHN0cmluZykgPT4ge31cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGNvbnN0IGVycm9ycyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGVycm9yT25jZSA9IChtc2c6IHN0cmluZykgPT4ge1xuICAgIGlmICghZXJyb3JzLmhhcyhtc2cpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1zZylcbiAgICB9XG4gICAgZXJyb3JzLmFkZChtc2cpXG4gIH1cbn1cblxuZXhwb3J0IHsgZXJyb3JPbmNlIH1cbiJdLCJuYW1lcyI6WyJlcnJvck9uY2UiLCJfIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZXJyb3JzIiwiU2V0IiwibXNnIiwiaGFzIiwiY29uc29sZSIsImVycm9yIiwiYWRkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/error-once.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/(dashboard)/inventory/page.tsx":
/*!************************************************!*\
  !*** ./src/app/(dashboard)/inventory/page.tsx ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ InventoryPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var dexie_react_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dexie-react-hooks */ \"(app-pages-browser)/./node_modules/dexie-react-hooks/dist/dexie-react-hooks.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/client/app-dir/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/db */ \"(app-pages-browser)/./src/lib/db.ts\");\n/* harmony import */ var _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/contexts/AuthContext */ \"(app-pages-browser)/./src/contexts/AuthContext.tsx\");\n/* harmony import */ var _hooks_useSyncManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/hooks/useSyncManager */ \"(app-pages-browser)/./src/hooks/useSyncManager.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst DEVICE_KEY = 'bluecounts_device_id';\nfunction getDeviceId() {\n    if (false) {}\n    let id = localStorage.getItem(DEVICE_KEY);\n    if (!id) {\n        id = crypto.randomUUID();\n        localStorage.setItem(DEVICE_KEY, id);\n    }\n    return id;\n}\nfunction InventoryPage() {\n    var _auth_tenant;\n    _s();\n    const auth = (0,_contexts_AuthContext__WEBPACK_IMPORTED_MODULE_5__.useAuth)();\n    var _auth_tenant_id;\n    const tenantId = (_auth_tenant_id = (_auth_tenant = auth.tenant) === null || _auth_tenant === void 0 ? void 0 : _auth_tenant.id) !== null && _auth_tenant_id !== void 0 ? _auth_tenant_id : '';\n    var _auth_outletId;\n    const outletId = (_auth_outletId = auth.outletId) !== null && _auth_outletId !== void 0 ? _auth_outletId : '';\n    const deviceId = getDeviceId();\n    const [productId, setProductId] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)('');\n    const [quantityChange, setQuantityChange] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)('');\n    const [message, setMessage] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    (0,_hooks_useSyncManager__WEBPACK_IMPORTED_MODULE_6__.useSyncManager)({\n        tenantId,\n        outletId,\n        deviceId,\n        enabled: !!tenantId && !!outletId\n    });\n    const products = (0,dexie_react_hooks__WEBPACK_IMPORTED_MODULE_1__.useLiveQuery)({\n        \"InventoryPage.useLiveQuery[products]\": ()=>_lib_db__WEBPACK_IMPORTED_MODULE_4__.db.products.where('tenant_id').equals(tenantId).filter({\n                \"InventoryPage.useLiveQuery[products]\": (p)=>p.deleted_at == null\n            }[\"InventoryPage.useLiveQuery[products]\"]).toArray()\n    }[\"InventoryPage.useLiveQuery[products]\"], [\n        tenantId\n    ]);\n    const inventory = (0,dexie_react_hooks__WEBPACK_IMPORTED_MODULE_1__.useLiveQuery)({\n        \"InventoryPage.useLiveQuery[inventory]\": ()=>_lib_db__WEBPACK_IMPORTED_MODULE_4__.db.inventory.where('[tenant_id+outlet_id]').equals([\n                tenantId,\n                outletId\n            ]).filter({\n                \"InventoryPage.useLiveQuery[inventory]\": (i)=>i.deleted_at == null\n            }[\"InventoryPage.useLiveQuery[inventory]\"]).toArray()\n    }[\"InventoryPage.useLiveQuery[inventory]\"], [\n        tenantId,\n        outletId\n    ]);\n    const getQty = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"InventoryPage.useCallback[getQty]\": (pid)=>{\n            var _inventory_filter;\n            const forProduct = (_inventory_filter = inventory === null || inventory === void 0 ? void 0 : inventory.filter({\n                \"InventoryPage.useCallback[getQty]\": (i)=>i.product_id === pid\n            }[\"InventoryPage.useCallback[getQty]\"])) !== null && _inventory_filter !== void 0 ? _inventory_filter : [];\n            const inv = forProduct.length === 0 ? null : forProduct.reduce({\n                \"InventoryPage.useCallback[getQty]\": (a, b)=>a.version_id > b.version_id ? a : b\n            }[\"InventoryPage.useCallback[getQty]\"]);\n            var _inv_quantity;\n            return (_inv_quantity = inv === null || inv === void 0 ? void 0 : inv.quantity) !== null && _inv_quantity !== void 0 ? _inv_quantity : 0;\n        }\n    }[\"InventoryPage.useCallback[getQty]\"], [\n        inventory\n    ]);\n    const handleAdjust = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"InventoryPage.useCallback[handleAdjust]\": async (e)=>{\n            e.preventDefault();\n            setMessage(null);\n            const change = parseInt(quantityChange, 10);\n            if (!productId || Number.isNaN(change) || change === 0) {\n                setMessage('Select a product and enter a non-zero quantity change.');\n                return;\n            }\n            await _lib_db__WEBPACK_IMPORTED_MODULE_4__.db.sync_queue.add({\n                id: crypto.randomUUID(),\n                action_type: 'ADJUST_STOCK',\n                payload: {\n                    product_id: productId,\n                    quantity_change: change\n                },\n                timestamp: Date.now(),\n                status: 'pending'\n            });\n            setQuantityChange('');\n            setProductId('');\n            setMessage('Adjustment queued. It will sync when online.');\n        }\n    }[\"InventoryPage.useCallback[handleAdjust]\"], [\n        productId,\n        quantityChange\n    ]);\n    if (!auth.token) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"max-w-4xl mx-auto\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"text-slate-400\",\n                    children: \"Sign in to manage inventory.\"\n                }, void 0, false, {\n                    fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                    lineNumber: 96,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_3___default()), {\n                    href: \"/login\",\n                    className: \"text-sky-400 hover:underline mt-2 inline-block\",\n                    children: \"Sign in\"\n                }, void 0, false, {\n                    fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                    lineNumber: 97,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n            lineNumber: 95,\n            columnNumber: 7\n        }, this);\n    }\n    if (!outletId) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"max-w-4xl mx-auto\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"text-slate-400\",\n                children: \"Select an outlet in the sidebar to view and adjust inventory.\"\n            }, void 0, false, {\n                fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                lineNumber: 107,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n            lineNumber: 106,\n            columnNumber: 7\n        }, this);\n    }\n    const productList = products !== null && products !== void 0 ? products : [];\n    const inventoryByProduct = productList.map((p)=>({\n            product: p,\n            quantity: getQty(p.id)\n        }));\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"max-w-4xl mx-auto space-y-6\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                className: \"border-b border-slate-600 pb-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                    className: \"text-2xl font-bold text-slate-100\",\n                    children: \"Inventory\"\n                }, void 0, false, {\n                    fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                    lineNumber: 121,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                lineNumber: 120,\n                columnNumber: 7\n            }, this),\n            message && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"rounded-lg bg-sky-500/15 border border-sky-500/30 px-4 py-2 text-sm text-sky-400\",\n                children: message\n            }, void 0, false, {\n                fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                lineNumber: 125,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: \"rounded-xl bg-slate-800/50 border border-slate-700 p-4\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-lg font-semibold text-slate-200 mb-3\",\n                        children: \"Adjust stock\"\n                    }, void 0, false, {\n                        fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                        lineNumber: 131,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-slate-400 text-sm mb-4\",\n                        children: \"Changes are queued and synced when online. Use a positive value to add, negative to remove.\"\n                    }, void 0, false, {\n                        fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                        lineNumber: 132,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                        onSubmit: handleAdjust,\n                        className: \"flex flex-wrap items-end gap-3\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        htmlFor: \"product\",\n                                        className: \"block text-sm text-slate-400 mb-1\",\n                                        children: \"Product\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                                        lineNumber: 137,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                        id: \"product\",\n                                        value: productId,\n                                        onChange: (e)=>setProductId(e.target.value),\n                                        className: \"rounded-lg bg-slate-700 border border-slate-600 px-3 py-2 text-slate-200\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                value: \"\",\n                                                children: \"Select\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                                                lineNumber: 146,\n                                                columnNumber: 15\n                                            }, this),\n                                            productList.map((p)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: p.id,\n                                                    children: [\n                                                        p.name,\n                                                        \" (current: \",\n                                                        getQty(p.id),\n                                                        \")\"\n                                                    ]\n                                                }, p.id, true, {\n                                                    fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                                                    lineNumber: 148,\n                                                    columnNumber: 17\n                                                }, this))\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                                        lineNumber: 140,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                                lineNumber: 136,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        htmlFor: \"qty_change\",\n                                        className: \"block text-sm text-slate-400 mb-1\",\n                                        children: \"Quantity change\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                                        lineNumber: 155,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        id: \"qty_change\",\n                                        type: \"number\",\n                                        value: quantityChange,\n                                        onChange: (e)=>setQuantityChange(e.target.value),\n                                        placeholder: \"+10 or -5\",\n                                        className: \"rounded-lg bg-slate-700 border border-slate-600 px-3 py-2 text-slate-200 w-32\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                                        lineNumber: 158,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                                lineNumber: 154,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                type: \"submit\",\n                                className: \"rounded-lg bg-amber-600 px-4 py-2 text-sm font-medium text-white hover:bg-amber-500\",\n                                children: \"Apply\"\n                            }, void 0, false, {\n                                fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                                lineNumber: 167,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                        lineNumber: 135,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                lineNumber: 130,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: \"rounded-xl bg-slate-800/50 border border-slate-700 p-4\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-lg font-semibold text-slate-200 mb-3\",\n                        children: \"Current stock\"\n                    }, void 0, false, {\n                        fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                        lineNumber: 177,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                        className: \"space-y-2\",\n                        children: [\n                            inventoryByProduct.map((param)=>{\n                                let { product, quantity } = param;\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                    className: \"flex justify-between text-sm\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-slate-300\",\n                                            children: product.name\n                                        }, void 0, false, {\n                                            fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                                            lineNumber: 181,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-slate-200 font-medium\",\n                                            children: quantity\n                                        }, void 0, false, {\n                                            fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                                            lineNumber: 182,\n                                            columnNumber: 15\n                                        }, this)\n                                    ]\n                                }, product.id, true, {\n                                    fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                                    lineNumber: 180,\n                                    columnNumber: 13\n                                }, this);\n                            }),\n                            inventoryByProduct.length === 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-slate-500 text-sm\",\n                                children: \"No products for this outlet.\"\n                            }, void 0, false, {\n                                fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                                lineNumber: 186,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                        lineNumber: 178,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n                lineNumber: 176,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/app/(dashboard)/inventory/page.tsx\",\n        lineNumber: 119,\n        columnNumber: 5\n    }, this);\n}\n_s(InventoryPage, \"HSDiNaYeW1aimrnRah/6nJBdb1U=\", false, function() {\n    return [\n        _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_5__.useAuth,\n        _hooks_useSyncManager__WEBPACK_IMPORTED_MODULE_6__.useSyncManager,\n        dexie_react_hooks__WEBPACK_IMPORTED_MODULE_1__.useLiveQuery,\n        dexie_react_hooks__WEBPACK_IMPORTED_MODULE_1__.useLiveQuery\n    ];\n});\n_c = InventoryPage;\nvar _c;\n$RefreshReg$(_c, \"InventoryPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvKGRhc2hib2FyZCkvaW52ZW50b3J5L3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVpRDtBQUNIO0FBQ2pCO0FBQ0M7QUFDbUI7QUFDTztBQUV4RCxNQUFNTyxhQUFhO0FBRW5CLFNBQVNDO0lBQ1AsSUFBSSxLQUE2QixFQUFFLEVBQVU7SUFDN0MsSUFBSUMsS0FBS0MsYUFBYUMsT0FBTyxDQUFDSjtJQUM5QixJQUFJLENBQUNFLElBQUk7UUFDUEEsS0FBS0csT0FBT0MsVUFBVTtRQUN0QkgsYUFBYUksT0FBTyxDQUFDUCxZQUFZRTtJQUNuQztJQUNBLE9BQU9BO0FBQ1Q7QUFFZSxTQUFTTTtRQUVMQzs7SUFEakIsTUFBTUEsT0FBT1gsOERBQU9BO1FBQ0hXO0lBQWpCLE1BQU1DLFdBQVdELENBQUFBLG1CQUFBQSxlQUFBQSxLQUFLRSxNQUFNLGNBQVhGLG1DQUFBQSxhQUFhUCxFQUFFLGNBQWZPLDZCQUFBQSxrQkFBbUI7UUFDbkJBO0lBQWpCLE1BQU1HLFdBQVdILENBQUFBLGlCQUFBQSxLQUFLRyxRQUFRLGNBQWJILDRCQUFBQSxpQkFBaUI7SUFDbEMsTUFBTUksV0FBV1o7SUFDakIsTUFBTSxDQUFDYSxXQUFXQyxhQUFhLEdBQUdwQiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNxQixnQkFBZ0JDLGtCQUFrQixHQUFHdEIsK0NBQVFBLENBQUM7SUFDckQsTUFBTSxDQUFDdUIsU0FBU0MsV0FBVyxHQUFHeEIsK0NBQVFBLENBQWdCO0lBRXRESSxxRUFBY0EsQ0FBQztRQUNiVztRQUNBRTtRQUNBQztRQUNBTyxTQUFTLENBQUMsQ0FBQ1YsWUFBWSxDQUFDLENBQUNFO0lBQzNCO0lBRUEsTUFBTVMsV0FBVzVCLCtEQUFZQTtnREFDM0IsSUFDRUksdUNBQUVBLENBQUN3QixRQUFRLENBQ1JDLEtBQUssQ0FBQyxhQUNOQyxNQUFNLENBQUNiLFVBQ1BjLE1BQU07d0RBQUMsQ0FBQ0Ms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QThCbkI7Ozs7Ozs7bUNBRnZDd0IsUUFBUTlELEVBQUU7Ozs7Ozs0QkFLcEI0RCxtQkFBbUIzQixNQUFNLEtBQUssbUJBQzdCLDhEQUFDVjtnQ0FBRWtDLFdBQVU7MENBQXlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNbEQ7R0ExS3dCbkQ7O1FBQ1RWLDBEQUFPQTtRQVFwQkMsaUVBQWNBO1FBT0dOLDJEQUFZQTtRQVVYQSwyREFBWUE7OztLQTFCUmUiLCJzb3VyY2VzIjpbIi9Vc2Vycy90aW1vdGh5ZWRpYm8vcHJvamVjdHMvcGVyc29uYWwvYmx1ZWNvdW50cy9mcm9udGVuZC9zcmMvYXBwLyhkYXNoYm9hcmQpL2ludmVudG9yeS9wYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUxpdmVRdWVyeSB9IGZyb20gJ2RleGllLXJlYWN0LWhvb2tzJztcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBMaW5rIGZyb20gJ25leHQvbGluayc7XG5pbXBvcnQgeyBkYiB9IGZyb20gJ0AvbGliL2RiJztcbmltcG9ydCB7IHVzZUF1dGggfSBmcm9tICdAL2NvbnRleHRzL0F1dGhDb250ZXh0JztcbmltcG9ydCB7IHVzZVN5bmNNYW5hZ2VyIH0gZnJvbSAnQC9ob29rcy91c2VTeW5jTWFuYWdlcic7XG5cbmNvbnN0IERFVklDRV9LRVkgPSAnYmx1ZWNvdW50c19kZXZpY2VfaWQnO1xuXG5mdW5jdGlvbiBnZXREZXZpY2VJZCgpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAnJztcbiAgbGV0IGlkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oREVWSUNFX0tFWSk7XG4gIGlmICghaWQpIHtcbiAgICBpZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oREVWSUNFX0tFWSwgaWQpO1xuICB9XG4gIHJldHVybiBpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSW52ZW50b3J5UGFnZSgpIHtcbiAgY29uc3QgYXV0aCA9IHVzZUF1dGgoKTtcbiAgY29uc3QgdGVuYW50SWQgPSBhdXRoLnRlbmFudD8uaWQgPz8gJyc7XG4gIGNvbnN0IG91dGxldElkID0gYXV0aC5vdXRsZXRJZCA/PyAnJztcbiAgY29uc3QgZGV2aWNlSWQgPSBnZXREZXZpY2VJZCgpO1xuICBjb25zdCBbcHJvZHVjdElkLCBzZXRQcm9kdWN0SWRdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbcXVhbnRpdHlDaGFuZ2UsIHNldFF1YW50aXR5Q2hhbmdlXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW21lc3NhZ2UsIHNldE1lc3NhZ2VdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlU3luY01hbmFnZXIoe1xuICAgIHRlbmFudElkLFxuICAgIG91dGxldElkLFxuICAgIGRldmljZUlkLFxuICAgIGVuYWJsZWQ6ICEhdGVuYW50SWQgJiYgISFvdXRsZXRJZCxcbiAgfSk7XG5cbiAgY29uc3QgcHJvZHVjdHMgPSB1c2VMaXZlUXVlcnkoXG4gICAgKCkgPT5cbiAgICAgIGRiLnByb2R1Y3RzXG4gICAgICAgIC53aGVyZSgndGVuYW50X2lkJylcbiAgICAgICAgLmVxdWFscyh0ZW5hbnRJZClcbiAgICAgICAgLmZpbHRlcigocCkgPT4gcC5kZWxldGVkX2F0ID09IG51bGwpXG4gICAgICAgIC50b0FycmF5KCksXG4gICAgW3RlbmFudElkXVxuICApO1xuXG4gIGNvbnN0IGludmVudG9yeSA9IHVzZUxpdmVRdWVyeShcbiAgICAoKSA9PlxuICAgICAgZGIuaW52ZW50b3J5XG4gICAgICAgIC53aGVyZSgnW3RlbmFudF9pZCtvdXRsZXRfaWRdJylcbiAgICAgICAgLmVxdWFscyhbdGVuYW50SWQsIG91dGxldElkXSlcbiAgICAgICAgLmZpbHRlcigoaSkgPT4gaS5kZWxldGVkX2F0ID09IG51bGwpXG4gICAgICAgIC50b0FycmF5KCksXG4gICAgW3RlbmFudElkLCBvdXRsZXRJZF1cbiAgKTtcblxuICBjb25zdCBnZXRRdHkgPSB1c2VDYWxsYmFjayhcbiAgICAocGlkOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGZvclByb2R1Y3QgPSBpbnZlbnRvcnk/LmZpbHRlcigoaSkgPT4gaS5wcm9kdWN0X2lkID09PSBwaWQpID8/IFtdO1xuICAgICAgY29uc3QgaW52ID1cbiAgICAgICAgZm9yUHJvZHVjdC5sZW5ndGggPT09IDBcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IGZvclByb2R1Y3QucmVkdWNlKChhLCBiKSA9PiAoYS52ZXJzaW9uX2lkID4gYi52ZXJzaW9uX2lkID8gYSA6IGIpKTtcbiAgICAgIHJldHVybiBpbnY/LnF1YW50aXR5ID8/IDA7XG4gICAgfSxcbiAgICBbaW52ZW50b3J5XVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUFkanVzdCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChlOiBSZWFjdC5Gb3JtRXZlbnQpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNldE1lc3NhZ2UobnVsbCk7XG4gICAgICBjb25zdCBjaGFuZ2UgPSBwYXJzZUludChxdWFudGl0eUNoYW5nZSwgMTApO1xuICAgICAgaWYgKCFwcm9kdWN0SWQgfHwgTnVtYmVyLmlzTmFOKGNoYW5nZSkgfHwgY2hhbmdlID09PSAwKSB7XG4gICAgICAgIHNldE1lc3NhZ2UoJ1NlbGVjdCBhIHByb2R1Y3QgYW5kIGVudGVyIGEgbm9uLXplcm8gcXVhbnRpdHkgY2hhbmdlLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCBkYi5zeW5jX3F1ZXVlLmFkZCh7XG4gICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICBhY3Rpb25fdHlwZTogJ0FESlVTVF9TVE9DSycsXG4gICAgICAgIHBheWxvYWQ6IHsgcHJvZHVjdF9pZDogcHJvZHVjdElkLCBxdWFudGl0eV9jaGFuZ2U6IGNoYW5nZSB9LFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgfSk7XG4gICAgICBzZXRRdWFudGl0eUNoYW5nZSgnJyk7XG4gICAgICBzZXRQcm9kdWN0SWQoJycpO1xuICAgICAgc2V0TWVzc2FnZSgnQWRqdXN0bWVudCBxdWV1ZWQuIEl0IHdpbGwgc3luYyB3aGVuIG9ubGluZS4nKTtcbiAgICB9LFxuICAgIFtwcm9kdWN0SWQsIHF1YW50aXR5Q2hhbmdlXVxuICApO1xuXG4gIGlmICghYXV0aC50b2tlbikge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1heC13LTR4bCBteC1hdXRvXCI+XG4gICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc2xhdGUtNDAwXCI+U2lnbiBpbiB0byBtYW5hZ2UgaW52ZW50b3J5LjwvcD5cbiAgICAgICAgPExpbmsgaHJlZj1cIi9sb2dpblwiIGNsYXNzTmFtZT1cInRleHQtc2t5LTQwMCBob3Zlcjp1bmRlcmxpbmUgbXQtMiBpbmxpbmUtYmxvY2tcIj5cbiAgICAgICAgICBTaWduIGluXG4gICAgICAgIDwvTGluaz5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICBpZiAoIW91dGxldElkKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWF4LXctNHhsIG14LWF1dG9cIj5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbGF0ZS00MDBcIj5TZWxlY3QgYW4gb3V0bGV0IGluIHRoZSBzaWRlYmFyIHRvIHZpZXcgYW5kIGFkanVzdCBpbnZlbnRvcnkuPC9wPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHByb2R1Y3RMaXN0ID0gcHJvZHVjdHMgPz8gW107XG4gIGNvbnN0IGludmVudG9yeUJ5UHJvZHVjdCA9IHByb2R1Y3RMaXN0Lm1hcCgocCkgPT4gKHtcbiAgICBwcm9kdWN0OiBwLFxuICAgIHF1YW50aXR5OiBnZXRRdHkocC5pZCksXG4gIH0pKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwibWF4LXctNHhsIG14LWF1dG8gc3BhY2UteS02XCI+XG4gICAgICA8aGVhZGVyIGNsYXNzTmFtZT1cImJvcmRlci1iIGJvcmRlci1zbGF0ZS02MDAgcGItNFwiPlxuICAgICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1ib2xkIHRleHQtc2xhdGUtMTAwXCI+SW52ZW50b3J5PC9oMT5cbiAgICAgIDwvaGVhZGVyPlxuXG4gICAgICB7bWVzc2FnZSAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm91bmRlZC1sZyBiZy1za3ktNTAwLzE1IGJvcmRlciBib3JkZXItc2t5LTUwMC8zMCBweC00IHB5LTIgdGV4dC1zbSB0ZXh0LXNreS00MDBcIj5cbiAgICAgICAgICB7bWVzc2FnZX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuXG4gICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJyb3VuZGVkLXhsIGJnLXNsYXRlLTgwMC81MCBib3JkZXIgYm9yZGVyLXNsYXRlLTcwMCBwLTRcIj5cbiAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1zZW1pYm9sZCB0ZXh0LXNsYXRlLTIwMCBtYi0zXCI+QWRqdXN0IHN0b2NrPC9oMj5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbGF0ZS00MDAgdGV4dC1zbSBtYi00XCI+XG4gICAgICAgICAgQ2hhbmdlcyBhcmUgcXVldWVkIGFuZCBzeW5jZWQgd2hlbiBvbmxpbmUuIFVzZSBhIHBvc2l0aXZlIHZhbHVlIHRvIGFkZCwgbmVnYXRpdmUgdG8gcmVtb3ZlLlxuICAgICAgICA8L3A+XG4gICAgICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVBZGp1c3R9IGNsYXNzTmFtZT1cImZsZXggZmxleC13cmFwIGl0ZW1zLWVuZCBnYXAtM1wiPlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cInByb2R1Y3RcIiBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtIHRleHQtc2xhdGUtNDAwIG1iLTFcIj5cbiAgICAgICAgICAgICAgUHJvZHVjdFxuICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgIDxzZWxlY3RcbiAgICAgICAgICAgICAgaWQ9XCJwcm9kdWN0XCJcbiAgICAgICAgICAgICAgdmFsdWU9e3Byb2R1Y3RJZH1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRQcm9kdWN0SWQoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyb3VuZGVkLWxnIGJnLXNsYXRlLTcwMCBib3JkZXIgYm9yZGVyLXNsYXRlLTYwMCBweC0zIHB5LTIgdGV4dC1zbGF0ZS0yMDBcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCI+U2VsZWN0PC9vcHRpb24+XG4gICAgICAgICAgICAgIHtwcm9kdWN0TGlzdC5tYXAoKHApID0+IChcbiAgICAgICAgICAgICAgICA8b3B0aW9uIGtleT17cC5pZH0gdmFsdWU9e3AuaWR9PlxuICAgICAgICAgICAgICAgICAge3AubmFtZX0gKGN1cnJlbnQ6IHtnZXRRdHkocC5pZCl9KVxuICAgICAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cInF0eV9jaGFuZ2VcIiBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtIHRleHQtc2xhdGUtNDAwIG1iLTFcIj5cbiAgICAgICAgICAgICAgUXVhbnRpdHkgY2hhbmdlXG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIGlkPVwicXR5X2NoYW5nZVwiXG4gICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgICB2YWx1ZT17cXVhbnRpdHlDaGFuZ2V9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0UXVhbnRpdHlDaGFuZ2UoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIisxMCBvciAtNVwiXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInJvdW5kZWQtbGcgYmctc2xhdGUtNzAwIGJvcmRlciBib3JkZXItc2xhdGUtNjAwIHB4LTMgcHktMiB0ZXh0LXNsYXRlLTIwMCB3LTMyXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJyb3VuZGVkLWxnIGJnLWFtYmVyLTYwMCBweC00IHB5LTIgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LXdoaXRlIGhvdmVyOmJnLWFtYmVyLTUwMFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgQXBwbHlcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9mb3JtPlxuICAgICAgPC9zZWN0aW9uPlxuXG4gICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJyb3VuZGVkLXhsIGJnLXNsYXRlLTgwMC81MCBib3JkZXIgYm9yZGVyLXNsYXRlLTcwMCBwLTRcIj5cbiAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1zZW1pYm9sZCB0ZXh0LXNsYXRlLTIwMCBtYi0zXCI+Q3VycmVudCBzdG9jazwvaDI+XG4gICAgICAgIDx1bCBjbGFzc05hbWU9XCJzcGFjZS15LTJcIj5cbiAgICAgICAgICB7aW52ZW50b3J5QnlQcm9kdWN0Lm1hcCgoeyBwcm9kdWN0LCBxdWFudGl0eSB9KSA9PiAoXG4gICAgICAgICAgICA8bGkga2V5PXtwcm9kdWN0LmlkfSBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlbiB0ZXh0LXNtXCI+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc2xhdGUtMzAwXCI+e3Byb2R1Y3QubmFtZX08L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc2xhdGUtMjAwIGZvbnQtbWVkaXVtXCI+e3F1YW50aXR5fTwvc3Bhbj5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgKSl9XG4gICAgICAgICAge2ludmVudG9yeUJ5UHJvZHVjdC5sZW5ndGggPT09IDAgJiYgKFxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbGF0ZS01MDAgdGV4dC1zbVwiPk5vIHByb2R1Y3RzIGZvciB0aGlzIG91dGxldC48L3A+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvc2VjdGlvbj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VMaXZlUXVlcnkiLCJ1c2VDYWxsYmFjayIsInVzZVN0YXRlIiwiTGluayIsImRiIiwidXNlQXV0aCIsInVzZVN5bmNNYW5hZ2VyIiwiREVWSUNFX0tFWSIsImdldERldmljZUlkIiwiaWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsInNldEl0ZW0iLCJJbnZlbnRvcnlQYWdlIiwiYXV0aCIsInRlbmFudElkIiwidGVuYW50Iiwib3V0bGV0SWQiLCJkZXZpY2VJZCIsInByb2R1Y3RJZCIsInNldFByb2R1Y3RJZCIsInF1YW50aXR5Q2hhbmdlIiwic2V0UXVhbnRpdHlDaGFuZ2UiLCJtZXNzYWdlIiwic2V0TWVzc2FnZSIsImVuYWJsZWQiLCJwcm9kdWN0cyIsIndoZXJlIiwiZXF1YWxzIiwiZmlsdGVyIiwicCIsImRlbGV0ZWRfYXQiLCJ0b0FycmF5IiwiaW52ZW50b3J5IiwiaSIsImdldFF0eSIsInBpZCIsImZvclByb2R1Y3QiLCJwcm9kdWN0X2lkIiwiaW52IiwibGVuZ3RoIiwicmVkdWNlIiwiYSIsImIiLCJ2ZXJzaW9uX2lkIiwicXVhbnRpdHkiLCJoYW5kbGVBZGp1c3QiLCJlIiwicHJldmVudERlZmF1bHQiLCJjaGFuZ2UiLCJwYXJzZUludCIsIk51bWJlciIsImlzTmFOIiwic3luY19xdWV1ZSIsImFkZCIsImFjdGlvbl90eXBlIiwicGF5bG9hZCIsInF1YW50aXR5X2NoYW5nZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJzdGF0dXMiLCJ0b2tlbiIsImRpdiIsImNsYXNzTmFtZSIsImhyZWYiLCJwcm9kdWN0TGlzdCIsImludmVudG9yeUJ5UHJvZHVjdCIsIm1hcCIsInByb2R1Y3QiLCJoZWFkZXIiLCJoMSIsInNlY3Rpb24iLCJoMiIsImZvcm0iLCJvblN1Ym1pdCIsImxhYmVsIiwiaHRtbEZvciIsInNlbGVjdCIsInZhbHVlIiwib25DaGFuZ2UiLCJ0YXJnZXQiLCJvcHRpb24iLCJuYW1lIiwiaW5wdXQiLCJ0eXBlIiwicGxhY2Vob2xkZXIiLCJidXR0b24iLCJ1bCIsImxpIiwic3BhbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/(dashboard)/inventory/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/contexts/AuthContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/AuthContext.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   getAuthToken: () => (/* binding */ getAuthToken),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth,getAuthToken auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';\nconst STORAGE_KEY = 'bluecounts_auth';\nconst defaultState = {\n    user: null,\n    tenant: null,\n    role: '',\n    outletId: null,\n    token: null\n};\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nfunction loadStored() {\n    if (false) {}\n    try {\n        var _data_tenant;\n        const raw = localStorage.getItem(STORAGE_KEY);\n        if (!raw) return defaultState;\n        const data = JSON.parse(raw);\n        if ((data === null || data === void 0 ? void 0 : data.token) && (data === null || data === void 0 ? void 0 : (_data_tenant = data.tenant) === null || _data_tenant === void 0 ? void 0 : _data_tenant.id)) {\n            var _data_user, _data_tenant1, _data_role, _data_outletId;\n            return {\n                user: (_data_user = data.user) !== null && _data_user !== void 0 ? _data_user : null,\n                tenant: (_data_tenant1 = data.tenant) !== null && _data_tenant1 !== void 0 ? _data_tenant1 : null,\n                role: (_data_role = data.role) !== null && _data_role !== void 0 ? _data_role : '',\n                outletId: (_data_outletId = data.outletId) !== null && _data_outletId !== void 0 ? _data_outletId : null,\n                token: data.token\n            };\n        }\n    } catch (e) {\n    // ignore\n    }\n    return defaultState;\n}\nfunction saveStored(state) {\n    if (false) {}\n    if (state.token && state.tenant) {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));\n    } else {\n        localStorage.removeItem(STORAGE_KEY);\n    }\n}\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(defaultState);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            setState(loadStored());\n        }\n    }[\"AuthProvider.useEffect\"], []);\n    const setAuth = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[setAuth]\": (next)=>{\n            setState(next);\n            saveStored(next);\n        }\n    }[\"AuthProvider.useCallback[setAuth]\"], []);\n    const login = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[login]\": async (email, password)=>{\n            const res = await fetch(\"\".concat(API_BASE, \"/auth/login\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    email,\n                    password\n                })\n            });\n            if (!res.ok) {\n                const err = await res.json().catch({\n                    \"AuthProvider.useCallback[login]\": ()=>({})\n                }[\"AuthProvider.useCallback[login]\"]);\n                throw new Error(err.error || 'Login failed');\n            }\n            const data = await res.json();\n            var _data_outletId;\n            setAuth({\n                user: data.user,\n                tenant: data.tenant,\n                role: data.role,\n                outletId: (_data_outletId = data.outletId) !== null && _data_outletId !== void 0 ? _data_outletId : null,\n                token: data.token\n            });\n        }\n    }[\"AuthProvider.useCallback[login]\"], [\n        setAuth\n    ]);\n    const register = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[register]\": async (email, password, businessName)=>{\n            const res = await fetch(\"\".concat(API_BASE, \"/auth/register\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    email,\n                    password,\n                    businessName\n                })\n            });\n            if (!res.ok) {\n                const err = await res.json().catch({\n                    \"AuthProvider.useCallback[register]\": ()=>({})\n                }[\"AuthProvider.useCallback[register]\"]);\n                throw new Error(err.error || 'Registration failed');\n            }\n            const data = await res.json();\n            setAuth({\n                user: data.user,\n                tenant: data.tenant,\n                role: data.role,\n                outletId: null,\n                token: data.token\n            });\n        }\n    }[\"AuthProvider.useCallback[register]\"], [\n        setAuth\n    ]);\n    const logout = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[logout]\": ()=>{\n            setAuth(defaultState);\n        }\n    }[\"AuthProvider.useCallback[logout]\"], [\n        setAuth\n    ]);\n    const setOutletId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[setOutletId]\": (outletId)=>{\n            setState({\n                \"AuthProvider.useCallback[setOutletId]\": (prev)=>{\n                    const next = {\n                        ...prev,\n                        outletId\n                    };\n                    saveStored(next);\n                    return next;\n                }\n            }[\"AuthProvider.useCallback[setOutletId]\"]);\n        }\n    }[\"AuthProvider.useCallback[setOutletId]\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            ...state,\n            login,\n            register,\n            logout,\n            setOutletId,\n            setAuth\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/timothyedibo/projects/personal/bluecounts/frontend/src/contexts/AuthContext.tsx\",\n        lineNumber: 140,\n        columnNumber: 5\n    }, this);\n}\n_s(AuthProvider, \"2awu1ccSGhBdzBJ7XL6nRg67ihU=\");\n_c = AuthProvider;\nfunction useAuth() {\n    _s1();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (!ctx) throw new Error('useAuth must be used within AuthProvider');\n    return ctx;\n}\n_s1(useAuth, \"/dMy7t63NXD4eYACoT93CePwGrg=\");\nfunction getAuthToken() {\n    if (false) {}\n    try {\n        const raw = localStorage.getItem(STORAGE_KEY);\n        if (!raw) return null;\n        const data = JSON.parse(raw);\n        var _data_token;\n        return (_data_token = data === null || data === void 0 ? void 0 : data.token) !== null && _data_token !== void 0 ? _data_token : null;\n    } catch (e) {\n        return null;\n    }\n}\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9BdXRoQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRW9GO0FBRXBGLE1BQU1LLFdBQVdDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLElBQUk7QUFDcEQsTUFBTUMsY0FBYztBQTZCcEIsTUFBTUMsZUFBMEI7SUFDOUJDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxNQUFNO0lBQ05DLFVBQVU7SUFDVkMsT0FBTztBQUNUO0FBRUEsTUFBTUMsNEJBQWNoQixvREFBYUEsQ0FBMEI7QUFFM0QsU0FBU2lCO0lBQ1AsSUFBSSxLQUE2QixFQUFFLEVBQW9CUDtJQUN2RCxJQUFJO1lBSWlCUTtRQUhuQixNQUFNQyxNQUFNQyxhQUFhQyxPQUFPLENBQUNaO1FBQ2pDLElBQUksQ0FBQ1UsS0FBSyxPQUFPVDtRQUNqQixNQUFNUSxPQUFPSSxLQUFLQyxLQUFLLENBQUNKO1FBQ3hCLElBQUlELENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTUgsS0FBSyxNQUFJRyxpQkFBQUEsNEJBQUFBLGVBQUFBLEtBQU1OLE1BQU0sY0FBWk0sbUNBQUFBLGFBQWNNLEVBQUUsR0FBRTtnQkFFM0JOLFlBQ0VBLGVBQ0ZBLFlBQ0lBO1lBSlosT0FBTztnQkFDTFAsTUFBTU8sQ0FBQUEsYUFBQUEsS0FBS1AsSUFBSSxjQUFUTyx3QkFBQUEsYUFBYTtnQkFDbkJOLFFBQVFNLENBQUFBLGdCQUFBQSxLQUFLTixNQUFNLGNBQVhNLDJCQUFBQSxnQkFBZTtnQkFDdkJMLE1BQU1LLENBQUFBLGFBQUFBLEtBQUtMLElBQUksY0FBVEssd0JBQUFBLGFBQWE7Z0JBQ25CSixVQUFVSSxDQUFBQSxpQkFBQUEsS0FBS0osUUFBUSxjQUFiSSw0QkFBQUEsaUJBQWlCO2dCQUMzQkgsT0FBT0csS0FBS0gsS0FBSztZQUNuQjtRQUNGO0lBQ0YsRUFBRSxVQUFNO0lBQ04sU0FBUztJQUNYO0lBQ0EsT0FBT0w7QUFDVDtBQUVBLFNB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WUFDTCxHQUFHN0IsS0FBSztZQUNSUztZQUNBYztZQUNBRTtZQUNBQztZQUNBbkI7UUFDRjtrQkFFQ0Y7Ozs7OztBQUdQO0dBOUVnQkQ7S0FBQUE7QUFnRlQsU0FBUzBCOztJQUNkLE1BQU1DLE1BQU12RCxpREFBVUEsQ0FBQ2M7SUFDdkIsSUFBSSxDQUFDeUMsS0FBSyxNQUFNLElBQUlWLE1BQU07SUFDMUIsT0FBT1U7QUFDVDtJQUpnQkQ7QUFNVCxTQUFTRTtJQUNkLElBQUksS0FBNkIsRUFBRSxFQUFZO0lBQy9DLElBQUk7UUFDRixNQUFNdkMsTUFBTUMsYUFBYUMsT0FBTyxDQUFDWjtRQUNqQyxJQUFJLENBQUNVLEtBQUssT0FBTztRQUNqQixNQUFNRCxPQUFPSSxLQUFLQyxLQUFLLENBQUNKO1lBQ2pCRDtRQUFQLE9BQU9BLENBQUFBLGNBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTUgsS0FBSyxjQUFYRyx5QkFBQUEsY0FBZTtJQUN4QixFQUFFLFVBQU07UUFDTixPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3RpbW90aHllZGliby9wcm9qZWN0cy9wZXJzb25hbC9ibHVlY291bnRzL2Zyb250ZW5kL3NyYy9jb250ZXh0cy9BdXRoQ29udGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgQVBJX0JBU0UgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDEnO1xuY29uc3QgU1RPUkFHRV9LRVkgPSAnYmx1ZWNvdW50c19hdXRoJztcblxuZXhwb3J0IGludGVyZmFjZSBBdXRoVXNlciB7XG4gIGlkOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aFRlbmFudCB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRoU3RhdGUge1xuICB1c2VyOiBBdXRoVXNlciB8IG51bGw7XG4gIHRlbmFudDogQXV0aFRlbmFudCB8IG51bGw7XG4gIHJvbGU6IHN0cmluZztcbiAgb3V0bGV0SWQ6IHN0cmluZyB8IG51bGw7XG4gIHRva2VuOiBzdHJpbmcgfCBudWxsO1xufVxuXG5pbnRlcmZhY2UgQXV0aENvbnRleHRWYWx1ZSBleHRlbmRzIEF1dGhTdGF0ZSB7XG4gIGxvZ2luOiAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcmVnaXN0ZXI6IChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCBidXNpbmVzc05hbWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgbG9nb3V0OiAoKSA9PiB2b2lkO1xuICBzZXRPdXRsZXRJZDogKG91dGxldElkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRBdXRoOiAoc3RhdGU6IEF1dGhTdGF0ZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgZGVmYXVsdFN0YXRlOiBBdXRoU3RhdGUgPSB7XG4gIHVzZXI6IG51bGwsXG4gIHRlbmFudDogbnVsbCxcbiAgcm9sZTogJycsXG4gIG91dGxldElkOiBudWxsLFxuICB0b2tlbjogbnVsbCxcbn07XG5cbmNvbnN0IEF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdXRoQ29udGV4dFZhbHVlIHwgbnVsbD4obnVsbCk7XG5cbmZ1bmN0aW9uIGxvYWRTdG9yZWQoKTogQXV0aFN0YXRlIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZGVmYXVsdFN0YXRlO1xuICB0cnkge1xuICAgIGNvbnN0IHJhdyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZKTtcbiAgICBpZiAoIXJhdykgcmV0dXJuIGRlZmF1bHRTdGF0ZTtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShyYXcpO1xuICAgIGlmIChkYXRhPy50b2tlbiAmJiBkYXRhPy50ZW5hbnQ/LmlkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1c2VyOiBkYXRhLnVzZXIgPz8gbnVsbCxcbiAgICAgICAgdGVuYW50OiBkYXRhLnRlbmFudCA/PyBudWxsLFxuICAgICAgICByb2xlOiBkYXRhLnJvbGUgPz8gJycsXG4gICAgICAgIG91dGxldElkOiBkYXRhLm91dGxldElkID8/IG51bGwsXG4gICAgICAgIHRva2VuOiBkYXRhLnRva2VuLFxuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIC8vIGlnbm9yZVxuICB9XG4gIHJldHVybiBkZWZhdWx0U3RhdGU7XG59XG5cbmZ1bmN0aW9uIHNhdmVTdG9yZWQoc3RhdGU6IEF1dGhTdGF0ZSkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgaWYgKHN0YXRlLnRva2VuICYmIHN0YXRlLnRlbmFudCkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICB9IGVsc2Uge1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfS0VZKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQXV0aFByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxBdXRoU3RhdGU+KGRlZmF1bHRTdGF0ZSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRTdGF0ZShsb2FkU3RvcmVkKCkpO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgc2V0QXV0aCA9IHVzZUNhbGxiYWNrKChuZXh0OiBBdXRoU3RhdGUpID0+IHtcbiAgICBzZXRTdGF0ZShuZXh0KTtcbiAgICBzYXZlU3RvcmVkKG5leHQpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgbG9naW4gPSB1c2VDYWxsYmFjayhhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFfS9hdXRoL2xvZ2luYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwsIHBhc3N3b3JkIH0pLFxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICBjb25zdCBlcnIgPSBhd2FpdCByZXMuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVyci5lcnJvciB8fCAnTG9naW4gZmFpbGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHNldEF1dGgoe1xuICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgdGVuYW50OiBkYXRhLnRlbmFudCxcbiAgICAgIHJvbGU6IGRhdGEucm9sZSxcbiAgICAgIG91dGxldElkOiBkYXRhLm91dGxldElkID8/IG51bGwsXG4gICAgICB0b2tlbjogZGF0YS50b2tlbixcbiAgICB9KTtcbiAgfSwgW3NldEF1dGhdKTtcblxuICBjb25zdCByZWdpc3RlciA9IHVzZUNhbGxiYWNrKGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCBidXNpbmVzc05hbWU6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFfS9hdXRoL3JlZ2lzdGVyYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwsIHBhc3N3b3JkLCBidXNpbmVzc05hbWUgfSksXG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IGVyciA9IGF3YWl0IHJlcy5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyLmVycm9yIHx8ICdSZWdpc3RyYXRpb24gZmFpbGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHNldEF1dGgoe1xuICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgdGVuYW50OiBkYXRhLnRlbmFudCxcbiAgICAgIHJvbGU6IGRhdGEucm9sZSxcbiAgICAgIG91dGxldElkOiBudWxsLFxuICAgICAgdG9rZW46IGRhdGEudG9rZW4sXG4gICAgfSk7XG4gIH0sIFtzZXRBdXRoXSk7XG5cbiAgY29uc3QgbG9nb3V0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldEF1dGgoZGVmYXVsdFN0YXRlKTtcbiAgfSwgW3NldEF1dGhdKTtcblxuICBjb25zdCBzZXRPdXRsZXRJZCA9IHVzZUNhbGxiYWNrKChvdXRsZXRJZDogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICAgIHNldFN0YXRlKChwcmV2KSA9PiB7XG4gICAgICBjb25zdCBuZXh0ID0geyAuLi5wcmV2LCBvdXRsZXRJZCB9O1xuICAgICAgc2F2ZVN0b3JlZChuZXh0KTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8QXV0aENvbnRleHQuUHJvdmlkZXJcbiAgICAgIHZhbHVlPXt7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBsb2dpbixcbiAgICAgICAgcmVnaXN0ZXIsXG4gICAgICAgIGxvZ291dCxcbiAgICAgICAgc2V0T3V0bGV0SWQsXG4gICAgICAgIHNldEF1dGgsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0F1dGhDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQXV0aCgpIHtcbiAgY29uc3QgY3R4ID0gdXNlQ29udGV4dChBdXRoQ29udGV4dCk7XG4gIGlmICghY3R4KSB0aHJvdyBuZXcgRXJyb3IoJ3VzZUF1dGggbXVzdCBiZSB1c2VkIHdpdGhpbiBBdXRoUHJvdmlkZXInKTtcbiAgcmV0dXJuIGN0eDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF1dGhUb2tlbigpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWSk7XG4gICAgaWYgKCFyYXcpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHJhdyk7XG4gICAgcmV0dXJuIGRhdGE/LnRva2VuID8/IG51bGw7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiQVBJX0JBU0UiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIlNUT1JBR0VfS0VZIiwiZGVmYXVsdFN0YXRlIiwidXNlciIsInRlbmFudCIsInJvbGUiLCJvdXRsZXRJZCIsInRva2VuIiwiQXV0aENvbnRleHQiLCJsb2FkU3RvcmVkIiwiZGF0YSIsInJhdyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJpZCIsInNhdmVTdG9yZWQiLCJzdGF0ZSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJyZW1vdmVJdGVtIiwiQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzZXRTdGF0ZSIsInNldEF1dGgiLCJuZXh0IiwibG9naW4iLCJlbWFpbCIsInBhc3N3b3JkIiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIm9rIiwiZXJyIiwianNvbiIsImNhdGNoIiwiRXJyb3IiLCJlcnJvciIsInJlZ2lzdGVyIiwiYnVzaW5lc3NOYW1lIiwibG9nb3V0Iiwic2V0T3V0bGV0SWQiLCJwcmV2IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUF1dGgiLCJjdHgiLCJnZXRBdXRoVG9rZW4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/AuthContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/useSyncManager.ts":
/*!*************************************!*\
  !*** ./src/hooks/useSyncManager.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSyncManager: () => (/* binding */ useSyncManager)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/db */ \"(app-pages-browser)/./src/lib/db.ts\");\n/* harmony import */ var _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/contexts/AuthContext */ \"(app-pages-browser)/./src/contexts/AuthContext.tsx\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ useSyncManager auto */ /**\n * useSyncManager - The Heart of Offline-First Sync.\n * - Listens to navigator.onLine; on reconnection runs pull then push.\n * - Pull: GET /sync/pull?tenant_id=&max_version_id=  apply delta to Dexie (server wins for products).\n * - Push: POST /sync with SyncQueue items  server processes in transaction, returns version_id.\n */ \n\n\nconst SYNC_META_KEY_MAX_VERSION = 'local_max_version_id';\nconst SIMULATE_OFFLINE_KEY = 'bluecounts_simulate_offline';\nconst API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';\nfunction getSimulateOffline() {\n    if (false) {}\n    return localStorage.getItem(SIMULATE_OFFLINE_KEY) === '1';\n}\nfunction authHeaders() {\n    const token = (0,_contexts_AuthContext__WEBPACK_IMPORTED_MODULE_2__.getAuthToken)();\n    const h = {\n        'Content-Type': 'application/json'\n    };\n    if (token) h['Authorization'] = \"Bearer \".concat(token);\n    return h;\n}\nfunction useSyncManager(param) {\n    let { tenantId, outletId, deviceId, enabled = true } = param;\n    const [simulateOffline, setSimulateOfflineState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useSyncManager.useState\": ()=> true && getSimulateOffline()\n    }[\"useSyncManager.useState\"]);\n    const [navigatorOnline, setNavigatorOnline] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)( true ? window.navigator.onLine : 0);\n    const isOnline = navigatorOnline && !simulateOffline;\n    const setSimulateOffline = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[setSimulateOffline]\": (value)=>{\n            if (false) {}\n            if (value) localStorage.setItem(SIMULATE_OFFLINE_KEY, '1');\n            else localStorage.removeItem(SIMULATE_OFFLINE_KEY);\n            setSimulateOfflineState(value);\n        }\n    }[\"useSyncManager.useCallback[setSimulateOffline]\"], []);\n    const [syncState, setSyncState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('idle');\n    const [lastError, setLastError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [pendingCount, setPendingCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const getMaxVersion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[getMaxVersion]\": async ()=>{\n            const row = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_meta.get(SYNC_META_KEY_MAX_VERSION);\n            const v = row === null || row === void 0 ? void 0 : row.value;\n            if (typeof v === 'number') return v;\n            if (typeof v === 'string') return parseInt(v, 10) || 0;\n            return 0;\n        }\n    }[\"useSyncManager.useCallback[getMaxVersion]\"], []);\n    const setMaxVersion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[setMaxVersion]\": async (version)=>{\n            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_meta.put({\n                key: SYNC_META_KEY_MAX_VERSION,\n                value: version\n            });\n        }\n    }[\"useSyncManager.useCallback[setMaxVersion]\"], []);\n    const pull = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[pull]\": async function() {\n            let forceFullSync = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n            if (!tenantId) return;\n            setSyncState('pulling');\n            setLastError(null);\n            try {\n                var _tables_products, _tables_inventory, _tables_sales, _tables_sale_items, _tables_pos_sessions;\n                let maxVer = await getMaxVersion();\n                if (forceFullSync) {\n                    maxVer = 0;\n                } else {\n                    const hasLocalData = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.products.where('tenant_id').equals(tenantId).count();\n                    if (hasLocalData === 0) {\n                        maxVer = 0;\n                    }\n                }\n                const url = \"\".concat(API_BASE, \"/sync/pull?tenant_id=\").concat(encodeURIComponent(tenantId), \"&max_version_id=\").concat(maxVer);\n                const res = await fetch(url, {\n                    headers: authHeaders()\n                });\n                if (!res.ok) throw new Error(\"Pull failed: \".concat(res.status));\n                const data = await res.json();\n                const { tables, server_max_version_id } = data;\n                if ((_tables_products = tables.products) === null || _tables_products === void 0 ? void 0 : _tables_products.length) {\n                    for (const row of tables.products){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.products.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_description, _row_deleted_at;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.products.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                sku: row.sku,\n                                name: row.name,\n                                description: (_row_description = row.description) !== null && _row_description !== void 0 ? _row_description : null,\n                                price: Number(row.price),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                updated_at: row.updated_at,\n                                deleted_at: (_row_deleted_at = row.deleted_at) !== null && _row_deleted_at !== void 0 ? _row_deleted_at : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_inventory = tables.inventory) === null || _tables_inventory === void 0 ? void 0 : _tables_inventory.length) {\n                    for (const row of tables.inventory){\n                        const productKey = [\n                            row.tenant_id,\n                            row.outlet_id,\n                            row.product_id\n                        ];\n                        const existing = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.where('[tenant_id+outlet_id+product_id]').equals(productKey).toArray();\n                        for (const e of existing){\n                            if (e.id !== row.id) await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.delete(e.id);\n                        }\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_deleted_at1;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.inventory.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                product_id: row.product_id,\n                                quantity: Number(row.quantity),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                updated_at: row.updated_at,\n                                deleted_at: (_row_deleted_at1 = row.deleted_at) !== null && _row_deleted_at1 !== void 0 ? _row_deleted_at1 : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_sales = tables.sales) === null || _tables_sales === void 0 ? void 0 : _tables_sales.length) {\n                    for (const row of tables.sales){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sales.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_session_id, _row_deleted_at2;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sales.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                device_id: row.device_id,\n                                session_id: (_row_session_id = row.session_id) !== null && _row_session_id !== void 0 ? _row_session_id : null,\n                                device_transaction_id: row.device_transaction_id,\n                                total_amount: Number(row.total_amount),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                updated_at: row.updated_at,\n                                deleted_at: (_row_deleted_at2 = row.deleted_at) !== null && _row_deleted_at2 !== void 0 ? _row_deleted_at2 : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_sale_items = tables.sale_items) === null || _tables_sale_items === void 0 ? void 0 : _tables_sale_items.length) {\n                    for (const row of tables.sale_items){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sale_items.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_deleted_at3;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sale_items.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                sale_id: row.sale_id,\n                                product_id: row.product_id,\n                                quantity: row.quantity,\n                                unit_price: Number(row.unit_price),\n                                line_total: Number(row.line_total),\n                                version_id: row.version_id,\n                                created_at: row.created_at,\n                                deleted_at: (_row_deleted_at3 = row.deleted_at) !== null && _row_deleted_at3 !== void 0 ? _row_deleted_at3 : null\n                            });\n                        }\n                    }\n                }\n                if ((_tables_pos_sessions = tables.pos_sessions) === null || _tables_pos_sessions === void 0 ? void 0 : _tables_pos_sessions.length) {\n                    for (const row of tables.pos_sessions){\n                        if (row.deleted_at) {\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.pos_sessions.update(row.id, {\n                                deleted_at: row.deleted_at,\n                                version_id: row.version_id\n                            });\n                        } else {\n                            var _row_device_id, _row_closed_at, _row_deleted_at4;\n                            await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.pos_sessions.put({\n                                id: row.id,\n                                tenant_id: row.tenant_id,\n                                outlet_id: row.outlet_id,\n                                user_id: row.user_id,\n                                device_id: (_row_device_id = row.device_id) !== null && _row_device_id !== void 0 ? _row_device_id : null,\n                                opening_balance: Number(row.opening_balance),\n                                closing_balance: row.closing_balance != null ? Number(row.closing_balance) : null,\n                                expected_balance: row.expected_balance != null ? Number(row.expected_balance) : null,\n                                status: row.status === 'closed' ? 'closed' : 'open',\n                                opened_at: row.opened_at,\n                                closed_at: (_row_closed_at = row.closed_at) !== null && _row_closed_at !== void 0 ? _row_closed_at : null,\n                                version_id: row.version_id,\n                                deleted_at: (_row_deleted_at4 = row.deleted_at) !== null && _row_deleted_at4 !== void 0 ? _row_deleted_at4 : null\n                            });\n                        }\n                    }\n                }\n                if (typeof server_max_version_id === 'number') {\n                    await setMaxVersion(server_max_version_id);\n                }\n            } catch (e) {\n                const msg = e instanceof Error ? e.message : 'Pull failed';\n                setLastError(msg);\n                setSyncState('error');\n                return;\n            }\n            setSyncState('idle');\n        }\n    }[\"useSyncManager.useCallback[pull]\"], [\n        tenantId,\n        outletId,\n        getMaxVersion,\n        setMaxVersion\n    ]);\n    const push = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[push]\": async ()=>{\n            if (!tenantId || !outletId || !deviceId) return;\n            const pending = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').toArray();\n            if (pending.length === 0) {\n                setPendingCount(0);\n                return;\n            }\n            setSyncState('pushing');\n            setLastError(null);\n            try {\n                const items = pending.map({\n                    \"useSyncManager.useCallback[push].items\": (q)=>({\n                            id: q.id,\n                            action_type: q.action_type,\n                            payload: q.payload\n                        })\n                }[\"useSyncManager.useCallback[push].items\"]);\n                const res = await fetch(\"\".concat(API_BASE, \"/sync\"), {\n                    method: 'POST',\n                    headers: authHeaders(),\n                    body: JSON.stringify({\n                        tenant_id: tenantId,\n                        outlet_id: outletId,\n                        device_id: deviceId,\n                        items\n                    })\n                });\n                if (!res.ok) {\n                    const errBody = await res.text();\n                    throw new Error(errBody || \"Push failed: \".concat(res.status));\n                }\n                const data = await res.json();\n                if (data.version_id != null) await setMaxVersion(data.version_id);\n                for (const r of data.results || []){\n                    if (r.status === 'accepted' || r.status === 'synced') {\n                        await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.update(r.queue_id, {\n                            status: 'synced'\n                        });\n                    } else if (r.status === 'failed') {\n                        await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.update(r.queue_id, {\n                            status: 'failed',\n                            error_message: r.error\n                        });\n                    }\n                }\n                const stillPending = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count();\n                setPendingCount(stillPending);\n            } catch (e) {\n                const msg = e instanceof Error ? e.message : 'Push failed';\n                setLastError(msg);\n                setSyncState('error');\n                return;\n            }\n            setSyncState('idle');\n            const stillPending = await _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count();\n            setPendingCount(stillPending);\n        }\n    }[\"useSyncManager.useCallback[push]\"], [\n        tenantId,\n        outletId,\n        deviceId,\n        setMaxVersion\n    ]);\n    const sync = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncManager.useCallback[sync]\": async ()=>{\n            if (!enabled) return;\n            await pull(true);\n            await push();\n            await pull(true);\n        }\n    }[\"useSyncManager.useCallback[sync]\"], [\n        enabled,\n        pull,\n        push\n    ]);\n    // When online (and not simulating offline), do a full pull on page load.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncManager.useEffect\": ()=>{\n            if ( false || !enabled || !tenantId || !isOnline) return;\n            pull(true);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useSyncManager.useEffect\"], [\n        tenantId,\n        enabled,\n        isOnline\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncManager.useEffect\": ()=>{\n            if (false) {}\n            const handleOnline = {\n                \"useSyncManager.useEffect.handleOnline\": ()=>{\n                    setNavigatorOnline(true);\n                    if (!getSimulateOffline() && enabled && tenantId) sync();\n                }\n            }[\"useSyncManager.useEffect.handleOnline\"];\n            const handleOffline = {\n                \"useSyncManager.useEffect.handleOffline\": ()=>setNavigatorOnline(false)\n            }[\"useSyncManager.useEffect.handleOffline\"];\n            window.addEventListener('online', handleOnline);\n            window.addEventListener('offline', handleOffline);\n            return ({\n                \"useSyncManager.useEffect\": ()=>{\n                    window.removeEventListener('online', handleOnline);\n                    window.removeEventListener('offline', handleOffline);\n                }\n            })[\"useSyncManager.useEffect\"];\n        }\n    }[\"useSyncManager.useEffect\"], [\n        enabled,\n        tenantId,\n        sync\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncManager.useEffect\": ()=>{\n            let cancelled = false;\n            _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count().then({\n                \"useSyncManager.useEffect\": (c)=>{\n                    if (!cancelled) setPendingCount(c);\n                }\n            }[\"useSyncManager.useEffect\"]);\n            const interval = setInterval({\n                \"useSyncManager.useEffect.interval\": ()=>{\n                    _lib_db__WEBPACK_IMPORTED_MODULE_1__.db.sync_queue.where('status').equals('pending').count().then({\n                        \"useSyncManager.useEffect.interval\": (c)=>{\n                            if (!cancelled) setPendingCount(c);\n                        }\n                    }[\"useSyncManager.useEffect.interval\"]);\n                }\n            }[\"useSyncManager.useEffect.interval\"], 2000);\n            return ({\n                \"useSyncManager.useEffect\": ()=>{\n                    cancelled = true;\n                    clearInterval(interval);\n                }\n            })[\"useSyncManager.useEffect\"];\n        }\n    }[\"useSyncManager.useEffect\"], []);\n    return {\n        isOnline,\n        syncState,\n        lastError,\n        pendingCount,\n        sync,\n        pull,\n        push,\n        simulateOffline,\n        setSimulateOffline\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTeW5jTWFuYWdlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7b0VBRUE7Ozs7O0NBS0MsR0FFd0Q7QUFDTDtBQUNFO0FBRXRELE1BQU1LLDRCQUE0QjtBQUNsQyxNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTUMsV0FBV0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSTtBQUVwRCxTQUFTQztJQUNQLElBQUksS0FBNkIsRUFBRSxFQUFhO0lBQ2hELE9BQU9DLGFBQWFDLE9BQU8sQ0FBQ1AsMEJBQTBCO0FBQ3hEO0FBRUEsU0FBU1E7SUFDUCxNQUFNQyxRQUFRWCxtRUFBWUE7SUFDMUIsTUFBTVksSUFBaUI7UUFBRSxnQkFBZ0I7SUFBbUI7SUFDNUQsSUFBSUQsT0FBTyxDQUE2QixDQUFDLGdCQUFnQixHQUFHLFVBQWdCLE9BQU5BO0lBQ3RFLE9BQU9DO0FBQ1Q7QUFXTyxTQUFTQyxlQUFlLEtBQXVFO1FBQXZFLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsSUFBSSxFQUF5QixHQUF2RTtJQUM3QixNQUFNLENBQUNDLGlCQUFpQkMsd0JBQXdCLEdBQUdyQiwrQ0FBUUE7bUNBQ3pELElBQU0sS0FBNkIsSUFBSVM7O0lBRXpDLE1BQU0sQ0FBQ2EsaUJBQWlCQyxtQkFBbUIsR0FBR3ZCLCtDQUFRQSxDQUNwRCxLQUE2QixHQUFHd0IsT0FBT0MsU0FBUyxDQUFDQyxNQUFNLEdBQUcsQ0FBSTtJQUVoRSxNQUFNQyxXQUFXTCxtQkFBbUIsQ0FBQ0Y7SUFFckMsTUFBTVEscUJBQXFCOUIsa0RBQVdBOzBEQUFDLENBQUMrQjtZQUN0QyxJQUFJLEtBQTZCLEVBQUUsRUFBTztZQUMxQyxJQUFJQSxPQUFPbkIsYUFBYW9CLE9BQU8sQ0FBQzFCLHNCQUFzQjtpQkFDakRNLGFBQWFxQixVQUFVLENBQUMzQjtZQUM3QmlCLHdCQUF3QlE7UUFDMUI7eURBQUcsRUFBRTtJQUVM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O0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90aW1vdGh5ZWRpYm8vcHJvamVjdHMvcGVyc29uYWwvYmx1ZWNvdW50cy9mcm9udGVuZC9zcmMvaG9va3MvdXNlU3luY01hbmFnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG4vKipcbiAqIHVzZVN5bmNNYW5hZ2VyIC0gVGhlIEhlYXJ0IG9mIE9mZmxpbmUtRmlyc3QgU3luYy5cbiAqIC0gTGlzdGVucyB0byBuYXZpZ2F0b3Iub25MaW5lOyBvbiByZWNvbm5lY3Rpb24gcnVucyBwdWxsIHRoZW4gcHVzaC5cbiAqIC0gUHVsbDogR0VUIC9zeW5jL3B1bGw/dGVuYW50X2lkPSZtYXhfdmVyc2lvbl9pZD0g4oaSIGFwcGx5IGRlbHRhIHRvIERleGllIChzZXJ2ZXIgd2lucyBmb3IgcHJvZHVjdHMpLlxuICogLSBQdXNoOiBQT1NUIC9zeW5jIHdpdGggU3luY1F1ZXVlIGl0ZW1zIOKGkiBzZXJ2ZXIgcHJvY2Vzc2VzIGluIHRyYW5zYWN0aW9uLCByZXR1cm5zIHZlcnNpb25faWQuXG4gKi9cblxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBkYiwgdHlwZSBTeW5jUXVldWVSZWNvcmQgfSBmcm9tICdAL2xpYi9kYic7XG5pbXBvcnQgeyBnZXRBdXRoVG9rZW4gfSBmcm9tICdAL2NvbnRleHRzL0F1dGhDb250ZXh0JztcblxuY29uc3QgU1lOQ19NRVRBX0tFWV9NQVhfVkVSU0lPTiA9ICdsb2NhbF9tYXhfdmVyc2lvbl9pZCc7XG5jb25zdCBTSU1VTEFURV9PRkZMSU5FX0tFWSA9ICdibHVlY291bnRzX3NpbXVsYXRlX29mZmxpbmUnO1xuY29uc3QgQVBJX0JBU0UgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDEnO1xuXG5mdW5jdGlvbiBnZXRTaW11bGF0ZU9mZmxpbmUoKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU0lNVUxBVEVfT0ZGTElORV9LRVkpID09PSAnMSc7XG59XG5cbmZ1bmN0aW9uIGF1dGhIZWFkZXJzKCk6IEhlYWRlcnNJbml0IHtcbiAgY29uc3QgdG9rZW4gPSBnZXRBdXRoVG9rZW4oKTtcbiAgY29uc3QgaDogSGVhZGVyc0luaXQgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfTtcbiAgaWYgKHRva2VuKSAoaCBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KVsnQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2VufWA7XG4gIHJldHVybiBoO1xufVxuXG50eXBlIFN5bmNTdGF0ZSA9ICdpZGxlJyB8ICdwdWxsaW5nJyB8ICdwdXNoaW5nJyB8ICdlcnJvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU3luY01hbmFnZXJPcHRpb25zIHtcbiAgdGVuYW50SWQ6IHN0cmluZztcbiAgb3V0bGV0SWQ6IHN0cmluZztcbiAgZGV2aWNlSWQ6IHN0cmluZztcbiAgZW5hYmxlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTeW5jTWFuYWdlcih7IHRlbmFudElkLCBvdXRsZXRJZCwgZGV2aWNlSWQsIGVuYWJsZWQgPSB0cnVlIH06IFVzZVN5bmNNYW5hZ2VyT3B0aW9ucykge1xuICBjb25zdCBbc2ltdWxhdGVPZmZsaW5lLCBzZXRTaW11bGF0ZU9mZmxpbmVTdGF0ZV0gPSB1c2VTdGF0ZShcbiAgICAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBnZXRTaW11bGF0ZU9mZmxpbmUoKVxuICApO1xuICBjb25zdCBbbmF2aWdhdG9yT25saW5lLCBzZXROYXZpZ2F0b3JPbmxpbmVdID0gdXNlU3RhdGUoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubmF2aWdhdG9yLm9uTGluZSA6IHRydWVcbiAgKTtcbiAgY29uc3QgaXNPbmxpbmUgPSBuYXZpZ2F0b3JPbmxpbmUgJiYgIXNpbXVsYXRlT2ZmbGluZTtcblxuICBjb25zdCBzZXRTaW11bGF0ZU9mZmxpbmUgPSB1c2VDYWxsYmFjaygodmFsdWU6IGJvb2xlYW4pID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBpZiAodmFsdWUpIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNJTVVMQVRFX09GRkxJTkVfS0VZLCAnMScpO1xuICAgIGVsc2UgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oU0lNVUxBVEVfT0ZGTElORV9LRVkpO1xuICAgIHNldFNpbXVsYXRlT2ZmbGluZVN0YXRlKHZhbHVlKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IFtzeW5jU3RhdGUsIHNldFN5bmNTdGF0ZV0gPSB1c2VTdGF0ZTxTeW5jU3RhdGU+KCdpZGxlJyk7XG4gIGNvbnN0IFtsYXN0RXJyb3IsIHNldExhc3RFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3BlbmRpbmdDb3VudCwgc2V0UGVuZGluZ0NvdW50XSA9IHVzZVN0YXRlKDApO1xuXG4gIGNvbnN0IGdldE1heFZlcnNpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoKTogUHJvbWlzZTxudW1iZXI+ID0+IHtcbiAgICBjb25zdCByb3cgPSBhd2FpdCBkYi5zeW5jX21ldGEuZ2V0KFNZTkNfTUVUQV9LRVlfTUFYX1ZFUlNJT04pO1xuICAgIGNvbnN0IHYgPSByb3c/LnZhbHVlO1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHJldHVybiB2O1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHJldHVybiBwYXJzZUludCh2LCAxMCkgfHwgMDtcbiAgICByZXR1cm4gMDtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNldE1heFZlcnNpb24gPSB1c2VDYWxsYmFjayhhc3luYyAodmVyc2lvbjogbnVtYmVyKSA9PiB7XG4gICAgYXdhaXQgZGIuc3luY19tZXRhLnB1dCh7IGtleTogU1lOQ19NRVRBX0tFWV9NQVhfVkVSU0lPTiwgdmFsdWU6IHZlcnNpb24gfSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBwdWxsID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGZvcmNlRnVsbFN5bmMgPSBmYWxzZSkgPT4ge1xuICAgICAgaWYgKCF0ZW5hbnRJZCkgcmV0dXJuO1xuICAgICAgc2V0U3luY1N0YXRlKCdwdWxsaW5nJyk7XG4gICAgICBzZXRMYXN0RXJyb3IobnVsbCk7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgbWF4VmVyID0gYXdhaXQgZ2V0TWF4VmVyc2lvbigpO1xuICAgICAgICBpZiAoZm9yY2VGdWxsU3luYykge1xuICAgICAgICAgIG1heFZlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaGFzTG9jYWxEYXRhID0gYXdhaXQgZGIucHJvZHVjdHMud2hlcmUoJ3RlbmFudF9pZCcpLmVxdWFscyh0ZW5hbnRJZCkuY291bnQoKTtcbiAgICAgICAgICBpZiAoaGFzTG9jYWxEYXRhID09PSAwKSB7XG4gICAgICAgICAgICBtYXhWZXIgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBgJHtBUElfQkFTRX0vc3luYy9wdWxsP3RlbmFudF9pZD0ke2VuY29kZVVSSUNvbXBvbmVudCh0ZW5hbnRJZCl9Jm1heF92ZXJzaW9uX2lkPSR7bWF4VmVyfWA7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHsgaGVhZGVyczogYXV0aEhlYWRlcnMoKSB9KTtcbiAgICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoYFB1bGwgZmFpbGVkOiAke3Jlcy5zdGF0dXN9YCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgIGNvbnN0IHsgdGFibGVzLCBzZXJ2ZXJfbWF4X3ZlcnNpb25faWQgfSA9IGRhdGE7XG5cbiAgICAgIGlmICh0YWJsZXMucHJvZHVjdHM/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZXMucHJvZHVjdHMpIHtcbiAgICAgICAgICBpZiAocm93LmRlbGV0ZWRfYXQpIHtcbiAgICAgICAgICAgIGF3YWl0IGRiLnByb2R1Y3RzLnVwZGF0ZShyb3cuaWQsIHsgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQsIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5wcm9kdWN0cy5wdXQoe1xuICAgICAgICAgICAgICBpZDogcm93LmlkLFxuICAgICAgICAgICAgICB0ZW5hbnRfaWQ6IHJvdy50ZW5hbnRfaWQsXG4gICAgICAgICAgICAgIHNrdTogcm93LnNrdSxcbiAgICAgICAgICAgICAgbmFtZTogcm93Lm5hbWUsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiByb3cuZGVzY3JpcHRpb24gPz8gbnVsbCxcbiAgICAgICAgICAgICAgcHJpY2U6IE51bWJlcihyb3cucHJpY2UpLFxuICAgICAgICAgICAgICB2ZXJzaW9uX2lkOiByb3cudmVyc2lvbl9pZCxcbiAgICAgICAgICAgICAgY3JlYXRlZF9hdDogcm93LmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IHJvdy51cGRhdGVkX2F0LFxuICAgICAgICAgICAgICBkZWxldGVkX2F0OiByb3cuZGVsZXRlZF9hdCA/PyBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGFibGVzLmludmVudG9yeT8ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlcy5pbnZlbnRvcnkpIHtcbiAgICAgICAgICBjb25zdCBwcm9kdWN0S2V5ID0gW3Jvdy50ZW5hbnRfaWQsIHJvdy5vdXRsZXRfaWQsIHJvdy5wcm9kdWN0X2lkXSBhcyBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ107XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCBkYi5pbnZlbnRvcnkud2hlcmUoJ1t0ZW5hbnRfaWQrb3V0bGV0X2lkK3Byb2R1Y3RfaWRdJykuZXF1YWxzKHByb2R1Y3RLZXkpLnRvQXJyYXkoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGlmIChlLmlkICE9PSByb3cuaWQpIGF3YWl0IGRiLmludmVudG9yeS5kZWxldGUoZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb3cuZGVsZXRlZF9hdCkge1xuICAgICAgICAgICAgYXdhaXQgZGIuaW52ZW50b3J5LnVwZGF0ZShyb3cuaWQsIHsgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQsIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5pbnZlbnRvcnkucHV0KHtcbiAgICAgICAgICAgICAgaWQ6IHJvdy5pZCxcbiAgICAgICAgICAgICAgdGVuYW50X2lkOiByb3cudGVuYW50X2lkLFxuICAgICAgICAgICAgICBvdXRsZXRfaWQ6IHJvdy5vdXRsZXRfaWQsXG4gICAgICAgICAgICAgIHByb2R1Y3RfaWQ6IHJvdy5wcm9kdWN0X2lkLFxuICAgICAgICAgICAgICBxdWFudGl0eTogTnVtYmVyKHJvdy5xdWFudGl0eSksXG4gICAgICAgICAgICAgIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkLFxuICAgICAgICAgICAgICBjcmVhdGVkX2F0OiByb3cuY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgdXBkYXRlZF9hdDogcm93LnVwZGF0ZWRfYXQsXG4gICAgICAgICAgICAgIGRlbGV0ZWRfYXQ6IHJvdy5kZWxldGVkX2F0ID8/IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZXMuc2FsZXM/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZXMuc2FsZXMpIHtcbiAgICAgICAgICBpZiAocm93LmRlbGV0ZWRfYXQpIHtcbiAgICAgICAgICAgIGF3YWl0IGRiLnNhbGVzLnVwZGF0ZShyb3cuaWQsIHsgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQsIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5zYWxlcy5wdXQoe1xuICAgICAgICAgICAgICBpZDogcm93LmlkLFxuICAgICAgICAgICAgICB0ZW5hbnRfaWQ6IHJvdy50ZW5hbnRfaWQsXG4gICAgICAgICAgICAgIG91dGxldF9pZDogcm93Lm91dGxldF9pZCxcbiAgICAgICAgICAgICAgZGV2aWNlX2lkOiByb3cuZGV2aWNlX2lkLFxuICAgICAgICAgICAgICBzZXNzaW9uX2lkOiByb3cuc2Vzc2lvbl9pZCA/PyBudWxsLFxuICAgICAgICAgICAgICBkZXZpY2VfdHJhbnNhY3Rpb25faWQ6IHJvdy5kZXZpY2VfdHJhbnNhY3Rpb25faWQsXG4gICAgICAgICAgICAgIHRvdGFsX2Ftb3VudDogTnVtYmVyKHJvdy50b3RhbF9hbW91bnQpLFxuICAgICAgICAgICAgICB2ZXJzaW9uX2lkOiByb3cudmVyc2lvbl9pZCxcbiAgICAgICAgICAgICAgY3JlYXRlZF9hdDogcm93LmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IHJvdy51cGRhdGVkX2F0LFxuICAgICAgICAgICAgICBkZWxldGVkX2F0OiByb3cuZGVsZXRlZF9hdCA/PyBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGFibGVzLnNhbGVfaXRlbXM/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZXMuc2FsZV9pdGVtcykge1xuICAgICAgICAgIGlmIChyb3cuZGVsZXRlZF9hdCkge1xuICAgICAgICAgICAgYXdhaXQgZGIuc2FsZV9pdGVtcy51cGRhdGUocm93LmlkLCB7IGRlbGV0ZWRfYXQ6IHJvdy5kZWxldGVkX2F0LCB2ZXJzaW9uX2lkOiByb3cudmVyc2lvbl9pZCB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgZGIuc2FsZV9pdGVtcy5wdXQoe1xuICAgICAgICAgICAgICBpZDogcm93LmlkLFxuICAgICAgICAgICAgICB0ZW5hbnRfaWQ6IHJvdy50ZW5hbnRfaWQsXG4gICAgICAgICAgICAgIG91dGxldF9pZDogcm93Lm91dGxldF9pZCxcbiAgICAgICAgICAgICAgc2FsZV9pZDogcm93LnNhbGVfaWQsXG4gICAgICAgICAgICAgIHByb2R1Y3RfaWQ6IHJvdy5wcm9kdWN0X2lkLFxuICAgICAgICAgICAgICBxdWFudGl0eTogcm93LnF1YW50aXR5LFxuICAgICAgICAgICAgICB1bml0X3ByaWNlOiBOdW1iZXIocm93LnVuaXRfcHJpY2UpLFxuICAgICAgICAgICAgICBsaW5lX3RvdGFsOiBOdW1iZXIocm93LmxpbmVfdG90YWwpLFxuICAgICAgICAgICAgICB2ZXJzaW9uX2lkOiByb3cudmVyc2lvbl9pZCxcbiAgICAgICAgICAgICAgY3JlYXRlZF9hdDogcm93LmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgIGRlbGV0ZWRfYXQ6IHJvdy5kZWxldGVkX2F0ID8/IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZXMucG9zX3Nlc3Npb25zPy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGVzLnBvc19zZXNzaW9ucykge1xuICAgICAgICAgIGlmIChyb3cuZGVsZXRlZF9hdCkge1xuICAgICAgICAgICAgYXdhaXQgZGIucG9zX3Nlc3Npb25zLnVwZGF0ZShyb3cuaWQsIHsgZGVsZXRlZF9hdDogcm93LmRlbGV0ZWRfYXQsIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5wb3Nfc2Vzc2lvbnMucHV0KHtcbiAgICAgICAgICAgICAgaWQ6IHJvdy5pZCxcbiAgICAgICAgICAgICAgdGVuYW50X2lkOiByb3cudGVuYW50X2lkLFxuICAgICAgICAgICAgICBvdXRsZXRfaWQ6IHJvdy5vdXRsZXRfaWQsXG4gICAgICAgICAgICAgIHVzZXJfaWQ6IHJvdy51c2VyX2lkLFxuICAgICAgICAgICAgICBkZXZpY2VfaWQ6IHJvdy5kZXZpY2VfaWQgPz8gbnVsbCxcbiAgICAgICAgICAgICAgb3BlbmluZ19iYWxhbmNlOiBOdW1iZXIocm93Lm9wZW5pbmdfYmFsYW5jZSksXG4gICAgICAgICAgICAgIGNsb3NpbmdfYmFsYW5jZTogcm93LmNsb3NpbmdfYmFsYW5jZSAhPSBudWxsID8gTnVtYmVyKHJvdy5jbG9zaW5nX2JhbGFuY2UpIDogbnVsbCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWRfYmFsYW5jZTogcm93LmV4cGVjdGVkX2JhbGFuY2UgIT0gbnVsbCA/IE51bWJlcihyb3cuZXhwZWN0ZWRfYmFsYW5jZSkgOiBudWxsLFxuICAgICAgICAgICAgICBzdGF0dXM6IHJvdy5zdGF0dXMgPT09ICdjbG9zZWQnID8gJ2Nsb3NlZCcgOiAnb3BlbicsXG4gICAgICAgICAgICAgIG9wZW5lZF9hdDogcm93Lm9wZW5lZF9hdCxcbiAgICAgICAgICAgICAgY2xvc2VkX2F0OiByb3cuY2xvc2VkX2F0ID8/IG51bGwsXG4gICAgICAgICAgICAgIHZlcnNpb25faWQ6IHJvdy52ZXJzaW9uX2lkLFxuICAgICAgICAgICAgICBkZWxldGVkX2F0OiByb3cuZGVsZXRlZF9hdCA/PyBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VydmVyX21heF92ZXJzaW9uX2lkID09PSAnbnVtYmVyJykge1xuICAgICAgICBhd2FpdCBzZXRNYXhWZXJzaW9uKHNlcnZlcl9tYXhfdmVyc2lvbl9pZCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgbXNnID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogJ1B1bGwgZmFpbGVkJztcbiAgICAgIHNldExhc3RFcnJvcihtc2cpO1xuICAgICAgc2V0U3luY1N0YXRlKCdlcnJvcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRTeW5jU3RhdGUoJ2lkbGUnKTtcbiAgfSxcbiAgICBbdGVuYW50SWQsIG91dGxldElkLCBnZXRNYXhWZXJzaW9uLCBzZXRNYXhWZXJzaW9uXVxuICApO1xuXG4gIGNvbnN0IHB1c2ggPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF0ZW5hbnRJZCB8fCAhb3V0bGV0SWQgfHwgIWRldmljZUlkKSByZXR1cm47XG4gICAgY29uc3QgcGVuZGluZyA9IGF3YWl0IGRiLnN5bmNfcXVldWUud2hlcmUoJ3N0YXR1cycpLmVxdWFscygncGVuZGluZycpLnRvQXJyYXkoKTtcbiAgICBpZiAocGVuZGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHNldFBlbmRpbmdDb3VudCgwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0U3luY1N0YXRlKCdwdXNoaW5nJyk7XG4gICAgc2V0TGFzdEVycm9yKG51bGwpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpdGVtcyA9IHBlbmRpbmcubWFwKChxOiBTeW5jUXVldWVSZWNvcmQpID0+ICh7XG4gICAgICAgIGlkOiBxLmlkLFxuICAgICAgICBhY3Rpb25fdHlwZTogcS5hY3Rpb25fdHlwZSxcbiAgICAgICAgcGF5bG9hZDogcS5wYXlsb2FkLFxuICAgICAgfSkpO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0V9L3N5bmNgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycygpLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdGVuYW50X2lkOiB0ZW5hbnRJZCxcbiAgICAgICAgICBvdXRsZXRfaWQ6IG91dGxldElkLFxuICAgICAgICAgIGRldmljZV9pZDogZGV2aWNlSWQsXG4gICAgICAgICAgaXRlbXMsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICBjb25zdCBlcnJCb2R5ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyckJvZHkgfHwgYFB1c2ggZmFpbGVkOiAke3Jlcy5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgIGlmIChkYXRhLnZlcnNpb25faWQgIT0gbnVsbCkgYXdhaXQgc2V0TWF4VmVyc2lvbihkYXRhLnZlcnNpb25faWQpO1xuICAgICAgZm9yIChjb25zdCByIG9mIGRhdGEucmVzdWx0cyB8fCBbXSkge1xuICAgICAgICBpZiAoci5zdGF0dXMgPT09ICdhY2NlcHRlZCcgfHwgci5zdGF0dXMgPT09ICdzeW5jZWQnKSB7XG4gICAgICAgICAgYXdhaXQgZGIuc3luY19xdWV1ZS51cGRhdGUoci5xdWV1ZV9pZCwgeyBzdGF0dXM6ICdzeW5jZWQnIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHIuc3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgICAgIGF3YWl0IGRiLnN5bmNfcXVldWUudXBkYXRlKHIucXVldWVfaWQsIHsgc3RhdHVzOiAnZmFpbGVkJywgZXJyb3JfbWVzc2FnZTogci5lcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc3RpbGxQZW5kaW5nID0gYXdhaXQgZGIuc3luY19xdWV1ZS53aGVyZSgnc3RhdHVzJykuZXF1YWxzKCdwZW5kaW5nJykuY291bnQoKTtcbiAgICAgIHNldFBlbmRpbmdDb3VudChzdGlsbFBlbmRpbmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6ICdQdXNoIGZhaWxlZCc7XG4gICAgICBzZXRMYXN0RXJyb3IobXNnKTtcbiAgICAgIHNldFN5bmNTdGF0ZSgnZXJyb3InKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0U3luY1N0YXRlKCdpZGxlJyk7XG4gICAgY29uc3Qgc3RpbGxQZW5kaW5nID0gYXdhaXQgZGIuc3luY19xdWV1ZS53aGVyZSgnc3RhdHVzJykuZXF1YWxzKCdwZW5kaW5nJykuY291bnQoKTtcbiAgICBzZXRQZW5kaW5nQ291bnQoc3RpbGxQZW5kaW5nKTtcbiAgfSwgW3RlbmFudElkLCBvdXRsZXRJZCwgZGV2aWNlSWQsIHNldE1heFZlcnNpb25dKTtcblxuICBjb25zdCBzeW5jID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGF3YWl0IHB1bGwodHJ1ZSk7XG4gICAgYXdhaXQgcHVzaCgpO1xuICAgIGF3YWl0IHB1bGwodHJ1ZSk7XG4gIH0sIFtlbmFibGVkLCBwdWxsLCBwdXNoXSk7XG5cbiAgLy8gV2hlbiBvbmxpbmUgKGFuZCBub3Qgc2ltdWxhdGluZyBvZmZsaW5lKSwgZG8gYSBmdWxsIHB1bGwgb24gcGFnZSBsb2FkLlxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhZW5hYmxlZCB8fCAhdGVuYW50SWQgfHwgIWlzT25saW5lKSByZXR1cm47XG4gICAgcHVsbCh0cnVlKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFt0ZW5hbnRJZCwgZW5hYmxlZCwgaXNPbmxpbmVdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIGNvbnN0IGhhbmRsZU9ubGluZSA9ICgpID0+IHtcbiAgICAgIHNldE5hdmlnYXRvck9ubGluZSh0cnVlKTtcbiAgICAgIGlmICghZ2V0U2ltdWxhdGVPZmZsaW5lKCkgJiYgZW5hYmxlZCAmJiB0ZW5hbnRJZCkgc3luYygpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlT2ZmbGluZSA9ICgpID0+IHNldE5hdmlnYXRvck9ubGluZShmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGhhbmRsZU9ubGluZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBoYW5kbGVPZmZsaW5lKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGhhbmRsZU9ubGluZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGhhbmRsZU9mZmxpbmUpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCB0ZW5hbnRJZCwgc3luY10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGRiLnN5bmNfcXVldWUud2hlcmUoJ3N0YXR1cycpLmVxdWFscygncGVuZGluZycpLmNvdW50KCkudGhlbigoYykgPT4ge1xuICAgICAgaWYgKCFjYW5jZWxsZWQpIHNldFBlbmRpbmdDb3VudChjKTtcbiAgICB9KTtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGRiLnN5bmNfcXVldWUud2hlcmUoJ3N0YXR1cycpLmVxdWFscygncGVuZGluZycpLmNvdW50KCkudGhlbigoYykgPT4ge1xuICAgICAgICBpZiAoIWNhbmNlbGxlZCkgc2V0UGVuZGluZ0NvdW50KGMpO1xuICAgICAgfSk7XG4gICAgfSwgMjAwMCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpc09ubGluZSxcbiAgICBzeW5jU3RhdGUsXG4gICAgbGFzdEVycm9yLFxuICAgIHBlbmRpbmdDb3VudCxcbiAgICBzeW5jLFxuICAgIHB1bGwsXG4gICAgcHVzaCxcbiAgICBzaW11bGF0ZU9mZmxpbmUsXG4gICAgc2V0U2ltdWxhdGVPZmZsaW5lLFxuICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJkYiIsImdldEF1dGhUb2tlbiIsIlNZTkNfTUVUQV9LRVlfTUFYX1ZFUlNJT04iLCJTSU1VTEFURV9PRkZMSU5FX0tFWSIsIkFQSV9CQVNFIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJnZXRTaW11bGF0ZU9mZmxpbmUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiYXV0aEhlYWRlcnMiLCJ0b2tlbiIsImgiLCJ1c2VTeW5jTWFuYWdlciIsInRlbmFudElkIiwib3V0bGV0SWQiLCJkZXZpY2VJZCIsImVuYWJsZWQiLCJzaW11bGF0ZU9mZmxpbmUiLCJzZXRTaW11bGF0ZU9mZmxpbmVTdGF0ZSIsIm5hdmlnYXRvck9ubGluZSIsInNldE5hdmlnYXRvck9ubGluZSIsIndpbmRvdyIsIm5hdmlnYXRvciIsIm9uTGluZSIsImlzT25saW5lIiwic2V0U2ltdWxhdGVPZmZsaW5lIiwidmFsdWUiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsInN5bmNTdGF0ZSIsInNldFN5bmNTdGF0ZSIsImxhc3RFcnJvciIsInNldExhc3RFcnJvciIsInBlbmRpbmdDb3VudCIsInNldFBlbmRpbmdDb3VudCIsImdldE1heFZlcnNpb24iLCJyb3ciLCJzeW5jX21ldGEiLCJnZXQiLCJ2IiwicGFyc2VJbnQiLCJzZXRNYXhWZXJzaW9uIiwidmVyc2lvbiIsInB1dCIsImtleSIsInB1bGwiLCJmb3JjZUZ1bGxTeW5jIiwidGFibGVzIiwibWF4VmVyIiwiaGFzTG9jYWxEYXRhIiwicHJvZHVjdHMiLCJ3aGVyZSIsImVxdWFscyIsImNvdW50IiwidXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVzIiwiZmV0Y2giLCJoZWFkZXJzIiwib2siLCJFcnJvciIsInN0YXR1cyIsImRhdGEiLCJqc29uIiwic2VydmVyX21heF92ZXJzaW9uX2lkIiwibGVuZ3RoIiwiZGVsZXRlZF9hdCIsInVwZGF0ZSIsImlkIiwidmVyc2lvbl9pZCIsInRlbmFudF9pZCIsInNrdSIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInByaWNlIiwiTnVtYmVyIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJpbnZlbnRvcnkiLCJwcm9kdWN0S2V5Iiwib3V0bGV0X2lkIiwicHJvZHVjdF9pZCIsImV4aXN0aW5nIiwidG9BcnJheSIsImUiLCJkZWxldGUiLCJxdWFudGl0eSIsInNhbGVzIiwiZGV2aWNlX2lkIiwic2Vzc2lvbl9pZCIsImRldmljZV90cmFuc2FjdGlvbl9pZCIsInRvdGFsX2Ftb3VudCIsInNhbGVfaXRlbXMiLCJzYWxlX2lkIiwidW5pdF9wcmljZSIsImxpbmVfdG90YWwiLCJwb3Nfc2Vzc2lvbnMiLCJ1c2VyX2lkIiwib3BlbmluZ19iYWxhbmNlIiwiY2xvc2luZ19iYWxhbmNlIiwiZXhwZWN0ZWRfYmFsYW5jZSIsIm9wZW5lZF9hdCIsImNsb3NlZF9hdCIsIm1zZyIsIm1lc3NhZ2UiLCJwdXNoIiwicGVuZGluZyIsInN5bmNfcXVldWUiLCJpdGVtcyIsIm1hcCIsInEiLCJhY3Rpb25fdHlwZSIsInBheWxvYWQiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImVyckJvZHkiLCJ0ZXh0IiwiciIsInJlc3VsdHMiLCJxdWV1ZV9pZCIsImVycm9yX21lc3NhZ2UiLCJlcnJvciIsInN0aWxsUGVuZGluZyIsInN5bmMiLCJoYW5kbGVPbmxpbmUiLCJoYW5kbGVPZmZsaW5lIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxsZWQiLCJ0aGVuIiwiYyIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSyncManager.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/db.ts":
/*!***********************!*\
  !*** ./src/lib/db.ts ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BluecountsDB: () => (/* binding */ BluecountsDB),\n/* harmony export */   db: () => (/* binding */ db)\n/* harmony export */ });\n/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dexie */ \"(app-pages-browser)/./node_modules/dexie/import-wrapper.mjs\");\n/**\n * Dexie.js - Local-First source of truth.\n * All UI writes go here first; sync engine pushes to server when online.\n */ \nclass BluecountsDB extends dexie__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(){\n        super('BluecountsDB');\n        this.version(1).stores({\n            products: 'id, tenant_id, outlet_id, [tenant_id+outlet_id], [tenant_id+sku], version_id',\n            inventory: 'id, tenant_id, outlet_id, product_id, [tenant_id+outlet_id+product_id], version_id',\n            sales: 'id, tenant_id, outlet_id, device_id, [tenant_id+device_id+device_transaction_id], version_id, created_at',\n            sale_items: 'id, sale_id, tenant_id, outlet_id, product_id',\n            sync_queue: 'id, timestamp, status',\n            sync_meta: 'key'\n        });\n        this.version(2).stores({\n            products: 'id, tenant_id, outlet_id, [tenant_id+outlet_id], [tenant_id+sku], version_id',\n            inventory: 'id, tenant_id, outlet_id, product_id, [tenant_id+outlet_id+product_id], version_id',\n            sales: 'id, tenant_id, outlet_id, device_id, session_id, [tenant_id+device_id+device_transaction_id], version_id, created_at',\n            sale_items: 'id, sale_id, tenant_id, outlet_id, product_id',\n            pos_sessions: 'id, tenant_id, outlet_id, user_id, [outlet_id+status], version_id, opened_at',\n            sync_queue: 'id, timestamp, status',\n            sync_meta: 'key'\n        });\n        this.version(3).stores({\n            products: 'id, tenant_id, [tenant_id+sku], version_id',\n            inventory: 'id, tenant_id, outlet_id, product_id, [tenant_id+outlet_id+product_id], version_id',\n            sales: 'id, tenant_id, outlet_id, device_id, session_id, [tenant_id+device_id+device_transaction_id], version_id, created_at',\n            sale_items: 'id, sale_id, tenant_id, outlet_id, product_id',\n            pos_sessions: 'id, tenant_id, outlet_id, user_id, [outlet_id+status], version_id, opened_at',\n            sync_queue: 'id, timestamp, status',\n            sync_meta: 'key'\n        });\n    }\n}\nconst db = new BluecountsDB();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZGIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztDQUdDLEdBRStDO0FBd0Z6QyxNQUFNQyxxQkFBcUJELDZDQUFLQTtJQVNyQyxhQUFjO1FBQ1osS0FBSyxDQUFDO1FBQ04sSUFBSSxDQUFDRSxPQUFPLENBQUMsR0FBR0MsTUFBTSxDQUFDO1lBQ3JCQyxVQUFVO1lBQ1ZDLFdBQVc7WUFDWEMsT0FBTztZQUNQQyxZQUFZO1lBQ1pDLFlBQVk7WUFDWkMsV0FBVztRQUNiO1FBQ0EsSUFBSSxDQUFDUCxPQUFPLENBQUMsR0FBR0MsTUFBTSxDQUFDO1lBQ3JCQyxVQUFVO1lBQ1ZDLFdBQVc7WUFDWEMsT0FBTztZQUNQQyxZQUFZO1lBQ1pHLGNBQWM7WUFDZEYsWUFBWTtZQUNaQyxXQUFXO1FBQ2I7UUFDQSxJQUFJLENBQUNQLE9BQU8sQ0FBQyxHQUFHQyxNQUFNLENBQUM7WUFDckJDLFVBQVU7WUFDVkMsV0FBVztZQUNYQyxPQUFPO1lBQ1BDLFlBQVk7WUFDWkcsY0FBYztZQUNkRixZQUFZO1lBQ1pDLFdBQVc7UUFDYjtJQUNGO0FBQ0Y7QUFFTyxNQUFNRSxLQUFLLElBQUlWLGVBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy90aW1vdGh5ZWRpYm8vcHJvamVjdHMvcGVyc29uYWwvYmx1ZWNvdW50cy9mcm9udGVuZC9zcmMvbGliL2RiLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGV4aWUuanMgLSBMb2NhbC1GaXJzdCBzb3VyY2Ugb2YgdHJ1dGguXG4gKiBBbGwgVUkgd3JpdGVzIGdvIGhlcmUgZmlyc3Q7IHN5bmMgZW5naW5lIHB1c2hlcyB0byBzZXJ2ZXIgd2hlbiBvbmxpbmUuXG4gKi9cblxuaW1wb3J0IERleGllLCB7IHR5cGUgRW50aXR5VGFibGUgfSBmcm9tICdkZXhpZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZHVjdFJlY29yZCB7XG4gIGlkOiBzdHJpbmc7XG4gIHRlbmFudF9pZDogc3RyaW5nO1xuICBza3U6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZyB8IG51bGw7XG4gIHByaWNlOiBudW1iZXI7XG4gIHZlcnNpb25faWQ6IG51bWJlcjtcbiAgY3JlYXRlZF9hdD86IHN0cmluZztcbiAgdXBkYXRlZF9hdD86IHN0cmluZztcbiAgZGVsZXRlZF9hdD86IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW52ZW50b3J5UmVjb3JkIHtcbiAgaWQ6IHN0cmluZztcbiAgdGVuYW50X2lkOiBzdHJpbmc7XG4gIG91dGxldF9pZDogc3RyaW5nO1xuICBwcm9kdWN0X2lkOiBzdHJpbmc7XG4gIHF1YW50aXR5OiBudW1iZXI7XG4gIHZlcnNpb25faWQ6IG51bWJlcjtcbiAgY3JlYXRlZF9hdD86IHN0cmluZztcbiAgdXBkYXRlZF9hdD86IHN0cmluZztcbiAgZGVsZXRlZF9hdD86IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2FsZVJlY29yZCB7XG4gIGlkOiBzdHJpbmc7XG4gIHRlbmFudF9pZDogc3RyaW5nO1xuICBvdXRsZXRfaWQ6IHN0cmluZztcbiAgZGV2aWNlX2lkOiBzdHJpbmc7XG4gIHNlc3Npb25faWQ/OiBzdHJpbmcgfCBudWxsO1xuICBkZXZpY2VfdHJhbnNhY3Rpb25faWQ6IHN0cmluZztcbiAgdG90YWxfYW1vdW50OiBudW1iZXI7XG4gIHZlcnNpb25faWQ6IG51bWJlcjtcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICB1cGRhdGVkX2F0Pzogc3RyaW5nO1xuICBkZWxldGVkX2F0Pzogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb3NTZXNzaW9uUmVjb3JkIHtcbiAgaWQ6IHN0cmluZztcbiAgdGVuYW50X2lkOiBzdHJpbmc7XG4gIG91dGxldF9pZDogc3RyaW5nO1xuICB1c2VyX2lkOiBzdHJpbmc7XG4gIGRldmljZV9pZD86IHN0cmluZyB8IG51bGw7XG4gIG9wZW5pbmdfYmFsYW5jZTogbnVtYmVyO1xuICBjbG9zaW5nX2JhbGFuY2U/OiBudW1iZXIgfCBudWxsO1xuICBleHBlY3RlZF9iYWxhbmNlPzogbnVtYmVyIHwgbnVsbDtcbiAgc3RhdHVzOiAnb3BlbicgfCAnY2xvc2VkJztcbiAgb3BlbmVkX2F0OiBzdHJpbmc7XG4gIGNsb3NlZF9hdD86IHN0cmluZyB8IG51bGw7XG4gIHZlcnNpb25faWQ6IG51bWJlcjtcbiAgZGVsZXRlZF9hdD86IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2FsZUl0ZW1SZWNvcmQge1xuICBpZDogc3RyaW5nO1xuICB0ZW5hbnRfaWQ6IHN0cmluZztcbiAgb3V0bGV0X2lkOiBzdHJpbmc7XG4gIHNhbGVfaWQ6IHN0cmluZztcbiAgcHJvZHVjdF9pZDogc3RyaW5nO1xuICBxdWFudGl0eTogbnVtYmVyO1xuICB1bml0X3ByaWNlOiBudW1iZXI7XG4gIGxpbmVfdG90YWw6IG51bWJlcjtcbiAgdmVyc2lvbl9pZDogbnVtYmVyO1xuICBjcmVhdGVkX2F0Pzogc3RyaW5nO1xuICBkZWxldGVkX2F0Pzogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IHR5cGUgU3luY0FjdGlvblR5cGUgPSAnU0FMRScgfCAnQURKVVNUX1NUT0NLJyB8ICdBRERfUFJPRFVDVCcgfCAnT1BFTl9TRVNTSU9OJyB8ICdDTE9TRV9TRVNTSU9OJztcbmV4cG9ydCB0eXBlIFN5bmNTdGF0dXMgPSAncGVuZGluZycgfCAnc3luY2VkJyB8ICdmYWlsZWQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNRdWV1ZVJlY29yZCB7XG4gIGlkOiBzdHJpbmc7XG4gIGFjdGlvbl90eXBlOiBTeW5jQWN0aW9uVHlwZTtcbiAgcGF5bG9hZDogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICBzdGF0dXM6IFN5bmNTdGF0dXM7XG4gIGVycm9yX21lc3NhZ2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3luY01ldGFSZWNvcmQge1xuICBrZXk6IHN0cmluZztcbiAgdmFsdWU6IHN0cmluZyB8IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEJsdWVjb3VudHNEQiBleHRlbmRzIERleGllIHtcbiAgcHJvZHVjdHMhOiBFbnRpdHlUYWJsZTxQcm9kdWN0UmVjb3JkLCAnaWQnPjtcbiAgaW52ZW50b3J5ITogRW50aXR5VGFibGU8SW52ZW50b3J5UmVjb3JkLCAnaWQnPjtcbiAgc2FsZXMhOiBFbnRpdHlUYWJsZTxTYWxlUmVjb3JkLCAnaWQnPjtcbiAgc2FsZV9pdGVtcyE6IEVudGl0eVRhYmxlPFNhbGVJdGVtUmVjb3JkLCAnaWQnPjtcbiAgcG9zX3Nlc3Npb25zITogRW50aXR5VGFibGU8UG9zU2Vzc2lvblJlY29yZCwgJ2lkJz47XG4gIHN5bmNfcXVldWUhOiBFbnRpdHlUYWJsZTxTeW5jUXVldWVSZWNvcmQsICdpZCc+O1xuICBzeW5jX21ldGEhOiBFbnRpdHlUYWJsZTxTeW5jTWV0YVJlY29yZCwgJ2tleSc+O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdCbHVlY291bnRzREInKTtcbiAgICB0aGlzLnZlcnNpb24oMSkuc3RvcmVzKHtcbiAgICAgIHByb2R1Y3RzOiAnaWQsIHRlbmFudF9pZCwgb3V0bGV0X2lkLCBbdGVuYW50X2lkK291dGxldF9pZF0sIFt0ZW5hbnRfaWQrc2t1XSwgdmVyc2lvbl9pZCcsXG4gICAgICBpbnZlbnRvcnk6ICdpZCwgdGVuYW50X2lkLCBvdXRsZXRfaWQsIHByb2R1Y3RfaWQsIFt0ZW5hbnRfaWQrb3V0bGV0X2lkK3Byb2R1Y3RfaWRdLCB2ZXJzaW9uX2lkJyxcbiAgICAgIHNhbGVzOiAnaWQsIHRlbmFudF9pZCwgb3V0bGV0X2lkLCBkZXZpY2VfaWQsIFt0ZW5hbnRfaWQrZGV2aWNlX2lkK2RldmljZV90cmFuc2FjdGlvbl9pZF0sIHZlcnNpb25faWQsIGNyZWF0ZWRfYXQnLFxuICAgICAgc2FsZV9pdGVtczogJ2lkLCBzYWxlX2lkLCB0ZW5hbnRfaWQsIG91dGxldF9pZCwgcHJvZHVjdF9pZCcsXG4gICAgICBzeW5jX3F1ZXVlOiAnaWQsIHRpbWVzdGFtcCwgc3RhdHVzJyxcbiAgICAgIHN5bmNfbWV0YTogJ2tleScsXG4gICAgfSk7XG4gICAgdGhpcy52ZXJzaW9uKDIpLnN0b3Jlcyh7XG4gICAgICBwcm9kdWN0czogJ2lkLCB0ZW5hbnRfaWQsIG91dGxldF9pZCwgW3RlbmFudF9pZCtvdXRsZXRfaWRdLCBbdGVuYW50X2lkK3NrdV0sIHZlcnNpb25faWQnLFxuICAgICAgaW52ZW50b3J5OiAnaWQsIHRlbmFudF9pZCwgb3V0bGV0X2lkLCBwcm9kdWN0X2lkLCBbdGVuYW50X2lkK291dGxldF9pZCtwcm9kdWN0X2lkXSwgdmVyc2lvbl9pZCcsXG4gICAgICBzYWxlczogJ2lkLCB0ZW5hbnRfaWQsIG91dGxldF9pZCwgZGV2aWNlX2lkLCBzZXNzaW9uX2lkLCBbdGVuYW50X2lkK2RldmljZV9pZCtkZXZpY2VfdHJhbnNhY3Rpb25faWRdLCB2ZXJzaW9uX2lkLCBjcmVhdGVkX2F0JyxcbiAgICAgIHNhbGVfaXRlbXM6ICdpZCwgc2FsZV9pZCwgdGVuYW50X2lkLCBvdXRsZXRfaWQsIHByb2R1Y3RfaWQnLFxuICAgICAgcG9zX3Nlc3Npb25zOiAnaWQsIHRlbmFudF9pZCwgb3V0bGV0X2lkLCB1c2VyX2lkLCBbb3V0bGV0X2lkK3N0YXR1c10sIHZlcnNpb25faWQsIG9wZW5lZF9hdCcsXG4gICAgICBzeW5jX3F1ZXVlOiAnaWQsIHRpbWVzdGFtcCwgc3RhdHVzJyxcbiAgICAgIHN5bmNfbWV0YTogJ2tleScsXG4gICAgfSk7XG4gICAgdGhpcy52ZXJzaW9uKDMpLnN0b3Jlcyh7XG4gICAgICBwcm9kdWN0czogJ2lkLCB0ZW5hbnRfaWQsIFt0ZW5hbnRfaWQrc2t1XSwgdmVyc2lvbl9pZCcsXG4gICAgICBpbnZlbnRvcnk6ICdpZCwgdGVuYW50X2lkLCBvdXRsZXRfaWQsIHByb2R1Y3RfaWQsIFt0ZW5hbnRfaWQrb3V0bGV0X2lkK3Byb2R1Y3RfaWRdLCB2ZXJzaW9uX2lkJyxcbiAgICAgIHNhbGVzOiAnaWQsIHRlbmFudF9pZCwgb3V0bGV0X2lkLCBkZXZpY2VfaWQsIHNlc3Npb25faWQsIFt0ZW5hbnRfaWQrZGV2aWNlX2lkK2RldmljZV90cmFuc2FjdGlvbl9pZF0sIHZlcnNpb25faWQsIGNyZWF0ZWRfYXQnLFxuICAgICAgc2FsZV9pdGVtczogJ2lkLCBzYWxlX2lkLCB0ZW5hbnRfaWQsIG91dGxldF9pZCwgcHJvZHVjdF9pZCcsXG4gICAgICBwb3Nfc2Vzc2lvbnM6ICdpZCwgdGVuYW50X2lkLCBvdXRsZXRfaWQsIHVzZXJfaWQsIFtvdXRsZXRfaWQrc3RhdHVzXSwgdmVyc2lvbl9pZCwgb3BlbmVkX2F0JyxcbiAgICAgIHN5bmNfcXVldWU6ICdpZCwgdGltZXN0YW1wLCBzdGF0dXMnLFxuICAgICAgc3luY19tZXRhOiAna2V5JyxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGIgPSBuZXcgQmx1ZWNvdW50c0RCKCk7XG4iXSwibmFtZXMiOlsiRGV4aWUiLCJCbHVlY291bnRzREIiLCJ2ZXJzaW9uIiwic3RvcmVzIiwicHJvZHVjdHMiLCJpbnZlbnRvcnkiLCJzYWxlcyIsInNhbGVfaXRlbXMiLCJzeW5jX3F1ZXVlIiwic3luY19tZXRhIiwicG9zX3Nlc3Npb25zIiwiZGIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/db.ts\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Ftimothyedibo%2Fprojects%2Fpersonal%2Fbluecounts%2Ffrontend%2Fsrc%2Fapp%2F(dashboard)%2Finventory%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);